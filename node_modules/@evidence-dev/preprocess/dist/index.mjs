import $773sa$path1, * as $773sa$path from "path";
import $773sa$fs, {readFileSync as $773sa$readFileSync} from "fs";
import $773sa$util from "util";
import {release as $773sa$release} from "os";
import {isatty as $773sa$isatty} from "tty";


      var $parcel$global = globalThis;
    
function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}

function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

var $parcel$modules = {};
var $parcel$inits = {};

var parcelRequire = $parcel$global["parcelRequire94c2"];

if (parcelRequire == null) {
  parcelRequire = function(id) {
    if (id in $parcel$modules) {
      return $parcel$modules[id].exports;
    }
    if (id in $parcel$inits) {
      var init = $parcel$inits[id];
      delete $parcel$inits[id];
      var module = {id: id, exports: {}};
      $parcel$modules[id] = module;
      init.call(module.exports, module, module.exports);
      return module.exports;
    }
    var err = new Error("Cannot find module '" + id + "'");
    err.code = 'MODULE_NOT_FOUND';
    throw err;
  };

  parcelRequire.register = function register(id, init) {
    $parcel$inits[id] = init;
  };

  $parcel$global["parcelRequire94c2"] = parcelRequire;
}

var parcelRegister = parcelRequire.register;
parcelRegister("k5gQN", function(module, exports) {
module.exports = JSON.parse('{"core":{"meta":{"path":"components/prism-core.js","option":"mandatory"},"core":"Core"},"themes":{"meta":{"path":"themes/{id}.css","link":"index.html?theme={id}","exclusive":true},"prism":{"title":"Default","option":"default"},"prism-dark":"Dark","prism-funky":"Funky","prism-okaidia":{"title":"Okaidia","owner":"ocodia"},"prism-twilight":{"title":"Twilight","owner":"remybach"},"prism-coy":{"title":"Coy","owner":"tshedor"},"prism-solarizedlight":{"title":"Solarized Light","owner":"hectormatos2011 "},"prism-tomorrow":{"title":"Tomorrow Night","owner":"Rosey"}},"languages":{"meta":{"path":"components/prism-{id}","noCSS":true,"examplesPath":"examples/prism-{id}","addCheckAll":true},"markup":{"title":"Markup","alias":["html","xml","svg","mathml","ssml","atom","rss"],"aliasTitles":{"html":"HTML","xml":"XML","svg":"SVG","mathml":"MathML","ssml":"SSML","atom":"Atom","rss":"RSS"},"option":"default"},"css":{"title":"CSS","option":"default","modify":"markup"},"clike":{"title":"C-like","option":"default"},"javascript":{"title":"JavaScript","require":"clike","modify":"markup","optional":"regex","alias":"js","option":"default"},"abap":{"title":"ABAP","owner":"dellagustin"},"abnf":{"title":"ABNF","owner":"RunDevelopment"},"actionscript":{"title":"ActionScript","require":"javascript","modify":"markup","owner":"Golmote"},"ada":{"title":"Ada","owner":"Lucretia"},"agda":{"title":"Agda","owner":"xy-ren"},"al":{"title":"AL","owner":"RunDevelopment"},"antlr4":{"title":"ANTLR4","alias":"g4","owner":"RunDevelopment"},"apacheconf":{"title":"Apache Configuration","owner":"GuiTeK"},"apex":{"title":"Apex","require":["clike","sql"],"owner":"RunDevelopment"},"apl":{"title":"APL","owner":"ngn"},"applescript":{"title":"AppleScript","owner":"Golmote"},"aql":{"title":"AQL","owner":"RunDevelopment"},"arduino":{"title":"Arduino","require":"cpp","alias":"ino","owner":"dkern"},"arff":{"title":"ARFF","owner":"Golmote"},"armasm":{"title":"ARM Assembly","alias":"arm-asm","owner":"RunDevelopment"},"arturo":{"title":"Arturo","alias":"art","optional":["bash","css","javascript","markup","markdown","sql"],"owner":"drkameleon"},"asciidoc":{"alias":"adoc","title":"AsciiDoc","owner":"Golmote"},"aspnet":{"title":"ASP.NET (C#)","require":["markup","csharp"],"owner":"nauzilus"},"asm6502":{"title":"6502 Assembly","owner":"kzurawel"},"asmatmel":{"title":"Atmel AVR Assembly","owner":"cerkit"},"autohotkey":{"title":"AutoHotkey","owner":"aviaryan"},"autoit":{"title":"AutoIt","owner":"Golmote"},"avisynth":{"title":"AviSynth","alias":"avs","owner":"Zinfidel"},"avro-idl":{"title":"Avro IDL","alias":"avdl","owner":"RunDevelopment"},"awk":{"title":"AWK","alias":"gawk","aliasTitles":{"gawk":"GAWK"},"owner":"RunDevelopment"},"bash":{"title":"Bash","alias":["sh","shell"],"aliasTitles":{"sh":"Shell","shell":"Shell"},"owner":"zeitgeist87"},"basic":{"title":"BASIC","owner":"Golmote"},"batch":{"title":"Batch","owner":"Golmote"},"bbcode":{"title":"BBcode","alias":"shortcode","aliasTitles":{"shortcode":"Shortcode"},"owner":"RunDevelopment"},"bbj":{"title":"BBj","owner":"hyyan"},"bicep":{"title":"Bicep","owner":"johnnyreilly"},"birb":{"title":"Birb","require":"clike","owner":"Calamity210"},"bison":{"title":"Bison","require":"c","owner":"Golmote"},"bnf":{"title":"BNF","alias":"rbnf","aliasTitles":{"rbnf":"RBNF"},"owner":"RunDevelopment"},"bqn":{"title":"BQN","owner":"yewscion"},"brainfuck":{"title":"Brainfuck","owner":"Golmote"},"brightscript":{"title":"BrightScript","owner":"RunDevelopment"},"bro":{"title":"Bro","owner":"wayward710"},"bsl":{"title":"BSL (1C:Enterprise)","alias":"oscript","aliasTitles":{"oscript":"OneScript"},"owner":"Diversus23"},"c":{"title":"C","require":"clike","owner":"zeitgeist87"},"csharp":{"title":"C#","require":"clike","alias":["cs","dotnet"],"owner":"mvalipour"},"cpp":{"title":"C++","require":"c","owner":"zeitgeist87"},"cfscript":{"title":"CFScript","require":"clike","alias":"cfc","owner":"mjclemente"},"chaiscript":{"title":"ChaiScript","require":["clike","cpp"],"owner":"RunDevelopment"},"cil":{"title":"CIL","owner":"sbrl"},"cilkc":{"title":"Cilk/C","require":"c","alias":"cilk-c","owner":"OpenCilk"},"cilkcpp":{"title":"Cilk/C++","require":"cpp","alias":["cilk-cpp","cilk"],"owner":"OpenCilk"},"clojure":{"title":"Clojure","owner":"troglotit"},"cmake":{"title":"CMake","owner":"mjrogozinski"},"cobol":{"title":"COBOL","owner":"RunDevelopment"},"coffeescript":{"title":"CoffeeScript","require":"javascript","alias":"coffee","owner":"R-osey"},"concurnas":{"title":"Concurnas","alias":"conc","owner":"jasontatton"},"csp":{"title":"Content-Security-Policy","owner":"ScottHelme"},"cooklang":{"title":"Cooklang","owner":"ahue"},"coq":{"title":"Coq","owner":"RunDevelopment"},"crystal":{"title":"Crystal","require":"ruby","owner":"MakeNowJust"},"css-extras":{"title":"CSS Extras","require":"css","modify":"css","owner":"milesj"},"csv":{"title":"CSV","owner":"RunDevelopment"},"cue":{"title":"CUE","owner":"RunDevelopment"},"cypher":{"title":"Cypher","owner":"RunDevelopment"},"d":{"title":"D","require":"clike","owner":"Golmote"},"dart":{"title":"Dart","require":"clike","owner":"Golmote"},"dataweave":{"title":"DataWeave","owner":"machaval"},"dax":{"title":"DAX","owner":"peterbud"},"dhall":{"title":"Dhall","owner":"RunDevelopment"},"diff":{"title":"Diff","owner":"uranusjr"},"django":{"title":"Django/Jinja2","require":"markup-templating","alias":"jinja2","owner":"romanvm"},"dns-zone-file":{"title":"DNS zone file","owner":"RunDevelopment","alias":"dns-zone"},"docker":{"title":"Docker","alias":"dockerfile","owner":"JustinBeckwith"},"dot":{"title":"DOT (Graphviz)","alias":"gv","optional":"markup","owner":"RunDevelopment"},"ebnf":{"title":"EBNF","owner":"RunDevelopment"},"editorconfig":{"title":"EditorConfig","owner":"osipxd"},"eiffel":{"title":"Eiffel","owner":"Conaclos"},"ejs":{"title":"EJS","require":["javascript","markup-templating"],"owner":"RunDevelopment","alias":"eta","aliasTitles":{"eta":"Eta"}},"elixir":{"title":"Elixir","owner":"Golmote"},"elm":{"title":"Elm","owner":"zwilias"},"etlua":{"title":"Embedded Lua templating","require":["lua","markup-templating"],"owner":"RunDevelopment"},"erb":{"title":"ERB","require":["ruby","markup-templating"],"owner":"Golmote"},"erlang":{"title":"Erlang","owner":"Golmote"},"excel-formula":{"title":"Excel Formula","alias":["xlsx","xls"],"owner":"RunDevelopment"},"fsharp":{"title":"F#","require":"clike","owner":"simonreynolds7"},"factor":{"title":"Factor","owner":"catb0t"},"false":{"title":"False","owner":"edukisto"},"firestore-security-rules":{"title":"Firestore security rules","require":"clike","owner":"RunDevelopment"},"flow":{"title":"Flow","require":"javascript","owner":"Golmote"},"fortran":{"title":"Fortran","owner":"Golmote"},"ftl":{"title":"FreeMarker Template Language","require":"markup-templating","owner":"RunDevelopment"},"gml":{"title":"GameMaker Language","alias":"gamemakerlanguage","require":"clike","owner":"LiarOnce"},"gap":{"title":"GAP (CAS)","owner":"RunDevelopment"},"gcode":{"title":"G-code","owner":"RunDevelopment"},"gdscript":{"title":"GDScript","owner":"RunDevelopment"},"gedcom":{"title":"GEDCOM","owner":"Golmote"},"gettext":{"title":"gettext","alias":"po","owner":"RunDevelopment"},"gherkin":{"title":"Gherkin","owner":"hason"},"git":{"title":"Git","owner":"lgiraudel"},"glsl":{"title":"GLSL","require":"c","owner":"Golmote"},"gn":{"title":"GN","alias":"gni","owner":"RunDevelopment"},"linker-script":{"title":"GNU Linker Script","alias":"ld","owner":"RunDevelopment"},"go":{"title":"Go","require":"clike","owner":"arnehormann"},"go-module":{"title":"Go module","alias":"go-mod","owner":"RunDevelopment"},"gradle":{"title":"Gradle","require":"clike","owner":"zeabdelkhalek-badido18"},"graphql":{"title":"GraphQL","optional":"markdown","owner":"Golmote"},"groovy":{"title":"Groovy","require":"clike","owner":"robfletcher"},"haml":{"title":"Haml","require":"ruby","optional":["css","css-extras","coffeescript","erb","javascript","less","markdown","scss","textile"],"owner":"Golmote"},"handlebars":{"title":"Handlebars","require":"markup-templating","alias":["hbs","mustache"],"aliasTitles":{"mustache":"Mustache"},"owner":"Golmote"},"haskell":{"title":"Haskell","alias":"hs","owner":"bholst"},"haxe":{"title":"Haxe","require":"clike","optional":"regex","owner":"Golmote"},"hcl":{"title":"HCL","owner":"outsideris"},"hlsl":{"title":"HLSL","require":"c","owner":"RunDevelopment"},"hoon":{"title":"Hoon","owner":"matildepark"},"http":{"title":"HTTP","optional":["csp","css","hpkp","hsts","javascript","json","markup","uri"],"owner":"danielgtaylor"},"hpkp":{"title":"HTTP Public-Key-Pins","owner":"ScottHelme"},"hsts":{"title":"HTTP Strict-Transport-Security","owner":"ScottHelme"},"ichigojam":{"title":"IchigoJam","owner":"BlueCocoa"},"icon":{"title":"Icon","owner":"Golmote"},"icu-message-format":{"title":"ICU Message Format","owner":"RunDevelopment"},"idris":{"title":"Idris","alias":"idr","owner":"KeenS","require":"haskell"},"ignore":{"title":".ignore","owner":"osipxd","alias":["gitignore","hgignore","npmignore"],"aliasTitles":{"gitignore":".gitignore","hgignore":".hgignore","npmignore":".npmignore"}},"inform7":{"title":"Inform 7","owner":"Golmote"},"ini":{"title":"Ini","owner":"aviaryan"},"io":{"title":"Io","owner":"AlesTsurko"},"j":{"title":"J","owner":"Golmote"},"java":{"title":"Java","require":"clike","owner":"sherblot"},"javadoc":{"title":"JavaDoc","require":["markup","java","javadoclike"],"modify":"java","optional":"scala","owner":"RunDevelopment"},"javadoclike":{"title":"JavaDoc-like","modify":["java","javascript","php"],"owner":"RunDevelopment"},"javastacktrace":{"title":"Java stack trace","owner":"RunDevelopment"},"jexl":{"title":"Jexl","owner":"czosel"},"jolie":{"title":"Jolie","require":"clike","owner":"thesave"},"jq":{"title":"JQ","owner":"RunDevelopment"},"jsdoc":{"title":"JSDoc","require":["javascript","javadoclike","typescript"],"modify":"javascript","optional":["actionscript","coffeescript"],"owner":"RunDevelopment"},"js-extras":{"title":"JS Extras","require":"javascript","modify":"javascript","optional":["actionscript","coffeescript","flow","n4js","typescript"],"owner":"RunDevelopment"},"json":{"title":"JSON","alias":"webmanifest","aliasTitles":{"webmanifest":"Web App Manifest"},"owner":"CupOfTea696"},"json5":{"title":"JSON5","require":"json","owner":"RunDevelopment"},"jsonp":{"title":"JSONP","require":"json","owner":"RunDevelopment"},"jsstacktrace":{"title":"JS stack trace","owner":"sbrl"},"js-templates":{"title":"JS Templates","require":"javascript","modify":"javascript","optional":["css","css-extras","graphql","markdown","markup","sql"],"owner":"RunDevelopment"},"julia":{"title":"Julia","owner":"cdagnino"},"keepalived":{"title":"Keepalived Configure","owner":"dev-itsheng"},"keyman":{"title":"Keyman","owner":"mcdurdin"},"kotlin":{"title":"Kotlin","alias":["kt","kts"],"aliasTitles":{"kts":"Kotlin Script"},"require":"clike","owner":"Golmote"},"kumir":{"title":"KuMir (\u041A\u0443\u041C\u0438\u0440)","alias":"kum","owner":"edukisto"},"kusto":{"title":"Kusto","owner":"RunDevelopment"},"latex":{"title":"LaTeX","alias":["tex","context"],"aliasTitles":{"tex":"TeX","context":"ConTeXt"},"owner":"japborst"},"latte":{"title":"Latte","require":["clike","markup-templating","php"],"owner":"nette"},"less":{"title":"Less","require":"css","optional":"css-extras","owner":"Golmote"},"lilypond":{"title":"LilyPond","require":"scheme","alias":"ly","owner":"RunDevelopment"},"liquid":{"title":"Liquid","require":"markup-templating","owner":"cinhtau"},"lisp":{"title":"Lisp","alias":["emacs","elisp","emacs-lisp"],"owner":"JuanCaicedo"},"livescript":{"title":"LiveScript","owner":"Golmote"},"llvm":{"title":"LLVM IR","owner":"porglezomp"},"log":{"title":"Log file","optional":"javastacktrace","owner":"RunDevelopment"},"lolcode":{"title":"LOLCODE","owner":"Golmote"},"lua":{"title":"Lua","owner":"Golmote"},"magma":{"title":"Magma (CAS)","owner":"RunDevelopment"},"makefile":{"title":"Makefile","owner":"Golmote"},"markdown":{"title":"Markdown","require":"markup","optional":"yaml","alias":"md","owner":"Golmote"},"markup-templating":{"title":"Markup templating","require":"markup","owner":"Golmote"},"mata":{"title":"Mata","owner":"RunDevelopment"},"matlab":{"title":"MATLAB","owner":"Golmote"},"maxscript":{"title":"MAXScript","owner":"RunDevelopment"},"mel":{"title":"MEL","owner":"Golmote"},"mermaid":{"title":"Mermaid","owner":"RunDevelopment"},"metafont":{"title":"METAFONT","owner":"LaeriExNihilo"},"mizar":{"title":"Mizar","owner":"Golmote"},"mongodb":{"title":"MongoDB","owner":"airs0urce","require":"javascript"},"monkey":{"title":"Monkey","owner":"Golmote"},"moonscript":{"title":"MoonScript","alias":"moon","owner":"RunDevelopment"},"n1ql":{"title":"N1QL","owner":"TMWilds"},"n4js":{"title":"N4JS","require":"javascript","optional":"jsdoc","alias":"n4jsd","owner":"bsmith-n4"},"nand2tetris-hdl":{"title":"Nand To Tetris HDL","owner":"stephanmax"},"naniscript":{"title":"Naninovel Script","owner":"Elringus","alias":"nani"},"nasm":{"title":"NASM","owner":"rbmj"},"neon":{"title":"NEON","owner":"nette"},"nevod":{"title":"Nevod","owner":"nezaboodka"},"nginx":{"title":"nginx","owner":"volado"},"nim":{"title":"Nim","owner":"Golmote"},"nix":{"title":"Nix","owner":"Golmote"},"nsis":{"title":"NSIS","owner":"idleberg"},"objectivec":{"title":"Objective-C","require":"c","alias":"objc","owner":"uranusjr"},"ocaml":{"title":"OCaml","owner":"Golmote"},"odin":{"title":"Odin","owner":"edukisto"},"opencl":{"title":"OpenCL","require":"c","modify":["c","cpp"],"owner":"Milania1"},"openqasm":{"title":"OpenQasm","alias":"qasm","owner":"RunDevelopment"},"oz":{"title":"Oz","owner":"Golmote"},"parigp":{"title":"PARI/GP","owner":"Golmote"},"parser":{"title":"Parser","require":"markup","owner":"Golmote"},"pascal":{"title":"Pascal","alias":"objectpascal","aliasTitles":{"objectpascal":"Object Pascal"},"owner":"Golmote"},"pascaligo":{"title":"Pascaligo","owner":"DefinitelyNotAGoat"},"psl":{"title":"PATROL Scripting Language","owner":"bertysentry"},"pcaxis":{"title":"PC-Axis","alias":"px","owner":"RunDevelopment"},"peoplecode":{"title":"PeopleCode","alias":"pcode","owner":"RunDevelopment"},"perl":{"title":"Perl","owner":"Golmote"},"php":{"title":"PHP","require":"markup-templating","owner":"milesj"},"phpdoc":{"title":"PHPDoc","require":["php","javadoclike"],"modify":"php","owner":"RunDevelopment"},"php-extras":{"title":"PHP Extras","require":"php","modify":"php","owner":"milesj"},"plant-uml":{"title":"PlantUML","alias":"plantuml","owner":"RunDevelopment"},"plsql":{"title":"PL/SQL","require":"sql","owner":"Golmote"},"powerquery":{"title":"PowerQuery","alias":["pq","mscript"],"owner":"peterbud"},"powershell":{"title":"PowerShell","owner":"nauzilus"},"processing":{"title":"Processing","require":"clike","owner":"Golmote"},"prolog":{"title":"Prolog","owner":"Golmote"},"promql":{"title":"PromQL","owner":"arendjr"},"properties":{"title":".properties","owner":"Golmote"},"protobuf":{"title":"Protocol Buffers","require":"clike","owner":"just-boris"},"pug":{"title":"Pug","require":["markup","javascript"],"optional":["coffeescript","ejs","handlebars","less","livescript","markdown","scss","stylus","twig"],"owner":"Golmote"},"puppet":{"title":"Puppet","owner":"Golmote"},"pure":{"title":"Pure","optional":["c","cpp","fortran"],"owner":"Golmote"},"purebasic":{"title":"PureBasic","require":"clike","alias":"pbfasm","owner":"HeX0R101"},"purescript":{"title":"PureScript","require":"haskell","alias":"purs","owner":"sriharshachilakapati"},"python":{"title":"Python","alias":"py","owner":"multipetros"},"qsharp":{"title":"Q#","require":"clike","alias":"qs","owner":"fedonman"},"q":{"title":"Q (kdb+ database)","owner":"Golmote"},"qml":{"title":"QML","require":"javascript","owner":"RunDevelopment"},"qore":{"title":"Qore","require":"clike","owner":"temnroegg"},"r":{"title":"R","owner":"Golmote"},"racket":{"title":"Racket","require":"scheme","alias":"rkt","owner":"RunDevelopment"},"cshtml":{"title":"Razor C#","alias":"razor","require":["markup","csharp"],"optional":["css","css-extras","javascript","js-extras"],"owner":"RunDevelopment"},"jsx":{"title":"React JSX","require":["markup","javascript"],"optional":["jsdoc","js-extras","js-templates"],"owner":"vkbansal"},"tsx":{"title":"React TSX","require":["jsx","typescript"]},"reason":{"title":"Reason","require":"clike","owner":"Golmote"},"regex":{"title":"Regex","owner":"RunDevelopment"},"rego":{"title":"Rego","owner":"JordanSh"},"renpy":{"title":"Ren\'py","alias":"rpy","owner":"HyuchiaDiego"},"rescript":{"title":"ReScript","alias":"res","owner":"vmarcosp"},"rest":{"title":"reST (reStructuredText)","owner":"Golmote"},"rip":{"title":"Rip","owner":"ravinggenius"},"roboconf":{"title":"Roboconf","owner":"Golmote"},"robotframework":{"title":"Robot Framework","alias":"robot","owner":"RunDevelopment"},"ruby":{"title":"Ruby","require":"clike","alias":"rb","owner":"samflores"},"rust":{"title":"Rust","owner":"Golmote"},"sas":{"title":"SAS","optional":["groovy","lua","sql"],"owner":"Golmote"},"sass":{"title":"Sass (Sass)","require":"css","optional":"css-extras","owner":"Golmote"},"scss":{"title":"Sass (SCSS)","require":"css","optional":"css-extras","owner":"MoOx"},"scala":{"title":"Scala","require":"java","owner":"jozic"},"scheme":{"title":"Scheme","owner":"bacchus123"},"shell-session":{"title":"Shell session","require":"bash","alias":["sh-session","shellsession"],"owner":"RunDevelopment"},"smali":{"title":"Smali","owner":"RunDevelopment"},"smalltalk":{"title":"Smalltalk","owner":"Golmote"},"smarty":{"title":"Smarty","require":"markup-templating","optional":"php","owner":"Golmote"},"sml":{"title":"SML","alias":"smlnj","aliasTitles":{"smlnj":"SML/NJ"},"owner":"RunDevelopment"},"solidity":{"title":"Solidity (Ethereum)","alias":"sol","require":"clike","owner":"glachaud"},"solution-file":{"title":"Solution file","alias":"sln","owner":"RunDevelopment"},"soy":{"title":"Soy (Closure Template)","require":"markup-templating","owner":"Golmote"},"sparql":{"title":"SPARQL","require":"turtle","owner":"Triply-Dev","alias":"rq"},"splunk-spl":{"title":"Splunk SPL","owner":"RunDevelopment"},"sqf":{"title":"SQF: Status Quo Function (Arma 3)","require":"clike","owner":"RunDevelopment"},"sql":{"title":"SQL","owner":"multipetros"},"squirrel":{"title":"Squirrel","require":"clike","owner":"RunDevelopment"},"stan":{"title":"Stan","owner":"RunDevelopment"},"stata":{"title":"Stata Ado","require":["mata","java","python"],"owner":"RunDevelopment"},"iecst":{"title":"Structured Text (IEC 61131-3)","owner":"serhioromano"},"stylus":{"title":"Stylus","owner":"vkbansal"},"supercollider":{"title":"SuperCollider","alias":"sclang","owner":"RunDevelopment"},"swift":{"title":"Swift","owner":"chrischares"},"systemd":{"title":"Systemd configuration file","owner":"RunDevelopment"},"t4-templating":{"title":"T4 templating","owner":"RunDevelopment"},"t4-cs":{"title":"T4 Text Templates (C#)","require":["t4-templating","csharp"],"alias":"t4","owner":"RunDevelopment"},"t4-vb":{"title":"T4 Text Templates (VB)","require":["t4-templating","vbnet"],"owner":"RunDevelopment"},"tap":{"title":"TAP","owner":"isaacs","require":"yaml"},"tcl":{"title":"Tcl","owner":"PeterChaplin"},"tt2":{"title":"Template Toolkit 2","require":["clike","markup-templating"],"owner":"gflohr"},"textile":{"title":"Textile","require":"markup","optional":"css","owner":"Golmote"},"toml":{"title":"TOML","owner":"RunDevelopment"},"tremor":{"title":"Tremor","alias":["trickle","troy"],"owner":"darach","aliasTitles":{"trickle":"trickle","troy":"troy"}},"turtle":{"title":"Turtle","alias":"trig","aliasTitles":{"trig":"TriG"},"owner":"jakubklimek"},"twig":{"title":"Twig","require":"markup-templating","owner":"brandonkelly"},"typescript":{"title":"TypeScript","require":"javascript","optional":"js-templates","alias":"ts","owner":"vkbansal"},"typoscript":{"title":"TypoScript","alias":"tsconfig","aliasTitles":{"tsconfig":"TSConfig"},"owner":"dkern"},"unrealscript":{"title":"UnrealScript","alias":["uscript","uc"],"owner":"RunDevelopment"},"uorazor":{"title":"UO Razor Script","owner":"jaseowns"},"uri":{"title":"URI","alias":"url","aliasTitles":{"url":"URL"},"owner":"RunDevelopment"},"v":{"title":"V","require":"clike","owner":"taggon"},"vala":{"title":"Vala","require":"clike","optional":"regex","owner":"TemplarVolk"},"vbnet":{"title":"VB.Net","require":"basic","owner":"Bigsby"},"velocity":{"title":"Velocity","require":"markup","owner":"Golmote"},"verilog":{"title":"Verilog","owner":"a-rey"},"vhdl":{"title":"VHDL","owner":"a-rey"},"vim":{"title":"vim","owner":"westonganger"},"visual-basic":{"title":"Visual Basic","alias":["vb","vba"],"aliasTitles":{"vba":"VBA"},"owner":"Golmote"},"warpscript":{"title":"WarpScript","owner":"RunDevelopment"},"wasm":{"title":"WebAssembly","owner":"Golmote"},"web-idl":{"title":"Web IDL","alias":"webidl","owner":"RunDevelopment"},"wgsl":{"title":"WGSL","owner":"Dr4gonthree"},"wiki":{"title":"Wiki markup","require":"markup","owner":"Golmote"},"wolfram":{"title":"Wolfram language","alias":["mathematica","nb","wl"],"aliasTitles":{"mathematica":"Mathematica","nb":"Mathematica Notebook"},"owner":"msollami"},"wren":{"title":"Wren","owner":"clsource"},"xeora":{"title":"Xeora","require":"markup","alias":"xeoracube","aliasTitles":{"xeoracube":"XeoraCube"},"owner":"freakmaxi"},"xml-doc":{"title":"XML doc (.net)","require":"markup","modify":["csharp","fsharp","vbnet"],"owner":"RunDevelopment"},"xojo":{"title":"Xojo (REALbasic)","owner":"Golmote"},"xquery":{"title":"XQuery","require":"markup","owner":"Golmote"},"yaml":{"title":"YAML","alias":"yml","owner":"hason"},"yang":{"title":"YANG","owner":"RunDevelopment"},"zig":{"title":"Zig","owner":"RunDevelopment"}},"plugins":{"meta":{"path":"plugins/{id}/prism-{id}","link":"plugins/{id}/"},"line-highlight":{"title":"Line Highlight","description":"Highlights specific lines and/or line ranges."},"line-numbers":{"title":"Line Numbers","description":"Line number at the beginning of code lines.","owner":"kuba-kubula"},"show-invisibles":{"title":"Show Invisibles","description":"Show hidden characters such as tabs and line breaks.","optional":["autolinker","data-uri-highlight"]},"autolinker":{"title":"Autolinker","description":"Converts URLs and emails in code to clickable links. Parses Markdown links in comments."},"wpd":{"title":"WebPlatform Docs","description":"Makes tokens link to <a href=\\"https://webplatform.github.io/docs/\\">WebPlatform.org documentation</a>. The links open in a new tab."},"custom-class":{"title":"Custom Class","description":"This plugin allows you to prefix Prism\'s default classes (<code>.comment</code> can become <code>.namespace--comment</code>) or replace them with your defined ones (like <code>.editor__comment</code>). You can even add new classes.","owner":"dvkndn","noCSS":true},"file-highlight":{"title":"File Highlight","description":"Fetch external files and highlight them with Prism. Used on the Prism website itself.","noCSS":true},"show-language":{"title":"Show Language","description":"Display the highlighted language in code blocks (inline code does not show the label).","owner":"nauzilus","noCSS":true,"require":"toolbar"},"jsonp-highlight":{"title":"JSONP Highlight","description":"Fetch content with JSONP and highlight some interesting content (e.g. GitHub/Gists or Bitbucket API).","noCSS":true,"owner":"nauzilus"},"highlight-keywords":{"title":"Highlight Keywords","description":"Adds special CSS classes for each keyword for fine-grained highlighting.","owner":"vkbansal","noCSS":true},"remove-initial-line-feed":{"title":"Remove initial line feed","description":"Removes the initial line feed in code blocks.","owner":"Golmote","noCSS":true},"inline-color":{"title":"Inline color","description":"Adds a small inline preview for colors in style sheets.","require":"css-extras","owner":"RunDevelopment"},"previewers":{"title":"Previewers","description":"Previewers for angles, colors, gradients, easing and time.","require":"css-extras","owner":"Golmote"},"autoloader":{"title":"Autoloader","description":"Automatically loads the needed languages to highlight the code blocks.","owner":"Golmote","noCSS":true},"keep-markup":{"title":"Keep Markup","description":"Prevents custom markup from being dropped out during highlighting.","owner":"Golmote","optional":"normalize-whitespace","noCSS":true},"command-line":{"title":"Command Line","description":"Display a command line with a prompt and, optionally, the output/response from the commands.","owner":"chriswells0"},"unescaped-markup":{"title":"Unescaped Markup","description":"Write markup without having to escape anything."},"normalize-whitespace":{"title":"Normalize Whitespace","description":"Supports multiple operations to normalize whitespace in code blocks.","owner":"zeitgeist87","optional":"unescaped-markup","noCSS":true},"data-uri-highlight":{"title":"Data-URI Highlight","description":"Highlights data-URI contents.","owner":"Golmote","noCSS":true},"toolbar":{"title":"Toolbar","description":"Attach a toolbar for plugins to easily register buttons on the top of a code block.","owner":"mAAdhaTTah"},"copy-to-clipboard":{"title":"Copy to Clipboard Button","description":"Add a button that copies the code block to the clipboard when clicked.","owner":"mAAdhaTTah","require":"toolbar","noCSS":true},"download-button":{"title":"Download Button","description":"A button in the toolbar of a code block adding a convenient way to download a code file.","owner":"Golmote","require":"toolbar","noCSS":true},"match-braces":{"title":"Match braces","description":"Highlights matching braces.","owner":"RunDevelopment"},"diff-highlight":{"title":"Diff Highlight","description":"Highlights the code inside diff blocks.","owner":"RunDevelopment","require":"diff"},"filter-highlight-all":{"title":"Filter highlightAll","description":"Filters the elements the <code>highlightAll</code> and <code>highlightAllUnder</code> methods actually highlight.","owner":"RunDevelopment","noCSS":true},"treeview":{"title":"Treeview","description":"A language with special styles to highlight file system tree structures.","owner":"Golmote"}}}');

});

parcelRegister("c6ROf", function(module, exports) {
/* **********************************************
     Begin prism-core.js
********************************************** */ /// <reference lib="WebWorker"/>
var $8d0fc8fcdd0ba5d1$var$_self = typeof window !== "undefined" ? window // if in browser
 : typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope ? self // if in worker
 : {} // if in node js
;
/**
 * Prism: Lightweight, robust, elegant syntax highlighting
 *
 * @license MIT <https://opensource.org/licenses/MIT>
 * @author Lea Verou <https://lea.verou.me>
 * @namespace
 * @public
 */ var $8d0fc8fcdd0ba5d1$var$Prism = function(_self) {
    // Private helper vars
    var lang = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i;
    var uniqueId = 0;
    // The grammar object for plaintext
    var plainTextGrammar = {};
    var _ = {
        /**
		 * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the
		 * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load
		 * additional languages or plugins yourself.
		 *
		 * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.
		 *
		 * You obviously have to change this value before the automatic highlighting started. To do this, you can add an
		 * empty Prism object into the global scope before loading the Prism script like this:
		 *
		 * ```js
		 * window.Prism = window.Prism || {};
		 * Prism.manual = true;
		 * // add a new <script> to load Prism's script
		 * ```
		 *
		 * @default false
		 * @type {boolean}
		 * @memberof Prism
		 * @public
		 */ manual: _self.Prism && _self.Prism.manual,
        /**
		 * By default, if Prism is in a web worker, it assumes that it is in a worker it created itself, so it uses
		 * `addEventListener` to communicate with its parent instance. However, if you're using Prism manually in your
		 * own worker, you don't want it to do this.
		 *
		 * By setting this value to `true`, Prism will not add its own listeners to the worker.
		 *
		 * You obviously have to change this value before Prism executes. To do this, you can add an
		 * empty Prism object into the global scope before loading the Prism script like this:
		 *
		 * ```js
		 * window.Prism = window.Prism || {};
		 * Prism.disableWorkerMessageHandler = true;
		 * // Load Prism's script
		 * ```
		 *
		 * @default false
		 * @type {boolean}
		 * @memberof Prism
		 * @public
		 */ disableWorkerMessageHandler: _self.Prism && _self.Prism.disableWorkerMessageHandler,
        /**
		 * A namespace for utility methods.
		 *
		 * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
		 * change or disappear at any time.
		 *
		 * @namespace
		 * @memberof Prism
		 */ util: {
            encode: function encode(tokens) {
                if (tokens instanceof Token) return new Token(tokens.type, encode(tokens.content), tokens.alias);
                else if (Array.isArray(tokens)) return tokens.map(encode);
                else return tokens.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
            },
            /**
			 * Returns the name of the type of the given value.
			 *
			 * @param {any} o
			 * @returns {string}
			 * @example
			 * type(null)      === 'Null'
			 * type(undefined) === 'Undefined'
			 * type(123)       === 'Number'
			 * type('foo')     === 'String'
			 * type(true)      === 'Boolean'
			 * type([1, 2])    === 'Array'
			 * type({})        === 'Object'
			 * type(String)    === 'Function'
			 * type(/abc+/)    === 'RegExp'
			 */ type: function(o) {
                return Object.prototype.toString.call(o).slice(8, -1);
            },
            /**
			 * Returns a unique number for the given object. Later calls will still return the same number.
			 *
			 * @param {Object} obj
			 * @returns {number}
			 */ objId: function(obj) {
                if (!obj["__id"]) Object.defineProperty(obj, "__id", {
                    value: ++uniqueId
                });
                return obj["__id"];
            },
            /**
			 * Creates a deep clone of the given object.
			 *
			 * The main intended use of this function is to clone language definitions.
			 *
			 * @param {T} o
			 * @param {Record<number, any>} [visited]
			 * @returns {T}
			 * @template T
			 */ clone: function deepClone(o, visited) {
                visited = visited || {};
                var clone;
                var id;
                switch(_.util.type(o)){
                    case "Object":
                        id = _.util.objId(o);
                        if (visited[id]) return visited[id];
                        clone = /** @type {Record<string, any>} */ {};
                        visited[id] = clone;
                        for(var key in o)if (o.hasOwnProperty(key)) clone[key] = deepClone(o[key], visited);
                        return /** @type {any} */ clone;
                    case "Array":
                        id = _.util.objId(o);
                        if (visited[id]) return visited[id];
                        clone = [];
                        visited[id] = clone;
                        /** @type {any} */ o.forEach(function(v, i) {
                            clone[i] = deepClone(v, visited);
                        });
                        return /** @type {any} */ clone;
                    default:
                        return o;
                }
            },
            /**
			 * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
			 *
			 * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
			 *
			 * @param {Element} element
			 * @returns {string}
			 */ getLanguage: function(element) {
                while(element){
                    var m = lang.exec(element.className);
                    if (m) return m[1].toLowerCase();
                    element = element.parentElement;
                }
                return "none";
            },
            /**
			 * Sets the Prism `language-xxxx` class of the given element.
			 *
			 * @param {Element} element
			 * @param {string} language
			 * @returns {void}
			 */ setLanguage: function(element, language) {
                // remove all `language-xxxx` classes
                // (this might leave behind a leading space)
                element.className = element.className.replace(RegExp(lang, "gi"), "");
                // add the new `language-xxxx` class
                // (using `classList` will automatically clean up spaces for us)
                element.classList.add("language-" + language);
            },
            /**
			 * Returns the script element that is currently executing.
			 *
			 * This does __not__ work for line script element.
			 *
			 * @returns {HTMLScriptElement | null}
			 */ currentScript: function() {
                if (typeof document === "undefined") return null;
                if ("currentScript" in document && true /* hack to trip TS' flow analysis */ ) return /** @type {any} */ document.currentScript;
                // IE11 workaround
                // we'll get the src of the current script by parsing IE11's error stack trace
                // this will not work for inline scripts
                try {
                    throw new Error();
                } catch (err) {
                    // Get file src url from stack. Specifically works with the format of stack traces in IE.
                    // A stack will look like this:
                    //
                    // Error
                    //    at _.util.currentScript (http://localhost/components/prism-core.js:119:5)
                    //    at Global code (http://localhost/components/prism-core.js:606:1)
                    var src = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(err.stack) || [])[1];
                    if (src) {
                        var scripts = document.getElementsByTagName("script");
                        for(var i in scripts){
                            if (scripts[i].src == src) return scripts[i];
                        }
                    }
                    return null;
                }
            },
            /**
			 * Returns whether a given class is active for `element`.
			 *
			 * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
			 * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
			 * given class is just the given class with a `no-` prefix.
			 *
			 * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
			 * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
			 * ancestors have the given class or the negated version of it, then the default activation will be returned.
			 *
			 * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
			 * version of it, the class is considered active.
			 *
			 * @param {Element} element
			 * @param {string} className
			 * @param {boolean} [defaultActivation=false]
			 * @returns {boolean}
			 */ isActive: function(element, className, defaultActivation) {
                var no = "no-" + className;
                while(element){
                    var classList = element.classList;
                    if (classList.contains(className)) return true;
                    if (classList.contains(no)) return false;
                    element = element.parentElement;
                }
                return !!defaultActivation;
            }
        },
        /**
		 * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
		 *
		 * @namespace
		 * @memberof Prism
		 * @public
		 */ languages: {
            /**
			 * The grammar for plain, unformatted text.
			 */ plain: plainTextGrammar,
            plaintext: plainTextGrammar,
            text: plainTextGrammar,
            txt: plainTextGrammar,
            /**
			 * Creates a deep copy of the language with the given id and appends the given tokens.
			 *
			 * If a token in `redef` also appears in the copied language, then the existing token in the copied language
			 * will be overwritten at its original position.
			 *
			 * ## Best practices
			 *
			 * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
			 * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
			 * understand the language definition because, normally, the order of tokens matters in Prism grammars.
			 *
			 * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
			 * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
			 *
			 * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
			 * @param {Grammar} redef The new tokens to append.
			 * @returns {Grammar} The new language created.
			 * @public
			 * @example
			 * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
			 *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
			 *     // at its original position
			 *     'comment': { ... },
			 *     // CSS doesn't have a 'color' token, so this token will be appended
			 *     'color': /\b(?:red|green|blue)\b/
			 * });
			 */ extend: function(id, redef) {
                var lang = _.util.clone(_.languages[id]);
                for(var key in redef)lang[key] = redef[key];
                return lang;
            },
            /**
			 * Inserts tokens _before_ another token in a language definition or any other grammar.
			 *
			 * ## Usage
			 *
			 * This helper method makes it easy to modify existing languages. For example, the CSS language definition
			 * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
			 * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
			 * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
			 * this:
			 *
			 * ```js
			 * Prism.languages.markup.style = {
			 *     // token
			 * };
			 * ```
			 *
			 * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
			 * before existing tokens. For the CSS example above, you would use it like this:
			 *
			 * ```js
			 * Prism.languages.insertBefore('markup', 'cdata', {
			 *     'style': {
			 *         // token
			 *     }
			 * });
			 * ```
			 *
			 * ## Special cases
			 *
			 * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
			 * will be ignored.
			 *
			 * This behavior can be used to insert tokens after `before`:
			 *
			 * ```js
			 * Prism.languages.insertBefore('markup', 'comment', {
			 *     'comment': Prism.languages.markup.comment,
			 *     // tokens after 'comment'
			 * });
			 * ```
			 *
			 * ## Limitations
			 *
			 * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
			 * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
			 * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
			 * deleting properties which is necessary to insert at arbitrary positions.
			 *
			 * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
			 * Instead, it will create a new object and replace all references to the target object with the new one. This
			 * can be done without temporarily deleting properties, so the iteration order is well-defined.
			 *
			 * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
			 * you hold the target object in a variable, then the value of the variable will not change.
			 *
			 * ```js
			 * var oldMarkup = Prism.languages.markup;
			 * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
			 *
			 * assert(oldMarkup !== Prism.languages.markup);
			 * assert(newMarkup === Prism.languages.markup);
			 * ```
			 *
			 * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
			 * object to be modified.
			 * @param {string} before The key to insert before.
			 * @param {Grammar} insert An object containing the key-value pairs to be inserted.
			 * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
			 * object to be modified.
			 *
			 * Defaults to `Prism.languages`.
			 * @returns {Grammar} The new grammar object.
			 * @public
			 */ insertBefore: function(inside, before, insert, root) {
                root = root || /** @type {any} */ _.languages;
                var grammar = root[inside];
                /** @type {Grammar} */ var ret = {};
                for(var token in grammar)if (grammar.hasOwnProperty(token)) {
                    if (token == before) {
                        for(var newToken in insert)if (insert.hasOwnProperty(newToken)) ret[newToken] = insert[newToken];
                    }
                    // Do not insert token which also occur in insert. See #1525
                    if (!insert.hasOwnProperty(token)) ret[token] = grammar[token];
                }
                var old = root[inside];
                root[inside] = ret;
                // Update references in other language definitions
                _.languages.DFS(_.languages, function(key, value) {
                    if (value === old && key != inside) this[key] = ret;
                });
                return ret;
            },
            // Traverse a language definition with Depth First Search
            DFS: function DFS(o, callback, type, visited) {
                visited = visited || {};
                var objId = _.util.objId;
                for(var i in o)if (o.hasOwnProperty(i)) {
                    callback.call(o, i, o[i], type || i);
                    var property = o[i];
                    var propertyType = _.util.type(property);
                    if (propertyType === "Object" && !visited[objId(property)]) {
                        visited[objId(property)] = true;
                        DFS(property, callback, null, visited);
                    } else if (propertyType === "Array" && !visited[objId(property)]) {
                        visited[objId(property)] = true;
                        DFS(property, callback, i, visited);
                    }
                }
            }
        },
        plugins: {},
        /**
		 * This is the most high-level function in Prism’s API.
		 * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on
		 * each one of them.
		 *
		 * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.
		 *
		 * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.
		 * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.
		 * @memberof Prism
		 * @public
		 */ highlightAll: function(async, callback) {
            _.highlightAllUnder(document, async, callback);
        },
        /**
		 * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls
		 * {@link Prism.highlightElement} on each one of them.
		 *
		 * The following hooks will be run:
		 * 1. `before-highlightall`
		 * 2. `before-all-elements-highlight`
		 * 3. All hooks of {@link Prism.highlightElement} for each element.
		 *
		 * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.
		 * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.
		 * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.
		 * @memberof Prism
		 * @public
		 */ highlightAllUnder: function(container, async, callback) {
            var env = {
                callback: callback,
                container: container,
                selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
            };
            _.hooks.run("before-highlightall", env);
            env.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector));
            _.hooks.run("before-all-elements-highlight", env);
            for(var i = 0, element; element = env.elements[i++];)_.highlightElement(element, async === true, env.callback);
        },
        /**
		 * Highlights the code inside a single element.
		 *
		 * The following hooks will be run:
		 * 1. `before-sanity-check`
		 * 2. `before-highlight`
		 * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.
		 * 4. `before-insert`
		 * 5. `after-highlight`
		 * 6. `complete`
		 *
		 * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for
		 * the element's language.
		 *
		 * @param {Element} element The element containing the code.
		 * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.
		 * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers
		 * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is
		 * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).
		 *
		 * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for
		 * asynchronous highlighting to work. You can build your own bundle on the
		 * [Download page](https://prismjs.com/download.html).
		 * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.
		 * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.
		 * @memberof Prism
		 * @public
		 */ highlightElement: function(element, async, callback) {
            // Find language
            var language = _.util.getLanguage(element);
            var grammar = _.languages[language];
            // Set language on the element, if not present
            _.util.setLanguage(element, language);
            // Set language on the parent, for styling
            var parent = element.parentElement;
            if (parent && parent.nodeName.toLowerCase() === "pre") _.util.setLanguage(parent, language);
            var code = element.textContent;
            var env = {
                element: element,
                language: language,
                grammar: grammar,
                code: code
            };
            function insertHighlightedCode(highlightedCode) {
                env.highlightedCode = highlightedCode;
                _.hooks.run("before-insert", env);
                env.element.innerHTML = env.highlightedCode;
                _.hooks.run("after-highlight", env);
                _.hooks.run("complete", env);
                callback && callback.call(env.element);
            }
            _.hooks.run("before-sanity-check", env);
            // plugins may change/add the parent/element
            parent = env.element.parentElement;
            if (parent && parent.nodeName.toLowerCase() === "pre" && !parent.hasAttribute("tabindex")) parent.setAttribute("tabindex", "0");
            if (!env.code) {
                _.hooks.run("complete", env);
                callback && callback.call(env.element);
                return;
            }
            _.hooks.run("before-highlight", env);
            if (!env.grammar) {
                insertHighlightedCode(_.util.encode(env.code));
                return;
            }
            if (async && _self.Worker) {
                var worker = new Worker(_.filename);
                worker.onmessage = function(evt) {
                    insertHighlightedCode(evt.data);
                };
                worker.postMessage(JSON.stringify({
                    language: env.language,
                    code: env.code,
                    immediateClose: true
                }));
            } else insertHighlightedCode(_.highlight(env.code, env.grammar, env.language));
        },
        /**
		 * Low-level function, only use if you know what you’re doing. It accepts a string of text as input
		 * and the language definitions to use, and returns a string with the HTML produced.
		 *
		 * The following hooks will be run:
		 * 1. `before-tokenize`
		 * 2. `after-tokenize`
		 * 3. `wrap`: On each {@link Token}.
		 *
		 * @param {string} text A string with the code to be highlighted.
		 * @param {Grammar} grammar An object containing the tokens to use.
		 *
		 * Usually a language definition like `Prism.languages.markup`.
		 * @param {string} language The name of the language definition passed to `grammar`.
		 * @returns {string} The highlighted HTML.
		 * @memberof Prism
		 * @public
		 * @example
		 * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
		 */ highlight: function(text, grammar, language) {
            var env = {
                code: text,
                grammar: grammar,
                language: language
            };
            _.hooks.run("before-tokenize", env);
            if (!env.grammar) throw new Error('The language "' + env.language + '" has no grammar.');
            env.tokens = _.tokenize(env.code, env.grammar);
            _.hooks.run("after-tokenize", env);
            return Token.stringify(_.util.encode(env.tokens), env.language);
        },
        /**
		 * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
		 * and the language definitions to use, and returns an array with the tokenized code.
		 *
		 * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
		 *
		 * This method could be useful in other contexts as well, as a very crude parser.
		 *
		 * @param {string} text A string with the code to be highlighted.
		 * @param {Grammar} grammar An object containing the tokens to use.
		 *
		 * Usually a language definition like `Prism.languages.markup`.
		 * @returns {TokenStream} An array of strings and tokens, a token stream.
		 * @memberof Prism
		 * @public
		 * @example
		 * let code = `var foo = 0;`;
		 * let tokens = Prism.tokenize(code, Prism.languages.javascript);
		 * tokens.forEach(token => {
		 *     if (token instanceof Prism.Token && token.type === 'number') {
		 *         console.log(`Found numeric literal: ${token.content}`);
		 *     }
		 * });
		 */ tokenize: function(text, grammar) {
            var rest = grammar.rest;
            if (rest) {
                for(var token in rest)grammar[token] = rest[token];
                delete grammar.rest;
            }
            var tokenList = new LinkedList();
            addAfter(tokenList, tokenList.head, text);
            matchGrammar(text, tokenList, grammar, tokenList.head, 0);
            return toArray(tokenList);
        },
        /**
		 * @namespace
		 * @memberof Prism
		 * @public
		 */ hooks: {
            all: {},
            /**
			 * Adds the given callback to the list of callbacks for the given hook.
			 *
			 * The callback will be invoked when the hook it is registered for is run.
			 * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
			 *
			 * One callback function can be registered to multiple hooks and the same hook multiple times.
			 *
			 * @param {string} name The name of the hook.
			 * @param {HookCallback} callback The callback function which is given environment variables.
			 * @public
			 */ add: function(name, callback) {
                var hooks = _.hooks.all;
                hooks[name] = hooks[name] || [];
                hooks[name].push(callback);
            },
            /**
			 * Runs a hook invoking all registered callbacks with the given environment variables.
			 *
			 * Callbacks will be invoked synchronously and in the order in which they were registered.
			 *
			 * @param {string} name The name of the hook.
			 * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
			 * @public
			 */ run: function(name, env) {
                var callbacks = _.hooks.all[name];
                if (!callbacks || !callbacks.length) return;
                for(var i = 0, callback; callback = callbacks[i++];)callback(env);
            }
        },
        Token: Token
    };
    _self.Prism = _;
    // Typescript note:
    // The following can be used to import the Token type in JSDoc:
    //
    //   @typedef {InstanceType<import("./prism-core")["Token"]>} Token
    /**
	 * Creates a new token.
	 *
	 * @param {string} type See {@link Token#type type}
	 * @param {string | TokenStream} content See {@link Token#content content}
	 * @param {string|string[]} [alias] The alias(es) of the token.
	 * @param {string} [matchedStr=""] A copy of the full string this token was created from.
	 * @class
	 * @global
	 * @public
	 */ function Token(type, content, alias, matchedStr) {
        /**
		 * The type of the token.
		 *
		 * This is usually the key of a pattern in a {@link Grammar}.
		 *
		 * @type {string}
		 * @see GrammarToken
		 * @public
		 */ this.type = type;
        /**
		 * The strings or tokens contained by this token.
		 *
		 * This will be a token stream if the pattern matched also defined an `inside` grammar.
		 *
		 * @type {string | TokenStream}
		 * @public
		 */ this.content = content;
        /**
		 * The alias(es) of the token.
		 *
		 * @type {string|string[]}
		 * @see GrammarToken
		 * @public
		 */ this.alias = alias;
        // Copy of the full string this token was created from
        this.length = (matchedStr || "").length | 0;
    }
    /**
	 * A token stream is an array of strings and {@link Token Token} objects.
	 *
	 * Token streams have to fulfill a few properties that are assumed by most functions (mostly internal ones) that process
	 * them.
	 *
	 * 1. No adjacent strings.
	 * 2. No empty strings.
	 *
	 *    The only exception here is the token stream that only contains the empty string and nothing else.
	 *
	 * @typedef {Array<string | Token>} TokenStream
	 * @global
	 * @public
	 */ /**
	 * Converts the given token or token stream to an HTML representation.
	 *
	 * The following hooks will be run:
	 * 1. `wrap`: On each {@link Token}.
	 *
	 * @param {string | Token | TokenStream} o The token or token stream to be converted.
	 * @param {string} language The name of current language.
	 * @returns {string} The HTML representation of the token or token stream.
	 * @memberof Token
	 * @static
	 */ Token.stringify = function stringify(o, language) {
        if (typeof o == "string") return o;
        if (Array.isArray(o)) {
            var s = "";
            o.forEach(function(e) {
                s += stringify(e, language);
            });
            return s;
        }
        var env = {
            type: o.type,
            content: stringify(o.content, language),
            tag: "span",
            classes: [
                "token",
                o.type
            ],
            attributes: {},
            language: language
        };
        var aliases = o.alias;
        if (aliases) {
            if (Array.isArray(aliases)) Array.prototype.push.apply(env.classes, aliases);
            else env.classes.push(aliases);
        }
        _.hooks.run("wrap", env);
        var attributes = "";
        for(var name in env.attributes)attributes += " " + name + '="' + (env.attributes[name] || "").replace(/"/g, "&quot;") + '"';
        return "<" + env.tag + ' class="' + env.classes.join(" ") + '"' + attributes + ">" + env.content + "</" + env.tag + ">";
    };
    /**
	 * @param {RegExp} pattern
	 * @param {number} pos
	 * @param {string} text
	 * @param {boolean} lookbehind
	 * @returns {RegExpExecArray | null}
	 */ function matchPattern(pattern, pos, text, lookbehind) {
        pattern.lastIndex = pos;
        var match = pattern.exec(text);
        if (match && lookbehind && match[1]) {
            // change the match to remove the text matched by the Prism lookbehind group
            var lookbehindLength = match[1].length;
            match.index += lookbehindLength;
            match[0] = match[0].slice(lookbehindLength);
        }
        return match;
    }
    /**
	 * @param {string} text
	 * @param {LinkedList<string | Token>} tokenList
	 * @param {any} grammar
	 * @param {LinkedListNode<string | Token>} startNode
	 * @param {number} startPos
	 * @param {RematchOptions} [rematch]
	 * @returns {void}
	 * @private
	 *
	 * @typedef RematchOptions
	 * @property {string} cause
	 * @property {number} reach
	 */ function matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {
        for(var token in grammar){
            if (!grammar.hasOwnProperty(token) || !grammar[token]) continue;
            var patterns = grammar[token];
            patterns = Array.isArray(patterns) ? patterns : [
                patterns
            ];
            for(var j = 0; j < patterns.length; ++j){
                if (rematch && rematch.cause == token + "," + j) return;
                var patternObj = patterns[j];
                var inside = patternObj.inside;
                var lookbehind = !!patternObj.lookbehind;
                var greedy = !!patternObj.greedy;
                var alias = patternObj.alias;
                if (greedy && !patternObj.pattern.global) {
                    // Without the global flag, lastIndex won't work
                    var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];
                    patternObj.pattern = RegExp(patternObj.pattern.source, flags + "g");
                }
                /** @type {RegExp} */ var pattern = patternObj.pattern || patternObj;
                for(var currentNode = startNode.next, pos = startPos; currentNode !== tokenList.tail; pos += currentNode.value.length, currentNode = currentNode.next){
                    if (rematch && pos >= rematch.reach) break;
                    var str = currentNode.value;
                    if (tokenList.length > text.length) // Something went terribly wrong, ABORT, ABORT!
                    return;
                    if (str instanceof Token) continue;
                    var removeCount = 1; // this is the to parameter of removeBetween
                    var match;
                    if (greedy) {
                        match = matchPattern(pattern, pos, text, lookbehind);
                        if (!match || match.index >= text.length) break;
                        var from = match.index;
                        var to = match.index + match[0].length;
                        var p = pos;
                        // find the node that contains the match
                        p += currentNode.value.length;
                        while(from >= p){
                            currentNode = currentNode.next;
                            p += currentNode.value.length;
                        }
                        // adjust pos (and p)
                        p -= currentNode.value.length;
                        pos = p;
                        // the current node is a Token, then the match starts inside another Token, which is invalid
                        if (currentNode.value instanceof Token) continue;
                        // find the last node which is affected by this match
                        for(var k = currentNode; k !== tokenList.tail && (p < to || typeof k.value === "string"); k = k.next){
                            removeCount++;
                            p += k.value.length;
                        }
                        removeCount--;
                        // replace with the new match
                        str = text.slice(pos, p);
                        match.index -= pos;
                    } else {
                        match = matchPattern(pattern, 0, str, lookbehind);
                        if (!match) continue;
                    }
                    // eslint-disable-next-line no-redeclare
                    var from = match.index;
                    var matchStr = match[0];
                    var before = str.slice(0, from);
                    var after = str.slice(from + matchStr.length);
                    var reach = pos + str.length;
                    if (rematch && reach > rematch.reach) rematch.reach = reach;
                    var removeFrom = currentNode.prev;
                    if (before) {
                        removeFrom = addAfter(tokenList, removeFrom, before);
                        pos += before.length;
                    }
                    removeRange(tokenList, removeFrom, removeCount);
                    var wrapped = new Token(token, inside ? _.tokenize(matchStr, inside) : matchStr, alias, matchStr);
                    currentNode = addAfter(tokenList, removeFrom, wrapped);
                    if (after) addAfter(tokenList, currentNode, after);
                    if (removeCount > 1) {
                        // at least one Token object was removed, so we have to do some rematching
                        // this can only happen if the current pattern is greedy
                        /** @type {RematchOptions} */ var nestedRematch = {
                            cause: token + "," + j,
                            reach: reach
                        };
                        matchGrammar(text, tokenList, grammar, currentNode.prev, pos, nestedRematch);
                        // the reach might have been extended because of the rematching
                        if (rematch && nestedRematch.reach > rematch.reach) rematch.reach = nestedRematch.reach;
                    }
                }
            }
        }
    }
    /**
	 * @typedef LinkedListNode
	 * @property {T} value
	 * @property {LinkedListNode<T> | null} prev The previous node.
	 * @property {LinkedListNode<T> | null} next The next node.
	 * @template T
	 * @private
	 */ /**
	 * @template T
	 * @private
	 */ function LinkedList() {
        /** @type {LinkedListNode<T>} */ var head = {
            value: null,
            prev: null,
            next: null
        };
        /** @type {LinkedListNode<T>} */ var tail = {
            value: null,
            prev: head,
            next: null
        };
        head.next = tail;
        /** @type {LinkedListNode<T>} */ this.head = head;
        /** @type {LinkedListNode<T>} */ this.tail = tail;
        this.length = 0;
    }
    /**
	 * Adds a new node with the given value to the list.
	 *
	 * @param {LinkedList<T>} list
	 * @param {LinkedListNode<T>} node
	 * @param {T} value
	 * @returns {LinkedListNode<T>} The added node.
	 * @template T
	 */ function addAfter(list, node, value) {
        // assumes that node != list.tail && values.length >= 0
        var next = node.next;
        var newNode = {
            value: value,
            prev: node,
            next: next
        };
        node.next = newNode;
        next.prev = newNode;
        list.length++;
        return newNode;
    }
    /**
	 * Removes `count` nodes after the given node. The given node will not be removed.
	 *
	 * @param {LinkedList<T>} list
	 * @param {LinkedListNode<T>} node
	 * @param {number} count
	 * @template T
	 */ function removeRange(list, node, count) {
        var next = node.next;
        for(var i = 0; i < count && next !== list.tail; i++)next = next.next;
        node.next = next;
        next.prev = node;
        list.length -= i;
    }
    /**
	 * @param {LinkedList<T>} list
	 * @returns {T[]}
	 * @template T
	 */ function toArray(list) {
        var array = [];
        var node = list.head.next;
        while(node !== list.tail){
            array.push(node.value);
            node = node.next;
        }
        return array;
    }
    if (!_self.document) {
        if (!_self.addEventListener) // in Node.js
        return _;
        if (!_.disableWorkerMessageHandler) // In worker
        _self.addEventListener("message", function(evt) {
            var message = JSON.parse(evt.data);
            var lang = message.language;
            var code = message.code;
            var immediateClose = message.immediateClose;
            _self.postMessage(_.highlight(code, _.languages[lang], lang));
            if (immediateClose) _self.close();
        }, false);
        return _;
    }
    // Get current script and highlight
    var script = _.util.currentScript();
    if (script) {
        _.filename = script.src;
        if (script.hasAttribute("data-manual")) _.manual = true;
    }
    function highlightAutomaticallyCallback() {
        if (!_.manual) _.highlightAll();
    }
    if (!_.manual) {
        // If the document state is "loading", then we'll use DOMContentLoaded.
        // If the document state is "interactive" and the prism.js script is deferred, then we'll also use the
        // DOMContentLoaded event because there might be some plugins or languages which have also been deferred and they
        // might take longer one animation frame to execute which can create a race condition where only some plugins have
        // been loaded when Prism.highlightAll() is executed, depending on how fast resources are loaded.
        // See https://github.com/PrismJS/prism/issues/2102
        var readyState = document.readyState;
        if (readyState === "loading" || readyState === "interactive" && script && script.defer) document.addEventListener("DOMContentLoaded", highlightAutomaticallyCallback);
        else if (window.requestAnimationFrame) window.requestAnimationFrame(highlightAutomaticallyCallback);
        else window.setTimeout(highlightAutomaticallyCallback, 16);
    }
    return _;
}($8d0fc8fcdd0ba5d1$var$_self);
if (0, module.exports) module.exports = $8d0fc8fcdd0ba5d1$var$Prism;
// hack for components to work correctly in node.js
if (typeof $parcel$global !== "undefined") $parcel$global.Prism = $8d0fc8fcdd0ba5d1$var$Prism;
// some additional documentation/types
/**
 * The expansion of a simple `RegExp` literal to support additional properties.
 *
 * @typedef GrammarToken
 * @property {RegExp} pattern The regular expression of the token.
 * @property {boolean} [lookbehind=false] If `true`, then the first capturing group of `pattern` will (effectively)
 * behave as a lookbehind group meaning that the captured text will not be part of the matched text of the new token.
 * @property {boolean} [greedy=false] Whether the token is greedy.
 * @property {string|string[]} [alias] An optional alias or list of aliases.
 * @property {Grammar} [inside] The nested grammar of this token.
 *
 * The `inside` grammar will be used to tokenize the text value of each token of this kind.
 *
 * This can be used to make nested and even recursive language definitions.
 *
 * Note: This can cause infinite recursion. Be careful when you embed different languages or even the same language into
 * each another.
 * @global
 * @public
 */ /**
 * @typedef Grammar
 * @type {Object<string, RegExp | GrammarToken | Array<RegExp | GrammarToken>>}
 * @property {Grammar} [rest] An optional grammar object that will be appended to this grammar.
 * @global
 * @public
 */ /**
 * A function which will invoked after an element was successfully highlighted.
 *
 * @callback HighlightCallback
 * @param {Element} element The element successfully highlighted.
 * @returns {void}
 * @global
 * @public
 */ /**
 * @callback HookCallback
 * @param {Object<string, any>} env The environment variables of the hook.
 * @returns {void}
 * @global
 * @public
 */ /* **********************************************
     Begin prism-markup.js
********************************************** */ $8d0fc8fcdd0ba5d1$var$Prism.languages.markup = {
    "comment": {
        pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
        greedy: true
    },
    "prolog": {
        pattern: /<\?[\s\S]+?\?>/,
        greedy: true
    },
    "doctype": {
        // https://www.w3.org/TR/xml/#NT-doctypedecl
        pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
        greedy: true,
        inside: {
            "internal-subset": {
                pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
                lookbehind: true,
                greedy: true,
                inside: null // see below
            },
            "string": {
                pattern: /"[^"]*"|'[^']*'/,
                greedy: true
            },
            "punctuation": /^<!|>$|[[\]]/,
            "doctype-tag": /^DOCTYPE/i,
            "name": /[^\s<>'"]+/
        }
    },
    "cdata": {
        pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
        greedy: true
    },
    "tag": {
        pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
        greedy: true,
        inside: {
            "tag": {
                pattern: /^<\/?[^\s>\/]+/,
                inside: {
                    "punctuation": /^<\/?/,
                    "namespace": /^[^\s>\/:]+:/
                }
            },
            "special-attr": [],
            "attr-value": {
                pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
                inside: {
                    "punctuation": [
                        {
                            pattern: /^=/,
                            alias: "attr-equals"
                        },
                        {
                            pattern: /^(\s*)["']|["']$/,
                            lookbehind: true
                        }
                    ]
                }
            },
            "punctuation": /\/?>/,
            "attr-name": {
                pattern: /[^\s>\/]+/,
                inside: {
                    "namespace": /^[^\s>\/:]+:/
                }
            }
        }
    },
    "entity": [
        {
            pattern: /&[\da-z]{1,8};/i,
            alias: "named-entity"
        },
        /&#x?[\da-f]{1,8};/i
    ]
};
$8d0fc8fcdd0ba5d1$var$Prism.languages.markup["tag"].inside["attr-value"].inside["entity"] = $8d0fc8fcdd0ba5d1$var$Prism.languages.markup["entity"];
$8d0fc8fcdd0ba5d1$var$Prism.languages.markup["doctype"].inside["internal-subset"].inside = $8d0fc8fcdd0ba5d1$var$Prism.languages.markup;
// Plugin to make entity title show the real entity, idea by Roman Komarov
$8d0fc8fcdd0ba5d1$var$Prism.hooks.add("wrap", function(env) {
    if (env.type === "entity") env.attributes["title"] = env.content.replace(/&amp;/, "&");
});
Object.defineProperty($8d0fc8fcdd0ba5d1$var$Prism.languages.markup.tag, "addInlined", {
    /**
	 * Adds an inlined language to markup.
	 *
	 * An example of an inlined language is CSS with `<style>` tags.
	 *
	 * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
	 * case insensitive.
	 * @param {string} lang The language key.
	 * @example
	 * addInlined('style', 'css');
	 */ value: function addInlined(tagName, lang) {
        var includedCdataInside = {};
        includedCdataInside["language-" + lang] = {
            pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
            lookbehind: true,
            inside: $8d0fc8fcdd0ba5d1$var$Prism.languages[lang]
        };
        includedCdataInside["cdata"] = /^<!\[CDATA\[|\]\]>$/i;
        var inside = {
            "included-cdata": {
                pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
                inside: includedCdataInside
            }
        };
        inside["language-" + lang] = {
            pattern: /[\s\S]+/,
            inside: $8d0fc8fcdd0ba5d1$var$Prism.languages[lang]
        };
        var def = {};
        def[tagName] = {
            pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
                return tagName;
            }), "i"),
            lookbehind: true,
            greedy: true,
            inside: inside
        };
        $8d0fc8fcdd0ba5d1$var$Prism.languages.insertBefore("markup", "cdata", def);
    }
});
Object.defineProperty($8d0fc8fcdd0ba5d1$var$Prism.languages.markup.tag, "addAttribute", {
    /**
	 * Adds an pattern to highlight languages embedded in HTML attributes.
	 *
	 * An example of an inlined language is CSS with `style` attributes.
	 *
	 * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
	 * case insensitive.
	 * @param {string} lang The language key.
	 * @example
	 * addAttribute('style', 'css');
	 */ value: function(attrName, lang) {
        $8d0fc8fcdd0ba5d1$var$Prism.languages.markup.tag.inside["special-attr"].push({
            pattern: RegExp(/(^|["'\s])/.source + "(?:" + attrName + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source, "i"),
            lookbehind: true,
            inside: {
                "attr-name": /^[^\s=]+/,
                "attr-value": {
                    pattern: /=[\s\S]+/,
                    inside: {
                        "value": {
                            pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
                            lookbehind: true,
                            alias: [
                                lang,
                                "language-" + lang
                            ],
                            inside: $8d0fc8fcdd0ba5d1$var$Prism.languages[lang]
                        },
                        "punctuation": [
                            {
                                pattern: /^=/,
                                alias: "attr-equals"
                            },
                            /"|'/
                        ]
                    }
                }
            }
        });
    }
});
$8d0fc8fcdd0ba5d1$var$Prism.languages.html = $8d0fc8fcdd0ba5d1$var$Prism.languages.markup;
$8d0fc8fcdd0ba5d1$var$Prism.languages.mathml = $8d0fc8fcdd0ba5d1$var$Prism.languages.markup;
$8d0fc8fcdd0ba5d1$var$Prism.languages.svg = $8d0fc8fcdd0ba5d1$var$Prism.languages.markup;
$8d0fc8fcdd0ba5d1$var$Prism.languages.xml = $8d0fc8fcdd0ba5d1$var$Prism.languages.extend("markup", {});
$8d0fc8fcdd0ba5d1$var$Prism.languages.ssml = $8d0fc8fcdd0ba5d1$var$Prism.languages.xml;
$8d0fc8fcdd0ba5d1$var$Prism.languages.atom = $8d0fc8fcdd0ba5d1$var$Prism.languages.xml;
$8d0fc8fcdd0ba5d1$var$Prism.languages.rss = $8d0fc8fcdd0ba5d1$var$Prism.languages.xml;
/* **********************************************
     Begin prism-css.js
********************************************** */ (function(Prism) {
    var string = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
    Prism.languages.css = {
        "comment": /\/\*[\s\S]*?\*\//,
        "atrule": {
            pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + string.source + ")*?" + /(?:;|(?=\s*\{))/.source),
            inside: {
                "rule": /^@[\w-]+/,
                "selector-function-argument": {
                    pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
                    lookbehind: true,
                    alias: "selector"
                },
                "keyword": {
                    pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
                    lookbehind: true
                }
            }
        },
        "url": {
            // https://drafts.csswg.org/css-values-3/#urls
            pattern: RegExp("\\burl\\((?:" + string.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
            greedy: true,
            inside: {
                "function": /^url/i,
                "punctuation": /^\(|\)$/,
                "string": {
                    pattern: RegExp("^" + string.source + "$"),
                    alias: "url"
                }
            }
        },
        "selector": {
            pattern: RegExp("(^|[{}\\s])[^{}\\s](?:[^{};\"'\\s]|\\s+(?![\\s{])|" + string.source + ")*(?=\\s*\\{)"),
            lookbehind: true
        },
        "string": {
            pattern: string,
            greedy: true
        },
        "property": {
            pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
            lookbehind: true
        },
        "important": /!important\b/i,
        "function": {
            pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
            lookbehind: true
        },
        "punctuation": /[(){};:,]/
    };
    Prism.languages.css["atrule"].inside.rest = Prism.languages.css;
    var markup = Prism.languages.markup;
    if (markup) {
        markup.tag.addInlined("style", "css");
        markup.tag.addAttribute("style", "css");
    }
})($8d0fc8fcdd0ba5d1$var$Prism);
/* **********************************************
     Begin prism-clike.js
********************************************** */ $8d0fc8fcdd0ba5d1$var$Prism.languages.clike = {
    "comment": [
        {
            pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
            lookbehind: true,
            greedy: true
        },
        {
            pattern: /(^|[^\\:])\/\/.*/,
            lookbehind: true,
            greedy: true
        }
    ],
    "string": {
        pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
        greedy: true
    },
    "class-name": {
        pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
        lookbehind: true,
        inside: {
            "punctuation": /[.\\]/
        }
    },
    "keyword": /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
    "boolean": /\b(?:false|true)\b/,
    "function": /\b\w+(?=\()/,
    "number": /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
    "operator": /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
    "punctuation": /[{}[\];(),.:]/
};
/* **********************************************
     Begin prism-javascript.js
********************************************** */ $8d0fc8fcdd0ba5d1$var$Prism.languages.javascript = $8d0fc8fcdd0ba5d1$var$Prism.languages.extend("clike", {
    "class-name": [
        $8d0fc8fcdd0ba5d1$var$Prism.languages.clike["class-name"],
        {
            pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
            lookbehind: true
        }
    ],
    "keyword": [
        {
            pattern: /((?:^|\})\s*)catch\b/,
            lookbehind: true
        },
        {
            pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
            lookbehind: true
        }
    ],
    // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
    "function": /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
    "number": {
        pattern: RegExp(/(^|[^\w$])/.source + "(?:" + // constant
        (/NaN|Infinity/.source + "|" + // binary integer
        /0[bB][01]+(?:_[01]+)*n?/.source + "|" + // octal integer
        /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + // hexadecimal integer
        /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + // decimal bigint
        /\d+(?:_\d+)*n/.source + "|" + // decimal number (integer or float) but no bigint
        /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source),
        lookbehind: true
    },
    "operator": /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
});
$8d0fc8fcdd0ba5d1$var$Prism.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;
$8d0fc8fcdd0ba5d1$var$Prism.languages.insertBefore("javascript", "keyword", {
    "regex": {
        pattern: RegExp(// lookbehind
        // eslint-disable-next-line regexp/no-dupe-characters-character-class
        /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source + // Regex pattern:
        // There are 2 regex patterns here. The RegExp set notation proposal added support for nested character
        // classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible
        // with the only syntax, so we have to define 2 different regex patterns.
        /\//.source + "(?:" + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + "|" + // `v` flag syntax. This supports 3 levels of nested character classes.
        /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ")" + // lookahead
        /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source),
        lookbehind: true,
        greedy: true,
        inside: {
            "regex-source": {
                pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
                lookbehind: true,
                alias: "language-regex",
                inside: $8d0fc8fcdd0ba5d1$var$Prism.languages.regex
            },
            "regex-delimiter": /^\/|\/$/,
            "regex-flags": /^[a-z]+$/
        }
    },
    // This must be declared before keyword because we use "function" inside the look-forward
    "function-variable": {
        pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
        alias: "function"
    },
    "parameter": [
        {
            pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
            lookbehind: true,
            inside: $8d0fc8fcdd0ba5d1$var$Prism.languages.javascript
        },
        {
            pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
            lookbehind: true,
            inside: $8d0fc8fcdd0ba5d1$var$Prism.languages.javascript
        },
        {
            pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
            lookbehind: true,
            inside: $8d0fc8fcdd0ba5d1$var$Prism.languages.javascript
        },
        {
            pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
            lookbehind: true,
            inside: $8d0fc8fcdd0ba5d1$var$Prism.languages.javascript
        }
    ],
    "constant": /\b[A-Z](?:[A-Z_]|\dx?)*\b/
});
$8d0fc8fcdd0ba5d1$var$Prism.languages.insertBefore("javascript", "string", {
    "hashbang": {
        pattern: /^#!.*/,
        greedy: true,
        alias: "comment"
    },
    "template-string": {
        pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
        greedy: true,
        inside: {
            "template-punctuation": {
                pattern: /^`|`$/,
                alias: "string"
            },
            "interpolation": {
                pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
                lookbehind: true,
                inside: {
                    "interpolation-punctuation": {
                        pattern: /^\$\{|\}$/,
                        alias: "punctuation"
                    },
                    rest: $8d0fc8fcdd0ba5d1$var$Prism.languages.javascript
                }
            },
            "string": /[\s\S]+/
        }
    },
    "string-property": {
        pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
        lookbehind: true,
        greedy: true,
        alias: "property"
    }
});
$8d0fc8fcdd0ba5d1$var$Prism.languages.insertBefore("javascript", "operator", {
    "literal-property": {
        pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
        lookbehind: true,
        alias: "property"
    }
});
if ($8d0fc8fcdd0ba5d1$var$Prism.languages.markup) {
    $8d0fc8fcdd0ba5d1$var$Prism.languages.markup.tag.addInlined("script", "javascript");
    // add attribute support for all DOM events.
    // https://developer.mozilla.org/en-US/docs/Web/Events#Standard_events
    $8d0fc8fcdd0ba5d1$var$Prism.languages.markup.tag.addAttribute(/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source, "javascript");
}
$8d0fc8fcdd0ba5d1$var$Prism.languages.js = $8d0fc8fcdd0ba5d1$var$Prism.languages.javascript;
/* **********************************************
     Begin prism-file-highlight.js
********************************************** */ (function() {
    if (typeof $8d0fc8fcdd0ba5d1$var$Prism === "undefined" || typeof document === "undefined") return;
    // https://developer.mozilla.org/en-US/docs/Web/API/Element/matches#Polyfill
    if (!Element.prototype.matches) Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
    var LOADING_MESSAGE = "Loading\u2026";
    var FAILURE_MESSAGE = function(status, message) {
        return "\u2716 Error " + status + " while fetching file: " + message;
    };
    var FAILURE_EMPTY_MESSAGE = "\u2716 Error: File does not exist or is empty";
    var EXTENSIONS = {
        "js": "javascript",
        "py": "python",
        "rb": "ruby",
        "ps1": "powershell",
        "psm1": "powershell",
        "sh": "bash",
        "bat": "batch",
        "h": "c",
        "tex": "latex"
    };
    var STATUS_ATTR = "data-src-status";
    var STATUS_LOADING = "loading";
    var STATUS_LOADED = "loaded";
    var STATUS_FAILED = "failed";
    var SELECTOR = "pre[data-src]:not([" + STATUS_ATTR + '="' + STATUS_LOADED + '"])' + ":not([" + STATUS_ATTR + '="' + STATUS_LOADING + '"])';
    /**
	 * Loads the given file.
	 *
	 * @param {string} src The URL or path of the source file to load.
	 * @param {(result: string) => void} success
	 * @param {(reason: string) => void} error
	 */ function loadFile(src, success, error) {
        var xhr = new XMLHttpRequest();
        xhr.open("GET", src, true);
        xhr.onreadystatechange = function() {
            if (xhr.readyState == 4) {
                if (xhr.status < 400 && xhr.responseText) success(xhr.responseText);
                else if (xhr.status >= 400) error(FAILURE_MESSAGE(xhr.status, xhr.statusText));
                else error(FAILURE_EMPTY_MESSAGE);
            }
        };
        xhr.send(null);
    }
    /**
	 * Parses the given range.
	 *
	 * This returns a range with inclusive ends.
	 *
	 * @param {string | null | undefined} range
	 * @returns {[number, number | undefined] | undefined}
	 */ function parseRange(range) {
        var m = /^\s*(\d+)\s*(?:(,)\s*(?:(\d+)\s*)?)?$/.exec(range || "");
        if (m) {
            var start = Number(m[1]);
            var comma = m[2];
            var end = m[3];
            if (!comma) return [
                start,
                start
            ];
            if (!end) return [
                start,
                undefined
            ];
            return [
                start,
                Number(end)
            ];
        }
        return undefined;
    }
    $8d0fc8fcdd0ba5d1$var$Prism.hooks.add("before-highlightall", function(env) {
        env.selector += ", " + SELECTOR;
    });
    $8d0fc8fcdd0ba5d1$var$Prism.hooks.add("before-sanity-check", function(env) {
        var pre = /** @type {HTMLPreElement} */ env.element;
        if (pre.matches(SELECTOR)) {
            env.code = ""; // fast-path the whole thing and go to complete
            pre.setAttribute(STATUS_ATTR, STATUS_LOADING); // mark as loading
            // add code element with loading message
            var code = pre.appendChild(document.createElement("CODE"));
            code.textContent = LOADING_MESSAGE;
            var src = pre.getAttribute("data-src");
            var language = env.language;
            if (language === "none") {
                // the language might be 'none' because there is no language set;
                // in this case, we want to use the extension as the language
                var extension = (/\.(\w+)$/.exec(src) || [
                    ,
                    "none"
                ])[1];
                language = EXTENSIONS[extension] || extension;
            }
            // set language classes
            $8d0fc8fcdd0ba5d1$var$Prism.util.setLanguage(code, language);
            $8d0fc8fcdd0ba5d1$var$Prism.util.setLanguage(pre, language);
            // preload the language
            var autoloader = $8d0fc8fcdd0ba5d1$var$Prism.plugins.autoloader;
            if (autoloader) autoloader.loadLanguages(language);
            // load file
            loadFile(src, function(text) {
                // mark as loaded
                pre.setAttribute(STATUS_ATTR, STATUS_LOADED);
                // handle data-range
                var range = parseRange(pre.getAttribute("data-range"));
                if (range) {
                    var lines = text.split(/\r\n?|\n/g);
                    // the range is one-based and inclusive on both ends
                    var start = range[0];
                    var end = range[1] == null ? lines.length : range[1];
                    if (start < 0) start += lines.length;
                    start = Math.max(0, Math.min(start - 1, lines.length));
                    if (end < 0) end += lines.length;
                    end = Math.max(0, Math.min(end, lines.length));
                    text = lines.slice(start, end).join("\n");
                    // add data-start for line numbers
                    if (!pre.hasAttribute("data-start")) pre.setAttribute("data-start", String(start + 1));
                }
                // highlight code
                code.textContent = text;
                $8d0fc8fcdd0ba5d1$var$Prism.highlightElement(code);
            }, function(error) {
                // mark as failed
                pre.setAttribute(STATUS_ATTR, STATUS_FAILED);
                code.textContent = error;
            });
        }
    });
    $8d0fc8fcdd0ba5d1$var$Prism.plugins.fileHighlight = {
        /**
		 * Executes the File Highlight plugin for all matching `pre` elements under the given container.
		 *
		 * Note: Elements which are already loaded or currently loading will not be touched by this method.
		 *
		 * @param {ParentNode} [container=document]
		 */ highlight: function highlight(container) {
            var elements = (container || document).querySelectorAll(SELECTOR);
            for(var i = 0, element; element = elements[i++];)$8d0fc8fcdd0ba5d1$var$Prism.highlightElement(element);
        }
    };
    var logged = false;
    /** @deprecated Use `Prism.plugins.fileHighlight.highlight` instead. */ $8d0fc8fcdd0ba5d1$var$Prism.fileHighlight = function() {
        if (!logged) {
            console.warn("Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead.");
            logged = true;
        }
        $8d0fc8fcdd0ba5d1$var$Prism.plugins.fileHighlight.highlight.apply(this, arguments);
    };
})();

});

parcelRegister("iDD18", function(module, exports) {
"use strict";

var $h57vw = parcelRequire("h57vw");

var $luHy5 = parcelRequire("luHy5");
module.exports = $luHy5;
$luHy5.prototype.message = $d91a2285cfa13691$var$message;
$luHy5.prototype.info = $d91a2285cfa13691$var$info;
$luHy5.prototype.fail = $d91a2285cfa13691$var$fail;
// Create a message with `reason` at `position`.
// When an error is passed in as `reason`, copies the stack.
function $d91a2285cfa13691$var$message(reason, position, origin) {
    var message = new $h57vw(reason, position, origin);
    if (this.path) {
        message.name = this.path + ":" + message.name;
        message.file = this.path;
    }
    message.fatal = false;
    this.messages.push(message);
    return message;
}
// Fail: creates a vmessage, associates it with the file, and throws it.
function $d91a2285cfa13691$var$fail() {
    var message = this.message.apply(this, arguments);
    message.fatal = true;
    throw message;
}
// Info: creates a vmessage, associates it with the file, and marks the fatality
// as null.
function $d91a2285cfa13691$var$info() {
    var message = this.message.apply(this, arguments);
    message.fatal = null;
    return message;
}

});
parcelRegister("h57vw", function(module, exports) {
"use strict";

var $daLR9 = parcelRequire("daLR9");
module.exports = $c6f8ba190cd790e8$var$VMessage;
// Inherit from `Error#`.
function $c6f8ba190cd790e8$var$VMessagePrototype() {}
$c6f8ba190cd790e8$var$VMessagePrototype.prototype = Error.prototype;
$c6f8ba190cd790e8$var$VMessage.prototype = new $c6f8ba190cd790e8$var$VMessagePrototype();
// Message properties.
var $c6f8ba190cd790e8$var$proto = $c6f8ba190cd790e8$var$VMessage.prototype;
$c6f8ba190cd790e8$var$proto.file = "";
$c6f8ba190cd790e8$var$proto.name = "";
$c6f8ba190cd790e8$var$proto.reason = "";
$c6f8ba190cd790e8$var$proto.message = "";
$c6f8ba190cd790e8$var$proto.stack = "";
$c6f8ba190cd790e8$var$proto.fatal = null;
$c6f8ba190cd790e8$var$proto.column = null;
$c6f8ba190cd790e8$var$proto.line = null;
// Construct a new VMessage.
//
// Note: We cannot invoke `Error` on the created context, as that adds readonly
// `line` and `column` attributes on Safari 9, thus throwing and failing the
// data.
function $c6f8ba190cd790e8$var$VMessage(reason, position, origin) {
    var parts;
    var range;
    var location;
    if (typeof position === "string") {
        origin = position;
        position = null;
    }
    parts = $c6f8ba190cd790e8$var$parseOrigin(origin);
    range = $daLR9(position) || "1:1";
    location = {
        start: {
            line: null,
            column: null
        },
        end: {
            line: null,
            column: null
        }
    };
    // Node.
    if (position && position.position) position = position.position;
    if (position) {
        // Position.
        if (position.start) {
            location = position;
            position = position.start;
        } else // Point.
        location.start = position;
    }
    if (reason.stack) {
        this.stack = reason.stack;
        reason = reason.message;
    }
    this.message = reason;
    this.name = range;
    this.reason = reason;
    this.line = position ? position.line : null;
    this.column = position ? position.column : null;
    this.location = location;
    this.source = parts[0];
    this.ruleId = parts[1];
}
function $c6f8ba190cd790e8$var$parseOrigin(origin) {
    var result = [
        null,
        null
    ];
    var index;
    if (typeof origin === "string") {
        index = origin.indexOf(":");
        if (index === -1) result[1] = origin;
        else {
            result[0] = origin.slice(0, index);
            result[1] = origin.slice(index + 1);
        }
    }
    return result;
}

});
parcelRegister("daLR9", function(module, exports) {
"use strict";
var $997154c8a8eacca8$var$own = {}.hasOwnProperty;
module.exports = $997154c8a8eacca8$var$stringify;
function $997154c8a8eacca8$var$stringify(value) {
    // Nothing.
    if (!value || typeof value !== "object") return "";
    // Node.
    if ($997154c8a8eacca8$var$own.call(value, "position") || $997154c8a8eacca8$var$own.call(value, "type")) return $997154c8a8eacca8$var$position(value.position);
    // Position.
    if ($997154c8a8eacca8$var$own.call(value, "start") || $997154c8a8eacca8$var$own.call(value, "end")) return $997154c8a8eacca8$var$position(value);
    // Point.
    if ($997154c8a8eacca8$var$own.call(value, "line") || $997154c8a8eacca8$var$own.call(value, "column")) return $997154c8a8eacca8$var$point(value);
    // ?
    return "";
}
function $997154c8a8eacca8$var$point(point) {
    if (!point || typeof point !== "object") point = {};
    return $997154c8a8eacca8$var$index(point.line) + ":" + $997154c8a8eacca8$var$index(point.column);
}
function $997154c8a8eacca8$var$position(pos) {
    if (!pos || typeof pos !== "object") pos = {};
    return $997154c8a8eacca8$var$point(pos.start) + "-" + $997154c8a8eacca8$var$point(pos.end);
}
function $997154c8a8eacca8$var$index(value) {
    return value && typeof value === "number" ? value : 1;
}

});


parcelRegister("luHy5", function(module, exports) {
"use strict";

var $5fJTo = parcelRequire("5fJTo");

var $gKuDl = parcelRequire("gKuDl");

var $9pg6E = parcelRequire("9pg6E");
module.exports = $fa5e2e367b2e707d$var$VFile;
var $fa5e2e367b2e707d$var$own = {}.hasOwnProperty;
// Order of setting (least specific to most), we need this because otherwise
// `{stem: 'a', path: '~/b.js'}` would throw, as a path is needed before a
// stem can be set.
var $fa5e2e367b2e707d$var$order = [
    "history",
    "path",
    "basename",
    "stem",
    "extname",
    "dirname"
];
$fa5e2e367b2e707d$var$VFile.prototype.toString = $fa5e2e367b2e707d$var$toString;
// Access full path (`~/index.min.js`).
Object.defineProperty($fa5e2e367b2e707d$var$VFile.prototype, "path", {
    get: $fa5e2e367b2e707d$var$getPath,
    set: $fa5e2e367b2e707d$var$setPath
});
// Access parent path (`~`).
Object.defineProperty($fa5e2e367b2e707d$var$VFile.prototype, "dirname", {
    get: $fa5e2e367b2e707d$var$getDirname,
    set: $fa5e2e367b2e707d$var$setDirname
});
// Access basename (`index.min.js`).
Object.defineProperty($fa5e2e367b2e707d$var$VFile.prototype, "basename", {
    get: $fa5e2e367b2e707d$var$getBasename,
    set: $fa5e2e367b2e707d$var$setBasename
});
// Access extname (`.js`).
Object.defineProperty($fa5e2e367b2e707d$var$VFile.prototype, "extname", {
    get: $fa5e2e367b2e707d$var$getExtname,
    set: $fa5e2e367b2e707d$var$setExtname
});
// Access stem (`index.min`).
Object.defineProperty($fa5e2e367b2e707d$var$VFile.prototype, "stem", {
    get: $fa5e2e367b2e707d$var$getStem,
    set: $fa5e2e367b2e707d$var$setStem
});
// Construct a new file.
function $fa5e2e367b2e707d$var$VFile(options) {
    var prop;
    var index;
    if (!options) options = {};
    else if (typeof options === "string" || $9pg6E(options)) options = {
        contents: options
    };
    else if ("message" in options && "messages" in options) return options;
    if (!(this instanceof $fa5e2e367b2e707d$var$VFile)) return new $fa5e2e367b2e707d$var$VFile(options);
    this.data = {};
    this.messages = [];
    this.history = [];
    this.cwd = $gKuDl.cwd();
    // Set path related properties in the correct order.
    index = -1;
    while(++index < $fa5e2e367b2e707d$var$order.length){
        prop = $fa5e2e367b2e707d$var$order[index];
        if ($fa5e2e367b2e707d$var$own.call(options, prop)) this[prop] = options[prop];
    }
    // Set non-path related properties.
    for(prop in options)if ($fa5e2e367b2e707d$var$order.indexOf(prop) < 0) this[prop] = options[prop];
}
function $fa5e2e367b2e707d$var$getPath() {
    return this.history[this.history.length - 1];
}
function $fa5e2e367b2e707d$var$setPath(path) {
    $fa5e2e367b2e707d$var$assertNonEmpty(path, "path");
    if (this.path !== path) this.history.push(path);
}
function $fa5e2e367b2e707d$var$getDirname() {
    return typeof this.path === "string" ? $5fJTo.dirname(this.path) : undefined;
}
function $fa5e2e367b2e707d$var$setDirname(dirname) {
    $fa5e2e367b2e707d$var$assertPath(this.path, "dirname");
    this.path = $5fJTo.join(dirname || "", this.basename);
}
function $fa5e2e367b2e707d$var$getBasename() {
    return typeof this.path === "string" ? $5fJTo.basename(this.path) : undefined;
}
function $fa5e2e367b2e707d$var$setBasename(basename) {
    $fa5e2e367b2e707d$var$assertNonEmpty(basename, "basename");
    $fa5e2e367b2e707d$var$assertPart(basename, "basename");
    this.path = $5fJTo.join(this.dirname || "", basename);
}
function $fa5e2e367b2e707d$var$getExtname() {
    return typeof this.path === "string" ? $5fJTo.extname(this.path) : undefined;
}
function $fa5e2e367b2e707d$var$setExtname(extname) {
    $fa5e2e367b2e707d$var$assertPart(extname, "extname");
    $fa5e2e367b2e707d$var$assertPath(this.path, "extname");
    if (extname) {
        if (extname.charCodeAt(0) !== 46 /* `.` */ ) throw new Error("`extname` must start with `.`");
        if (extname.indexOf(".", 1) > -1) throw new Error("`extname` cannot contain multiple dots");
    }
    this.path = $5fJTo.join(this.dirname, this.stem + (extname || ""));
}
function $fa5e2e367b2e707d$var$getStem() {
    return typeof this.path === "string" ? $5fJTo.basename(this.path, this.extname) : undefined;
}
function $fa5e2e367b2e707d$var$setStem(stem) {
    $fa5e2e367b2e707d$var$assertNonEmpty(stem, "stem");
    $fa5e2e367b2e707d$var$assertPart(stem, "stem");
    this.path = $5fJTo.join(this.dirname || "", stem + (this.extname || ""));
}
// Get the value of the file.
function $fa5e2e367b2e707d$var$toString(encoding) {
    return (this.contents || "").toString(encoding);
}
// Assert that `part` is not a path (i.e., does not contain `p.sep`).
function $fa5e2e367b2e707d$var$assertPart(part, name) {
    if (part && part.indexOf($5fJTo.sep) > -1) throw new Error("`" + name + "` cannot be a path: did not expect `" + $5fJTo.sep + "`");
}
// Assert that `part` is not empty.
function $fa5e2e367b2e707d$var$assertNonEmpty(part, name) {
    if (!part) throw new Error("`" + name + "` cannot be empty");
}
// Assert `path` exists.
function $fa5e2e367b2e707d$var$assertPath(path, name) {
    if (!path) throw new Error("Setting `" + name + "` requires `path` to be set too");
}

});
parcelRegister("5fJTo", function(module, exports) {
"use strict";

module.exports = $773sa$path;

});

parcelRegister("gKuDl", function(module, exports) {
"use strict";
module.exports = process;

});

parcelRegister("9pg6E", function(module, exports) {
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ module.exports = function isBuffer(obj) {
    return obj != null && obj.constructor != null && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
};

});



parcelRegister("28zcN", function(module, exports) {
if (typeof Object.create === "function") // implementation from standard node.js 'util' module
module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
    }
};
else // old school shim for old browsers
module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {};
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
    }
};

});

parcelRegister("lziKw", function(module, exports) {
"use strict";

var $l7d6x = parcelRequire("l7d6x");

var $dVLpd = parcelRequire("dVLpd");

var $hljKK = parcelRequire("hljKK");
module.exports = $fb3b691145ab4cc1$var$setOptions;
function $fb3b691145ab4cc1$var$setOptions(options) {
    var self = this;
    var current = self.options;
    var key;
    var value;
    if (options == null) options = {};
    else if (typeof options === "object") options = $l7d6x(options);
    else throw new Error("Invalid value `" + options + "` for setting `options`");
    for(key in $hljKK){
        value = options[key];
        if (value == null) value = current[key];
        if (key !== "blocks" && typeof value !== "boolean" || key === "blocks" && typeof value !== "object") throw new Error("Invalid value `" + value + "` for setting `options." + key + "`");
        options[key] = value;
    }
    self.options = options;
    self.escape = $dVLpd(options);
    return self;
}

});
parcelRegister("l7d6x", function(module, exports) {
module.exports = $f5f46aab6785d946$var$extend;
var $f5f46aab6785d946$var$hasOwnProperty = Object.prototype.hasOwnProperty;
function $f5f46aab6785d946$var$extend() {
    var target = {};
    for(var i = 0; i < arguments.length; i++){
        var source = arguments[i];
        for(var key in source)if ($f5f46aab6785d946$var$hasOwnProperty.call(source, key)) target[key] = source[key];
    }
    return target;
}

});

parcelRegister("dVLpd", function(module, exports) {
"use strict";
module.exports = $a2455f0acd1dd15e$var$escapes;
var $a2455f0acd1dd15e$var$defaults = [
    "\\",
    "`",
    "*",
    "{",
    "}",
    "[",
    "]",
    "(",
    ")",
    "#",
    "+",
    "-",
    ".",
    "!",
    "_",
    ">"
];
var $a2455f0acd1dd15e$var$gfm = $a2455f0acd1dd15e$var$defaults.concat([
    "~",
    "|"
]);
var $a2455f0acd1dd15e$var$commonmark = $a2455f0acd1dd15e$var$gfm.concat([
    "\n",
    '"',
    "$",
    "%",
    "&",
    "'",
    ",",
    "/",
    ":",
    ";",
    "<",
    "=",
    "?",
    "@",
    "^"
]);
$a2455f0acd1dd15e$var$escapes.default = $a2455f0acd1dd15e$var$defaults;
$a2455f0acd1dd15e$var$escapes.gfm = $a2455f0acd1dd15e$var$gfm;
$a2455f0acd1dd15e$var$escapes.commonmark = $a2455f0acd1dd15e$var$commonmark;
// Get markdown escapes.
function $a2455f0acd1dd15e$var$escapes(options) {
    var settings = options || {};
    if (settings.commonmark) return $a2455f0acd1dd15e$var$commonmark;
    return settings.gfm ? $a2455f0acd1dd15e$var$gfm : $a2455f0acd1dd15e$var$defaults;
}

});

parcelRegister("hljKK", function(module, exports) {
"use strict";

module.exports = {
    position: true,
    gfm: true,
    commonmark: false,
    pedantic: false,
    blocks: (parcelRequire("3i6ev"))
};

});
parcelRegister("3i6ev", function(module, exports) {
"use strict";
module.exports = [
    "address",
    "article",
    "aside",
    "base",
    "basefont",
    "blockquote",
    "body",
    "caption",
    "center",
    "col",
    "colgroup",
    "dd",
    "details",
    "dialog",
    "dir",
    "div",
    "dl",
    "dt",
    "fieldset",
    "figcaption",
    "figure",
    "footer",
    "form",
    "frame",
    "frameset",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "head",
    "header",
    "hgroup",
    "hr",
    "html",
    "iframe",
    "legend",
    "li",
    "link",
    "main",
    "menu",
    "menuitem",
    "meta",
    "nav",
    "noframes",
    "ol",
    "optgroup",
    "option",
    "p",
    "param",
    "pre",
    "section",
    "source",
    "title",
    "summary",
    "table",
    "tbody",
    "td",
    "tfoot",
    "th",
    "thead",
    "title",
    "tr",
    "track",
    "ul"
];

});



parcelRegister("iJz74", function(module, exports) {
"use strict";

var $l7d6x = parcelRequire("l7d6x");

var $2NQhM = parcelRequire("2NQhM");
module.exports = $da37aab129bde593$var$parse;
var $da37aab129bde593$var$lineFeed = "\n";
var $da37aab129bde593$var$lineBreaksExpression = /\r\n|\r/g;
// Parse the bound file.
function $da37aab129bde593$var$parse() {
    var self = this;
    var value = String(self.file);
    var start = {
        line: 1,
        column: 1,
        offset: 0
    };
    var content = $l7d6x(start);
    var node;
    // Clean non-unix newlines: `\r\n` and `\r` are all changed to `\n`.
    // This should not affect positional information.
    value = value.replace($da37aab129bde593$var$lineBreaksExpression, $da37aab129bde593$var$lineFeed);
    // BOM.
    if (value.charCodeAt(0) === 0xfeff) {
        value = value.slice(1);
        content.column++;
        content.offset++;
    }
    node = {
        type: "root",
        children: self.tokenizeBlock(value, content),
        position: {
            start: start,
            end: self.eof || $l7d6x(start)
        }
    };
    if (!self.options.position) $2NQhM(node, true);
    return node;
}

});
parcelRegister("2NQhM", function(module, exports) {
"use strict";

var $cGAg2 = parcelRequire("cGAg2");
module.exports = $20a8b740bff97ae4$var$removePosition;
function $20a8b740bff97ae4$var$removePosition(node, force) {
    $cGAg2(node, force ? $20a8b740bff97ae4$var$hard : $20a8b740bff97ae4$var$soft);
    return node;
}
function $20a8b740bff97ae4$var$hard(node) {
    delete node.position;
}
function $20a8b740bff97ae4$var$soft(node) {
    node.position = undefined;
}

});
parcelRegister("cGAg2", function(module, exports) {
"use strict";
module.exports = $93c5884a34e3da5e$var$visit;

var $iPiOu = parcelRequire("iPiOu");
var $93c5884a34e3da5e$var$CONTINUE = $iPiOu.CONTINUE;
var $93c5884a34e3da5e$var$SKIP = $iPiOu.SKIP;
var $93c5884a34e3da5e$var$EXIT = $iPiOu.EXIT;
$93c5884a34e3da5e$var$visit.CONTINUE = $93c5884a34e3da5e$var$CONTINUE;
$93c5884a34e3da5e$var$visit.SKIP = $93c5884a34e3da5e$var$SKIP;
$93c5884a34e3da5e$var$visit.EXIT = $93c5884a34e3da5e$var$EXIT;
function $93c5884a34e3da5e$var$visit(tree, test, visitor, reverse) {
    if (typeof test === "function" && typeof visitor !== "function") {
        reverse = visitor;
        visitor = test;
        test = null;
    }
    $iPiOu(tree, test, overload, reverse);
    function overload(node, parents) {
        var parent = parents[parents.length - 1];
        var index = parent ? parent.children.indexOf(node) : null;
        return visitor(node, index, parent);
    }
}

});
parcelRegister("iPiOu", function(module, exports) {
"use strict";
module.exports = $db4b955af2e80904$var$visitParents;

var $4tPT6 = parcelRequire("4tPT6");

var $5jFgv = parcelRequire("5jFgv");
var $db4b955af2e80904$var$CONTINUE = true;
var $db4b955af2e80904$var$SKIP = "skip";
var $db4b955af2e80904$var$EXIT = false;
$db4b955af2e80904$var$visitParents.CONTINUE = $db4b955af2e80904$var$CONTINUE;
$db4b955af2e80904$var$visitParents.SKIP = $db4b955af2e80904$var$SKIP;
$db4b955af2e80904$var$visitParents.EXIT = $db4b955af2e80904$var$EXIT;
function $db4b955af2e80904$var$visitParents(tree, test, visitor, reverse) {
    var step;
    var is;
    if (typeof test === "function" && typeof visitor !== "function") {
        reverse = visitor;
        visitor = test;
        test = null;
    }
    is = $4tPT6(test);
    step = reverse ? -1 : 1;
    factory(tree, null, [])();
    function factory(node, index, parents) {
        var value = typeof node === "object" && node !== null ? node : {};
        var name;
        if (typeof value.type === "string") {
            name = typeof value.tagName === "string" ? value.tagName : typeof value.name === "string" ? value.name : undefined;
            visit.displayName = "node (" + $5jFgv(value.type + (name ? "<" + name + ">" : "")) + ")";
        }
        return visit;
        function visit() {
            var grandparents = parents.concat(node);
            var result = [];
            var subresult;
            var offset;
            if (!test || is(node, index, parents[parents.length - 1] || null)) {
                result = $db4b955af2e80904$var$toResult(visitor(node, parents));
                if (result[0] === $db4b955af2e80904$var$EXIT) return result;
            }
            if (node.children && result[0] !== $db4b955af2e80904$var$SKIP) {
                offset = (reverse ? node.children.length : -1) + step;
                while(offset > -1 && offset < node.children.length){
                    subresult = factory(node.children[offset], offset, grandparents)();
                    if (subresult[0] === $db4b955af2e80904$var$EXIT) return subresult;
                    offset = typeof subresult[1] === "number" ? subresult[1] : offset + step;
                }
            }
            return result;
        }
    }
}
function $db4b955af2e80904$var$toResult(value) {
    if (value !== null && typeof value === "object" && "length" in value) return value;
    if (typeof value === "number") return [
        $db4b955af2e80904$var$CONTINUE,
        value
    ];
    return [
        value
    ];
}

});
parcelRegister("4tPT6", function(module, exports) {
"use strict";
module.exports = $34321eac7b5f9986$var$convert;
function $34321eac7b5f9986$var$convert(test) {
    if (test == null) return $34321eac7b5f9986$var$ok;
    if (typeof test === "string") return $34321eac7b5f9986$var$typeFactory(test);
    if (typeof test === "object") return "length" in test ? $34321eac7b5f9986$var$anyFactory(test) : $34321eac7b5f9986$var$allFactory(test);
    if (typeof test === "function") return test;
    throw new Error("Expected function, string, or object as test");
}
// Utility assert each property in `test` is represented in `node`, and each
// values are strictly equal.
function $34321eac7b5f9986$var$allFactory(test) {
    return all;
    function all(node) {
        var key;
        for(key in test){
            if (node[key] !== test[key]) return false;
        }
        return true;
    }
}
function $34321eac7b5f9986$var$anyFactory(tests) {
    var checks = [];
    var index = -1;
    while(++index < tests.length)checks[index] = $34321eac7b5f9986$var$convert(tests[index]);
    return any;
    function any() {
        var index = -1;
        while(++index < checks.length){
            if (checks[index].apply(this, arguments)) return true;
        }
        return false;
    }
}
// Utility to convert a string into a function which checks a given node’s type
// for said string.
function $34321eac7b5f9986$var$typeFactory(test) {
    return type;
    function type(node) {
        return Boolean(node && node.type === test);
    }
}
// Utility to return true.
function $34321eac7b5f9986$var$ok() {
    return true;
}

});

parcelRegister("5jFgv", function(module, exports) {
module.exports = $3deebc8867982244$var$color;
function $3deebc8867982244$var$color(d) {
    return "\x1b[33m" + d + "\x1b[39m";
}

});





parcelRegister("2ywBB", function(module, exports) {
"use strict";
// A line containing no characters, or a line containing only spaces (U+0020) or
// tabs (U+0009), is called a blank line.
// See <https://spec.commonmark.org/0.29/#blank-line>.
var $1dc80c7e732abd07$var$reBlankLine = /^[ \t]*(\n|$)/;
// Note that though blank lines play a special role in lists to determine
// whether the list is tight or loose
// (<https://spec.commonmark.org/0.29/#blank-lines>), it’s done by the list
// tokenizer and this blank line tokenizer does not have to be responsible for
// that.
// Therefore, configs such as `blankLine.notInList` do not have to be set here.
module.exports = $1dc80c7e732abd07$var$blankLine;
function $1dc80c7e732abd07$var$blankLine(eat, value, silent) {
    var match;
    var subvalue = "";
    var index = 0;
    var length = value.length;
    while(index < length){
        match = $1dc80c7e732abd07$var$reBlankLine.exec(value.slice(index));
        if (match == null) break;
        index += match[0].length;
        subvalue += match[0];
    }
    if (subvalue === "") return;
    /* istanbul ignore if - never used (yet) */ if (silent) return true;
    eat(subvalue);
}

});

parcelRegister("ht18v", function(module, exports) {
"use strict";

var $8EZDg = parcelRequire("8EZDg");

var $7HEQ1 = parcelRequire("7HEQ1");
module.exports = $cb7606b5ba76c605$var$indentedCode;
var $cb7606b5ba76c605$var$lineFeed = "\n";
var $cb7606b5ba76c605$var$tab = "	";
var $cb7606b5ba76c605$var$space = " ";
var $cb7606b5ba76c605$var$tabSize = 4;
var $cb7606b5ba76c605$var$codeIndent = $8EZDg($cb7606b5ba76c605$var$space, $cb7606b5ba76c605$var$tabSize);
function $cb7606b5ba76c605$var$indentedCode(eat, value, silent) {
    var index = -1;
    var length = value.length;
    var subvalue = "";
    var content = "";
    var subvalueQueue = "";
    var contentQueue = "";
    var character;
    var blankQueue;
    var indent;
    while(++index < length){
        character = value.charAt(index);
        if (indent) {
            indent = false;
            subvalue += subvalueQueue;
            content += contentQueue;
            subvalueQueue = "";
            contentQueue = "";
            if (character === $cb7606b5ba76c605$var$lineFeed) {
                subvalueQueue = character;
                contentQueue = character;
            } else {
                subvalue += character;
                content += character;
                while(++index < length){
                    character = value.charAt(index);
                    if (!character || character === $cb7606b5ba76c605$var$lineFeed) {
                        contentQueue = character;
                        subvalueQueue = character;
                        break;
                    }
                    subvalue += character;
                    content += character;
                }
            }
        } else if (character === $cb7606b5ba76c605$var$space && value.charAt(index + 1) === character && value.charAt(index + 2) === character && value.charAt(index + 3) === character) {
            subvalueQueue += $cb7606b5ba76c605$var$codeIndent;
            index += 3;
            indent = true;
        } else if (character === $cb7606b5ba76c605$var$tab) {
            subvalueQueue += character;
            indent = true;
        } else {
            blankQueue = "";
            while(character === $cb7606b5ba76c605$var$tab || character === $cb7606b5ba76c605$var$space){
                blankQueue += character;
                character = value.charAt(++index);
            }
            if (character !== $cb7606b5ba76c605$var$lineFeed) break;
            subvalueQueue += blankQueue + character;
            contentQueue += character;
        }
    }
    if (content) {
        if (silent) return true;
        return eat(subvalue)({
            type: "code",
            lang: null,
            meta: null,
            value: $7HEQ1(content)
        });
    }
}

});
parcelRegister("8EZDg", function(module, exports) {
/*!
 * repeat-string <https://github.com/jonschlinkert/repeat-string>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */ "use strict";
/**
 * Results cache
 */ var $01a08bd6ed2f051c$var$res = "";
var $01a08bd6ed2f051c$var$cache;
/**
 * Expose `repeat`
 */ module.exports = $01a08bd6ed2f051c$var$repeat;
/**
 * Repeat the given `string` the specified `number`
 * of times.
 *
 * **Example:**
 *
 * ```js
 * var repeat = require('repeat-string');
 * repeat('A', 5);
 * //=> AAAAA
 * ```
 *
 * @param {String} `string` The string to repeat
 * @param {Number} `number` The number of times to repeat the string
 * @return {String} Repeated string
 * @api public
 */ function $01a08bd6ed2f051c$var$repeat(str, num) {
    if (typeof str !== "string") throw new TypeError("expected a string");
    // cover common, quick use cases
    if (num === 1) return str;
    if (num === 2) return str + str;
    var max = str.length * num;
    if ($01a08bd6ed2f051c$var$cache !== str || typeof $01a08bd6ed2f051c$var$cache === "undefined") {
        $01a08bd6ed2f051c$var$cache = str;
        $01a08bd6ed2f051c$var$res = "";
    } else if ($01a08bd6ed2f051c$var$res.length >= max) return $01a08bd6ed2f051c$var$res.substr(0, max);
    while(max > $01a08bd6ed2f051c$var$res.length && num > 1){
        if (num & 1) $01a08bd6ed2f051c$var$res += str;
        num >>= 1;
        str += str;
    }
    $01a08bd6ed2f051c$var$res += str;
    $01a08bd6ed2f051c$var$res = $01a08bd6ed2f051c$var$res.substr(0, max);
    return $01a08bd6ed2f051c$var$res;
}

});

parcelRegister("7HEQ1", function(module, exports) {
"use strict";
module.exports = $59bc3a1ec94c1fe5$var$trimTrailingLines;
// Remove final newline characters from `value`.
function $59bc3a1ec94c1fe5$var$trimTrailingLines(value) {
    return String(value).replace(/\n+$/, "");
}

});


parcelRegister("dehwG", function(module, exports) {
"use strict";
module.exports = $9a1a2d812f4a4f14$var$fencedCode;
var $9a1a2d812f4a4f14$var$lineFeed = "\n";
var $9a1a2d812f4a4f14$var$tab = "	";
var $9a1a2d812f4a4f14$var$space = " ";
var $9a1a2d812f4a4f14$var$tilde = "~";
var $9a1a2d812f4a4f14$var$graveAccent = "`";
var $9a1a2d812f4a4f14$var$minFenceCount = 3;
var $9a1a2d812f4a4f14$var$tabSize = 4;
function $9a1a2d812f4a4f14$var$fencedCode(eat, value, silent) {
    var self = this;
    var gfm = self.options.gfm;
    var length = value.length + 1;
    var index = 0;
    var subvalue = "";
    var fenceCount;
    var marker;
    var character;
    var flag;
    var lang;
    var meta;
    var queue;
    var content;
    var exdentedContent;
    var closing;
    var exdentedClosing;
    var indent;
    var now;
    if (!gfm) return;
    // Eat initial spacing.
    while(index < length){
        character = value.charAt(index);
        if (character !== $9a1a2d812f4a4f14$var$space && character !== $9a1a2d812f4a4f14$var$tab) break;
        subvalue += character;
        index++;
    }
    indent = index;
    // Eat the fence.
    character = value.charAt(index);
    if (character !== $9a1a2d812f4a4f14$var$tilde && character !== $9a1a2d812f4a4f14$var$graveAccent) return;
    index++;
    marker = character;
    fenceCount = 1;
    subvalue += character;
    while(index < length){
        character = value.charAt(index);
        if (character !== marker) break;
        subvalue += character;
        fenceCount++;
        index++;
    }
    if (fenceCount < $9a1a2d812f4a4f14$var$minFenceCount) return;
    // Eat spacing before flag.
    while(index < length){
        character = value.charAt(index);
        if (character !== $9a1a2d812f4a4f14$var$space && character !== $9a1a2d812f4a4f14$var$tab) break;
        subvalue += character;
        index++;
    }
    // Eat flag.
    flag = "";
    queue = "";
    while(index < length){
        character = value.charAt(index);
        if (character === $9a1a2d812f4a4f14$var$lineFeed || marker === $9a1a2d812f4a4f14$var$graveAccent && character === marker) break;
        if (character === $9a1a2d812f4a4f14$var$space || character === $9a1a2d812f4a4f14$var$tab) queue += character;
        else {
            flag += queue + character;
            queue = "";
        }
        index++;
    }
    character = value.charAt(index);
    if (character && character !== $9a1a2d812f4a4f14$var$lineFeed) return;
    if (silent) return true;
    now = eat.now();
    now.column += subvalue.length;
    now.offset += subvalue.length;
    subvalue += flag;
    flag = self.decode.raw(self.unescape(flag), now);
    if (queue) subvalue += queue;
    queue = "";
    closing = "";
    exdentedClosing = "";
    content = "";
    exdentedContent = "";
    var skip = true;
    // Eat content.
    while(index < length){
        character = value.charAt(index);
        content += closing;
        exdentedContent += exdentedClosing;
        closing = "";
        exdentedClosing = "";
        if (character !== $9a1a2d812f4a4f14$var$lineFeed) {
            content += character;
            exdentedClosing += character;
            index++;
            continue;
        }
        // The first line feed is ignored. Others aren’t.
        if (skip) {
            subvalue += character;
            skip = false;
        } else {
            closing += character;
            exdentedClosing += character;
        }
        queue = "";
        index++;
        while(index < length){
            character = value.charAt(index);
            if (character !== $9a1a2d812f4a4f14$var$space) break;
            queue += character;
            index++;
        }
        closing += queue;
        exdentedClosing += queue.slice(indent);
        if (queue.length >= $9a1a2d812f4a4f14$var$tabSize) continue;
        queue = "";
        while(index < length){
            character = value.charAt(index);
            if (character !== marker) break;
            queue += character;
            index++;
        }
        closing += queue;
        exdentedClosing += queue;
        if (queue.length < fenceCount) continue;
        queue = "";
        while(index < length){
            character = value.charAt(index);
            if (character !== $9a1a2d812f4a4f14$var$space && character !== $9a1a2d812f4a4f14$var$tab) break;
            closing += character;
            exdentedClosing += character;
            index++;
        }
        if (!character || character === $9a1a2d812f4a4f14$var$lineFeed) break;
    }
    subvalue += content + closing;
    // Get lang and meta from the flag.
    index = -1;
    length = flag.length;
    while(++index < length){
        character = flag.charAt(index);
        if (character === $9a1a2d812f4a4f14$var$space || character === $9a1a2d812f4a4f14$var$tab) {
            if (!lang) lang = flag.slice(0, index);
        } else if (lang) {
            meta = flag.slice(index);
            break;
        }
    }
    return eat(subvalue)({
        type: "code",
        lang: lang || flag || null,
        meta: meta || null,
        value: exdentedContent
    });
}

});

parcelRegister("8pQ2R", function(module, exports) {
"use strict";

var $yVfl8 = parcelRequire("yVfl8");

var $gMsCU = parcelRequire("gMsCU");
module.exports = $620907a1bccb698c$var$blockquote;
var $620907a1bccb698c$var$lineFeed = "\n";
var $620907a1bccb698c$var$tab = "	";
var $620907a1bccb698c$var$space = " ";
var $620907a1bccb698c$var$greaterThan = ">";
function $620907a1bccb698c$var$blockquote(eat, value, silent) {
    var self = this;
    var offsets = self.offset;
    var tokenizers = self.blockTokenizers;
    var interruptors = self.interruptBlockquote;
    var now = eat.now();
    var currentLine = now.line;
    var length = value.length;
    var values = [];
    var contents = [];
    var indents = [];
    var add;
    var index = 0;
    var character;
    var rest;
    var nextIndex;
    var content;
    var line;
    var startIndex;
    var prefixed;
    var exit;
    while(index < length){
        character = value.charAt(index);
        if (character !== $620907a1bccb698c$var$space && character !== $620907a1bccb698c$var$tab) break;
        index++;
    }
    if (value.charAt(index) !== $620907a1bccb698c$var$greaterThan) return;
    if (silent) return true;
    index = 0;
    while(index < length){
        nextIndex = value.indexOf($620907a1bccb698c$var$lineFeed, index);
        startIndex = index;
        prefixed = false;
        if (nextIndex === -1) nextIndex = length;
        while(index < length){
            character = value.charAt(index);
            if (character !== $620907a1bccb698c$var$space && character !== $620907a1bccb698c$var$tab) break;
            index++;
        }
        if (value.charAt(index) === $620907a1bccb698c$var$greaterThan) {
            index++;
            prefixed = true;
            if (value.charAt(index) === $620907a1bccb698c$var$space) index++;
        } else index = startIndex;
        content = value.slice(index, nextIndex);
        if (!prefixed && !$yVfl8(content)) {
            index = startIndex;
            break;
        }
        if (!prefixed) {
            rest = value.slice(index);
            // Check if the following code contains a possible block.
            if ($gMsCU(interruptors, tokenizers, self, [
                eat,
                rest,
                true
            ])) break;
        }
        line = startIndex === index ? content : value.slice(startIndex, nextIndex);
        indents.push(index - startIndex);
        values.push(line);
        contents.push(content);
        index = nextIndex + 1;
    }
    index = -1;
    length = indents.length;
    add = eat(values.join($620907a1bccb698c$var$lineFeed));
    while(++index < length){
        offsets[currentLine] = (offsets[currentLine] || 0) + indents[index];
        currentLine++;
    }
    exit = self.enterBlock();
    contents = self.tokenizeBlock(contents.join($620907a1bccb698c$var$lineFeed), now);
    exit();
    return add({
        type: "blockquote",
        children: contents
    });
}

});
parcelRegister("yVfl8", function(module, exports) {
exports = module.exports = trim;
function trim(str) {
    if (str.trim) return str.trim();
    return exports.right(exports.left(str));
}
exports.left = function(str) {
    if (str.trimLeft) return str.trimLeft();
    return str.replace(/^\s\s*/, "");
};
exports.right = function(str) {
    if (str.trimRight) return str.trimRight();
    var whitespace_pattern = /\s/, i = str.length;
    while(whitespace_pattern.test(str.charAt(--i)));
    return str.slice(0, i + 1);
};

});

parcelRegister("gMsCU", function(module, exports) {
"use strict";
module.exports = $03271607011590b1$var$interrupt;
function $03271607011590b1$var$interrupt(interruptors, tokenizers, ctx, parameters) {
    var length = interruptors.length;
    var index = -1;
    var interruptor;
    var config;
    while(++index < length){
        interruptor = interruptors[index];
        config = interruptor[1] || {};
        if (config.pedantic !== undefined && config.pedantic !== ctx.options.pedantic) continue;
        if (config.commonmark !== undefined && config.commonmark !== ctx.options.commonmark) continue;
        if (tokenizers[interruptor[0]].apply(ctx, parameters)) return true;
    }
    return false;
}

});


parcelRegister("8lsyk", function(module, exports) {
"use strict";
module.exports = $61366ed7736f4ddd$var$atxHeading;
var $61366ed7736f4ddd$var$lineFeed = "\n";
var $61366ed7736f4ddd$var$tab = "	";
var $61366ed7736f4ddd$var$space = " ";
var $61366ed7736f4ddd$var$numberSign = "#";
var $61366ed7736f4ddd$var$maxFenceCount = 6;
function $61366ed7736f4ddd$var$atxHeading(eat, value, silent) {
    var self = this;
    var pedantic = self.options.pedantic;
    var length = value.length + 1;
    var index = -1;
    var now = eat.now();
    var subvalue = "";
    var content = "";
    var character;
    var queue;
    var depth;
    // Eat initial spacing.
    while(++index < length){
        character = value.charAt(index);
        if (character !== $61366ed7736f4ddd$var$space && character !== $61366ed7736f4ddd$var$tab) {
            index--;
            break;
        }
        subvalue += character;
    }
    // Eat hashes.
    depth = 0;
    while(++index <= length){
        character = value.charAt(index);
        if (character !== $61366ed7736f4ddd$var$numberSign) {
            index--;
            break;
        }
        subvalue += character;
        depth++;
    }
    if (depth > $61366ed7736f4ddd$var$maxFenceCount) return;
    if (!depth || !pedantic && value.charAt(index + 1) === $61366ed7736f4ddd$var$numberSign) return;
    length = value.length + 1;
    // Eat intermediate white-space.
    queue = "";
    while(++index < length){
        character = value.charAt(index);
        if (character !== $61366ed7736f4ddd$var$space && character !== $61366ed7736f4ddd$var$tab) {
            index--;
            break;
        }
        queue += character;
    }
    // Exit when not in pedantic mode without spacing.
    if (!pedantic && queue.length === 0 && character && character !== $61366ed7736f4ddd$var$lineFeed) return;
    if (silent) return true;
    // Eat content.
    subvalue += queue;
    queue = "";
    content = "";
    while(++index < length){
        character = value.charAt(index);
        if (!character || character === $61366ed7736f4ddd$var$lineFeed) break;
        if (character !== $61366ed7736f4ddd$var$space && character !== $61366ed7736f4ddd$var$tab && character !== $61366ed7736f4ddd$var$numberSign) {
            content += queue + character;
            queue = "";
            continue;
        }
        while(character === $61366ed7736f4ddd$var$space || character === $61366ed7736f4ddd$var$tab){
            queue += character;
            character = value.charAt(++index);
        }
        // `#` without a queue is part of the content.
        if (!pedantic && content && !queue && character === $61366ed7736f4ddd$var$numberSign) {
            content += character;
            continue;
        }
        while(character === $61366ed7736f4ddd$var$numberSign){
            queue += character;
            character = value.charAt(++index);
        }
        while(character === $61366ed7736f4ddd$var$space || character === $61366ed7736f4ddd$var$tab){
            queue += character;
            character = value.charAt(++index);
        }
        index--;
    }
    now.column += subvalue.length;
    now.offset += subvalue.length;
    subvalue += content + queue;
    return eat(subvalue)({
        type: "heading",
        depth: depth,
        children: self.tokenizeInline(content, now)
    });
}

});

parcelRegister("jsWmx", function(module, exports) {
"use strict";
module.exports = $e2bde76c49328984$var$thematicBreak;
var $e2bde76c49328984$var$tab = "	";
var $e2bde76c49328984$var$lineFeed = "\n";
var $e2bde76c49328984$var$space = " ";
var $e2bde76c49328984$var$asterisk = "*";
var $e2bde76c49328984$var$dash = "-";
var $e2bde76c49328984$var$underscore = "_";
var $e2bde76c49328984$var$maxCount = 3;
function $e2bde76c49328984$var$thematicBreak(eat, value, silent) {
    var index = -1;
    var length = value.length + 1;
    var subvalue = "";
    var character;
    var marker;
    var markerCount;
    var queue;
    while(++index < length){
        character = value.charAt(index);
        if (character !== $e2bde76c49328984$var$tab && character !== $e2bde76c49328984$var$space) break;
        subvalue += character;
    }
    if (character !== $e2bde76c49328984$var$asterisk && character !== $e2bde76c49328984$var$dash && character !== $e2bde76c49328984$var$underscore) return;
    marker = character;
    subvalue += character;
    markerCount = 1;
    queue = "";
    while(++index < length){
        character = value.charAt(index);
        if (character === marker) {
            markerCount++;
            subvalue += queue + marker;
            queue = "";
        } else if (character === $e2bde76c49328984$var$space) queue += character;
        else if (markerCount >= $e2bde76c49328984$var$maxCount && (!character || character === $e2bde76c49328984$var$lineFeed)) {
            subvalue += queue;
            if (silent) return true;
            return eat(subvalue)({
                type: "thematicBreak"
            });
        } else return;
    }
}

});

parcelRegister("bddsb", function(module, exports) {
"use strict";

var $yVfl8 = parcelRequire("yVfl8");

var $8EZDg = parcelRequire("8EZDg");

var $ffwtM = parcelRequire("ffwtM");

var $kmf7O = parcelRequire("kmf7O");

var $8vq4w = parcelRequire("8vq4w");

var $gMsCU = parcelRequire("gMsCU");
module.exports = $829b583095284272$var$list;
var $829b583095284272$var$asterisk = "*";
var $829b583095284272$var$underscore = "_";
var $829b583095284272$var$plusSign = "+";
var $829b583095284272$var$dash = "-";
var $829b583095284272$var$dot = ".";
var $829b583095284272$var$space = " ";
var $829b583095284272$var$lineFeed = "\n";
var $829b583095284272$var$tab = "	";
var $829b583095284272$var$rightParenthesis = ")";
var $829b583095284272$var$lowercaseX = "x";
var $829b583095284272$var$tabSize = 4;
var $829b583095284272$var$looseListItemExpression = /\n\n(?!\s*$)/;
var $829b583095284272$var$taskItemExpression = /^\[([ X\tx])][ \t]/;
var $829b583095284272$var$bulletExpression = /^([ \t]*)([*+-]|\d+[.)])( {1,4}(?! )| |\t|$|(?=\n))([^\n]*)/;
var $829b583095284272$var$pedanticBulletExpression = /^([ \t]*)([*+-]|\d+[.)])([ \t]+)/;
var $829b583095284272$var$initialIndentExpression = /^( {1,4}|\t)?/gm;
function $829b583095284272$var$list(eat, value, silent) {
    var self = this;
    var commonmark = self.options.commonmark;
    var pedantic = self.options.pedantic;
    var tokenizers = self.blockTokenizers;
    var interuptors = self.interruptList;
    var index = 0;
    var length = value.length;
    var start = null;
    var size;
    var queue;
    var ordered;
    var character;
    var marker;
    var nextIndex;
    var startIndex;
    var prefixed;
    var currentMarker;
    var content;
    var line;
    var previousEmpty;
    var empty;
    var items;
    var allLines;
    var emptyLines;
    var item;
    var enterTop;
    var exitBlockquote;
    var spread = false;
    var node;
    var now;
    var end;
    var indented;
    while(index < length){
        character = value.charAt(index);
        if (character !== $829b583095284272$var$tab && character !== $829b583095284272$var$space) break;
        index++;
    }
    character = value.charAt(index);
    if (character === $829b583095284272$var$asterisk || character === $829b583095284272$var$plusSign || character === $829b583095284272$var$dash) {
        marker = character;
        ordered = false;
    } else {
        ordered = true;
        queue = "";
        while(index < length){
            character = value.charAt(index);
            if (!$ffwtM(character)) break;
            queue += character;
            index++;
        }
        character = value.charAt(index);
        if (!queue || !(character === $829b583095284272$var$dot || commonmark && character === $829b583095284272$var$rightParenthesis)) return;
        /* Slightly abusing `silent` mode, whose goal is to make interrupting
     * paragraphs work.
     * Well, that’s exactly what we want to do here: don’t interrupt:
     * 2. here, because the “list” doesn’t start with `1`. */ if (silent && queue !== "1") return;
        start = parseInt(queue, 10);
        marker = character;
    }
    character = value.charAt(++index);
    if (character !== $829b583095284272$var$space && character !== $829b583095284272$var$tab && (pedantic || character !== $829b583095284272$var$lineFeed && character !== "")) return;
    if (silent) return true;
    index = 0;
    items = [];
    allLines = [];
    emptyLines = [];
    while(index < length){
        nextIndex = value.indexOf($829b583095284272$var$lineFeed, index);
        startIndex = index;
        prefixed = false;
        indented = false;
        if (nextIndex === -1) nextIndex = length;
        size = 0;
        while(index < length){
            character = value.charAt(index);
            if (character === $829b583095284272$var$tab) size += $829b583095284272$var$tabSize - size % $829b583095284272$var$tabSize;
            else if (character === $829b583095284272$var$space) size++;
            else break;
            index++;
        }
        if (item && size >= item.indent) indented = true;
        character = value.charAt(index);
        currentMarker = null;
        if (!indented) {
            if (character === $829b583095284272$var$asterisk || character === $829b583095284272$var$plusSign || character === $829b583095284272$var$dash) {
                currentMarker = character;
                index++;
                size++;
            } else {
                queue = "";
                while(index < length){
                    character = value.charAt(index);
                    if (!$ffwtM(character)) break;
                    queue += character;
                    index++;
                }
                character = value.charAt(index);
                index++;
                if (queue && (character === $829b583095284272$var$dot || commonmark && character === $829b583095284272$var$rightParenthesis)) {
                    currentMarker = character;
                    size += queue.length + 1;
                }
            }
            if (currentMarker) {
                character = value.charAt(index);
                if (character === $829b583095284272$var$tab) {
                    size += $829b583095284272$var$tabSize - size % $829b583095284272$var$tabSize;
                    index++;
                } else if (character === $829b583095284272$var$space) {
                    end = index + $829b583095284272$var$tabSize;
                    while(index < end){
                        if (value.charAt(index) !== $829b583095284272$var$space) break;
                        index++;
                        size++;
                    }
                    if (index === end && value.charAt(index) === $829b583095284272$var$space) {
                        index -= $829b583095284272$var$tabSize - 1;
                        size -= $829b583095284272$var$tabSize - 1;
                    }
                } else if (character !== $829b583095284272$var$lineFeed && character !== "") currentMarker = null;
            }
        }
        if (currentMarker) {
            if (!pedantic && marker !== currentMarker) break;
            prefixed = true;
        } else {
            if (!commonmark && !indented && value.charAt(startIndex) === $829b583095284272$var$space) indented = true;
            else if (commonmark && item) indented = size >= item.indent || size > $829b583095284272$var$tabSize;
            prefixed = false;
            index = startIndex;
        }
        line = value.slice(startIndex, nextIndex);
        content = startIndex === index ? line : value.slice(index, nextIndex);
        if (currentMarker === $829b583095284272$var$asterisk || currentMarker === $829b583095284272$var$underscore || currentMarker === $829b583095284272$var$dash) {
            if (tokenizers.thematicBreak.call(self, eat, line, true)) break;
        }
        previousEmpty = empty;
        empty = !prefixed && !$yVfl8(content).length;
        if (indented && item) {
            item.value = item.value.concat(emptyLines, line);
            allLines = allLines.concat(emptyLines, line);
            emptyLines = [];
        } else if (prefixed) {
            if (emptyLines.length !== 0) {
                spread = true;
                item.value.push("");
                item.trail = emptyLines.concat();
            }
            item = {
                value: [
                    line
                ],
                indent: size,
                trail: []
            };
            items.push(item);
            allLines = allLines.concat(emptyLines, line);
            emptyLines = [];
        } else if (empty) {
            if (previousEmpty && !commonmark) break;
            emptyLines.push(line);
        } else {
            if (previousEmpty) break;
            if ($gMsCU(interuptors, tokenizers, self, [
                eat,
                line,
                true
            ])) break;
            item.value = item.value.concat(emptyLines, line);
            allLines = allLines.concat(emptyLines, line);
            emptyLines = [];
        }
        index = nextIndex + 1;
    }
    node = eat(allLines.join($829b583095284272$var$lineFeed)).reset({
        type: "list",
        ordered: ordered,
        start: start,
        spread: spread,
        children: []
    });
    enterTop = self.enterList();
    exitBlockquote = self.enterBlock();
    index = -1;
    length = items.length;
    while(++index < length){
        item = items[index].value.join($829b583095284272$var$lineFeed);
        now = eat.now();
        eat(item)($829b583095284272$var$listItem(self, item, now), node);
        item = items[index].trail.join($829b583095284272$var$lineFeed);
        if (index !== length - 1) item += $829b583095284272$var$lineFeed;
        eat(item);
    }
    enterTop();
    exitBlockquote();
    return node;
}
function $829b583095284272$var$listItem(ctx, value, position) {
    var offsets = ctx.offset;
    var fn = ctx.options.pedantic ? $829b583095284272$var$pedanticListItem : $829b583095284272$var$normalListItem;
    var checked = null;
    var task;
    var indent;
    value = fn.apply(null, arguments);
    if (ctx.options.gfm) {
        task = value.match($829b583095284272$var$taskItemExpression);
        if (task) {
            indent = task[0].length;
            checked = task[1].toLowerCase() === $829b583095284272$var$lowercaseX;
            offsets[position.line] += indent;
            value = value.slice(indent);
        }
    }
    return {
        type: "listItem",
        spread: $829b583095284272$var$looseListItemExpression.test(value),
        checked: checked,
        children: ctx.tokenizeBlock(value, position)
    };
}
// Create a list-item using overly simple mechanics.
function $829b583095284272$var$pedanticListItem(ctx, value, position) {
    var offsets = ctx.offset;
    var line = position.line;
    // Remove the list-item’s bullet.
    value = value.replace($829b583095284272$var$pedanticBulletExpression, replacer);
    // The initial line was also matched by the below, so we reset the `line`.
    line = position.line;
    return value.replace($829b583095284272$var$initialIndentExpression, replacer);
    // A simple replacer which removed all matches, and adds their length to
    // `offset`.
    function replacer($0) {
        offsets[line] = (offsets[line] || 0) + $0.length;
        line++;
        return "";
    }
}
// Create a list-item using sane mechanics.
function $829b583095284272$var$normalListItem(ctx, value, position) {
    var offsets = ctx.offset;
    var line = position.line;
    var max;
    var bullet;
    var rest;
    var lines;
    var trimmedLines;
    var index;
    var length;
    // Remove the list-item’s bullet.
    value = value.replace($829b583095284272$var$bulletExpression, replacer);
    lines = value.split($829b583095284272$var$lineFeed);
    trimmedLines = $8vq4w(value, $kmf7O(max).indent).split($829b583095284272$var$lineFeed);
    // We replaced the initial bullet with something else above, which was used
    // to trick `removeIndentation` into removing some more characters when
    // possible.  However, that could result in the initial line to be stripped
    // more than it should be.
    trimmedLines[0] = rest;
    offsets[line] = (offsets[line] || 0) + bullet.length;
    line++;
    index = 0;
    length = lines.length;
    while(++index < length){
        offsets[line] = (offsets[line] || 0) + lines[index].length - trimmedLines[index].length;
        line++;
    }
    return trimmedLines.join($829b583095284272$var$lineFeed);
    /* eslint-disable-next-line max-params */ function replacer($0, $1, $2, $3, $4) {
        bullet = $1 + $2 + $3;
        rest = $4;
        // Make sure that the first nine numbered list items can indent with an
        // extra space.  That is, when the bullet did not receive an extra final
        // space.
        if (Number($2) < 10 && bullet.length % 2 === 1) $2 = $829b583095284272$var$space + $2;
        max = $1 + $8EZDg($829b583095284272$var$space, $2.length) + $3;
        return max + rest;
    }
}

});
parcelRegister("ffwtM", function(module, exports) {
"use strict";
module.exports = $02dd715895a6bd47$var$decimal;
// Check if the given character code, or the character code at the first
// character, is decimal.
function $02dd715895a6bd47$var$decimal(character) {
    var code = typeof character === "string" ? character.charCodeAt(0) : character;
    return code >= 48 && code <= 57 /* 0-9 */ ;
}

});

parcelRegister("kmf7O", function(module, exports) {
"use strict";
module.exports = $ed219837ca4b0e2e$var$indentation;
var $ed219837ca4b0e2e$var$tab = "	";
var $ed219837ca4b0e2e$var$space = " ";
var $ed219837ca4b0e2e$var$spaceSize = 1;
var $ed219837ca4b0e2e$var$tabSize = 4;
// Gets indentation information for a line.
function $ed219837ca4b0e2e$var$indentation(value) {
    var index = 0;
    var indent = 0;
    var character = value.charAt(index);
    var stops = {};
    var size;
    var lastIndent = 0;
    while(character === $ed219837ca4b0e2e$var$tab || character === $ed219837ca4b0e2e$var$space){
        size = character === $ed219837ca4b0e2e$var$tab ? $ed219837ca4b0e2e$var$tabSize : $ed219837ca4b0e2e$var$spaceSize;
        indent += size;
        if (size > 1) indent = Math.floor(indent / size) * size;
        while(lastIndent < indent)stops[++lastIndent] = index;
        character = value.charAt(++index);
    }
    return {
        indent: indent,
        stops: stops
    };
}

});

parcelRegister("8vq4w", function(module, exports) {
"use strict";

var $yVfl8 = parcelRequire("yVfl8");

var $8EZDg = parcelRequire("8EZDg");

var $kmf7O = parcelRequire("kmf7O");
module.exports = $63157157234ec88d$var$indentation;
var $63157157234ec88d$var$lineFeed = "\n";
var $63157157234ec88d$var$space = " ";
var $63157157234ec88d$var$exclamationMark = "!";
// Remove the minimum indent from every line in `value`.  Supports both tab,
// spaced, and mixed indentation (as well as possible).
function $63157157234ec88d$var$indentation(value, maximum) {
    var values = value.split($63157157234ec88d$var$lineFeed);
    var position = values.length + 1;
    var minIndent = Infinity;
    var matrix = [];
    var index;
    var indentation;
    var stops;
    values.unshift($8EZDg($63157157234ec88d$var$space, maximum) + $63157157234ec88d$var$exclamationMark);
    while(position--){
        indentation = $kmf7O(values[position]);
        matrix[position] = indentation.stops;
        if ($yVfl8(values[position]).length === 0) continue;
        if (indentation.indent) {
            if (indentation.indent > 0 && indentation.indent < minIndent) minIndent = indentation.indent;
        } else {
            minIndent = Infinity;
            break;
        }
    }
    if (minIndent !== Infinity) {
        position = values.length;
        while(position--){
            stops = matrix[position];
            index = minIndent;
            while(index && !(index in stops))index--;
            values[position] = values[position].slice(stops[index] + 1);
        }
    }
    values.shift();
    return values.join($63157157234ec88d$var$lineFeed);
}

});


parcelRegister("01T1z", function(module, exports) {
"use strict";
module.exports = $005ac6cfc68d2cb3$var$setextHeading;
var $005ac6cfc68d2cb3$var$lineFeed = "\n";
var $005ac6cfc68d2cb3$var$tab = "	";
var $005ac6cfc68d2cb3$var$space = " ";
var $005ac6cfc68d2cb3$var$equalsTo = "=";
var $005ac6cfc68d2cb3$var$dash = "-";
var $005ac6cfc68d2cb3$var$maxIndent = 3;
var $005ac6cfc68d2cb3$var$equalsToDepth = 1;
var $005ac6cfc68d2cb3$var$dashDepth = 2;
function $005ac6cfc68d2cb3$var$setextHeading(eat, value, silent) {
    var self = this;
    var now = eat.now();
    var length = value.length;
    var index = -1;
    var subvalue = "";
    var content;
    var queue;
    var character;
    var marker;
    var depth;
    // Eat initial indentation.
    while(++index < length){
        character = value.charAt(index);
        if (character !== $005ac6cfc68d2cb3$var$space || index >= $005ac6cfc68d2cb3$var$maxIndent) {
            index--;
            break;
        }
        subvalue += character;
    }
    // Eat content.
    content = "";
    queue = "";
    while(++index < length){
        character = value.charAt(index);
        if (character === $005ac6cfc68d2cb3$var$lineFeed) {
            index--;
            break;
        }
        if (character === $005ac6cfc68d2cb3$var$space || character === $005ac6cfc68d2cb3$var$tab) queue += character;
        else {
            content += queue + character;
            queue = "";
        }
    }
    now.column += subvalue.length;
    now.offset += subvalue.length;
    subvalue += content + queue;
    // Ensure the content is followed by a newline and a valid marker.
    character = value.charAt(++index);
    marker = value.charAt(++index);
    if (character !== $005ac6cfc68d2cb3$var$lineFeed || marker !== $005ac6cfc68d2cb3$var$equalsTo && marker !== $005ac6cfc68d2cb3$var$dash) return;
    subvalue += character;
    // Eat Setext-line.
    queue = marker;
    depth = marker === $005ac6cfc68d2cb3$var$equalsTo ? $005ac6cfc68d2cb3$var$equalsToDepth : $005ac6cfc68d2cb3$var$dashDepth;
    while(++index < length){
        character = value.charAt(index);
        if (character !== marker) {
            if (character !== $005ac6cfc68d2cb3$var$lineFeed) return;
            index--;
            break;
        }
        queue += character;
    }
    if (silent) return true;
    return eat(subvalue + queue)({
        type: "heading",
        depth: depth,
        children: self.tokenizeInline(content, now)
    });
}

});

parcelRegister("hJSi4", function(module, exports) {
"use strict";

var $gjHS1 = parcelRequire("gjHS1");
var $cea0c097c5d6c26a$require$openCloseTag = $gjHS1.openCloseTag;
module.exports = $cea0c097c5d6c26a$var$blockHtml;
var $cea0c097c5d6c26a$var$tab = "	";
var $cea0c097c5d6c26a$var$space = " ";
var $cea0c097c5d6c26a$var$lineFeed = "\n";
var $cea0c097c5d6c26a$var$lessThan = "<";
var $cea0c097c5d6c26a$var$rawOpenExpression = /^<(script|pre|style)(?=(\s|>|$))/i;
var $cea0c097c5d6c26a$var$rawCloseExpression = /<\/(script|pre|style)>/i;
var $cea0c097c5d6c26a$var$commentOpenExpression = /^<!--/;
var $cea0c097c5d6c26a$var$commentCloseExpression = /-->/;
var $cea0c097c5d6c26a$var$instructionOpenExpression = /^<\?/;
var $cea0c097c5d6c26a$var$instructionCloseExpression = /\?>/;
var $cea0c097c5d6c26a$var$directiveOpenExpression = /^<![A-Za-z]/;
var $cea0c097c5d6c26a$var$directiveCloseExpression = />/;
var $cea0c097c5d6c26a$var$cdataOpenExpression = /^<!\[CDATA\[/;
var $cea0c097c5d6c26a$var$cdataCloseExpression = /]]>/;
var $cea0c097c5d6c26a$var$elementCloseExpression = /^$/;
var $cea0c097c5d6c26a$var$otherElementOpenExpression = new RegExp($cea0c097c5d6c26a$require$openCloseTag.source + "\\s*$");
function $cea0c097c5d6c26a$var$blockHtml(eat, value, silent) {
    var self = this;
    var blocks = self.options.blocks.join("|");
    var elementOpenExpression = new RegExp("^</?(" + blocks + ")(?=(\\s|/?>|$))", "i");
    var length = value.length;
    var index = 0;
    var next;
    var line;
    var offset;
    var character;
    var count;
    var sequence;
    var subvalue;
    var sequences = [
        [
            $cea0c097c5d6c26a$var$rawOpenExpression,
            $cea0c097c5d6c26a$var$rawCloseExpression,
            true
        ],
        [
            $cea0c097c5d6c26a$var$commentOpenExpression,
            $cea0c097c5d6c26a$var$commentCloseExpression,
            true
        ],
        [
            $cea0c097c5d6c26a$var$instructionOpenExpression,
            $cea0c097c5d6c26a$var$instructionCloseExpression,
            true
        ],
        [
            $cea0c097c5d6c26a$var$directiveOpenExpression,
            $cea0c097c5d6c26a$var$directiveCloseExpression,
            true
        ],
        [
            $cea0c097c5d6c26a$var$cdataOpenExpression,
            $cea0c097c5d6c26a$var$cdataCloseExpression,
            true
        ],
        [
            elementOpenExpression,
            $cea0c097c5d6c26a$var$elementCloseExpression,
            true
        ],
        [
            $cea0c097c5d6c26a$var$otherElementOpenExpression,
            $cea0c097c5d6c26a$var$elementCloseExpression,
            false
        ]
    ];
    // Eat initial spacing.
    while(index < length){
        character = value.charAt(index);
        if (character !== $cea0c097c5d6c26a$var$tab && character !== $cea0c097c5d6c26a$var$space) break;
        index++;
    }
    if (value.charAt(index) !== $cea0c097c5d6c26a$var$lessThan) return;
    next = value.indexOf($cea0c097c5d6c26a$var$lineFeed, index + 1);
    next = next === -1 ? length : next;
    line = value.slice(index, next);
    offset = -1;
    count = sequences.length;
    while(++offset < count)if (sequences[offset][0].test(line)) {
        sequence = sequences[offset];
        break;
    }
    if (!sequence) return;
    if (silent) return sequence[2];
    index = next;
    if (!sequence[1].test(line)) while(index < length){
        next = value.indexOf($cea0c097c5d6c26a$var$lineFeed, index + 1);
        next = next === -1 ? length : next;
        line = value.slice(index + 1, next);
        if (sequence[1].test(line)) {
            if (line) index = next;
            break;
        }
        index = next;
    }
    subvalue = value.slice(0, index);
    return eat(subvalue)({
        type: "html",
        value: subvalue
    });
}

});
parcelRegister("gjHS1", function(module, exports) {

$parcel$export(module.exports, "openCloseTag", () => $be10736cdccdd6eb$export$a33a5d2984e0051b, (v) => $be10736cdccdd6eb$export$a33a5d2984e0051b = v);
$parcel$export(module.exports, "tag", () => $be10736cdccdd6eb$export$2b067c6666111485, (v) => $be10736cdccdd6eb$export$2b067c6666111485 = v);
var $be10736cdccdd6eb$export$a33a5d2984e0051b;
var $be10736cdccdd6eb$export$2b067c6666111485;
"use strict";
var $be10736cdccdd6eb$var$attributeName = "[a-zA-Z_:][a-zA-Z0-9:._-]*";
var $be10736cdccdd6eb$var$unquoted = "[^\"'=<>`\\u0000-\\u0020]+";
var $be10736cdccdd6eb$var$singleQuoted = "'[^']*'";
var $be10736cdccdd6eb$var$doubleQuoted = '"[^"]*"';
var $be10736cdccdd6eb$var$attributeValue = "(?:" + $be10736cdccdd6eb$var$unquoted + "|" + $be10736cdccdd6eb$var$singleQuoted + "|" + $be10736cdccdd6eb$var$doubleQuoted + ")";
var $be10736cdccdd6eb$var$attribute = "(?:\\s+" + $be10736cdccdd6eb$var$attributeName + "(?:\\s*=\\s*" + $be10736cdccdd6eb$var$attributeValue + ")?)";
var $be10736cdccdd6eb$var$openTag = "<[A-Za-z][A-Za-z0-9\\-]*" + $be10736cdccdd6eb$var$attribute + "*\\s*\\/?>";
var $be10736cdccdd6eb$var$closeTag = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>";
var $be10736cdccdd6eb$var$comment = "<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->";
var $be10736cdccdd6eb$var$processing = "<[?].*?[?]>";
var $be10736cdccdd6eb$var$declaration = "<![A-Za-z]+\\s+[^>]*>";
var $be10736cdccdd6eb$var$cdata = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>";
$be10736cdccdd6eb$export$a33a5d2984e0051b = new RegExp("^(?:" + $be10736cdccdd6eb$var$openTag + "|" + $be10736cdccdd6eb$var$closeTag + ")");
$be10736cdccdd6eb$export$2b067c6666111485 = new RegExp("^(?:" + $be10736cdccdd6eb$var$openTag + "|" + $be10736cdccdd6eb$var$closeTag + "|" + $be10736cdccdd6eb$var$comment + "|" + $be10736cdccdd6eb$var$processing + "|" + $be10736cdccdd6eb$var$declaration + "|" + $be10736cdccdd6eb$var$cdata + ")");

});


parcelRegister("h5OtA", function(module, exports) {
"use strict";

var $7YJTx = parcelRequire("7YJTx");

var $dHruv = parcelRequire("dHruv");
module.exports = $c71a0ed133af697e$var$definition;
var $c71a0ed133af697e$var$quotationMark = '"';
var $c71a0ed133af697e$var$apostrophe = "'";
var $c71a0ed133af697e$var$backslash = "\\";
var $c71a0ed133af697e$var$lineFeed = "\n";
var $c71a0ed133af697e$var$tab = "	";
var $c71a0ed133af697e$var$space = " ";
var $c71a0ed133af697e$var$leftSquareBracket = "[";
var $c71a0ed133af697e$var$rightSquareBracket = "]";
var $c71a0ed133af697e$var$leftParenthesis = "(";
var $c71a0ed133af697e$var$rightParenthesis = ")";
var $c71a0ed133af697e$var$colon = ":";
var $c71a0ed133af697e$var$lessThan = "<";
var $c71a0ed133af697e$var$greaterThan = ">";
function $c71a0ed133af697e$var$definition(eat, value, silent) {
    var self = this;
    var commonmark = self.options.commonmark;
    var index = 0;
    var length = value.length;
    var subvalue = "";
    var beforeURL;
    var beforeTitle;
    var queue;
    var character;
    var test;
    var identifier;
    var url;
    var title;
    while(index < length){
        character = value.charAt(index);
        if (character !== $c71a0ed133af697e$var$space && character !== $c71a0ed133af697e$var$tab) break;
        subvalue += character;
        index++;
    }
    character = value.charAt(index);
    if (character !== $c71a0ed133af697e$var$leftSquareBracket) return;
    index++;
    subvalue += character;
    queue = "";
    while(index < length){
        character = value.charAt(index);
        if (character === $c71a0ed133af697e$var$rightSquareBracket) break;
        else if (character === $c71a0ed133af697e$var$backslash) {
            queue += character;
            index++;
            character = value.charAt(index);
        }
        queue += character;
        index++;
    }
    if (!queue || value.charAt(index) !== $c71a0ed133af697e$var$rightSquareBracket || value.charAt(index + 1) !== $c71a0ed133af697e$var$colon) return;
    identifier = queue;
    subvalue += queue + $c71a0ed133af697e$var$rightSquareBracket + $c71a0ed133af697e$var$colon;
    index = subvalue.length;
    queue = "";
    while(index < length){
        character = value.charAt(index);
        if (character !== $c71a0ed133af697e$var$tab && character !== $c71a0ed133af697e$var$space && character !== $c71a0ed133af697e$var$lineFeed) break;
        subvalue += character;
        index++;
    }
    character = value.charAt(index);
    queue = "";
    beforeURL = subvalue;
    if (character === $c71a0ed133af697e$var$lessThan) {
        index++;
        while(index < length){
            character = value.charAt(index);
            if (!$c71a0ed133af697e$var$isEnclosedURLCharacter(character)) break;
            queue += character;
            index++;
        }
        character = value.charAt(index);
        if (character === $c71a0ed133af697e$var$isEnclosedURLCharacter.delimiter) {
            subvalue += $c71a0ed133af697e$var$lessThan + queue + character;
            index++;
        } else {
            if (commonmark) return;
            index -= queue.length + 1;
            queue = "";
        }
    }
    if (!queue) {
        while(index < length){
            character = value.charAt(index);
            if (!$c71a0ed133af697e$var$isUnclosedURLCharacter(character)) break;
            queue += character;
            index++;
        }
        subvalue += queue;
    }
    if (!queue) return;
    url = queue;
    queue = "";
    while(index < length){
        character = value.charAt(index);
        if (character !== $c71a0ed133af697e$var$tab && character !== $c71a0ed133af697e$var$space && character !== $c71a0ed133af697e$var$lineFeed) break;
        queue += character;
        index++;
    }
    character = value.charAt(index);
    test = null;
    if (character === $c71a0ed133af697e$var$quotationMark) test = $c71a0ed133af697e$var$quotationMark;
    else if (character === $c71a0ed133af697e$var$apostrophe) test = $c71a0ed133af697e$var$apostrophe;
    else if (character === $c71a0ed133af697e$var$leftParenthesis) test = $c71a0ed133af697e$var$rightParenthesis;
    if (!test) {
        queue = "";
        index = subvalue.length;
    } else if (queue) {
        subvalue += queue + character;
        index = subvalue.length;
        queue = "";
        while(index < length){
            character = value.charAt(index);
            if (character === test) break;
            if (character === $c71a0ed133af697e$var$lineFeed) {
                index++;
                character = value.charAt(index);
                if (character === $c71a0ed133af697e$var$lineFeed || character === test) return;
                queue += $c71a0ed133af697e$var$lineFeed;
            }
            queue += character;
            index++;
        }
        character = value.charAt(index);
        if (character !== test) return;
        beforeTitle = subvalue;
        subvalue += queue + character;
        index++;
        title = queue;
        queue = "";
    } else return;
    while(index < length){
        character = value.charAt(index);
        if (character !== $c71a0ed133af697e$var$tab && character !== $c71a0ed133af697e$var$space) break;
        subvalue += character;
        index++;
    }
    character = value.charAt(index);
    if (!character || character === $c71a0ed133af697e$var$lineFeed) {
        if (silent) return true;
        beforeURL = eat(beforeURL).test().end;
        url = self.decode.raw(self.unescape(url), beforeURL, {
            nonTerminated: false
        });
        if (title) {
            beforeTitle = eat(beforeTitle).test().end;
            title = self.decode.raw(self.unescape(title), beforeTitle);
        }
        return eat(subvalue)({
            type: "definition",
            identifier: $dHruv(identifier),
            label: identifier,
            title: title || null,
            url: url
        });
    }
}
// Check if `character` can be inside an enclosed URI.
function $c71a0ed133af697e$var$isEnclosedURLCharacter(character) {
    return character !== $c71a0ed133af697e$var$greaterThan && character !== $c71a0ed133af697e$var$leftSquareBracket && character !== $c71a0ed133af697e$var$rightSquareBracket;
}
$c71a0ed133af697e$var$isEnclosedURLCharacter.delimiter = $c71a0ed133af697e$var$greaterThan;
// Check if `character` can be inside an unclosed URI.
function $c71a0ed133af697e$var$isUnclosedURLCharacter(character) {
    return character !== $c71a0ed133af697e$var$leftSquareBracket && character !== $c71a0ed133af697e$var$rightSquareBracket && !$7YJTx(character);
}

});
parcelRegister("7YJTx", function(module, exports) {
"use strict";
module.exports = $5cf1bcbe433cafbf$var$whitespace;
var $5cf1bcbe433cafbf$var$fromCode = String.fromCharCode;
var $5cf1bcbe433cafbf$var$re = /\s/;
// Check if the given character code, or the character code at the first
// character, is a whitespace character.
function $5cf1bcbe433cafbf$var$whitespace(character) {
    return $5cf1bcbe433cafbf$var$re.test(typeof character === "number" ? $5cf1bcbe433cafbf$var$fromCode(character) : character.charAt(0));
}

});

parcelRegister("dHruv", function(module, exports) {
"use strict";

var $cm7TT = parcelRequire("cm7TT");
module.exports = $9f949da4b727edf7$var$normalize;
// Normalize an identifier.  Collapses multiple white space characters into a
// single space, and removes casing.
function $9f949da4b727edf7$var$normalize(value) {
    return $cm7TT(value).toLowerCase();
}

});
parcelRegister("cm7TT", function(module, exports) {
"use strict";
module.exports = $8fedaaf69579b268$var$collapse;
// `collapse(' \t\nbar \nbaz\t') // ' bar baz '`
function $8fedaaf69579b268$var$collapse(value) {
    return String(value).replace(/\s+/g, " ");
}

});



parcelRegister("23Qvg", function(module, exports) {
"use strict";

var $7YJTx = parcelRequire("7YJTx");
module.exports = $180496a1cb8523f8$var$table;
var $180496a1cb8523f8$var$tab = "	";
var $180496a1cb8523f8$var$lineFeed = "\n";
var $180496a1cb8523f8$var$space = " ";
var $180496a1cb8523f8$var$dash = "-";
var $180496a1cb8523f8$var$colon = ":";
var $180496a1cb8523f8$var$backslash = "\\";
var $180496a1cb8523f8$var$verticalBar = "|";
var $180496a1cb8523f8$var$minColumns = 1;
var $180496a1cb8523f8$var$minRows = 2;
var $180496a1cb8523f8$var$left = "left";
var $180496a1cb8523f8$var$center = "center";
var $180496a1cb8523f8$var$right = "right";
function $180496a1cb8523f8$var$table(eat, value, silent) {
    var self = this;
    var index;
    var alignments;
    var alignment;
    var subvalue;
    var row;
    var length;
    var lines;
    var queue;
    var character;
    var hasDash;
    var align;
    var cell;
    var preamble;
    var now;
    var position;
    var lineCount;
    var line;
    var rows;
    var table;
    var lineIndex;
    var pipeIndex;
    var first;
    // Exit when not in gfm-mode.
    if (!self.options.gfm) return;
    // Get the rows.
    // Detecting tables soon is hard, so there are some checks for performance
    // here, such as the minimum number of rows, and allowed characters in the
    // alignment row.
    index = 0;
    lineCount = 0;
    length = value.length + 1;
    lines = [];
    while(index < length){
        lineIndex = value.indexOf($180496a1cb8523f8$var$lineFeed, index);
        pipeIndex = value.indexOf($180496a1cb8523f8$var$verticalBar, index + 1);
        if (lineIndex === -1) lineIndex = value.length;
        if (pipeIndex === -1 || pipeIndex > lineIndex) {
            if (lineCount < $180496a1cb8523f8$var$minRows) return;
            break;
        }
        lines.push(value.slice(index, lineIndex));
        lineCount++;
        index = lineIndex + 1;
    }
    // Parse the alignment row.
    subvalue = lines.join($180496a1cb8523f8$var$lineFeed);
    alignments = lines.splice(1, 1)[0] || [];
    index = 0;
    length = alignments.length;
    lineCount--;
    alignment = false;
    align = [];
    while(index < length){
        character = alignments.charAt(index);
        if (character === $180496a1cb8523f8$var$verticalBar) {
            hasDash = null;
            if (alignment === false) {
                if (first === false) return;
            } else {
                align.push(alignment);
                alignment = false;
            }
            first = false;
        } else if (character === $180496a1cb8523f8$var$dash) {
            hasDash = true;
            alignment = alignment || null;
        } else if (character === $180496a1cb8523f8$var$colon) {
            if (alignment === $180496a1cb8523f8$var$left) alignment = $180496a1cb8523f8$var$center;
            else if (hasDash && alignment === null) alignment = $180496a1cb8523f8$var$right;
            else alignment = $180496a1cb8523f8$var$left;
        } else if (!$7YJTx(character)) return;
        index++;
    }
    if (alignment !== false) align.push(alignment);
    // Exit when without enough columns.
    if (align.length < $180496a1cb8523f8$var$minColumns) return;
    /* istanbul ignore if - never used (yet) */ if (silent) return true;
    // Parse the rows.
    position = -1;
    rows = [];
    table = eat(subvalue).reset({
        type: "table",
        align: align,
        children: rows
    });
    while(++position < lineCount){
        line = lines[position];
        row = {
            type: "tableRow",
            children: []
        };
        // Eat a newline character when this is not the first row.
        if (position) eat($180496a1cb8523f8$var$lineFeed);
        // Eat the row.
        eat(line).reset(row, table);
        length = line.length + 1;
        index = 0;
        queue = "";
        cell = "";
        preamble = true;
        while(index < length){
            character = line.charAt(index);
            if (character === $180496a1cb8523f8$var$tab || character === $180496a1cb8523f8$var$space) {
                if (cell) queue += character;
                else eat(character);
                index++;
                continue;
            }
            if (character === "" || character === $180496a1cb8523f8$var$verticalBar) {
                if (preamble) eat(character);
                else {
                    if ((cell || character) && !preamble) {
                        subvalue = cell;
                        if (queue.length > 1) {
                            if (character) {
                                subvalue += queue.slice(0, -1);
                                queue = queue.charAt(queue.length - 1);
                            } else {
                                subvalue += queue;
                                queue = "";
                            }
                        }
                        now = eat.now();
                        eat(subvalue)({
                            type: "tableCell",
                            children: self.tokenizeInline(cell, now)
                        }, row);
                    }
                    eat(queue + character);
                    queue = "";
                    cell = "";
                }
            } else {
                if (queue) {
                    cell += queue;
                    queue = "";
                }
                cell += character;
                if (character === $180496a1cb8523f8$var$backslash && index !== length - 2) {
                    cell += line.charAt(index + 1);
                    index++;
                }
            }
            preamble = false;
            index++;
        }
        // Eat the alignment row.
        if (!position) eat($180496a1cb8523f8$var$lineFeed + alignments);
    }
    return table;
}

});

parcelRegister("dwiBC", function(module, exports) {
"use strict";

var $yVfl8 = parcelRequire("yVfl8");

var $7HEQ1 = parcelRequire("7HEQ1");

var $gMsCU = parcelRequire("gMsCU");
module.exports = $9d7cb23f2967fdba$var$paragraph;
var $9d7cb23f2967fdba$var$tab = "	";
var $9d7cb23f2967fdba$var$lineFeed = "\n";
var $9d7cb23f2967fdba$var$space = " ";
var $9d7cb23f2967fdba$var$tabSize = 4;
// Tokenise paragraph.
function $9d7cb23f2967fdba$var$paragraph(eat, value, silent) {
    var self = this;
    var settings = self.options;
    var commonmark = settings.commonmark;
    var tokenizers = self.blockTokenizers;
    var interruptors = self.interruptParagraph;
    var index = value.indexOf($9d7cb23f2967fdba$var$lineFeed);
    var length = value.length;
    var position;
    var subvalue;
    var character;
    var size;
    var now;
    while(index < length){
        // Eat everything if there’s no following newline.
        if (index === -1) {
            index = length;
            break;
        }
        // Stop if the next character is NEWLINE.
        if (value.charAt(index + 1) === $9d7cb23f2967fdba$var$lineFeed) break;
        // In commonmark-mode, following indented lines are part of the paragraph.
        if (commonmark) {
            size = 0;
            position = index + 1;
            while(position < length){
                character = value.charAt(position);
                if (character === $9d7cb23f2967fdba$var$tab) {
                    size = $9d7cb23f2967fdba$var$tabSize;
                    break;
                } else if (character === $9d7cb23f2967fdba$var$space) size++;
                else break;
                position++;
            }
            if (size >= $9d7cb23f2967fdba$var$tabSize && character !== $9d7cb23f2967fdba$var$lineFeed) {
                index = value.indexOf($9d7cb23f2967fdba$var$lineFeed, index + 1);
                continue;
            }
        }
        subvalue = value.slice(index + 1);
        // Check if the following code contains a possible block.
        if ($gMsCU(interruptors, tokenizers, self, [
            eat,
            subvalue,
            true
        ])) break;
        position = index;
        index = value.indexOf($9d7cb23f2967fdba$var$lineFeed, index + 1);
        if (index !== -1 && $yVfl8(value.slice(position, index)) === "") {
            index = position;
            break;
        }
    }
    subvalue = value.slice(0, index);
    /* istanbul ignore if - never used (yet) */ if (silent) return true;
    now = eat.now();
    subvalue = $7HEQ1(subvalue);
    return eat(subvalue)({
        type: "paragraph",
        children: self.tokenizeInline(subvalue, now)
    });
}

});

parcelRegister("4Ueka", function(module, exports) {
"use strict";

var $881gM = parcelRequire("881gM");
module.exports = $392780e473a8673b$var$escape;
$392780e473a8673b$var$escape.locator = $881gM;
var $392780e473a8673b$var$lineFeed = "\n";
var $392780e473a8673b$var$backslash = "\\";
function $392780e473a8673b$var$escape(eat, value, silent) {
    var self = this;
    var character;
    var node;
    if (value.charAt(0) === $392780e473a8673b$var$backslash) {
        character = value.charAt(1);
        if (self.escape.indexOf(character) !== -1) {
            /* istanbul ignore if - never used (yet) */ if (silent) return true;
            if (character === $392780e473a8673b$var$lineFeed) node = {
                type: "break"
            };
            else node = {
                type: "text",
                value: character
            };
            return eat($392780e473a8673b$var$backslash + character)(node);
        }
    }
}

});
parcelRegister("881gM", function(module, exports) {
"use strict";
module.exports = $5eb00e3bdf0b554c$var$locate;
function $5eb00e3bdf0b554c$var$locate(value, fromIndex) {
    return value.indexOf("\\", fromIndex);
}

});


parcelRegister("bOmlb", function(module, exports) {
"use strict";

var $7YJTx = parcelRequire("7YJTx");

var $gYcXs = parcelRequire("gYcXs");

var $dTMCj = parcelRequire("dTMCj");
module.exports = $023817829302aec1$var$autoLink;
$023817829302aec1$var$autoLink.locator = $dTMCj;
$023817829302aec1$var$autoLink.notInLink = true;
var $023817829302aec1$var$lessThan = "<";
var $023817829302aec1$var$greaterThan = ">";
var $023817829302aec1$var$atSign = "@";
var $023817829302aec1$var$slash = "/";
var $023817829302aec1$var$mailto = "mailto:";
var $023817829302aec1$var$mailtoLength = $023817829302aec1$var$mailto.length;
function $023817829302aec1$var$autoLink(eat, value, silent) {
    var self = this;
    var subvalue = "";
    var length = value.length;
    var index = 0;
    var queue = "";
    var hasAtCharacter = false;
    var link = "";
    var character;
    var now;
    var content;
    var tokenizers;
    var exit;
    if (value.charAt(0) !== $023817829302aec1$var$lessThan) return;
    index++;
    subvalue = $023817829302aec1$var$lessThan;
    while(index < length){
        character = value.charAt(index);
        if ($7YJTx(character) || character === $023817829302aec1$var$greaterThan || character === $023817829302aec1$var$atSign || character === ":" && value.charAt(index + 1) === $023817829302aec1$var$slash) break;
        queue += character;
        index++;
    }
    if (!queue) return;
    link += queue;
    queue = "";
    character = value.charAt(index);
    link += character;
    index++;
    if (character === $023817829302aec1$var$atSign) hasAtCharacter = true;
    else {
        if (character !== ":" || value.charAt(index + 1) !== $023817829302aec1$var$slash) return;
        link += $023817829302aec1$var$slash;
        index++;
    }
    while(index < length){
        character = value.charAt(index);
        if ($7YJTx(character) || character === $023817829302aec1$var$greaterThan) break;
        queue += character;
        index++;
    }
    character = value.charAt(index);
    if (!queue || character !== $023817829302aec1$var$greaterThan) return;
    /* istanbul ignore if - never used (yet) */ if (silent) return true;
    link += queue;
    content = link;
    subvalue += link + character;
    now = eat.now();
    now.column++;
    now.offset++;
    if (hasAtCharacter) {
        if (link.slice(0, $023817829302aec1$var$mailtoLength).toLowerCase() === $023817829302aec1$var$mailto) {
            content = content.slice($023817829302aec1$var$mailtoLength);
            now.column += $023817829302aec1$var$mailtoLength;
            now.offset += $023817829302aec1$var$mailtoLength;
        } else link = $023817829302aec1$var$mailto + link;
    }
    // Temporarily remove all tokenizers except text in autolinks.
    tokenizers = self.inlineTokenizers;
    self.inlineTokenizers = {
        text: tokenizers.text
    };
    exit = self.enterLink();
    content = self.tokenizeInline(content, now);
    self.inlineTokenizers = tokenizers;
    exit();
    return eat(subvalue)({
        type: "link",
        title: null,
        url: $gYcXs(link, {
            nonTerminated: false
        }),
        children: content
    });
}

});
parcelRegister("gYcXs", function(module, exports) {
"use strict";

var $eRPAV = parcelRequire("eRPAV");

var $ixC46 = parcelRequire("ixC46");

var $ffwtM = parcelRequire("ffwtM");

var $3ApXj = parcelRequire("3ApXj");

var $4hNxx = parcelRequire("4hNxx");

var $2gEiO = parcelRequire("2gEiO");
module.exports = $c5ac4d1e04eb3b71$var$parseEntities;
var $c5ac4d1e04eb3b71$var$own = {}.hasOwnProperty;
var $c5ac4d1e04eb3b71$var$fromCharCode = String.fromCharCode;
var $c5ac4d1e04eb3b71$var$noop = Function.prototype;
// Default settings.
var $c5ac4d1e04eb3b71$var$defaults = {
    warning: null,
    reference: null,
    text: null,
    warningContext: null,
    referenceContext: null,
    textContext: null,
    position: {},
    additional: null,
    attribute: false,
    nonTerminated: true
};
// Characters.
var $c5ac4d1e04eb3b71$var$tab = 9 // '\t'
;
var $c5ac4d1e04eb3b71$var$lineFeed = 10 // '\n'
;
var $c5ac4d1e04eb3b71$var$formFeed = 12 // '\f'
;
var $c5ac4d1e04eb3b71$var$space = 32 // ' '
;
var $c5ac4d1e04eb3b71$var$ampersand = 38 // '&'
;
var $c5ac4d1e04eb3b71$var$semicolon = 59 // ';'
;
var $c5ac4d1e04eb3b71$var$lessThan = 60 // '<'
;
var $c5ac4d1e04eb3b71$var$equalsTo = 61 // '='
;
var $c5ac4d1e04eb3b71$var$numberSign = 35 // '#'
;
var $c5ac4d1e04eb3b71$var$uppercaseX = 88 // 'X'
;
var $c5ac4d1e04eb3b71$var$lowercaseX = 120 // 'x'
;
var $c5ac4d1e04eb3b71$var$replacementCharacter = 65533 // '�'
;
// Reference types.
var $c5ac4d1e04eb3b71$var$name = "named";
var $c5ac4d1e04eb3b71$var$hexa = "hexadecimal";
var $c5ac4d1e04eb3b71$var$deci = "decimal";
// Map of bases.
var $c5ac4d1e04eb3b71$var$bases = {};
$c5ac4d1e04eb3b71$var$bases[$c5ac4d1e04eb3b71$var$hexa] = 16;
$c5ac4d1e04eb3b71$var$bases[$c5ac4d1e04eb3b71$var$deci] = 10;
// Map of types to tests.
// Each type of character reference accepts different characters.
// This test is used to detect whether a reference has ended (as the semicolon
// is not strictly needed).
var $c5ac4d1e04eb3b71$var$tests = {};
$c5ac4d1e04eb3b71$var$tests[$c5ac4d1e04eb3b71$var$name] = $4hNxx;
$c5ac4d1e04eb3b71$var$tests[$c5ac4d1e04eb3b71$var$deci] = $ffwtM;
$c5ac4d1e04eb3b71$var$tests[$c5ac4d1e04eb3b71$var$hexa] = $3ApXj;
// Warning types.
var $c5ac4d1e04eb3b71$var$namedNotTerminated = 1;
var $c5ac4d1e04eb3b71$var$numericNotTerminated = 2;
var $c5ac4d1e04eb3b71$var$namedEmpty = 3;
var $c5ac4d1e04eb3b71$var$numericEmpty = 4;
var $c5ac4d1e04eb3b71$var$namedUnknown = 5;
var $c5ac4d1e04eb3b71$var$numericDisallowed = 6;
var $c5ac4d1e04eb3b71$var$numericProhibited = 7;
// Warning messages.
var $c5ac4d1e04eb3b71$var$messages = {};
$c5ac4d1e04eb3b71$var$messages[$c5ac4d1e04eb3b71$var$namedNotTerminated] = "Named character references must be terminated by a semicolon";
$c5ac4d1e04eb3b71$var$messages[$c5ac4d1e04eb3b71$var$numericNotTerminated] = "Numeric character references must be terminated by a semicolon";
$c5ac4d1e04eb3b71$var$messages[$c5ac4d1e04eb3b71$var$namedEmpty] = "Named character references cannot be empty";
$c5ac4d1e04eb3b71$var$messages[$c5ac4d1e04eb3b71$var$numericEmpty] = "Numeric character references cannot be empty";
$c5ac4d1e04eb3b71$var$messages[$c5ac4d1e04eb3b71$var$namedUnknown] = "Named character references must be known";
$c5ac4d1e04eb3b71$var$messages[$c5ac4d1e04eb3b71$var$numericDisallowed] = "Numeric character references cannot be disallowed";
$c5ac4d1e04eb3b71$var$messages[$c5ac4d1e04eb3b71$var$numericProhibited] = "Numeric character references cannot be outside the permissible Unicode range";
// Wrap to ensure clean parameters are given to `parse`.
function $c5ac4d1e04eb3b71$var$parseEntities(value, options) {
    var settings = {};
    var option;
    var key;
    if (!options) options = {};
    for(key in $c5ac4d1e04eb3b71$var$defaults){
        option = options[key];
        settings[key] = option === null || option === undefined ? $c5ac4d1e04eb3b71$var$defaults[key] : option;
    }
    if (settings.position.indent || settings.position.start) {
        settings.indent = settings.position.indent || [];
        settings.position = settings.position.start;
    }
    return $c5ac4d1e04eb3b71$var$parse(value, settings);
}
// Parse entities.
// eslint-disable-next-line complexity
function $c5ac4d1e04eb3b71$var$parse(value, settings) {
    var additional = settings.additional;
    var nonTerminated = settings.nonTerminated;
    var handleText = settings.text;
    var handleReference = settings.reference;
    var handleWarning = settings.warning;
    var textContext = settings.textContext;
    var referenceContext = settings.referenceContext;
    var warningContext = settings.warningContext;
    var pos = settings.position;
    var indent = settings.indent || [];
    var length = value.length;
    var index = 0;
    var lines = -1;
    var column = pos.column || 1;
    var line = pos.line || 1;
    var queue = "";
    var result = [];
    var entityCharacters;
    var namedEntity;
    var terminated;
    var characters;
    var character;
    var reference;
    var following;
    var warning;
    var reason;
    var output;
    var entity;
    var begin;
    var start;
    var type;
    var test;
    var prev;
    var next;
    var diff;
    var end;
    if (typeof additional === "string") additional = additional.charCodeAt(0);
    // Cache the current point.
    prev = now();
    // Wrap `handleWarning`.
    warning = handleWarning ? parseError : $c5ac4d1e04eb3b71$var$noop;
    // Ensure the algorithm walks over the first character and the end
    // (inclusive).
    index--;
    length++;
    while(++index < length){
        // If the previous character was a newline.
        if (character === $c5ac4d1e04eb3b71$var$lineFeed) column = indent[lines] || 1;
        character = value.charCodeAt(index);
        if (character === $c5ac4d1e04eb3b71$var$ampersand) {
            following = value.charCodeAt(index + 1);
            // The behaviour depends on the identity of the next character.
            if (following === $c5ac4d1e04eb3b71$var$tab || following === $c5ac4d1e04eb3b71$var$lineFeed || following === $c5ac4d1e04eb3b71$var$formFeed || following === $c5ac4d1e04eb3b71$var$space || following === $c5ac4d1e04eb3b71$var$ampersand || following === $c5ac4d1e04eb3b71$var$lessThan || following !== following || additional && following === additional) {
                // Not a character reference.
                // No characters are consumed, and nothing is returned.
                // This is not an error, either.
                queue += $c5ac4d1e04eb3b71$var$fromCharCode(character);
                column++;
                continue;
            }
            start = index + 1;
            begin = start;
            end = start;
            if (following === $c5ac4d1e04eb3b71$var$numberSign) {
                // Numerical entity.
                end = ++begin;
                // The behaviour further depends on the next character.
                following = value.charCodeAt(end);
                if (following === $c5ac4d1e04eb3b71$var$uppercaseX || following === $c5ac4d1e04eb3b71$var$lowercaseX) {
                    // ASCII hex digits.
                    type = $c5ac4d1e04eb3b71$var$hexa;
                    end = ++begin;
                } else // ASCII digits.
                type = $c5ac4d1e04eb3b71$var$deci;
            } else // Named entity.
            type = $c5ac4d1e04eb3b71$var$name;
            entityCharacters = "";
            entity = "";
            characters = "";
            test = $c5ac4d1e04eb3b71$var$tests[type];
            end--;
            while(++end < length){
                following = value.charCodeAt(end);
                if (!test(following)) break;
                characters += $c5ac4d1e04eb3b71$var$fromCharCode(following);
                // Check if we can match a legacy named reference.
                // If so, we cache that as the last viable named reference.
                // This ensures we do not need to walk backwards later.
                if (type === $c5ac4d1e04eb3b71$var$name && $c5ac4d1e04eb3b71$var$own.call($eRPAV, characters)) {
                    entityCharacters = characters;
                    entity = $eRPAV[characters];
                }
            }
            terminated = value.charCodeAt(end) === $c5ac4d1e04eb3b71$var$semicolon;
            if (terminated) {
                end++;
                namedEntity = type === $c5ac4d1e04eb3b71$var$name ? $2gEiO(characters) : false;
                if (namedEntity) {
                    entityCharacters = characters;
                    entity = namedEntity;
                }
            }
            diff = 1 + end - start;
            if (!terminated && !nonTerminated) ;
            else if (!characters) // An empty (possible) entity is valid, unless it’s numeric (thus an
            // ampersand followed by an octothorp).
            {
                if (type !== $c5ac4d1e04eb3b71$var$name) warning($c5ac4d1e04eb3b71$var$numericEmpty, diff);
            } else if (type === $c5ac4d1e04eb3b71$var$name) {
                // An ampersand followed by anything unknown, and not terminated, is
                // invalid.
                if (terminated && !entity) warning($c5ac4d1e04eb3b71$var$namedUnknown, 1);
                else {
                    // If theres something after an entity name which is not known, cap
                    // the reference.
                    if (entityCharacters !== characters) {
                        end = begin + entityCharacters.length;
                        diff = 1 + end - begin;
                        terminated = false;
                    }
                    // If the reference is not terminated, warn.
                    if (!terminated) {
                        reason = entityCharacters ? $c5ac4d1e04eb3b71$var$namedNotTerminated : $c5ac4d1e04eb3b71$var$namedEmpty;
                        if (settings.attribute) {
                            following = value.charCodeAt(end);
                            if (following === $c5ac4d1e04eb3b71$var$equalsTo) {
                                warning(reason, diff);
                                entity = null;
                            } else if ($4hNxx(following)) entity = null;
                            else warning(reason, diff);
                        } else warning(reason, diff);
                    }
                }
                reference = entity;
            } else {
                if (!terminated) // All non-terminated numeric entities are not rendered, and trigger a
                // warning.
                warning($c5ac4d1e04eb3b71$var$numericNotTerminated, diff);
                // When terminated and number, parse as either hexadecimal or decimal.
                reference = parseInt(characters, $c5ac4d1e04eb3b71$var$bases[type]);
                // Trigger a warning when the parsed number is prohibited, and replace
                // with replacement character.
                if ($c5ac4d1e04eb3b71$var$prohibited(reference)) {
                    warning($c5ac4d1e04eb3b71$var$numericProhibited, diff);
                    reference = $c5ac4d1e04eb3b71$var$fromCharCode($c5ac4d1e04eb3b71$var$replacementCharacter);
                } else if (reference in $ixC46) {
                    // Trigger a warning when the parsed number is disallowed, and replace
                    // by an alternative.
                    warning($c5ac4d1e04eb3b71$var$numericDisallowed, diff);
                    reference = $ixC46[reference];
                } else {
                    // Parse the number.
                    output = "";
                    // Trigger a warning when the parsed number should not be used.
                    if ($c5ac4d1e04eb3b71$var$disallowed(reference)) warning($c5ac4d1e04eb3b71$var$numericDisallowed, diff);
                    // Stringify the number.
                    if (reference > 0xffff) {
                        reference -= 0x10000;
                        output += $c5ac4d1e04eb3b71$var$fromCharCode(reference >>> 10 | 0xd800);
                        reference = 0xdc00 | reference & 0x3ff;
                    }
                    reference = output + $c5ac4d1e04eb3b71$var$fromCharCode(reference);
                }
            }
            // Found it!
            // First eat the queued characters as normal text, then eat an entity.
            if (reference) {
                flush();
                prev = now();
                index = end - 1;
                column += end - start + 1;
                result.push(reference);
                next = now();
                next.offset++;
                if (handleReference) handleReference.call(referenceContext, reference, {
                    start: prev,
                    end: next
                }, value.slice(start - 1, end));
                prev = next;
            } else {
                // If we could not find a reference, queue the checked characters (as
                // normal characters), and move the pointer to their end.
                // This is possible because we can be certain neither newlines nor
                // ampersands are included.
                characters = value.slice(start - 1, end);
                queue += characters;
                column += characters.length;
                index = end - 1;
            }
        } else {
            // Handle anything other than an ampersand, including newlines and EOF.
            if (character === 10 // Line feed
            ) {
                line++;
                lines++;
                column = 0;
            }
            if (character === character) {
                queue += $c5ac4d1e04eb3b71$var$fromCharCode(character);
                column++;
            } else flush();
        }
    }
    // Return the reduced nodes.
    return result.join("");
    // Get current position.
    function now() {
        return {
            line: line,
            column: column,
            offset: index + (pos.offset || 0)
        };
    }
    // “Throw” a parse-error: a warning.
    function parseError(code, offset) {
        var position = now();
        position.column += offset;
        position.offset += offset;
        handleWarning.call(warningContext, $c5ac4d1e04eb3b71$var$messages[code], position, code);
    }
    // Flush `queue` (normal text).
    // Macro invoked before each entity and at the end of `value`.
    // Does nothing when `queue` is empty.
    function flush() {
        if (queue) {
            result.push(queue);
            if (handleText) handleText.call(textContext, queue, {
                start: prev,
                end: now()
            });
            queue = "";
        }
    }
}
// Check if `character` is outside the permissible unicode range.
function $c5ac4d1e04eb3b71$var$prohibited(code) {
    return code >= 0xd800 && code <= 0xdfff || code > 0x10ffff;
}
// Check if `character` is disallowed.
function $c5ac4d1e04eb3b71$var$disallowed(code) {
    return code >= 0x0001 && code <= 0x0008 || code === 0x000b || code >= 0x000d && code <= 0x001f || code >= 0x007f && code <= 0x009f || code >= 0xfdd0 && code <= 0xfdef || (code & 0xffff) === 0xffff || (code & 0xffff) === 0xfffe;
}

});
parcelRegister("eRPAV", function(module, exports) {
module.exports = JSON.parse('{"AElig":"\xc6","AMP":"&","Aacute":"\xc1","Acirc":"\xc2","Agrave":"\xc0","Aring":"\xc5","Atilde":"\xc3","Auml":"\xc4","COPY":"\xa9","Ccedil":"\xc7","ETH":"\xd0","Eacute":"\xc9","Ecirc":"\xca","Egrave":"\xc8","Euml":"\xcb","GT":">","Iacute":"\xcd","Icirc":"\xce","Igrave":"\xcc","Iuml":"\xcf","LT":"<","Ntilde":"\xd1","Oacute":"\xd3","Ocirc":"\xd4","Ograve":"\xd2","Oslash":"\xd8","Otilde":"\xd5","Ouml":"\xd6","QUOT":"\\"","REG":"\xae","THORN":"\xde","Uacute":"\xda","Ucirc":"\xdb","Ugrave":"\xd9","Uuml":"\xdc","Yacute":"\xdd","aacute":"\xe1","acirc":"\xe2","acute":"\xb4","aelig":"\xe6","agrave":"\xe0","amp":"&","aring":"\xe5","atilde":"\xe3","auml":"\xe4","brvbar":"\xa6","ccedil":"\xe7","cedil":"\xb8","cent":"\xa2","copy":"\xa9","curren":"\xa4","deg":"\xb0","divide":"\xf7","eacute":"\xe9","ecirc":"\xea","egrave":"\xe8","eth":"\xf0","euml":"\xeb","frac12":"\xbd","frac14":"\xbc","frac34":"\xbe","gt":">","iacute":"\xed","icirc":"\xee","iexcl":"\xa1","igrave":"\xec","iquest":"\xbf","iuml":"\xef","laquo":"\xab","lt":"<","macr":"\xaf","micro":"\xb5","middot":"\xb7","nbsp":"\xa0","not":"\xac","ntilde":"\xf1","oacute":"\xf3","ocirc":"\xf4","ograve":"\xf2","ordf":"\xaa","ordm":"\xba","oslash":"\xf8","otilde":"\xf5","ouml":"\xf6","para":"\xb6","plusmn":"\xb1","pound":"\xa3","quot":"\\"","raquo":"\xbb","reg":"\xae","sect":"\xa7","shy":"\xad","sup1":"\xb9","sup2":"\xb2","sup3":"\xb3","szlig":"\xdf","thorn":"\xfe","times":"\xd7","uacute":"\xfa","ucirc":"\xfb","ugrave":"\xf9","uml":"\xa8","uuml":"\xfc","yacute":"\xfd","yen":"\xa5","yuml":"\xff"}');

});

parcelRegister("ixC46", function(module, exports) {
module.exports = JSON.parse('{"0":"\uFFFD","128":"\u20AC","130":"\u201A","131":"\u0192","132":"\u201E","133":"\u2026","134":"\u2020","135":"\u2021","136":"\u02C6","137":"\u2030","138":"\u0160","139":"\u2039","140":"\u0152","142":"\u017D","145":"\u2018","146":"\u2019","147":"\u201C","148":"\u201D","149":"\u2022","150":"\u2013","151":"\u2014","152":"\u02DC","153":"\u2122","154":"\u0161","155":"\u203A","156":"\u0153","158":"\u017E","159":"\u0178"}');

});

parcelRegister("3ApXj", function(module, exports) {
"use strict";
module.exports = $29c8de1f5ee25c19$var$hexadecimal;
// Check if the given character code, or the character code at the first
// character, is hexadecimal.
function $29c8de1f5ee25c19$var$hexadecimal(character) {
    var code = typeof character === "string" ? character.charCodeAt(0) : character;
    return code >= 97 /* a */  && code <= 102 || code >= 65 /* A */  && code <= 70 || code >= 48 /* A */  && code <= 57;
}

});

parcelRegister("4hNxx", function(module, exports) {
"use strict";

var $9DWb3 = parcelRequire("9DWb3");

var $ffwtM = parcelRequire("ffwtM");
module.exports = $31ef2d8ecefd5285$var$alphanumerical;
// Check if the given character code, or the character code at the first
// character, is alphanumerical.
function $31ef2d8ecefd5285$var$alphanumerical(character) {
    return $9DWb3(character) || $ffwtM(character);
}

});
parcelRegister("9DWb3", function(module, exports) {
"use strict";
module.exports = $7054e25c713bd8ec$var$alphabetical;
// Check if the given character code, or the character code at the first
// character, is alphabetical.
function $7054e25c713bd8ec$var$alphabetical(character) {
    var code = typeof character === "string" ? character.charCodeAt(0) : character;
    return code >= 97 && code <= 122 || code >= 65 && code <= 90;
}

});


parcelRegister("2gEiO", function(module, exports) {
"use strict";

var $5MdTf = parcelRequire("5MdTf");
module.exports = $1a6c569e4a2b31cd$var$decodeEntity;
var $1a6c569e4a2b31cd$var$own = {}.hasOwnProperty;
function $1a6c569e4a2b31cd$var$decodeEntity(characters) {
    return $1a6c569e4a2b31cd$var$own.call($5MdTf, characters) ? $5MdTf[characters] : false;
}

});
parcelRegister("5MdTf", function(module, exports) {
module.exports = JSON.parse('{"AEli":"\xc6","AElig":"\xc6","AM":"&","AMP":"&","Aacut":"\xc1","Aacute":"\xc1","Abreve":"\u0102","Acir":"\xc2","Acirc":"\xc2","Acy":"\u0410","Afr":"\uD835\uDD04","Agrav":"\xc0","Agrave":"\xc0","Alpha":"\u0391","Amacr":"\u0100","And":"\u2A53","Aogon":"\u0104","Aopf":"\uD835\uDD38","ApplyFunction":"\u2061","Arin":"\xc5","Aring":"\xc5","Ascr":"\uD835\uDC9C","Assign":"\u2254","Atild":"\xc3","Atilde":"\xc3","Aum":"\xc4","Auml":"\xc4","Backslash":"\u2216","Barv":"\u2AE7","Barwed":"\u2306","Bcy":"\u0411","Because":"\u2235","Bernoullis":"\u212C","Beta":"\u0392","Bfr":"\uD835\uDD05","Bopf":"\uD835\uDD39","Breve":"\u02D8","Bscr":"\u212C","Bumpeq":"\u224E","CHcy":"\u0427","COP":"\xa9","COPY":"\xa9","Cacute":"\u0106","Cap":"\u22D2","CapitalDifferentialD":"\u2145","Cayleys":"\u212D","Ccaron":"\u010C","Ccedi":"\xc7","Ccedil":"\xc7","Ccirc":"\u0108","Cconint":"\u2230","Cdot":"\u010A","Cedilla":"\xb8","CenterDot":"\xb7","Cfr":"\u212D","Chi":"\u03A7","CircleDot":"\u2299","CircleMinus":"\u2296","CirclePlus":"\u2295","CircleTimes":"\u2297","ClockwiseContourIntegral":"\u2232","CloseCurlyDoubleQuote":"\u201D","CloseCurlyQuote":"\u2019","Colon":"\u2237","Colone":"\u2A74","Congruent":"\u2261","Conint":"\u222F","ContourIntegral":"\u222E","Copf":"\u2102","Coproduct":"\u2210","CounterClockwiseContourIntegral":"\u2233","Cross":"\u2A2F","Cscr":"\uD835\uDC9E","Cup":"\u22D3","CupCap":"\u224D","DD":"\u2145","DDotrahd":"\u2911","DJcy":"\u0402","DScy":"\u0405","DZcy":"\u040F","Dagger":"\u2021","Darr":"\u21A1","Dashv":"\u2AE4","Dcaron":"\u010E","Dcy":"\u0414","Del":"\u2207","Delta":"\u0394","Dfr":"\uD835\uDD07","DiacriticalAcute":"\xb4","DiacriticalDot":"\u02D9","DiacriticalDoubleAcute":"\u02DD","DiacriticalGrave":"`","DiacriticalTilde":"\u02DC","Diamond":"\u22C4","DifferentialD":"\u2146","Dopf":"\uD835\uDD3B","Dot":"\xa8","DotDot":"\u20DC","DotEqual":"\u2250","DoubleContourIntegral":"\u222F","DoubleDot":"\xa8","DoubleDownArrow":"\u21D3","DoubleLeftArrow":"\u21D0","DoubleLeftRightArrow":"\u21D4","DoubleLeftTee":"\u2AE4","DoubleLongLeftArrow":"\u27F8","DoubleLongLeftRightArrow":"\u27FA","DoubleLongRightArrow":"\u27F9","DoubleRightArrow":"\u21D2","DoubleRightTee":"\u22A8","DoubleUpArrow":"\u21D1","DoubleUpDownArrow":"\u21D5","DoubleVerticalBar":"\u2225","DownArrow":"\u2193","DownArrowBar":"\u2913","DownArrowUpArrow":"\u21F5","DownBreve":"\u0311","DownLeftRightVector":"\u2950","DownLeftTeeVector":"\u295E","DownLeftVector":"\u21BD","DownLeftVectorBar":"\u2956","DownRightTeeVector":"\u295F","DownRightVector":"\u21C1","DownRightVectorBar":"\u2957","DownTee":"\u22A4","DownTeeArrow":"\u21A7","Downarrow":"\u21D3","Dscr":"\uD835\uDC9F","Dstrok":"\u0110","ENG":"\u014A","ET":"\xd0","ETH":"\xd0","Eacut":"\xc9","Eacute":"\xc9","Ecaron":"\u011A","Ecir":"\xca","Ecirc":"\xca","Ecy":"\u042D","Edot":"\u0116","Efr":"\uD835\uDD08","Egrav":"\xc8","Egrave":"\xc8","Element":"\u2208","Emacr":"\u0112","EmptySmallSquare":"\u25FB","EmptyVerySmallSquare":"\u25AB","Eogon":"\u0118","Eopf":"\uD835\uDD3C","Epsilon":"\u0395","Equal":"\u2A75","EqualTilde":"\u2242","Equilibrium":"\u21CC","Escr":"\u2130","Esim":"\u2A73","Eta":"\u0397","Eum":"\xcb","Euml":"\xcb","Exists":"\u2203","ExponentialE":"\u2147","Fcy":"\u0424","Ffr":"\uD835\uDD09","FilledSmallSquare":"\u25FC","FilledVerySmallSquare":"\u25AA","Fopf":"\uD835\uDD3D","ForAll":"\u2200","Fouriertrf":"\u2131","Fscr":"\u2131","GJcy":"\u0403","G":">","GT":">","Gamma":"\u0393","Gammad":"\u03DC","Gbreve":"\u011E","Gcedil":"\u0122","Gcirc":"\u011C","Gcy":"\u0413","Gdot":"\u0120","Gfr":"\uD835\uDD0A","Gg":"\u22D9","Gopf":"\uD835\uDD3E","GreaterEqual":"\u2265","GreaterEqualLess":"\u22DB","GreaterFullEqual":"\u2267","GreaterGreater":"\u2AA2","GreaterLess":"\u2277","GreaterSlantEqual":"\u2A7E","GreaterTilde":"\u2273","Gscr":"\uD835\uDCA2","Gt":"\u226B","HARDcy":"\u042A","Hacek":"\u02C7","Hat":"^","Hcirc":"\u0124","Hfr":"\u210C","HilbertSpace":"\u210B","Hopf":"\u210D","HorizontalLine":"\u2500","Hscr":"\u210B","Hstrok":"\u0126","HumpDownHump":"\u224E","HumpEqual":"\u224F","IEcy":"\u0415","IJlig":"\u0132","IOcy":"\u0401","Iacut":"\xcd","Iacute":"\xcd","Icir":"\xce","Icirc":"\xce","Icy":"\u0418","Idot":"\u0130","Ifr":"\u2111","Igrav":"\xcc","Igrave":"\xcc","Im":"\u2111","Imacr":"\u012A","ImaginaryI":"\u2148","Implies":"\u21D2","Int":"\u222C","Integral":"\u222B","Intersection":"\u22C2","InvisibleComma":"\u2063","InvisibleTimes":"\u2062","Iogon":"\u012E","Iopf":"\uD835\uDD40","Iota":"\u0399","Iscr":"\u2110","Itilde":"\u0128","Iukcy":"\u0406","Ium":"\xcf","Iuml":"\xcf","Jcirc":"\u0134","Jcy":"\u0419","Jfr":"\uD835\uDD0D","Jopf":"\uD835\uDD41","Jscr":"\uD835\uDCA5","Jsercy":"\u0408","Jukcy":"\u0404","KHcy":"\u0425","KJcy":"\u040C","Kappa":"\u039A","Kcedil":"\u0136","Kcy":"\u041A","Kfr":"\uD835\uDD0E","Kopf":"\uD835\uDD42","Kscr":"\uD835\uDCA6","LJcy":"\u0409","L":"<","LT":"<","Lacute":"\u0139","Lambda":"\u039B","Lang":"\u27EA","Laplacetrf":"\u2112","Larr":"\u219E","Lcaron":"\u013D","Lcedil":"\u013B","Lcy":"\u041B","LeftAngleBracket":"\u27E8","LeftArrow":"\u2190","LeftArrowBar":"\u21E4","LeftArrowRightArrow":"\u21C6","LeftCeiling":"\u2308","LeftDoubleBracket":"\u27E6","LeftDownTeeVector":"\u2961","LeftDownVector":"\u21C3","LeftDownVectorBar":"\u2959","LeftFloor":"\u230A","LeftRightArrow":"\u2194","LeftRightVector":"\u294E","LeftTee":"\u22A3","LeftTeeArrow":"\u21A4","LeftTeeVector":"\u295A","LeftTriangle":"\u22B2","LeftTriangleBar":"\u29CF","LeftTriangleEqual":"\u22B4","LeftUpDownVector":"\u2951","LeftUpTeeVector":"\u2960","LeftUpVector":"\u21BF","LeftUpVectorBar":"\u2958","LeftVector":"\u21BC","LeftVectorBar":"\u2952","Leftarrow":"\u21D0","Leftrightarrow":"\u21D4","LessEqualGreater":"\u22DA","LessFullEqual":"\u2266","LessGreater":"\u2276","LessLess":"\u2AA1","LessSlantEqual":"\u2A7D","LessTilde":"\u2272","Lfr":"\uD835\uDD0F","Ll":"\u22D8","Lleftarrow":"\u21DA","Lmidot":"\u013F","LongLeftArrow":"\u27F5","LongLeftRightArrow":"\u27F7","LongRightArrow":"\u27F6","Longleftarrow":"\u27F8","Longleftrightarrow":"\u27FA","Longrightarrow":"\u27F9","Lopf":"\uD835\uDD43","LowerLeftArrow":"\u2199","LowerRightArrow":"\u2198","Lscr":"\u2112","Lsh":"\u21B0","Lstrok":"\u0141","Lt":"\u226A","Map":"\u2905","Mcy":"\u041C","MediumSpace":"\u205F","Mellintrf":"\u2133","Mfr":"\uD835\uDD10","MinusPlus":"\u2213","Mopf":"\uD835\uDD44","Mscr":"\u2133","Mu":"\u039C","NJcy":"\u040A","Nacute":"\u0143","Ncaron":"\u0147","Ncedil":"\u0145","Ncy":"\u041D","NegativeMediumSpace":"\u200B","NegativeThickSpace":"\u200B","NegativeThinSpace":"\u200B","NegativeVeryThinSpace":"\u200B","NestedGreaterGreater":"\u226B","NestedLessLess":"\u226A","NewLine":"\\n","Nfr":"\uD835\uDD11","NoBreak":"\u2060","NonBreakingSpace":"\xa0","Nopf":"\u2115","Not":"\u2AEC","NotCongruent":"\u2262","NotCupCap":"\u226D","NotDoubleVerticalBar":"\u2226","NotElement":"\u2209","NotEqual":"\u2260","NotEqualTilde":"\u2242\u0338","NotExists":"\u2204","NotGreater":"\u226F","NotGreaterEqual":"\u2271","NotGreaterFullEqual":"\u2267\u0338","NotGreaterGreater":"\u226B\u0338","NotGreaterLess":"\u2279","NotGreaterSlantEqual":"\u2A7E\u0338","NotGreaterTilde":"\u2275","NotHumpDownHump":"\u224E\u0338","NotHumpEqual":"\u224F\u0338","NotLeftTriangle":"\u22EA","NotLeftTriangleBar":"\u29CF\u0338","NotLeftTriangleEqual":"\u22EC","NotLess":"\u226E","NotLessEqual":"\u2270","NotLessGreater":"\u2278","NotLessLess":"\u226A\u0338","NotLessSlantEqual":"\u2A7D\u0338","NotLessTilde":"\u2274","NotNestedGreaterGreater":"\u2AA2\u0338","NotNestedLessLess":"\u2AA1\u0338","NotPrecedes":"\u2280","NotPrecedesEqual":"\u2AAF\u0338","NotPrecedesSlantEqual":"\u22E0","NotReverseElement":"\u220C","NotRightTriangle":"\u22EB","NotRightTriangleBar":"\u29D0\u0338","NotRightTriangleEqual":"\u22ED","NotSquareSubset":"\u228F\u0338","NotSquareSubsetEqual":"\u22E2","NotSquareSuperset":"\u2290\u0338","NotSquareSupersetEqual":"\u22E3","NotSubset":"\u2282\u20D2","NotSubsetEqual":"\u2288","NotSucceeds":"\u2281","NotSucceedsEqual":"\u2AB0\u0338","NotSucceedsSlantEqual":"\u22E1","NotSucceedsTilde":"\u227F\u0338","NotSuperset":"\u2283\u20D2","NotSupersetEqual":"\u2289","NotTilde":"\u2241","NotTildeEqual":"\u2244","NotTildeFullEqual":"\u2247","NotTildeTilde":"\u2249","NotVerticalBar":"\u2224","Nscr":"\uD835\uDCA9","Ntild":"\xd1","Ntilde":"\xd1","Nu":"\u039D","OElig":"\u0152","Oacut":"\xd3","Oacute":"\xd3","Ocir":"\xd4","Ocirc":"\xd4","Ocy":"\u041E","Odblac":"\u0150","Ofr":"\uD835\uDD12","Ograv":"\xd2","Ograve":"\xd2","Omacr":"\u014C","Omega":"\u03A9","Omicron":"\u039F","Oopf":"\uD835\uDD46","OpenCurlyDoubleQuote":"\u201C","OpenCurlyQuote":"\u2018","Or":"\u2A54","Oscr":"\uD835\uDCAA","Oslas":"\xd8","Oslash":"\xd8","Otild":"\xd5","Otilde":"\xd5","Otimes":"\u2A37","Oum":"\xd6","Ouml":"\xd6","OverBar":"\u203E","OverBrace":"\u23DE","OverBracket":"\u23B4","OverParenthesis":"\u23DC","PartialD":"\u2202","Pcy":"\u041F","Pfr":"\uD835\uDD13","Phi":"\u03A6","Pi":"\u03A0","PlusMinus":"\xb1","Poincareplane":"\u210C","Popf":"\u2119","Pr":"\u2ABB","Precedes":"\u227A","PrecedesEqual":"\u2AAF","PrecedesSlantEqual":"\u227C","PrecedesTilde":"\u227E","Prime":"\u2033","Product":"\u220F","Proportion":"\u2237","Proportional":"\u221D","Pscr":"\uD835\uDCAB","Psi":"\u03A8","QUO":"\\"","QUOT":"\\"","Qfr":"\uD835\uDD14","Qopf":"\u211A","Qscr":"\uD835\uDCAC","RBarr":"\u2910","RE":"\xae","REG":"\xae","Racute":"\u0154","Rang":"\u27EB","Rarr":"\u21A0","Rarrtl":"\u2916","Rcaron":"\u0158","Rcedil":"\u0156","Rcy":"\u0420","Re":"\u211C","ReverseElement":"\u220B","ReverseEquilibrium":"\u21CB","ReverseUpEquilibrium":"\u296F","Rfr":"\u211C","Rho":"\u03A1","RightAngleBracket":"\u27E9","RightArrow":"\u2192","RightArrowBar":"\u21E5","RightArrowLeftArrow":"\u21C4","RightCeiling":"\u2309","RightDoubleBracket":"\u27E7","RightDownTeeVector":"\u295D","RightDownVector":"\u21C2","RightDownVectorBar":"\u2955","RightFloor":"\u230B","RightTee":"\u22A2","RightTeeArrow":"\u21A6","RightTeeVector":"\u295B","RightTriangle":"\u22B3","RightTriangleBar":"\u29D0","RightTriangleEqual":"\u22B5","RightUpDownVector":"\u294F","RightUpTeeVector":"\u295C","RightUpVector":"\u21BE","RightUpVectorBar":"\u2954","RightVector":"\u21C0","RightVectorBar":"\u2953","Rightarrow":"\u21D2","Ropf":"\u211D","RoundImplies":"\u2970","Rrightarrow":"\u21DB","Rscr":"\u211B","Rsh":"\u21B1","RuleDelayed":"\u29F4","SHCHcy":"\u0429","SHcy":"\u0428","SOFTcy":"\u042C","Sacute":"\u015A","Sc":"\u2ABC","Scaron":"\u0160","Scedil":"\u015E","Scirc":"\u015C","Scy":"\u0421","Sfr":"\uD835\uDD16","ShortDownArrow":"\u2193","ShortLeftArrow":"\u2190","ShortRightArrow":"\u2192","ShortUpArrow":"\u2191","Sigma":"\u03A3","SmallCircle":"\u2218","Sopf":"\uD835\uDD4A","Sqrt":"\u221A","Square":"\u25A1","SquareIntersection":"\u2293","SquareSubset":"\u228F","SquareSubsetEqual":"\u2291","SquareSuperset":"\u2290","SquareSupersetEqual":"\u2292","SquareUnion":"\u2294","Sscr":"\uD835\uDCAE","Star":"\u22C6","Sub":"\u22D0","Subset":"\u22D0","SubsetEqual":"\u2286","Succeeds":"\u227B","SucceedsEqual":"\u2AB0","SucceedsSlantEqual":"\u227D","SucceedsTilde":"\u227F","SuchThat":"\u220B","Sum":"\u2211","Sup":"\u22D1","Superset":"\u2283","SupersetEqual":"\u2287","Supset":"\u22D1","THOR":"\xde","THORN":"\xde","TRADE":"\u2122","TSHcy":"\u040B","TScy":"\u0426","Tab":"\\t","Tau":"\u03A4","Tcaron":"\u0164","Tcedil":"\u0162","Tcy":"\u0422","Tfr":"\uD835\uDD17","Therefore":"\u2234","Theta":"\u0398","ThickSpace":"\u205F\u200A","ThinSpace":"\u2009","Tilde":"\u223C","TildeEqual":"\u2243","TildeFullEqual":"\u2245","TildeTilde":"\u2248","Topf":"\uD835\uDD4B","TripleDot":"\u20DB","Tscr":"\uD835\uDCAF","Tstrok":"\u0166","Uacut":"\xda","Uacute":"\xda","Uarr":"\u219F","Uarrocir":"\u2949","Ubrcy":"\u040E","Ubreve":"\u016C","Ucir":"\xdb","Ucirc":"\xdb","Ucy":"\u0423","Udblac":"\u0170","Ufr":"\uD835\uDD18","Ugrav":"\xd9","Ugrave":"\xd9","Umacr":"\u016A","UnderBar":"_","UnderBrace":"\u23DF","UnderBracket":"\u23B5","UnderParenthesis":"\u23DD","Union":"\u22C3","UnionPlus":"\u228E","Uogon":"\u0172","Uopf":"\uD835\uDD4C","UpArrow":"\u2191","UpArrowBar":"\u2912","UpArrowDownArrow":"\u21C5","UpDownArrow":"\u2195","UpEquilibrium":"\u296E","UpTee":"\u22A5","UpTeeArrow":"\u21A5","Uparrow":"\u21D1","Updownarrow":"\u21D5","UpperLeftArrow":"\u2196","UpperRightArrow":"\u2197","Upsi":"\u03D2","Upsilon":"\u03A5","Uring":"\u016E","Uscr":"\uD835\uDCB0","Utilde":"\u0168","Uum":"\xdc","Uuml":"\xdc","VDash":"\u22AB","Vbar":"\u2AEB","Vcy":"\u0412","Vdash":"\u22A9","Vdashl":"\u2AE6","Vee":"\u22C1","Verbar":"\u2016","Vert":"\u2016","VerticalBar":"\u2223","VerticalLine":"|","VerticalSeparator":"\u2758","VerticalTilde":"\u2240","VeryThinSpace":"\u200A","Vfr":"\uD835\uDD19","Vopf":"\uD835\uDD4D","Vscr":"\uD835\uDCB1","Vvdash":"\u22AA","Wcirc":"\u0174","Wedge":"\u22C0","Wfr":"\uD835\uDD1A","Wopf":"\uD835\uDD4E","Wscr":"\uD835\uDCB2","Xfr":"\uD835\uDD1B","Xi":"\u039E","Xopf":"\uD835\uDD4F","Xscr":"\uD835\uDCB3","YAcy":"\u042F","YIcy":"\u0407","YUcy":"\u042E","Yacut":"\xdd","Yacute":"\xdd","Ycirc":"\u0176","Ycy":"\u042B","Yfr":"\uD835\uDD1C","Yopf":"\uD835\uDD50","Yscr":"\uD835\uDCB4","Yuml":"\u0178","ZHcy":"\u0416","Zacute":"\u0179","Zcaron":"\u017D","Zcy":"\u0417","Zdot":"\u017B","ZeroWidthSpace":"\u200B","Zeta":"\u0396","Zfr":"\u2128","Zopf":"\u2124","Zscr":"\uD835\uDCB5","aacut":"\xe1","aacute":"\xe1","abreve":"\u0103","ac":"\u223E","acE":"\u223E\u0333","acd":"\u223F","acir":"\xe2","acirc":"\xe2","acut":"\xb4","acute":"\xb4","acy":"\u0430","aeli":"\xe6","aelig":"\xe6","af":"\u2061","afr":"\uD835\uDD1E","agrav":"\xe0","agrave":"\xe0","alefsym":"\u2135","aleph":"\u2135","alpha":"\u03B1","amacr":"\u0101","amalg":"\u2A3F","am":"&","amp":"&","and":"\u2227","andand":"\u2A55","andd":"\u2A5C","andslope":"\u2A58","andv":"\u2A5A","ang":"\u2220","ange":"\u29A4","angle":"\u2220","angmsd":"\u2221","angmsdaa":"\u29A8","angmsdab":"\u29A9","angmsdac":"\u29AA","angmsdad":"\u29AB","angmsdae":"\u29AC","angmsdaf":"\u29AD","angmsdag":"\u29AE","angmsdah":"\u29AF","angrt":"\u221F","angrtvb":"\u22BE","angrtvbd":"\u299D","angsph":"\u2222","angst":"\xc5","angzarr":"\u237C","aogon":"\u0105","aopf":"\uD835\uDD52","ap":"\u2248","apE":"\u2A70","apacir":"\u2A6F","ape":"\u224A","apid":"\u224B","apos":"\'","approx":"\u2248","approxeq":"\u224A","arin":"\xe5","aring":"\xe5","ascr":"\uD835\uDCB6","ast":"*","asymp":"\u2248","asympeq":"\u224D","atild":"\xe3","atilde":"\xe3","aum":"\xe4","auml":"\xe4","awconint":"\u2233","awint":"\u2A11","bNot":"\u2AED","backcong":"\u224C","backepsilon":"\u03F6","backprime":"\u2035","backsim":"\u223D","backsimeq":"\u22CD","barvee":"\u22BD","barwed":"\u2305","barwedge":"\u2305","bbrk":"\u23B5","bbrktbrk":"\u23B6","bcong":"\u224C","bcy":"\u0431","bdquo":"\u201E","becaus":"\u2235","because":"\u2235","bemptyv":"\u29B0","bepsi":"\u03F6","bernou":"\u212C","beta":"\u03B2","beth":"\u2136","between":"\u226C","bfr":"\uD835\uDD1F","bigcap":"\u22C2","bigcirc":"\u25EF","bigcup":"\u22C3","bigodot":"\u2A00","bigoplus":"\u2A01","bigotimes":"\u2A02","bigsqcup":"\u2A06","bigstar":"\u2605","bigtriangledown":"\u25BD","bigtriangleup":"\u25B3","biguplus":"\u2A04","bigvee":"\u22C1","bigwedge":"\u22C0","bkarow":"\u290D","blacklozenge":"\u29EB","blacksquare":"\u25AA","blacktriangle":"\u25B4","blacktriangledown":"\u25BE","blacktriangleleft":"\u25C2","blacktriangleright":"\u25B8","blank":"\u2423","blk12":"\u2592","blk14":"\u2591","blk34":"\u2593","block":"\u2588","bne":"=\u20E5","bnequiv":"\u2261\u20E5","bnot":"\u2310","bopf":"\uD835\uDD53","bot":"\u22A5","bottom":"\u22A5","bowtie":"\u22C8","boxDL":"\u2557","boxDR":"\u2554","boxDl":"\u2556","boxDr":"\u2553","boxH":"\u2550","boxHD":"\u2566","boxHU":"\u2569","boxHd":"\u2564","boxHu":"\u2567","boxUL":"\u255D","boxUR":"\u255A","boxUl":"\u255C","boxUr":"\u2559","boxV":"\u2551","boxVH":"\u256C","boxVL":"\u2563","boxVR":"\u2560","boxVh":"\u256B","boxVl":"\u2562","boxVr":"\u255F","boxbox":"\u29C9","boxdL":"\u2555","boxdR":"\u2552","boxdl":"\u2510","boxdr":"\u250C","boxh":"\u2500","boxhD":"\u2565","boxhU":"\u2568","boxhd":"\u252C","boxhu":"\u2534","boxminus":"\u229F","boxplus":"\u229E","boxtimes":"\u22A0","boxuL":"\u255B","boxuR":"\u2558","boxul":"\u2518","boxur":"\u2514","boxv":"\u2502","boxvH":"\u256A","boxvL":"\u2561","boxvR":"\u255E","boxvh":"\u253C","boxvl":"\u2524","boxvr":"\u251C","bprime":"\u2035","breve":"\u02D8","brvba":"\xa6","brvbar":"\xa6","bscr":"\uD835\uDCB7","bsemi":"\u204F","bsim":"\u223D","bsime":"\u22CD","bsol":"\\\\","bsolb":"\u29C5","bsolhsub":"\u27C8","bull":"\u2022","bullet":"\u2022","bump":"\u224E","bumpE":"\u2AAE","bumpe":"\u224F","bumpeq":"\u224F","cacute":"\u0107","cap":"\u2229","capand":"\u2A44","capbrcup":"\u2A49","capcap":"\u2A4B","capcup":"\u2A47","capdot":"\u2A40","caps":"\u2229\uFE00","caret":"\u2041","caron":"\u02C7","ccaps":"\u2A4D","ccaron":"\u010D","ccedi":"\xe7","ccedil":"\xe7","ccirc":"\u0109","ccups":"\u2A4C","ccupssm":"\u2A50","cdot":"\u010B","cedi":"\xb8","cedil":"\xb8","cemptyv":"\u29B2","cen":"\xa2","cent":"\xa2","centerdot":"\xb7","cfr":"\uD835\uDD20","chcy":"\u0447","check":"\u2713","checkmark":"\u2713","chi":"\u03C7","cir":"\u25CB","cirE":"\u29C3","circ":"\u02C6","circeq":"\u2257","circlearrowleft":"\u21BA","circlearrowright":"\u21BB","circledR":"\xae","circledS":"\u24C8","circledast":"\u229B","circledcirc":"\u229A","circleddash":"\u229D","cire":"\u2257","cirfnint":"\u2A10","cirmid":"\u2AEF","cirscir":"\u29C2","clubs":"\u2663","clubsuit":"\u2663","colon":":","colone":"\u2254","coloneq":"\u2254","comma":",","commat":"@","comp":"\u2201","compfn":"\u2218","complement":"\u2201","complexes":"\u2102","cong":"\u2245","congdot":"\u2A6D","conint":"\u222E","copf":"\uD835\uDD54","coprod":"\u2210","cop":"\xa9","copy":"\xa9","copysr":"\u2117","crarr":"\u21B5","cross":"\u2717","cscr":"\uD835\uDCB8","csub":"\u2ACF","csube":"\u2AD1","csup":"\u2AD0","csupe":"\u2AD2","ctdot":"\u22EF","cudarrl":"\u2938","cudarrr":"\u2935","cuepr":"\u22DE","cuesc":"\u22DF","cularr":"\u21B6","cularrp":"\u293D","cup":"\u222A","cupbrcap":"\u2A48","cupcap":"\u2A46","cupcup":"\u2A4A","cupdot":"\u228D","cupor":"\u2A45","cups":"\u222A\uFE00","curarr":"\u21B7","curarrm":"\u293C","curlyeqprec":"\u22DE","curlyeqsucc":"\u22DF","curlyvee":"\u22CE","curlywedge":"\u22CF","curre":"\xa4","curren":"\xa4","curvearrowleft":"\u21B6","curvearrowright":"\u21B7","cuvee":"\u22CE","cuwed":"\u22CF","cwconint":"\u2232","cwint":"\u2231","cylcty":"\u232D","dArr":"\u21D3","dHar":"\u2965","dagger":"\u2020","daleth":"\u2138","darr":"\u2193","dash":"\u2010","dashv":"\u22A3","dbkarow":"\u290F","dblac":"\u02DD","dcaron":"\u010F","dcy":"\u0434","dd":"\u2146","ddagger":"\u2021","ddarr":"\u21CA","ddotseq":"\u2A77","de":"\xb0","deg":"\xb0","delta":"\u03B4","demptyv":"\u29B1","dfisht":"\u297F","dfr":"\uD835\uDD21","dharl":"\u21C3","dharr":"\u21C2","diam":"\u22C4","diamond":"\u22C4","diamondsuit":"\u2666","diams":"\u2666","die":"\xa8","digamma":"\u03DD","disin":"\u22F2","div":"\xf7","divid":"\xf7","divide":"\xf7","divideontimes":"\u22C7","divonx":"\u22C7","djcy":"\u0452","dlcorn":"\u231E","dlcrop":"\u230D","dollar":"$","dopf":"\uD835\uDD55","dot":"\u02D9","doteq":"\u2250","doteqdot":"\u2251","dotminus":"\u2238","dotplus":"\u2214","dotsquare":"\u22A1","doublebarwedge":"\u2306","downarrow":"\u2193","downdownarrows":"\u21CA","downharpoonleft":"\u21C3","downharpoonright":"\u21C2","drbkarow":"\u2910","drcorn":"\u231F","drcrop":"\u230C","dscr":"\uD835\uDCB9","dscy":"\u0455","dsol":"\u29F6","dstrok":"\u0111","dtdot":"\u22F1","dtri":"\u25BF","dtrif":"\u25BE","duarr":"\u21F5","duhar":"\u296F","dwangle":"\u29A6","dzcy":"\u045F","dzigrarr":"\u27FF","eDDot":"\u2A77","eDot":"\u2251","eacut":"\xe9","eacute":"\xe9","easter":"\u2A6E","ecaron":"\u011B","ecir":"\xea","ecirc":"\xea","ecolon":"\u2255","ecy":"\u044D","edot":"\u0117","ee":"\u2147","efDot":"\u2252","efr":"\uD835\uDD22","eg":"\u2A9A","egrav":"\xe8","egrave":"\xe8","egs":"\u2A96","egsdot":"\u2A98","el":"\u2A99","elinters":"\u23E7","ell":"\u2113","els":"\u2A95","elsdot":"\u2A97","emacr":"\u0113","empty":"\u2205","emptyset":"\u2205","emptyv":"\u2205","emsp13":"\u2004","emsp14":"\u2005","emsp":"\u2003","eng":"\u014B","ensp":"\u2002","eogon":"\u0119","eopf":"\uD835\uDD56","epar":"\u22D5","eparsl":"\u29E3","eplus":"\u2A71","epsi":"\u03B5","epsilon":"\u03B5","epsiv":"\u03F5","eqcirc":"\u2256","eqcolon":"\u2255","eqsim":"\u2242","eqslantgtr":"\u2A96","eqslantless":"\u2A95","equals":"=","equest":"\u225F","equiv":"\u2261","equivDD":"\u2A78","eqvparsl":"\u29E5","erDot":"\u2253","erarr":"\u2971","escr":"\u212F","esdot":"\u2250","esim":"\u2242","eta":"\u03B7","et":"\xf0","eth":"\xf0","eum":"\xeb","euml":"\xeb","euro":"\u20AC","excl":"!","exist":"\u2203","expectation":"\u2130","exponentiale":"\u2147","fallingdotseq":"\u2252","fcy":"\u0444","female":"\u2640","ffilig":"\uFB03","fflig":"\uFB00","ffllig":"\uFB04","ffr":"\uD835\uDD23","filig":"\uFB01","fjlig":"fj","flat":"\u266D","fllig":"\uFB02","fltns":"\u25B1","fnof":"\u0192","fopf":"\uD835\uDD57","forall":"\u2200","fork":"\u22D4","forkv":"\u2AD9","fpartint":"\u2A0D","frac1":"\xbc","frac12":"\xbd","frac13":"\u2153","frac14":"\xbc","frac15":"\u2155","frac16":"\u2159","frac18":"\u215B","frac23":"\u2154","frac25":"\u2156","frac3":"\xbe","frac34":"\xbe","frac35":"\u2157","frac38":"\u215C","frac45":"\u2158","frac56":"\u215A","frac58":"\u215D","frac78":"\u215E","frasl":"\u2044","frown":"\u2322","fscr":"\uD835\uDCBB","gE":"\u2267","gEl":"\u2A8C","gacute":"\u01F5","gamma":"\u03B3","gammad":"\u03DD","gap":"\u2A86","gbreve":"\u011F","gcirc":"\u011D","gcy":"\u0433","gdot":"\u0121","ge":"\u2265","gel":"\u22DB","geq":"\u2265","geqq":"\u2267","geqslant":"\u2A7E","ges":"\u2A7E","gescc":"\u2AA9","gesdot":"\u2A80","gesdoto":"\u2A82","gesdotol":"\u2A84","gesl":"\u22DB\uFE00","gesles":"\u2A94","gfr":"\uD835\uDD24","gg":"\u226B","ggg":"\u22D9","gimel":"\u2137","gjcy":"\u0453","gl":"\u2277","glE":"\u2A92","gla":"\u2AA5","glj":"\u2AA4","gnE":"\u2269","gnap":"\u2A8A","gnapprox":"\u2A8A","gne":"\u2A88","gneq":"\u2A88","gneqq":"\u2269","gnsim":"\u22E7","gopf":"\uD835\uDD58","grave":"`","gscr":"\u210A","gsim":"\u2273","gsime":"\u2A8E","gsiml":"\u2A90","g":">","gt":">","gtcc":"\u2AA7","gtcir":"\u2A7A","gtdot":"\u22D7","gtlPar":"\u2995","gtquest":"\u2A7C","gtrapprox":"\u2A86","gtrarr":"\u2978","gtrdot":"\u22D7","gtreqless":"\u22DB","gtreqqless":"\u2A8C","gtrless":"\u2277","gtrsim":"\u2273","gvertneqq":"\u2269\uFE00","gvnE":"\u2269\uFE00","hArr":"\u21D4","hairsp":"\u200A","half":"\xbd","hamilt":"\u210B","hardcy":"\u044A","harr":"\u2194","harrcir":"\u2948","harrw":"\u21AD","hbar":"\u210F","hcirc":"\u0125","hearts":"\u2665","heartsuit":"\u2665","hellip":"\u2026","hercon":"\u22B9","hfr":"\uD835\uDD25","hksearow":"\u2925","hkswarow":"\u2926","hoarr":"\u21FF","homtht":"\u223B","hookleftarrow":"\u21A9","hookrightarrow":"\u21AA","hopf":"\uD835\uDD59","horbar":"\u2015","hscr":"\uD835\uDCBD","hslash":"\u210F","hstrok":"\u0127","hybull":"\u2043","hyphen":"\u2010","iacut":"\xed","iacute":"\xed","ic":"\u2063","icir":"\xee","icirc":"\xee","icy":"\u0438","iecy":"\u0435","iexc":"\xa1","iexcl":"\xa1","iff":"\u21D4","ifr":"\uD835\uDD26","igrav":"\xec","igrave":"\xec","ii":"\u2148","iiiint":"\u2A0C","iiint":"\u222D","iinfin":"\u29DC","iiota":"\u2129","ijlig":"\u0133","imacr":"\u012B","image":"\u2111","imagline":"\u2110","imagpart":"\u2111","imath":"\u0131","imof":"\u22B7","imped":"\u01B5","in":"\u2208","incare":"\u2105","infin":"\u221E","infintie":"\u29DD","inodot":"\u0131","int":"\u222B","intcal":"\u22BA","integers":"\u2124","intercal":"\u22BA","intlarhk":"\u2A17","intprod":"\u2A3C","iocy":"\u0451","iogon":"\u012F","iopf":"\uD835\uDD5A","iota":"\u03B9","iprod":"\u2A3C","iques":"\xbf","iquest":"\xbf","iscr":"\uD835\uDCBE","isin":"\u2208","isinE":"\u22F9","isindot":"\u22F5","isins":"\u22F4","isinsv":"\u22F3","isinv":"\u2208","it":"\u2062","itilde":"\u0129","iukcy":"\u0456","ium":"\xef","iuml":"\xef","jcirc":"\u0135","jcy":"\u0439","jfr":"\uD835\uDD27","jmath":"\u0237","jopf":"\uD835\uDD5B","jscr":"\uD835\uDCBF","jsercy":"\u0458","jukcy":"\u0454","kappa":"\u03BA","kappav":"\u03F0","kcedil":"\u0137","kcy":"\u043A","kfr":"\uD835\uDD28","kgreen":"\u0138","khcy":"\u0445","kjcy":"\u045C","kopf":"\uD835\uDD5C","kscr":"\uD835\uDCC0","lAarr":"\u21DA","lArr":"\u21D0","lAtail":"\u291B","lBarr":"\u290E","lE":"\u2266","lEg":"\u2A8B","lHar":"\u2962","lacute":"\u013A","laemptyv":"\u29B4","lagran":"\u2112","lambda":"\u03BB","lang":"\u27E8","langd":"\u2991","langle":"\u27E8","lap":"\u2A85","laqu":"\xab","laquo":"\xab","larr":"\u2190","larrb":"\u21E4","larrbfs":"\u291F","larrfs":"\u291D","larrhk":"\u21A9","larrlp":"\u21AB","larrpl":"\u2939","larrsim":"\u2973","larrtl":"\u21A2","lat":"\u2AAB","latail":"\u2919","late":"\u2AAD","lates":"\u2AAD\uFE00","lbarr":"\u290C","lbbrk":"\u2772","lbrace":"{","lbrack":"[","lbrke":"\u298B","lbrksld":"\u298F","lbrkslu":"\u298D","lcaron":"\u013E","lcedil":"\u013C","lceil":"\u2308","lcub":"{","lcy":"\u043B","ldca":"\u2936","ldquo":"\u201C","ldquor":"\u201E","ldrdhar":"\u2967","ldrushar":"\u294B","ldsh":"\u21B2","le":"\u2264","leftarrow":"\u2190","leftarrowtail":"\u21A2","leftharpoondown":"\u21BD","leftharpoonup":"\u21BC","leftleftarrows":"\u21C7","leftrightarrow":"\u2194","leftrightarrows":"\u21C6","leftrightharpoons":"\u21CB","leftrightsquigarrow":"\u21AD","leftthreetimes":"\u22CB","leg":"\u22DA","leq":"\u2264","leqq":"\u2266","leqslant":"\u2A7D","les":"\u2A7D","lescc":"\u2AA8","lesdot":"\u2A7F","lesdoto":"\u2A81","lesdotor":"\u2A83","lesg":"\u22DA\uFE00","lesges":"\u2A93","lessapprox":"\u2A85","lessdot":"\u22D6","lesseqgtr":"\u22DA","lesseqqgtr":"\u2A8B","lessgtr":"\u2276","lesssim":"\u2272","lfisht":"\u297C","lfloor":"\u230A","lfr":"\uD835\uDD29","lg":"\u2276","lgE":"\u2A91","lhard":"\u21BD","lharu":"\u21BC","lharul":"\u296A","lhblk":"\u2584","ljcy":"\u0459","ll":"\u226A","llarr":"\u21C7","llcorner":"\u231E","llhard":"\u296B","lltri":"\u25FA","lmidot":"\u0140","lmoust":"\u23B0","lmoustache":"\u23B0","lnE":"\u2268","lnap":"\u2A89","lnapprox":"\u2A89","lne":"\u2A87","lneq":"\u2A87","lneqq":"\u2268","lnsim":"\u22E6","loang":"\u27EC","loarr":"\u21FD","lobrk":"\u27E6","longleftarrow":"\u27F5","longleftrightarrow":"\u27F7","longmapsto":"\u27FC","longrightarrow":"\u27F6","looparrowleft":"\u21AB","looparrowright":"\u21AC","lopar":"\u2985","lopf":"\uD835\uDD5D","loplus":"\u2A2D","lotimes":"\u2A34","lowast":"\u2217","lowbar":"_","loz":"\u25CA","lozenge":"\u25CA","lozf":"\u29EB","lpar":"(","lparlt":"\u2993","lrarr":"\u21C6","lrcorner":"\u231F","lrhar":"\u21CB","lrhard":"\u296D","lrm":"\u200E","lrtri":"\u22BF","lsaquo":"\u2039","lscr":"\uD835\uDCC1","lsh":"\u21B0","lsim":"\u2272","lsime":"\u2A8D","lsimg":"\u2A8F","lsqb":"[","lsquo":"\u2018","lsquor":"\u201A","lstrok":"\u0142","l":"<","lt":"<","ltcc":"\u2AA6","ltcir":"\u2A79","ltdot":"\u22D6","lthree":"\u22CB","ltimes":"\u22C9","ltlarr":"\u2976","ltquest":"\u2A7B","ltrPar":"\u2996","ltri":"\u25C3","ltrie":"\u22B4","ltrif":"\u25C2","lurdshar":"\u294A","luruhar":"\u2966","lvertneqq":"\u2268\uFE00","lvnE":"\u2268\uFE00","mDDot":"\u223A","mac":"\xaf","macr":"\xaf","male":"\u2642","malt":"\u2720","maltese":"\u2720","map":"\u21A6","mapsto":"\u21A6","mapstodown":"\u21A7","mapstoleft":"\u21A4","mapstoup":"\u21A5","marker":"\u25AE","mcomma":"\u2A29","mcy":"\u043C","mdash":"\u2014","measuredangle":"\u2221","mfr":"\uD835\uDD2A","mho":"\u2127","micr":"\xb5","micro":"\xb5","mid":"\u2223","midast":"*","midcir":"\u2AF0","middo":"\xb7","middot":"\xb7","minus":"\u2212","minusb":"\u229F","minusd":"\u2238","minusdu":"\u2A2A","mlcp":"\u2ADB","mldr":"\u2026","mnplus":"\u2213","models":"\u22A7","mopf":"\uD835\uDD5E","mp":"\u2213","mscr":"\uD835\uDCC2","mstpos":"\u223E","mu":"\u03BC","multimap":"\u22B8","mumap":"\u22B8","nGg":"\u22D9\u0338","nGt":"\u226B\u20D2","nGtv":"\u226B\u0338","nLeftarrow":"\u21CD","nLeftrightarrow":"\u21CE","nLl":"\u22D8\u0338","nLt":"\u226A\u20D2","nLtv":"\u226A\u0338","nRightarrow":"\u21CF","nVDash":"\u22AF","nVdash":"\u22AE","nabla":"\u2207","nacute":"\u0144","nang":"\u2220\u20D2","nap":"\u2249","napE":"\u2A70\u0338","napid":"\u224B\u0338","napos":"\u0149","napprox":"\u2249","natur":"\u266E","natural":"\u266E","naturals":"\u2115","nbs":"\xa0","nbsp":"\xa0","nbump":"\u224E\u0338","nbumpe":"\u224F\u0338","ncap":"\u2A43","ncaron":"\u0148","ncedil":"\u0146","ncong":"\u2247","ncongdot":"\u2A6D\u0338","ncup":"\u2A42","ncy":"\u043D","ndash":"\u2013","ne":"\u2260","neArr":"\u21D7","nearhk":"\u2924","nearr":"\u2197","nearrow":"\u2197","nedot":"\u2250\u0338","nequiv":"\u2262","nesear":"\u2928","nesim":"\u2242\u0338","nexist":"\u2204","nexists":"\u2204","nfr":"\uD835\uDD2B","ngE":"\u2267\u0338","nge":"\u2271","ngeq":"\u2271","ngeqq":"\u2267\u0338","ngeqslant":"\u2A7E\u0338","nges":"\u2A7E\u0338","ngsim":"\u2275","ngt":"\u226F","ngtr":"\u226F","nhArr":"\u21CE","nharr":"\u21AE","nhpar":"\u2AF2","ni":"\u220B","nis":"\u22FC","nisd":"\u22FA","niv":"\u220B","njcy":"\u045A","nlArr":"\u21CD","nlE":"\u2266\u0338","nlarr":"\u219A","nldr":"\u2025","nle":"\u2270","nleftarrow":"\u219A","nleftrightarrow":"\u21AE","nleq":"\u2270","nleqq":"\u2266\u0338","nleqslant":"\u2A7D\u0338","nles":"\u2A7D\u0338","nless":"\u226E","nlsim":"\u2274","nlt":"\u226E","nltri":"\u22EA","nltrie":"\u22EC","nmid":"\u2224","nopf":"\uD835\uDD5F","no":"\xac","not":"\xac","notin":"\u2209","notinE":"\u22F9\u0338","notindot":"\u22F5\u0338","notinva":"\u2209","notinvb":"\u22F7","notinvc":"\u22F6","notni":"\u220C","notniva":"\u220C","notnivb":"\u22FE","notnivc":"\u22FD","npar":"\u2226","nparallel":"\u2226","nparsl":"\u2AFD\u20E5","npart":"\u2202\u0338","npolint":"\u2A14","npr":"\u2280","nprcue":"\u22E0","npre":"\u2AAF\u0338","nprec":"\u2280","npreceq":"\u2AAF\u0338","nrArr":"\u21CF","nrarr":"\u219B","nrarrc":"\u2933\u0338","nrarrw":"\u219D\u0338","nrightarrow":"\u219B","nrtri":"\u22EB","nrtrie":"\u22ED","nsc":"\u2281","nsccue":"\u22E1","nsce":"\u2AB0\u0338","nscr":"\uD835\uDCC3","nshortmid":"\u2224","nshortparallel":"\u2226","nsim":"\u2241","nsime":"\u2244","nsimeq":"\u2244","nsmid":"\u2224","nspar":"\u2226","nsqsube":"\u22E2","nsqsupe":"\u22E3","nsub":"\u2284","nsubE":"\u2AC5\u0338","nsube":"\u2288","nsubset":"\u2282\u20D2","nsubseteq":"\u2288","nsubseteqq":"\u2AC5\u0338","nsucc":"\u2281","nsucceq":"\u2AB0\u0338","nsup":"\u2285","nsupE":"\u2AC6\u0338","nsupe":"\u2289","nsupset":"\u2283\u20D2","nsupseteq":"\u2289","nsupseteqq":"\u2AC6\u0338","ntgl":"\u2279","ntild":"\xf1","ntilde":"\xf1","ntlg":"\u2278","ntriangleleft":"\u22EA","ntrianglelefteq":"\u22EC","ntriangleright":"\u22EB","ntrianglerighteq":"\u22ED","nu":"\u03BD","num":"#","numero":"\u2116","numsp":"\u2007","nvDash":"\u22AD","nvHarr":"\u2904","nvap":"\u224D\u20D2","nvdash":"\u22AC","nvge":"\u2265\u20D2","nvgt":">\u20D2","nvinfin":"\u29DE","nvlArr":"\u2902","nvle":"\u2264\u20D2","nvlt":"<\u20D2","nvltrie":"\u22B4\u20D2","nvrArr":"\u2903","nvrtrie":"\u22B5\u20D2","nvsim":"\u223C\u20D2","nwArr":"\u21D6","nwarhk":"\u2923","nwarr":"\u2196","nwarrow":"\u2196","nwnear":"\u2927","oS":"\u24C8","oacut":"\xf3","oacute":"\xf3","oast":"\u229B","ocir":"\xf4","ocirc":"\xf4","ocy":"\u043E","odash":"\u229D","odblac":"\u0151","odiv":"\u2A38","odot":"\u2299","odsold":"\u29BC","oelig":"\u0153","ofcir":"\u29BF","ofr":"\uD835\uDD2C","ogon":"\u02DB","ograv":"\xf2","ograve":"\xf2","ogt":"\u29C1","ohbar":"\u29B5","ohm":"\u03A9","oint":"\u222E","olarr":"\u21BA","olcir":"\u29BE","olcross":"\u29BB","oline":"\u203E","olt":"\u29C0","omacr":"\u014D","omega":"\u03C9","omicron":"\u03BF","omid":"\u29B6","ominus":"\u2296","oopf":"\uD835\uDD60","opar":"\u29B7","operp":"\u29B9","oplus":"\u2295","or":"\u2228","orarr":"\u21BB","ord":"\xba","order":"\u2134","orderof":"\u2134","ordf":"\xaa","ordm":"\xba","origof":"\u22B6","oror":"\u2A56","orslope":"\u2A57","orv":"\u2A5B","oscr":"\u2134","oslas":"\xf8","oslash":"\xf8","osol":"\u2298","otild":"\xf5","otilde":"\xf5","otimes":"\u2297","otimesas":"\u2A36","oum":"\xf6","ouml":"\xf6","ovbar":"\u233D","par":"\xb6","para":"\xb6","parallel":"\u2225","parsim":"\u2AF3","parsl":"\u2AFD","part":"\u2202","pcy":"\u043F","percnt":"%","period":".","permil":"\u2030","perp":"\u22A5","pertenk":"\u2031","pfr":"\uD835\uDD2D","phi":"\u03C6","phiv":"\u03D5","phmmat":"\u2133","phone":"\u260E","pi":"\u03C0","pitchfork":"\u22D4","piv":"\u03D6","planck":"\u210F","planckh":"\u210E","plankv":"\u210F","plus":"+","plusacir":"\u2A23","plusb":"\u229E","pluscir":"\u2A22","plusdo":"\u2214","plusdu":"\u2A25","pluse":"\u2A72","plusm":"\xb1","plusmn":"\xb1","plussim":"\u2A26","plustwo":"\u2A27","pm":"\xb1","pointint":"\u2A15","popf":"\uD835\uDD61","poun":"\xa3","pound":"\xa3","pr":"\u227A","prE":"\u2AB3","prap":"\u2AB7","prcue":"\u227C","pre":"\u2AAF","prec":"\u227A","precapprox":"\u2AB7","preccurlyeq":"\u227C","preceq":"\u2AAF","precnapprox":"\u2AB9","precneqq":"\u2AB5","precnsim":"\u22E8","precsim":"\u227E","prime":"\u2032","primes":"\u2119","prnE":"\u2AB5","prnap":"\u2AB9","prnsim":"\u22E8","prod":"\u220F","profalar":"\u232E","profline":"\u2312","profsurf":"\u2313","prop":"\u221D","propto":"\u221D","prsim":"\u227E","prurel":"\u22B0","pscr":"\uD835\uDCC5","psi":"\u03C8","puncsp":"\u2008","qfr":"\uD835\uDD2E","qint":"\u2A0C","qopf":"\uD835\uDD62","qprime":"\u2057","qscr":"\uD835\uDCC6","quaternions":"\u210D","quatint":"\u2A16","quest":"?","questeq":"\u225F","quo":"\\"","quot":"\\"","rAarr":"\u21DB","rArr":"\u21D2","rAtail":"\u291C","rBarr":"\u290F","rHar":"\u2964","race":"\u223D\u0331","racute":"\u0155","radic":"\u221A","raemptyv":"\u29B3","rang":"\u27E9","rangd":"\u2992","range":"\u29A5","rangle":"\u27E9","raqu":"\xbb","raquo":"\xbb","rarr":"\u2192","rarrap":"\u2975","rarrb":"\u21E5","rarrbfs":"\u2920","rarrc":"\u2933","rarrfs":"\u291E","rarrhk":"\u21AA","rarrlp":"\u21AC","rarrpl":"\u2945","rarrsim":"\u2974","rarrtl":"\u21A3","rarrw":"\u219D","ratail":"\u291A","ratio":"\u2236","rationals":"\u211A","rbarr":"\u290D","rbbrk":"\u2773","rbrace":"}","rbrack":"]","rbrke":"\u298C","rbrksld":"\u298E","rbrkslu":"\u2990","rcaron":"\u0159","rcedil":"\u0157","rceil":"\u2309","rcub":"}","rcy":"\u0440","rdca":"\u2937","rdldhar":"\u2969","rdquo":"\u201D","rdquor":"\u201D","rdsh":"\u21B3","real":"\u211C","realine":"\u211B","realpart":"\u211C","reals":"\u211D","rect":"\u25AD","re":"\xae","reg":"\xae","rfisht":"\u297D","rfloor":"\u230B","rfr":"\uD835\uDD2F","rhard":"\u21C1","rharu":"\u21C0","rharul":"\u296C","rho":"\u03C1","rhov":"\u03F1","rightarrow":"\u2192","rightarrowtail":"\u21A3","rightharpoondown":"\u21C1","rightharpoonup":"\u21C0","rightleftarrows":"\u21C4","rightleftharpoons":"\u21CC","rightrightarrows":"\u21C9","rightsquigarrow":"\u219D","rightthreetimes":"\u22CC","ring":"\u02DA","risingdotseq":"\u2253","rlarr":"\u21C4","rlhar":"\u21CC","rlm":"\u200F","rmoust":"\u23B1","rmoustache":"\u23B1","rnmid":"\u2AEE","roang":"\u27ED","roarr":"\u21FE","robrk":"\u27E7","ropar":"\u2986","ropf":"\uD835\uDD63","roplus":"\u2A2E","rotimes":"\u2A35","rpar":")","rpargt":"\u2994","rppolint":"\u2A12","rrarr":"\u21C9","rsaquo":"\u203A","rscr":"\uD835\uDCC7","rsh":"\u21B1","rsqb":"]","rsquo":"\u2019","rsquor":"\u2019","rthree":"\u22CC","rtimes":"\u22CA","rtri":"\u25B9","rtrie":"\u22B5","rtrif":"\u25B8","rtriltri":"\u29CE","ruluhar":"\u2968","rx":"\u211E","sacute":"\u015B","sbquo":"\u201A","sc":"\u227B","scE":"\u2AB4","scap":"\u2AB8","scaron":"\u0161","sccue":"\u227D","sce":"\u2AB0","scedil":"\u015F","scirc":"\u015D","scnE":"\u2AB6","scnap":"\u2ABA","scnsim":"\u22E9","scpolint":"\u2A13","scsim":"\u227F","scy":"\u0441","sdot":"\u22C5","sdotb":"\u22A1","sdote":"\u2A66","seArr":"\u21D8","searhk":"\u2925","searr":"\u2198","searrow":"\u2198","sec":"\xa7","sect":"\xa7","semi":";","seswar":"\u2929","setminus":"\u2216","setmn":"\u2216","sext":"\u2736","sfr":"\uD835\uDD30","sfrown":"\u2322","sharp":"\u266F","shchcy":"\u0449","shcy":"\u0448","shortmid":"\u2223","shortparallel":"\u2225","sh":"\xad","shy":"\xad","sigma":"\u03C3","sigmaf":"\u03C2","sigmav":"\u03C2","sim":"\u223C","simdot":"\u2A6A","sime":"\u2243","simeq":"\u2243","simg":"\u2A9E","simgE":"\u2AA0","siml":"\u2A9D","simlE":"\u2A9F","simne":"\u2246","simplus":"\u2A24","simrarr":"\u2972","slarr":"\u2190","smallsetminus":"\u2216","smashp":"\u2A33","smeparsl":"\u29E4","smid":"\u2223","smile":"\u2323","smt":"\u2AAA","smte":"\u2AAC","smtes":"\u2AAC\uFE00","softcy":"\u044C","sol":"/","solb":"\u29C4","solbar":"\u233F","sopf":"\uD835\uDD64","spades":"\u2660","spadesuit":"\u2660","spar":"\u2225","sqcap":"\u2293","sqcaps":"\u2293\uFE00","sqcup":"\u2294","sqcups":"\u2294\uFE00","sqsub":"\u228F","sqsube":"\u2291","sqsubset":"\u228F","sqsubseteq":"\u2291","sqsup":"\u2290","sqsupe":"\u2292","sqsupset":"\u2290","sqsupseteq":"\u2292","squ":"\u25A1","square":"\u25A1","squarf":"\u25AA","squf":"\u25AA","srarr":"\u2192","sscr":"\uD835\uDCC8","ssetmn":"\u2216","ssmile":"\u2323","sstarf":"\u22C6","star":"\u2606","starf":"\u2605","straightepsilon":"\u03F5","straightphi":"\u03D5","strns":"\xaf","sub":"\u2282","subE":"\u2AC5","subdot":"\u2ABD","sube":"\u2286","subedot":"\u2AC3","submult":"\u2AC1","subnE":"\u2ACB","subne":"\u228A","subplus":"\u2ABF","subrarr":"\u2979","subset":"\u2282","subseteq":"\u2286","subseteqq":"\u2AC5","subsetneq":"\u228A","subsetneqq":"\u2ACB","subsim":"\u2AC7","subsub":"\u2AD5","subsup":"\u2AD3","succ":"\u227B","succapprox":"\u2AB8","succcurlyeq":"\u227D","succeq":"\u2AB0","succnapprox":"\u2ABA","succneqq":"\u2AB6","succnsim":"\u22E9","succsim":"\u227F","sum":"\u2211","sung":"\u266A","sup":"\u2283","sup1":"\xb9","sup2":"\xb2","sup3":"\xb3","supE":"\u2AC6","supdot":"\u2ABE","supdsub":"\u2AD8","supe":"\u2287","supedot":"\u2AC4","suphsol":"\u27C9","suphsub":"\u2AD7","suplarr":"\u297B","supmult":"\u2AC2","supnE":"\u2ACC","supne":"\u228B","supplus":"\u2AC0","supset":"\u2283","supseteq":"\u2287","supseteqq":"\u2AC6","supsetneq":"\u228B","supsetneqq":"\u2ACC","supsim":"\u2AC8","supsub":"\u2AD4","supsup":"\u2AD6","swArr":"\u21D9","swarhk":"\u2926","swarr":"\u2199","swarrow":"\u2199","swnwar":"\u292A","szli":"\xdf","szlig":"\xdf","target":"\u2316","tau":"\u03C4","tbrk":"\u23B4","tcaron":"\u0165","tcedil":"\u0163","tcy":"\u0442","tdot":"\u20DB","telrec":"\u2315","tfr":"\uD835\uDD31","there4":"\u2234","therefore":"\u2234","theta":"\u03B8","thetasym":"\u03D1","thetav":"\u03D1","thickapprox":"\u2248","thicksim":"\u223C","thinsp":"\u2009","thkap":"\u2248","thksim":"\u223C","thor":"\xfe","thorn":"\xfe","tilde":"\u02DC","time":"\xd7","times":"\xd7","timesb":"\u22A0","timesbar":"\u2A31","timesd":"\u2A30","tint":"\u222D","toea":"\u2928","top":"\u22A4","topbot":"\u2336","topcir":"\u2AF1","topf":"\uD835\uDD65","topfork":"\u2ADA","tosa":"\u2929","tprime":"\u2034","trade":"\u2122","triangle":"\u25B5","triangledown":"\u25BF","triangleleft":"\u25C3","trianglelefteq":"\u22B4","triangleq":"\u225C","triangleright":"\u25B9","trianglerighteq":"\u22B5","tridot":"\u25EC","trie":"\u225C","triminus":"\u2A3A","triplus":"\u2A39","trisb":"\u29CD","tritime":"\u2A3B","trpezium":"\u23E2","tscr":"\uD835\uDCC9","tscy":"\u0446","tshcy":"\u045B","tstrok":"\u0167","twixt":"\u226C","twoheadleftarrow":"\u219E","twoheadrightarrow":"\u21A0","uArr":"\u21D1","uHar":"\u2963","uacut":"\xfa","uacute":"\xfa","uarr":"\u2191","ubrcy":"\u045E","ubreve":"\u016D","ucir":"\xfb","ucirc":"\xfb","ucy":"\u0443","udarr":"\u21C5","udblac":"\u0171","udhar":"\u296E","ufisht":"\u297E","ufr":"\uD835\uDD32","ugrav":"\xf9","ugrave":"\xf9","uharl":"\u21BF","uharr":"\u21BE","uhblk":"\u2580","ulcorn":"\u231C","ulcorner":"\u231C","ulcrop":"\u230F","ultri":"\u25F8","umacr":"\u016B","um":"\xa8","uml":"\xa8","uogon":"\u0173","uopf":"\uD835\uDD66","uparrow":"\u2191","updownarrow":"\u2195","upharpoonleft":"\u21BF","upharpoonright":"\u21BE","uplus":"\u228E","upsi":"\u03C5","upsih":"\u03D2","upsilon":"\u03C5","upuparrows":"\u21C8","urcorn":"\u231D","urcorner":"\u231D","urcrop":"\u230E","uring":"\u016F","urtri":"\u25F9","uscr":"\uD835\uDCCA","utdot":"\u22F0","utilde":"\u0169","utri":"\u25B5","utrif":"\u25B4","uuarr":"\u21C8","uum":"\xfc","uuml":"\xfc","uwangle":"\u29A7","vArr":"\u21D5","vBar":"\u2AE8","vBarv":"\u2AE9","vDash":"\u22A8","vangrt":"\u299C","varepsilon":"\u03F5","varkappa":"\u03F0","varnothing":"\u2205","varphi":"\u03D5","varpi":"\u03D6","varpropto":"\u221D","varr":"\u2195","varrho":"\u03F1","varsigma":"\u03C2","varsubsetneq":"\u228A\uFE00","varsubsetneqq":"\u2ACB\uFE00","varsupsetneq":"\u228B\uFE00","varsupsetneqq":"\u2ACC\uFE00","vartheta":"\u03D1","vartriangleleft":"\u22B2","vartriangleright":"\u22B3","vcy":"\u0432","vdash":"\u22A2","vee":"\u2228","veebar":"\u22BB","veeeq":"\u225A","vellip":"\u22EE","verbar":"|","vert":"|","vfr":"\uD835\uDD33","vltri":"\u22B2","vnsub":"\u2282\u20D2","vnsup":"\u2283\u20D2","vopf":"\uD835\uDD67","vprop":"\u221D","vrtri":"\u22B3","vscr":"\uD835\uDCCB","vsubnE":"\u2ACB\uFE00","vsubne":"\u228A\uFE00","vsupnE":"\u2ACC\uFE00","vsupne":"\u228B\uFE00","vzigzag":"\u299A","wcirc":"\u0175","wedbar":"\u2A5F","wedge":"\u2227","wedgeq":"\u2259","weierp":"\u2118","wfr":"\uD835\uDD34","wopf":"\uD835\uDD68","wp":"\u2118","wr":"\u2240","wreath":"\u2240","wscr":"\uD835\uDCCC","xcap":"\u22C2","xcirc":"\u25EF","xcup":"\u22C3","xdtri":"\u25BD","xfr":"\uD835\uDD35","xhArr":"\u27FA","xharr":"\u27F7","xi":"\u03BE","xlArr":"\u27F8","xlarr":"\u27F5","xmap":"\u27FC","xnis":"\u22FB","xodot":"\u2A00","xopf":"\uD835\uDD69","xoplus":"\u2A01","xotime":"\u2A02","xrArr":"\u27F9","xrarr":"\u27F6","xscr":"\uD835\uDCCD","xsqcup":"\u2A06","xuplus":"\u2A04","xutri":"\u25B3","xvee":"\u22C1","xwedge":"\u22C0","yacut":"\xfd","yacute":"\xfd","yacy":"\u044F","ycirc":"\u0177","ycy":"\u044B","ye":"\xa5","yen":"\xa5","yfr":"\uD835\uDD36","yicy":"\u0457","yopf":"\uD835\uDD6A","yscr":"\uD835\uDCCE","yucy":"\u044E","yum":"\xff","yuml":"\xff","zacute":"\u017A","zcaron":"\u017E","zcy":"\u0437","zdot":"\u017C","zeetrf":"\u2128","zeta":"\u03B6","zfr":"\uD835\uDD37","zhcy":"\u0436","zigrarr":"\u21DD","zopf":"\uD835\uDD6B","zscr":"\uD835\uDCCF","zwj":"\u200D","zwnj":"\u200C"}');

});



parcelRegister("dTMCj", function(module, exports) {
"use strict";
module.exports = $a1e61fb6930004b1$var$locate;
function $a1e61fb6930004b1$var$locate(value, fromIndex) {
    return value.indexOf("<", fromIndex);
}

});


parcelRegister("7qwWb", function(module, exports) {
"use strict";

var $avME4 = parcelRequire("avME4");

var $gYcXs = parcelRequire("gYcXs");

var $ffwtM = parcelRequire("ffwtM");

var $9DWb3 = parcelRequire("9DWb3");

var $7YJTx = parcelRequire("7YJTx");

var $8FcUN = parcelRequire("8FcUN");
module.exports = $568482d02ffd3cba$var$url;
$568482d02ffd3cba$var$url.locator = $8FcUN;
$568482d02ffd3cba$var$url.notInLink = true;
var $568482d02ffd3cba$var$exclamationMark = 33 // '!'
;
var $568482d02ffd3cba$var$ampersand = 38 // '&'
;
var $568482d02ffd3cba$var$rightParenthesis = 41 // ')'
;
var $568482d02ffd3cba$var$asterisk = 42 // '*'
;
var $568482d02ffd3cba$var$comma = 44 // ','
;
var $568482d02ffd3cba$var$dash = 45 // '-'
;
var $568482d02ffd3cba$var$dot = 46 // '.'
;
var $568482d02ffd3cba$var$colon = 58 // ':'
;
var $568482d02ffd3cba$var$semicolon = 59 // ';'
;
var $568482d02ffd3cba$var$questionMark = 63 // '?'
;
var $568482d02ffd3cba$var$lessThan = 60 // '<'
;
var $568482d02ffd3cba$var$underscore = 95 // '_'
;
var $568482d02ffd3cba$var$tilde = 126 // '~'
;
var $568482d02ffd3cba$var$leftParenthesisCharacter = "(";
var $568482d02ffd3cba$var$rightParenthesisCharacter = ")";
function $568482d02ffd3cba$var$url(eat, value, silent) {
    var self = this;
    var gfm = self.options.gfm;
    var tokenizers = self.inlineTokenizers;
    var length = value.length;
    var previousDot = -1;
    var protocolless = false;
    var dots;
    var lastTwoPartsStart;
    var start;
    var index;
    var pathStart;
    var path;
    var code;
    var end;
    var leftCount;
    var rightCount;
    var content;
    var children;
    var url;
    var exit;
    if (!gfm) return;
    // `WWW.` doesn’t work.
    if (value.slice(0, 4) === "www.") {
        protocolless = true;
        index = 4;
    } else if (value.slice(0, 7).toLowerCase() === "http://") index = 7;
    else if (value.slice(0, 8).toLowerCase() === "https://") index = 8;
    else return;
    // Act as if the starting boundary is a dot.
    previousDot = index - 1;
    // Parse a valid domain.
    start = index;
    dots = [];
    while(index < length){
        code = value.charCodeAt(index);
        if (code === $568482d02ffd3cba$var$dot) {
            // Dots may not appear after each other.
            if (previousDot === index - 1) break;
            dots.push(index);
            previousDot = index;
            index++;
            continue;
        }
        if ($ffwtM(code) || $9DWb3(code) || code === $568482d02ffd3cba$var$dash || code === $568482d02ffd3cba$var$underscore) {
            index++;
            continue;
        }
        break;
    }
    // Ignore a final dot:
    if (code === $568482d02ffd3cba$var$dot) {
        dots.pop();
        index--;
    }
    // If there are not dots, exit.
    if (dots[0] === undefined) return;
    // If there is an underscore in the last two domain parts, exit:
    // `www.example.c_m` and `www.ex_ample.com` are not OK, but
    // `www.sub_domain.example.com` is.
    lastTwoPartsStart = dots.length < 2 ? start : dots[dots.length - 2] + 1;
    if (value.slice(lastTwoPartsStart, index).indexOf("_") !== -1) return;
    /* istanbul ignore if - never used (yet) */ if (silent) return true;
    end = index;
    pathStart = index;
    // Parse a path.
    while(index < length){
        code = value.charCodeAt(index);
        if ($7YJTx(code) || code === $568482d02ffd3cba$var$lessThan) break;
        index++;
        if (code === $568482d02ffd3cba$var$exclamationMark || code === $568482d02ffd3cba$var$asterisk || code === $568482d02ffd3cba$var$comma || code === $568482d02ffd3cba$var$dot || code === $568482d02ffd3cba$var$colon || code === $568482d02ffd3cba$var$questionMark || code === $568482d02ffd3cba$var$underscore || code === $568482d02ffd3cba$var$tilde) ;
        else end = index;
    }
    index = end;
    // If the path ends in a closing paren, and the count of closing parens is
    // higher than the opening count, then remove the supefluous closing parens.
    if (value.charCodeAt(index - 1) === $568482d02ffd3cba$var$rightParenthesis) {
        path = value.slice(pathStart, index);
        leftCount = $avME4(path, $568482d02ffd3cba$var$leftParenthesisCharacter);
        rightCount = $avME4(path, $568482d02ffd3cba$var$rightParenthesisCharacter);
        while(rightCount > leftCount){
            index = pathStart + path.lastIndexOf($568482d02ffd3cba$var$rightParenthesisCharacter);
            path = value.slice(pathStart, index);
            rightCount--;
        }
    }
    if (value.charCodeAt(index - 1) === $568482d02ffd3cba$var$semicolon) {
        // GitHub doesn’t document this, but final semicolons aren’t paret of the
        // URL either.
        index--;
        // // If the path ends in what looks like an entity, it’s not part of the path.
        if ($9DWb3(value.charCodeAt(index - 1))) {
            end = index - 2;
            while($9DWb3(value.charCodeAt(end)))end--;
            if (value.charCodeAt(end) === $568482d02ffd3cba$var$ampersand) index = end;
        }
    }
    content = value.slice(0, index);
    url = $gYcXs(content, {
        nonTerminated: false
    });
    if (protocolless) url = "http://" + url;
    exit = self.enterLink();
    // Temporarily remove all tokenizers except text in url.
    self.inlineTokenizers = {
        text: tokenizers.text
    };
    children = self.tokenizeInline(content, eat.now());
    self.inlineTokenizers = tokenizers;
    exit();
    return eat(content)({
        type: "link",
        title: null,
        url: url,
        children: children
    });
}

});
parcelRegister("avME4", function(module, exports) {
"use strict";
module.exports = $7a728898ce9e9005$var$ccount;
function $7a728898ce9e9005$var$ccount(source, character) {
    var value = String(source);
    var count = 0;
    var index;
    if (typeof character !== "string") throw new Error("Expected character");
    index = value.indexOf(character);
    while(index !== -1){
        count++;
        index = value.indexOf(character, index + character.length);
    }
    return count;
}

});

parcelRegister("8FcUN", function(module, exports) {
"use strict";
module.exports = $64ec2bb48b5d30e8$var$locate;
var $64ec2bb48b5d30e8$var$values = [
    "www.",
    "http://",
    "https://"
];
function $64ec2bb48b5d30e8$var$locate(value, fromIndex) {
    var min = -1;
    var index;
    var length;
    var position;
    if (!this.options.gfm) return min;
    length = $64ec2bb48b5d30e8$var$values.length;
    index = -1;
    while(++index < length){
        position = value.indexOf($64ec2bb48b5d30e8$var$values[index], fromIndex);
        if (position !== -1 && (min === -1 || position < min)) min = position;
    }
    return min;
}

});


parcelRegister("4DPeL", function(module, exports) {
"use strict";

var $gYcXs = parcelRequire("gYcXs");

var $ffwtM = parcelRequire("ffwtM");

var $9DWb3 = parcelRequire("9DWb3");

var $dmQVz = parcelRequire("dmQVz");
module.exports = $36128c8c4dd69e76$var$email;
$36128c8c4dd69e76$var$email.locator = $dmQVz;
$36128c8c4dd69e76$var$email.notInLink = true;
var $36128c8c4dd69e76$var$plusSign = 43 // '+'
;
var $36128c8c4dd69e76$var$dash = 45 // '-'
;
var $36128c8c4dd69e76$var$dot = 46 // '.'
;
var $36128c8c4dd69e76$var$atSign = 64 // '@'
;
var $36128c8c4dd69e76$var$underscore = 95 // '_'
;
function $36128c8c4dd69e76$var$email(eat, value, silent) {
    var self = this;
    var gfm = self.options.gfm;
    var tokenizers = self.inlineTokenizers;
    var index = 0;
    var length = value.length;
    var firstDot = -1;
    var code;
    var content;
    var children;
    var exit;
    if (!gfm) return;
    code = value.charCodeAt(index);
    while($ffwtM(code) || $9DWb3(code) || code === $36128c8c4dd69e76$var$plusSign || code === $36128c8c4dd69e76$var$dash || code === $36128c8c4dd69e76$var$dot || code === $36128c8c4dd69e76$var$underscore)code = value.charCodeAt(++index);
    if (index === 0) return;
    if (code !== $36128c8c4dd69e76$var$atSign) return;
    index++;
    while(index < length){
        code = value.charCodeAt(index);
        if ($ffwtM(code) || $9DWb3(code) || code === $36128c8c4dd69e76$var$dash || code === $36128c8c4dd69e76$var$dot || code === $36128c8c4dd69e76$var$underscore) {
            index++;
            if (firstDot === -1 && code === $36128c8c4dd69e76$var$dot) firstDot = index;
            continue;
        }
        break;
    }
    if (firstDot === -1 || firstDot === index || code === $36128c8c4dd69e76$var$dash || code === $36128c8c4dd69e76$var$underscore) return;
    if (code === $36128c8c4dd69e76$var$dot) index--;
    content = value.slice(0, index);
    /* istanbul ignore if - never used (yet) */ if (silent) return true;
    exit = self.enterLink();
    // Temporarily remove all tokenizers except text in url.
    self.inlineTokenizers = {
        text: tokenizers.text
    };
    children = self.tokenizeInline(content, eat.now());
    self.inlineTokenizers = tokenizers;
    exit();
    return eat(content)({
        type: "link",
        title: null,
        url: "mailto:" + $gYcXs(content, {
            nonTerminated: false
        }),
        children: children
    });
}

});
parcelRegister("dmQVz", function(module, exports) {
"use strict";

var $ffwtM = parcelRequire("ffwtM");

var $9DWb3 = parcelRequire("9DWb3");
var $9bb662b93cbc4aca$var$plusSign = 43 // '+'
;
var $9bb662b93cbc4aca$var$dash = 45 // '-'
;
var $9bb662b93cbc4aca$var$dot = 46 // '.'
;
var $9bb662b93cbc4aca$var$underscore = 95 // '_'
;
module.exports = $9bb662b93cbc4aca$var$locate;
// See: <https://github.github.com/gfm/#extended-email-autolink>
function $9bb662b93cbc4aca$var$locate(value, fromIndex) {
    var self = this;
    var at;
    var position;
    if (!this.options.gfm) return -1;
    at = value.indexOf("@", fromIndex);
    if (at === -1) return -1;
    position = at;
    if (position === fromIndex || !$9bb662b93cbc4aca$var$isGfmAtext(value.charCodeAt(position - 1))) return $9bb662b93cbc4aca$var$locate.call(self, value, at + 1);
    while(position > fromIndex && $9bb662b93cbc4aca$var$isGfmAtext(value.charCodeAt(position - 1)))position--;
    return position;
}
function $9bb662b93cbc4aca$var$isGfmAtext(code) {
    return $ffwtM(code) || $9DWb3(code) || code === $9bb662b93cbc4aca$var$plusSign || code === $9bb662b93cbc4aca$var$dash || code === $9bb662b93cbc4aca$var$dot || code === $9bb662b93cbc4aca$var$underscore;
}

});


parcelRegister("8MZNG", function(module, exports) {
"use strict";

var $9DWb3 = parcelRequire("9DWb3");

var $dTMCj = parcelRequire("dTMCj");

var $gjHS1 = parcelRequire("gjHS1");
var $6662beb1ae167450$require$tag = $gjHS1.tag;
module.exports = $6662beb1ae167450$var$inlineHTML;
$6662beb1ae167450$var$inlineHTML.locator = $dTMCj;
var $6662beb1ae167450$var$lessThan = "<";
var $6662beb1ae167450$var$questionMark = "?";
var $6662beb1ae167450$var$exclamationMark = "!";
var $6662beb1ae167450$var$slash = "/";
var $6662beb1ae167450$var$htmlLinkOpenExpression = /^<a /i;
var $6662beb1ae167450$var$htmlLinkCloseExpression = /^<\/a>/i;
function $6662beb1ae167450$var$inlineHTML(eat, value, silent) {
    var self = this;
    var length = value.length;
    var character;
    var subvalue;
    if (value.charAt(0) !== $6662beb1ae167450$var$lessThan || length < 3) return;
    character = value.charAt(1);
    if (!$9DWb3(character) && character !== $6662beb1ae167450$var$questionMark && character !== $6662beb1ae167450$var$exclamationMark && character !== $6662beb1ae167450$var$slash) return;
    subvalue = value.match($6662beb1ae167450$require$tag);
    if (!subvalue) return;
    /* istanbul ignore if - not used yet. */ if (silent) return true;
    subvalue = subvalue[0];
    if (!self.inLink && $6662beb1ae167450$var$htmlLinkOpenExpression.test(subvalue)) self.inLink = true;
    else if (self.inLink && $6662beb1ae167450$var$htmlLinkCloseExpression.test(subvalue)) self.inLink = false;
    return eat(subvalue)({
        type: "html",
        value: subvalue
    });
}

});

parcelRegister("qmr7W", function(module, exports) {
"use strict";

var $7YJTx = parcelRequire("7YJTx");

var $avC1o = parcelRequire("avC1o");
module.exports = $04f3d5404927cba6$var$link;
$04f3d5404927cba6$var$link.locator = $avC1o;
var $04f3d5404927cba6$var$lineFeed = "\n";
var $04f3d5404927cba6$var$exclamationMark = "!";
var $04f3d5404927cba6$var$quotationMark = '"';
var $04f3d5404927cba6$var$apostrophe = "'";
var $04f3d5404927cba6$var$leftParenthesis = "(";
var $04f3d5404927cba6$var$rightParenthesis = ")";
var $04f3d5404927cba6$var$lessThan = "<";
var $04f3d5404927cba6$var$greaterThan = ">";
var $04f3d5404927cba6$var$leftSquareBracket = "[";
var $04f3d5404927cba6$var$backslash = "\\";
var $04f3d5404927cba6$var$rightSquareBracket = "]";
var $04f3d5404927cba6$var$graveAccent = "`";
function $04f3d5404927cba6$var$link(eat, value, silent) {
    var self = this;
    var subvalue = "";
    var index = 0;
    var character = value.charAt(0);
    var pedantic = self.options.pedantic;
    var commonmark = self.options.commonmark;
    var gfm = self.options.gfm;
    var closed;
    var count;
    var opening;
    var beforeURL;
    var beforeTitle;
    var subqueue;
    var hasMarker;
    var isImage;
    var content;
    var marker;
    var length;
    var title;
    var depth;
    var queue;
    var url;
    var now;
    var exit;
    var node;
    // Detect whether this is an image.
    if (character === $04f3d5404927cba6$var$exclamationMark) {
        isImage = true;
        subvalue = character;
        character = value.charAt(++index);
    }
    // Eat the opening.
    if (character !== $04f3d5404927cba6$var$leftSquareBracket) return;
    // Exit when this is a link and we’re already inside a link.
    if (!isImage && self.inLink) return;
    subvalue += character;
    queue = "";
    index++;
    // Eat the content.
    length = value.length;
    now = eat.now();
    depth = 0;
    now.column += index;
    now.offset += index;
    while(index < length){
        character = value.charAt(index);
        subqueue = character;
        if (character === $04f3d5404927cba6$var$graveAccent) {
            // Inline-code in link content.
            count = 1;
            while(value.charAt(index + 1) === $04f3d5404927cba6$var$graveAccent){
                subqueue += character;
                index++;
                count++;
            }
            if (!opening) opening = count;
            else if (count >= opening) opening = 0;
        } else if (character === $04f3d5404927cba6$var$backslash) {
            // Allow brackets to be escaped.
            index++;
            subqueue += value.charAt(index);
        } else if ((!opening || gfm) && character === $04f3d5404927cba6$var$leftSquareBracket) // In GFM mode, brackets in code still count.  In all other modes,
        // they don’t.
        depth++;
        else if ((!opening || gfm) && character === $04f3d5404927cba6$var$rightSquareBracket) {
            if (depth) depth--;
            else {
                if (value.charAt(index + 1) !== $04f3d5404927cba6$var$leftParenthesis) return;
                subqueue += $04f3d5404927cba6$var$leftParenthesis;
                closed = true;
                index++;
                break;
            }
        }
        queue += subqueue;
        subqueue = "";
        index++;
    }
    // Eat the content closing.
    if (!closed) return;
    content = queue;
    subvalue += queue + subqueue;
    index++;
    // Eat white-space.
    while(index < length){
        character = value.charAt(index);
        if (!$7YJTx(character)) break;
        subvalue += character;
        index++;
    }
    // Eat the URL.
    character = value.charAt(index);
    queue = "";
    beforeURL = subvalue;
    if (character === $04f3d5404927cba6$var$lessThan) {
        index++;
        beforeURL += $04f3d5404927cba6$var$lessThan;
        while(index < length){
            character = value.charAt(index);
            if (character === $04f3d5404927cba6$var$greaterThan) break;
            if (commonmark && character === $04f3d5404927cba6$var$lineFeed) return;
            queue += character;
            index++;
        }
        if (value.charAt(index) !== $04f3d5404927cba6$var$greaterThan) return;
        subvalue += $04f3d5404927cba6$var$lessThan + queue + $04f3d5404927cba6$var$greaterThan;
        url = queue;
        index++;
    } else {
        character = null;
        subqueue = "";
        while(index < length){
            character = value.charAt(index);
            if (subqueue && (character === $04f3d5404927cba6$var$quotationMark || character === $04f3d5404927cba6$var$apostrophe || commonmark && character === $04f3d5404927cba6$var$leftParenthesis)) break;
            if ($7YJTx(character)) {
                if (!pedantic) break;
                subqueue += character;
            } else {
                if (character === $04f3d5404927cba6$var$leftParenthesis) depth++;
                else if (character === $04f3d5404927cba6$var$rightParenthesis) {
                    if (depth === 0) break;
                    depth--;
                }
                queue += subqueue;
                subqueue = "";
                if (character === $04f3d5404927cba6$var$backslash) {
                    queue += $04f3d5404927cba6$var$backslash;
                    character = value.charAt(++index);
                }
                queue += character;
            }
            index++;
        }
        subvalue += queue;
        url = queue;
        index = subvalue.length;
    }
    // Eat white-space.
    queue = "";
    while(index < length){
        character = value.charAt(index);
        if (!$7YJTx(character)) break;
        queue += character;
        index++;
    }
    character = value.charAt(index);
    subvalue += queue;
    // Eat the title.
    if (queue && (character === $04f3d5404927cba6$var$quotationMark || character === $04f3d5404927cba6$var$apostrophe || commonmark && character === $04f3d5404927cba6$var$leftParenthesis)) {
        index++;
        subvalue += character;
        queue = "";
        marker = character === $04f3d5404927cba6$var$leftParenthesis ? $04f3d5404927cba6$var$rightParenthesis : character;
        beforeTitle = subvalue;
        // In commonmark-mode, things are pretty easy: the marker cannot occur
        // inside the title.  Non-commonmark does, however, support nested
        // delimiters.
        if (commonmark) {
            while(index < length){
                character = value.charAt(index);
                if (character === marker) break;
                if (character === $04f3d5404927cba6$var$backslash) {
                    queue += $04f3d5404927cba6$var$backslash;
                    character = value.charAt(++index);
                }
                index++;
                queue += character;
            }
            character = value.charAt(index);
            if (character !== marker) return;
            title = queue;
            subvalue += queue + character;
            index++;
            while(index < length){
                character = value.charAt(index);
                if (!$7YJTx(character)) break;
                subvalue += character;
                index++;
            }
        } else {
            subqueue = "";
            while(index < length){
                character = value.charAt(index);
                if (character === marker) {
                    if (hasMarker) {
                        queue += marker + subqueue;
                        subqueue = "";
                    }
                    hasMarker = true;
                } else if (!hasMarker) queue += character;
                else if (character === $04f3d5404927cba6$var$rightParenthesis) {
                    subvalue += queue + marker + subqueue;
                    title = queue;
                    break;
                } else if ($7YJTx(character)) subqueue += character;
                else {
                    queue += marker + subqueue + character;
                    subqueue = "";
                    hasMarker = false;
                }
                index++;
            }
        }
    }
    if (value.charAt(index) !== $04f3d5404927cba6$var$rightParenthesis) return;
    /* istanbul ignore if - never used (yet) */ if (silent) return true;
    subvalue += $04f3d5404927cba6$var$rightParenthesis;
    url = self.decode.raw(self.unescape(url), eat(beforeURL).test().end, {
        nonTerminated: false
    });
    if (title) {
        beforeTitle = eat(beforeTitle).test().end;
        title = self.decode.raw(self.unescape(title), beforeTitle);
    }
    node = {
        type: isImage ? "image" : "link",
        title: title || null,
        url: url
    };
    if (isImage) node.alt = self.decode.raw(self.unescape(content), now) || null;
    else {
        exit = self.enterLink();
        node.children = self.tokenizeInline(content, now);
        exit();
    }
    return eat(subvalue)(node);
}

});
parcelRegister("avC1o", function(module, exports) {
"use strict";
module.exports = $7a6a4ae5a95ca976$var$locate;
function $7a6a4ae5a95ca976$var$locate(value, fromIndex) {
    var link = value.indexOf("[", fromIndex);
    var image = value.indexOf("![", fromIndex);
    if (image === -1) return link;
    // Link can never be `-1` if an image is found, so we don’t need to check
    // for that :)
    return link < image ? link : image;
}

});


parcelRegister("4JOvC", function(module, exports) {
"use strict";

var $7YJTx = parcelRequire("7YJTx");

var $avC1o = parcelRequire("avC1o");

var $dHruv = parcelRequire("dHruv");
module.exports = $37328b6dfefe0736$var$reference;
$37328b6dfefe0736$var$reference.locator = $avC1o;
var $37328b6dfefe0736$var$link = "link";
var $37328b6dfefe0736$var$image = "image";
var $37328b6dfefe0736$var$shortcut = "shortcut";
var $37328b6dfefe0736$var$collapsed = "collapsed";
var $37328b6dfefe0736$var$full = "full";
var $37328b6dfefe0736$var$exclamationMark = "!";
var $37328b6dfefe0736$var$leftSquareBracket = "[";
var $37328b6dfefe0736$var$backslash = "\\";
var $37328b6dfefe0736$var$rightSquareBracket = "]";
function $37328b6dfefe0736$var$reference(eat, value, silent) {
    var self = this;
    var commonmark = self.options.commonmark;
    var character = value.charAt(0);
    var index = 0;
    var length = value.length;
    var subvalue = "";
    var intro = "";
    var type = $37328b6dfefe0736$var$link;
    var referenceType = $37328b6dfefe0736$var$shortcut;
    var content;
    var identifier;
    var now;
    var node;
    var exit;
    var queue;
    var bracketed;
    var depth;
    // Check whether we’re eating an image.
    if (character === $37328b6dfefe0736$var$exclamationMark) {
        type = $37328b6dfefe0736$var$image;
        intro = character;
        character = value.charAt(++index);
    }
    if (character !== $37328b6dfefe0736$var$leftSquareBracket) return;
    index++;
    intro += character;
    queue = "";
    // Eat the text.
    depth = 0;
    while(index < length){
        character = value.charAt(index);
        if (character === $37328b6dfefe0736$var$leftSquareBracket) {
            bracketed = true;
            depth++;
        } else if (character === $37328b6dfefe0736$var$rightSquareBracket) {
            if (!depth) break;
            depth--;
        }
        if (character === $37328b6dfefe0736$var$backslash) {
            queue += $37328b6dfefe0736$var$backslash;
            character = value.charAt(++index);
        }
        queue += character;
        index++;
    }
    subvalue = queue;
    content = queue;
    character = value.charAt(index);
    if (character !== $37328b6dfefe0736$var$rightSquareBracket) return;
    index++;
    subvalue += character;
    queue = "";
    if (!commonmark) // The original markdown syntax definition explicitly allows for whitespace
    // between the link text and link label; commonmark departs from this, in
    // part to improve support for shortcut reference links
    while(index < length){
        character = value.charAt(index);
        if (!$7YJTx(character)) break;
        queue += character;
        index++;
    }
    character = value.charAt(index);
    if (character === $37328b6dfefe0736$var$leftSquareBracket) {
        identifier = "";
        queue += character;
        index++;
        while(index < length){
            character = value.charAt(index);
            if (character === $37328b6dfefe0736$var$leftSquareBracket || character === $37328b6dfefe0736$var$rightSquareBracket) break;
            if (character === $37328b6dfefe0736$var$backslash) {
                identifier += $37328b6dfefe0736$var$backslash;
                character = value.charAt(++index);
            }
            identifier += character;
            index++;
        }
        character = value.charAt(index);
        if (character === $37328b6dfefe0736$var$rightSquareBracket) {
            referenceType = identifier ? $37328b6dfefe0736$var$full : $37328b6dfefe0736$var$collapsed;
            queue += identifier + character;
            index++;
        } else identifier = "";
        subvalue += queue;
        queue = "";
    } else {
        if (!content) return;
        identifier = content;
    }
    // Brackets cannot be inside the identifier.
    if (referenceType !== $37328b6dfefe0736$var$full && bracketed) return;
    subvalue = intro + subvalue;
    if (type === $37328b6dfefe0736$var$link && self.inLink) return null;
    /* istanbul ignore if - never used (yet) */ if (silent) return true;
    now = eat.now();
    now.column += intro.length;
    now.offset += intro.length;
    identifier = referenceType === $37328b6dfefe0736$var$full ? identifier : content;
    node = {
        type: type + "Reference",
        identifier: $dHruv(identifier),
        label: identifier,
        referenceType: referenceType
    };
    if (type === $37328b6dfefe0736$var$link) {
        exit = self.enterLink();
        node.children = self.tokenizeInline(content, now);
        exit();
    } else node.alt = self.decode.raw(self.unescape(content), now) || null;
    return eat(subvalue)(node);
}

});

parcelRegister("adw3U", function(module, exports) {
"use strict";

var $yVfl8 = parcelRequire("yVfl8");

var $7YJTx = parcelRequire("7YJTx");

var $fQTS0 = parcelRequire("fQTS0");
module.exports = $7703fd1da73a3a37$var$strong;
$7703fd1da73a3a37$var$strong.locator = $fQTS0;
var $7703fd1da73a3a37$var$backslash = "\\";
var $7703fd1da73a3a37$var$asterisk = "*";
var $7703fd1da73a3a37$var$underscore = "_";
function $7703fd1da73a3a37$var$strong(eat, value, silent) {
    var self = this;
    var index = 0;
    var character = value.charAt(index);
    var now;
    var pedantic;
    var marker;
    var queue;
    var subvalue;
    var length;
    var previous;
    if (character !== $7703fd1da73a3a37$var$asterisk && character !== $7703fd1da73a3a37$var$underscore || value.charAt(++index) !== character) return;
    pedantic = self.options.pedantic;
    marker = character;
    subvalue = marker + marker;
    length = value.length;
    index++;
    queue = "";
    character = "";
    if (pedantic && $7YJTx(value.charAt(index))) return;
    while(index < length){
        previous = character;
        character = value.charAt(index);
        if (character === marker && value.charAt(index + 1) === marker && (!pedantic || !$7YJTx(previous))) {
            character = value.charAt(index + 2);
            if (character !== marker) {
                if (!$yVfl8(queue)) return;
                /* istanbul ignore if - never used (yet) */ if (silent) return true;
                now = eat.now();
                now.column += 2;
                now.offset += 2;
                return eat(subvalue + queue + subvalue)({
                    type: "strong",
                    children: self.tokenizeInline(queue, now)
                });
            }
        }
        if (!pedantic && character === $7703fd1da73a3a37$var$backslash) {
            queue += character;
            character = value.charAt(++index);
        }
        queue += character;
        index++;
    }
}

});
parcelRegister("fQTS0", function(module, exports) {
"use strict";
module.exports = $b8a70cfe4fd08c4f$var$locate;
function $b8a70cfe4fd08c4f$var$locate(value, fromIndex) {
    var asterisk = value.indexOf("**", fromIndex);
    var underscore = value.indexOf("__", fromIndex);
    if (underscore === -1) return asterisk;
    if (asterisk === -1) return underscore;
    return underscore < asterisk ? underscore : asterisk;
}

});


parcelRegister("9Y0N7", function(module, exports) {
"use strict";

var $yVfl8 = parcelRequire("yVfl8");

var $HeNv4 = parcelRequire("HeNv4");

var $7YJTx = parcelRequire("7YJTx");

var $A4IKd = parcelRequire("A4IKd");
module.exports = $741a54c5b9d1c204$var$emphasis;
$741a54c5b9d1c204$var$emphasis.locator = $A4IKd;
var $741a54c5b9d1c204$var$asterisk = "*";
var $741a54c5b9d1c204$var$underscore = "_";
var $741a54c5b9d1c204$var$backslash = "\\";
function $741a54c5b9d1c204$var$emphasis(eat, value, silent) {
    var self = this;
    var index = 0;
    var character = value.charAt(index);
    var now;
    var pedantic;
    var marker;
    var queue;
    var subvalue;
    var length;
    var previous;
    if (character !== $741a54c5b9d1c204$var$asterisk && character !== $741a54c5b9d1c204$var$underscore) return;
    pedantic = self.options.pedantic;
    subvalue = character;
    marker = character;
    length = value.length;
    index++;
    queue = "";
    character = "";
    if (pedantic && $7YJTx(value.charAt(index))) return;
    while(index < length){
        previous = character;
        character = value.charAt(index);
        if (character === marker && (!pedantic || !$7YJTx(previous))) {
            character = value.charAt(++index);
            if (character !== marker) {
                if (!$yVfl8(queue) || previous === marker) return;
                if (!pedantic && marker === $741a54c5b9d1c204$var$underscore && $HeNv4(character)) {
                    queue += marker;
                    continue;
                }
                /* istanbul ignore if - never used (yet) */ if (silent) return true;
                now = eat.now();
                now.column++;
                now.offset++;
                return eat(subvalue + queue + marker)({
                    type: "emphasis",
                    children: self.tokenizeInline(queue, now)
                });
            }
            queue += marker;
        }
        if (!pedantic && character === $741a54c5b9d1c204$var$backslash) {
            queue += character;
            character = value.charAt(++index);
        }
        queue += character;
        index++;
    }
}

});
parcelRegister("HeNv4", function(module, exports) {
"use strict";
module.exports = $081f7eb8794cc728$var$wordCharacter;
var $081f7eb8794cc728$var$fromCode = String.fromCharCode;
var $081f7eb8794cc728$var$re = /\w/;
// Check if the given character code, or the character code at the first
// character, is a word character.
function $081f7eb8794cc728$var$wordCharacter(character) {
    return $081f7eb8794cc728$var$re.test(typeof character === "number" ? $081f7eb8794cc728$var$fromCode(character) : character.charAt(0));
}

});

parcelRegister("A4IKd", function(module, exports) {
"use strict";
module.exports = $06c7065632c8cbef$var$locate;
function $06c7065632c8cbef$var$locate(value, fromIndex) {
    var asterisk = value.indexOf("*", fromIndex);
    var underscore = value.indexOf("_", fromIndex);
    if (underscore === -1) return asterisk;
    if (asterisk === -1) return underscore;
    return underscore < asterisk ? underscore : asterisk;
}

});


parcelRegister("9OC3l", function(module, exports) {
"use strict";

var $7YJTx = parcelRequire("7YJTx");

var $jI3p5 = parcelRequire("jI3p5");
module.exports = $72564d116b9bcd3f$var$strikethrough;
$72564d116b9bcd3f$var$strikethrough.locator = $jI3p5;
var $72564d116b9bcd3f$var$tilde = "~";
var $72564d116b9bcd3f$var$fence = "~~";
function $72564d116b9bcd3f$var$strikethrough(eat, value, silent) {
    var self = this;
    var character = "";
    var previous = "";
    var preceding = "";
    var subvalue = "";
    var index;
    var length;
    var now;
    if (!self.options.gfm || value.charAt(0) !== $72564d116b9bcd3f$var$tilde || value.charAt(1) !== $72564d116b9bcd3f$var$tilde || $7YJTx(value.charAt(2))) return;
    index = 1;
    length = value.length;
    now = eat.now();
    now.column += 2;
    now.offset += 2;
    while(++index < length){
        character = value.charAt(index);
        if (character === $72564d116b9bcd3f$var$tilde && previous === $72564d116b9bcd3f$var$tilde && (!preceding || !$7YJTx(preceding))) {
            /* istanbul ignore if - never used (yet) */ if (silent) return true;
            return eat($72564d116b9bcd3f$var$fence + subvalue + $72564d116b9bcd3f$var$fence)({
                type: "delete",
                children: self.tokenizeInline(subvalue, now)
            });
        }
        subvalue += previous;
        preceding = previous;
        previous = character;
    }
}

});
parcelRegister("jI3p5", function(module, exports) {
"use strict";
module.exports = $e594c4416ee1bc58$var$locate;
function $e594c4416ee1bc58$var$locate(value, fromIndex) {
    return value.indexOf("~~", fromIndex);
}

});


parcelRegister("4vCYF", function(module, exports) {
"use strict";

var $7RAoo = parcelRequire("7RAoo");
module.exports = $34884acfc491dbef$var$inlineCode;
$34884acfc491dbef$var$inlineCode.locator = $7RAoo;
var $34884acfc491dbef$var$lineFeed = 10 //  '\n'
;
var $34884acfc491dbef$var$space = 32 // ' '
;
var $34884acfc491dbef$var$graveAccent = 96 //  '`'
;
function $34884acfc491dbef$var$inlineCode(eat, value, silent) {
    var length = value.length;
    var index = 0;
    var openingFenceEnd;
    var closingFenceStart;
    var closingFenceEnd;
    var code;
    var next;
    var found;
    while(index < length){
        if (value.charCodeAt(index) !== $34884acfc491dbef$var$graveAccent) break;
        index++;
    }
    if (index === 0 || index === length) return;
    openingFenceEnd = index;
    next = value.charCodeAt(index);
    while(index < length){
        code = next;
        next = value.charCodeAt(index + 1);
        if (code === $34884acfc491dbef$var$graveAccent) {
            if (closingFenceStart === undefined) closingFenceStart = index;
            closingFenceEnd = index + 1;
            if (next !== $34884acfc491dbef$var$graveAccent && closingFenceEnd - closingFenceStart === openingFenceEnd) {
                found = true;
                break;
            }
        } else if (closingFenceStart !== undefined) {
            closingFenceStart = undefined;
            closingFenceEnd = undefined;
        }
        index++;
    }
    if (!found) return;
    /* istanbul ignore if - never used (yet) */ if (silent) return true;
    // Remove the initial and final space (or line feed), iff they exist and there
    // are non-space characters in the content.
    index = openingFenceEnd;
    length = closingFenceStart;
    code = value.charCodeAt(index);
    next = value.charCodeAt(length - 1);
    found = false;
    if (length - index > 2 && (code === $34884acfc491dbef$var$space || code === $34884acfc491dbef$var$lineFeed) && (next === $34884acfc491dbef$var$space || next === $34884acfc491dbef$var$lineFeed)) {
        index++;
        length--;
        while(index < length){
            code = value.charCodeAt(index);
            if (code !== $34884acfc491dbef$var$space && code !== $34884acfc491dbef$var$lineFeed) {
                found = true;
                break;
            }
            index++;
        }
        if (found === true) {
            openingFenceEnd++;
            closingFenceStart--;
        }
    }
    return eat(value.slice(0, closingFenceEnd))({
        type: "inlineCode",
        value: value.slice(openingFenceEnd, closingFenceStart)
    });
}

});
parcelRegister("7RAoo", function(module, exports) {
"use strict";
module.exports = $5b99b66600548b4d$var$locate;
function $5b99b66600548b4d$var$locate(value, fromIndex) {
    return value.indexOf("`", fromIndex);
}

});


parcelRegister("1ZgN2", function(module, exports) {
"use strict";

var $gbPb1 = parcelRequire("gbPb1");
module.exports = $1728831251eb6d8a$var$hardBreak;
$1728831251eb6d8a$var$hardBreak.locator = $gbPb1;
var $1728831251eb6d8a$var$space = " ";
var $1728831251eb6d8a$var$lineFeed = "\n";
var $1728831251eb6d8a$var$minBreakLength = 2;
function $1728831251eb6d8a$var$hardBreak(eat, value, silent) {
    var length = value.length;
    var index = -1;
    var queue = "";
    var character;
    while(++index < length){
        character = value.charAt(index);
        if (character === $1728831251eb6d8a$var$lineFeed) {
            if (index < $1728831251eb6d8a$var$minBreakLength) return;
            /* istanbul ignore if - never used (yet) */ if (silent) return true;
            queue += character;
            return eat(queue)({
                type: "break"
            });
        }
        if (character !== $1728831251eb6d8a$var$space) return;
        queue += character;
    }
}

});
parcelRegister("gbPb1", function(module, exports) {
"use strict";
module.exports = $bc955f0cd1bb4b84$var$locate;
function $bc955f0cd1bb4b84$var$locate(value, fromIndex) {
    var index = value.indexOf("\n", fromIndex);
    while(index > fromIndex){
        if (value.charAt(index - 1) !== " ") break;
        index--;
    }
    return index;
}

});


parcelRegister("2VPr6", function(module, exports) {
"use strict";
module.exports = $2228cdc852205d8d$var$text;
function $2228cdc852205d8d$var$text(eat, value, silent) {
    var self = this;
    var methods;
    var tokenizers;
    var index;
    var length;
    var subvalue;
    var position;
    var tokenizer;
    var name;
    var min;
    var now;
    /* istanbul ignore if - never used (yet) */ if (silent) return true;
    methods = self.inlineMethods;
    length = methods.length;
    tokenizers = self.inlineTokenizers;
    index = -1;
    min = value.length;
    while(++index < length){
        name = methods[index];
        if (name === "text" || !tokenizers[name]) continue;
        tokenizer = tokenizers[name].locator;
        if (!tokenizer) eat.file.fail("Missing locator: `" + name + "`");
        position = tokenizer.call(self, value, 1);
        if (position !== -1 && position < min) min = position;
    }
    subvalue = value.slice(0, min);
    now = eat.now();
    self.decode(subvalue, now, handler);
    function handler(content, position, source) {
        eat(source || content)({
            type: "text",
            value: content
        });
    }
}

});

parcelRegister("i09cj", function(module, exports) {

var $dn7tT = parcelRequire("dn7tT");

var $gJ8VZ = parcelRequire("gJ8VZ");
var $0695aac111eb07b6$require$containsFrontmatter = $gJ8VZ.containsFrontmatter;
/**
 * @param {string} content File Content
 * @returns {any}
 */ const $0695aac111eb07b6$var$parseFrontmatter = (content)=>{
    // Run against regex
    const frontmatter = $0695aac111eb07b6$require$containsFrontmatter(content);
    if (frontmatter) return $dn7tT.parse(frontmatter) ?? {};
    // No match for frontmatter
    return undefined;
};
module.exports = {
    parseFrontmatter: $0695aac111eb07b6$var$parseFrontmatter
};

});
parcelRegister("dn7tT", function(module, exports) {

$parcel$export(module.exports, "parse", () => $9bc339f81b21e6d0$export$98e6a39c04603d36, (v) => $9bc339f81b21e6d0$export$98e6a39c04603d36 = v);
var $9bc339f81b21e6d0$export$57ed0bcea28f97a2;
var $9bc339f81b21e6d0$export$b34a105447964f9f;
var $9bc339f81b21e6d0$export$19342e026b58ebb7;
var $9bc339f81b21e6d0$export$699cd54d617b337f;
var $9bc339f81b21e6d0$export$c1188aaa49090a5c;
var $9bc339f81b21e6d0$export$856b463bac79f971;
var $9bc339f81b21e6d0$export$17b520249a85fe16;
var $9bc339f81b21e6d0$export$c6275352883a2b3e;
var $9bc339f81b21e6d0$export$cea7aa84e978eba5;
var $9bc339f81b21e6d0$export$62858bae88b53fd0;
var $9bc339f81b21e6d0$export$5c90113a285f2241;
var $9bc339f81b21e6d0$export$8ee0fc9ee280b4ee;
var $9bc339f81b21e6d0$export$7c8d445944656308;
var $9bc339f81b21e6d0$export$8f3495e22775e76c;
var $9bc339f81b21e6d0$export$342ac1d101ffe14b;
var $9bc339f81b21e6d0$export$d63d7cff08fe4dc9;
var $9bc339f81b21e6d0$export$595dbf49c602a1f;
var $9bc339f81b21e6d0$export$eb1691c4b19bb5eb;
var $9bc339f81b21e6d0$export$47adc25f769055b2;
var $9bc339f81b21e6d0$export$dd3c50b1c80c78ef;
var $9bc339f81b21e6d0$export$6168dc8908a6c652;
var $9bc339f81b21e6d0$export$c8a6f24ae2865e59;
var $9bc339f81b21e6d0$export$7acfa6ed01010e37;
var $9bc339f81b21e6d0$export$98e6a39c04603d36;
var $9bc339f81b21e6d0$export$643da2570c3b3d01;
var $9bc339f81b21e6d0$export$b6a9369736b19f4d;
var $9bc339f81b21e6d0$export$fac44ee5b035f737;
var $9bc339f81b21e6d0$export$bf638b60ea8b89b7;
var $9bc339f81b21e6d0$export$3c4f5d970a5e6a3b;
"use strict";

var $e6LZ8 = parcelRequire("e6LZ8");

var $hfBM7 = parcelRequire("hfBM7");

var $9Z3DY = parcelRequire("9Z3DY");

var $9DvMJ = parcelRequire("9DvMJ");

var $jOHGy = parcelRequire("jOHGy");

var $FOECb = parcelRequire("FOECb");

var $5ff4n = parcelRequire("5ff4n");

var $d6XNP = parcelRequire("d6XNP");

var $649pE = parcelRequire("649pE");

var $hOWPS = parcelRequire("hOWPS");

var $cJNRU = parcelRequire("cJNRU");

var $dHsHc = parcelRequire("dHsHc");

var $4Fp6h = parcelRequire("4Fp6h");

var $ltR1M = parcelRequire("ltR1M");

var $bVh0N = parcelRequire("bVh0N");

var $jkImy = parcelRequire("jkImy");
$9bc339f81b21e6d0$export$57ed0bcea28f97a2 = $e6LZ8.Composer;
$9bc339f81b21e6d0$export$b34a105447964f9f = $hfBM7.Document;
$9bc339f81b21e6d0$export$19342e026b58ebb7 = $9Z3DY.Schema;
$9bc339f81b21e6d0$export$699cd54d617b337f = $9DvMJ.YAMLError;
$9bc339f81b21e6d0$export$c1188aaa49090a5c = $9DvMJ.YAMLParseError;
$9bc339f81b21e6d0$export$856b463bac79f971 = $9DvMJ.YAMLWarning;
$9bc339f81b21e6d0$export$17b520249a85fe16 = $jOHGy.Alias;
$9bc339f81b21e6d0$export$c6275352883a2b3e = $FOECb.isAlias;
$9bc339f81b21e6d0$export$cea7aa84e978eba5 = $FOECb.isCollection;
$9bc339f81b21e6d0$export$62858bae88b53fd0 = $FOECb.isDocument;
$9bc339f81b21e6d0$export$5c90113a285f2241 = $FOECb.isMap;
$9bc339f81b21e6d0$export$8ee0fc9ee280b4ee = $FOECb.isNode;
$9bc339f81b21e6d0$export$7c8d445944656308 = $FOECb.isPair;
$9bc339f81b21e6d0$export$8f3495e22775e76c = $FOECb.isScalar;
$9bc339f81b21e6d0$export$342ac1d101ffe14b = $FOECb.isSeq;
$9bc339f81b21e6d0$export$d63d7cff08fe4dc9 = $5ff4n.Pair;
$9bc339f81b21e6d0$export$595dbf49c602a1f = $d6XNP.Scalar;
$9bc339f81b21e6d0$export$eb1691c4b19bb5eb = $649pE.YAMLMap;
$9bc339f81b21e6d0$export$47adc25f769055b2 = $hOWPS.YAMLSeq;
$9bc339f81b21e6d0$export$dd3c50b1c80c78ef = $cJNRU;
$9bc339f81b21e6d0$export$6168dc8908a6c652 = $dHsHc.Lexer;
$9bc339f81b21e6d0$export$c8a6f24ae2865e59 = $4Fp6h.LineCounter;
$9bc339f81b21e6d0$export$7acfa6ed01010e37 = $ltR1M.Parser;
$9bc339f81b21e6d0$export$98e6a39c04603d36 = $bVh0N.parse;
$9bc339f81b21e6d0$export$643da2570c3b3d01 = $bVh0N.parseAllDocuments;
$9bc339f81b21e6d0$export$b6a9369736b19f4d = $bVh0N.parseDocument;
$9bc339f81b21e6d0$export$fac44ee5b035f737 = $bVh0N.stringify;
$9bc339f81b21e6d0$export$bf638b60ea8b89b7 = $jkImy.visit;
$9bc339f81b21e6d0$export$3c4f5d970a5e6a3b = $jkImy.visitAsync;

});
parcelRegister("e6LZ8", function(module, exports) {

$parcel$export(module.exports, "Composer", () => $a456d910d2baa5d6$export$57ed0bcea28f97a2, (v) => $a456d910d2baa5d6$export$57ed0bcea28f97a2 = v);
var $a456d910d2baa5d6$export$57ed0bcea28f97a2;
"use strict";

var $jk2hM = parcelRequire("jk2hM");

var $hfBM7 = parcelRequire("hfBM7");

var $9DvMJ = parcelRequire("9DvMJ");

var $FOECb = parcelRequire("FOECb");

var $bF1yA = parcelRequire("bF1yA");

var $9WEdM = parcelRequire("9WEdM");
function $a456d910d2baa5d6$var$getErrorPos(src) {
    if (typeof src === "number") return [
        src,
        src + 1
    ];
    if (Array.isArray(src)) return src.length === 2 ? src : [
        src[0],
        src[1]
    ];
    const { offset: offset, source: source } = src;
    return [
        offset,
        offset + (typeof source === "string" ? source.length : 1)
    ];
}
function $a456d910d2baa5d6$var$parsePrelude(prelude) {
    let comment = "";
    let atComment = false;
    let afterEmptyLine = false;
    for(let i = 0; i < prelude.length; ++i){
        const source = prelude[i];
        switch(source[0]){
            case "#":
                comment += (comment === "" ? "" : afterEmptyLine ? "\n\n" : "\n") + (source.substring(1) || " ");
                atComment = true;
                afterEmptyLine = false;
                break;
            case "%":
                if (prelude[i + 1]?.[0] !== "#") i += 1;
                atComment = false;
                break;
            default:
                // This may be wrong after doc-end, but in that case it doesn't matter
                if (!atComment) afterEmptyLine = true;
                atComment = false;
        }
    }
    return {
        comment: comment,
        afterEmptyLine: afterEmptyLine
    };
}
/**
 * Compose a stream of CST nodes into a stream of YAML Documents.
 *
 * ```ts
 * import { Composer, Parser } from 'yaml'
 *
 * const src: string = ...
 * const tokens = new Parser().parse(src)
 * const docs = new Composer().compose(tokens)
 * ```
 */ class $a456d910d2baa5d6$var$Composer {
    constructor(options = {}){
        this.doc = null;
        this.atDirectives = false;
        this.prelude = [];
        this.errors = [];
        this.warnings = [];
        this.onError = (source, code, message, warning)=>{
            const pos = $a456d910d2baa5d6$var$getErrorPos(source);
            if (warning) this.warnings.push(new $9DvMJ.YAMLWarning(pos, code, message));
            else this.errors.push(new $9DvMJ.YAMLParseError(pos, code, message));
        };
        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
        this.directives = new $jk2hM.Directives({
            version: options.version || "1.2"
        });
        this.options = options;
    }
    decorate(doc, afterDoc) {
        const { comment: comment, afterEmptyLine: afterEmptyLine } = $a456d910d2baa5d6$var$parsePrelude(this.prelude);
        //console.log({ dc: doc.comment, prelude, comment })
        if (comment) {
            const dc = doc.contents;
            if (afterDoc) doc.comment = doc.comment ? `${doc.comment}\n${comment}` : comment;
            else if (afterEmptyLine || doc.directives.docStart || !dc) doc.commentBefore = comment;
            else if ($FOECb.isCollection(dc) && !dc.flow && dc.items.length > 0) {
                let it = dc.items[0];
                if ($FOECb.isPair(it)) it = it.key;
                const cb = it.commentBefore;
                it.commentBefore = cb ? `${comment}\n${cb}` : comment;
            } else {
                const cb = dc.commentBefore;
                dc.commentBefore = cb ? `${comment}\n${cb}` : comment;
            }
        }
        if (afterDoc) {
            Array.prototype.push.apply(doc.errors, this.errors);
            Array.prototype.push.apply(doc.warnings, this.warnings);
        } else {
            doc.errors = this.errors;
            doc.warnings = this.warnings;
        }
        this.prelude = [];
        this.errors = [];
        this.warnings = [];
    }
    /**
     * Current stream status information.
     *
     * Mostly useful at the end of input for an empty stream.
     */ streamInfo() {
        return {
            comment: $a456d910d2baa5d6$var$parsePrelude(this.prelude).comment,
            directives: this.directives,
            errors: this.errors,
            warnings: this.warnings
        };
    }
    /**
     * Compose tokens into documents.
     *
     * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
     * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
     */ *compose(tokens, forceDoc = false, endOffset = -1) {
        for (const token of tokens)yield* this.next(token);
        yield* this.end(forceDoc, endOffset);
    }
    /** Advance the composer by one CST token. */ *next(token) {
        if (process.env.LOG_STREAM) console.dir(token, {
            depth: null
        });
        switch(token.type){
            case "directive":
                this.directives.add(token.source, (offset, message, warning)=>{
                    const pos = $a456d910d2baa5d6$var$getErrorPos(token);
                    pos[0] += offset;
                    this.onError(pos, "BAD_DIRECTIVE", message, warning);
                });
                this.prelude.push(token.source);
                this.atDirectives = true;
                break;
            case "document":
                {
                    const doc = $bF1yA.composeDoc(this.options, this.directives, token, this.onError);
                    if (this.atDirectives && !doc.directives.docStart) this.onError(token, "MISSING_CHAR", "Missing directives-end/doc-start indicator line");
                    this.decorate(doc, false);
                    if (this.doc) yield this.doc;
                    this.doc = doc;
                    this.atDirectives = false;
                    break;
                }
            case "byte-order-mark":
            case "space":
                break;
            case "comment":
            case "newline":
                this.prelude.push(token.source);
                break;
            case "error":
                {
                    const msg = token.source ? `${token.message}: ${JSON.stringify(token.source)}` : token.message;
                    const error = new $9DvMJ.YAMLParseError($a456d910d2baa5d6$var$getErrorPos(token), "UNEXPECTED_TOKEN", msg);
                    if (this.atDirectives || !this.doc) this.errors.push(error);
                    else this.doc.errors.push(error);
                    break;
                }
            case "doc-end":
                {
                    if (!this.doc) {
                        const msg = "Unexpected doc-end without preceding document";
                        this.errors.push(new $9DvMJ.YAMLParseError($a456d910d2baa5d6$var$getErrorPos(token), "UNEXPECTED_TOKEN", msg));
                        break;
                    }
                    this.doc.directives.docEnd = true;
                    const end = $9WEdM.resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);
                    this.decorate(this.doc, true);
                    if (end.comment) {
                        const dc = this.doc.comment;
                        this.doc.comment = dc ? `${dc}\n${end.comment}` : end.comment;
                    }
                    this.doc.range[2] = end.offset;
                    break;
                }
            default:
                this.errors.push(new $9DvMJ.YAMLParseError($a456d910d2baa5d6$var$getErrorPos(token), "UNEXPECTED_TOKEN", `Unsupported token ${token.type}`));
        }
    }
    /**
     * Call at end of input to yield any remaining document.
     *
     * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
     * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
     */ *end(forceDoc = false, endOffset = -1) {
        if (this.doc) {
            this.decorate(this.doc, true);
            yield this.doc;
            this.doc = null;
        } else if (forceDoc) {
            const opts = Object.assign({
                _directives: this.directives
            }, this.options);
            const doc = new $hfBM7.Document(undefined, opts);
            if (this.atDirectives) this.onError(endOffset, "MISSING_CHAR", "Missing directives-end indicator line");
            doc.range = [
                0,
                endOffset,
                endOffset
            ];
            this.decorate(doc, false);
            yield doc;
        }
    }
}
$a456d910d2baa5d6$export$57ed0bcea28f97a2 = $a456d910d2baa5d6$var$Composer;

});
parcelRegister("jk2hM", function(module, exports) {

$parcel$export(module.exports, "Directives", () => $e111a882191a53c0$export$129646a0e1af8d85, (v) => $e111a882191a53c0$export$129646a0e1af8d85 = v);
var $e111a882191a53c0$export$129646a0e1af8d85;
"use strict";

var $FOECb = parcelRequire("FOECb");

var $jkImy = parcelRequire("jkImy");
const $e111a882191a53c0$var$escapeChars = {
    "!": "%21",
    ",": "%2C",
    "[": "%5B",
    "]": "%5D",
    "{": "%7B",
    "}": "%7D"
};
const $e111a882191a53c0$var$escapeTagName = (tn)=>tn.replace(/[!,[\]{}]/g, (ch)=>$e111a882191a53c0$var$escapeChars[ch]);
class $e111a882191a53c0$var$Directives {
    constructor(yaml, tags){
        /**
         * The directives-end/doc-start marker `---`. If `null`, a marker may still be
         * included in the document's stringified representation.
         */ this.docStart = null;
        /** The doc-end marker `...`.  */ this.docEnd = false;
        this.yaml = Object.assign({}, $e111a882191a53c0$var$Directives.defaultYaml, yaml);
        this.tags = Object.assign({}, $e111a882191a53c0$var$Directives.defaultTags, tags);
    }
    clone() {
        const copy = new $e111a882191a53c0$var$Directives(this.yaml, this.tags);
        copy.docStart = this.docStart;
        return copy;
    }
    /**
     * During parsing, get a Directives instance for the current document and
     * update the stream state according to the current version's spec.
     */ atDocument() {
        const res = new $e111a882191a53c0$var$Directives(this.yaml, this.tags);
        switch(this.yaml.version){
            case "1.1":
                this.atNextDocument = true;
                break;
            case "1.2":
                this.atNextDocument = false;
                this.yaml = {
                    explicit: $e111a882191a53c0$var$Directives.defaultYaml.explicit,
                    version: "1.2"
                };
                this.tags = Object.assign({}, $e111a882191a53c0$var$Directives.defaultTags);
                break;
        }
        return res;
    }
    /**
     * @param onError - May be called even if the action was successful
     * @returns `true` on success
     */ add(line, onError) {
        if (this.atNextDocument) {
            this.yaml = {
                explicit: $e111a882191a53c0$var$Directives.defaultYaml.explicit,
                version: "1.1"
            };
            this.tags = Object.assign({}, $e111a882191a53c0$var$Directives.defaultTags);
            this.atNextDocument = false;
        }
        const parts = line.trim().split(/[ \t]+/);
        const name = parts.shift();
        switch(name){
            case "%TAG":
                {
                    if (parts.length !== 2) {
                        onError(0, "%TAG directive should contain exactly two parts");
                        if (parts.length < 2) return false;
                    }
                    const [handle, prefix] = parts;
                    this.tags[handle] = prefix;
                    return true;
                }
            case "%YAML":
                {
                    this.yaml.explicit = true;
                    if (parts.length !== 1) {
                        onError(0, "%YAML directive should contain exactly one part");
                        return false;
                    }
                    const [version] = parts;
                    if (version === "1.1" || version === "1.2") {
                        this.yaml.version = version;
                        return true;
                    } else {
                        const isValid = /^\d+\.\d+$/.test(version);
                        onError(6, `Unsupported YAML version ${version}`, isValid);
                        return false;
                    }
                }
            default:
                onError(0, `Unknown directive ${name}`, true);
                return false;
        }
    }
    /**
     * Resolves a tag, matching handles to those defined in %TAG directives.
     *
     * @returns Resolved tag, which may also be the non-specific tag `'!'` or a
     *   `'!local'` tag, or `null` if unresolvable.
     */ tagName(source, onError) {
        if (source === "!") return "!"; // non-specific tag
        if (source[0] !== "!") {
            onError(`Not a valid tag: ${source}`);
            return null;
        }
        if (source[1] === "<") {
            const verbatim = source.slice(2, -1);
            if (verbatim === "!" || verbatim === "!!") {
                onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);
                return null;
            }
            if (source[source.length - 1] !== ">") onError("Verbatim tags must end with a >");
            return verbatim;
        }
        const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/s);
        if (!suffix) onError(`The ${source} tag has no suffix`);
        const prefix = this.tags[handle];
        if (prefix) try {
            return prefix + decodeURIComponent(suffix);
        } catch (error) {
            onError(String(error));
            return null;
        }
        if (handle === "!") return source; // local tag
        onError(`Could not resolve tag: ${source}`);
        return null;
    }
    /**
     * Given a fully resolved tag, returns its printable string form,
     * taking into account current tag prefixes and defaults.
     */ tagString(tag) {
        for (const [handle, prefix] of Object.entries(this.tags)){
            if (tag.startsWith(prefix)) return handle + $e111a882191a53c0$var$escapeTagName(tag.substring(prefix.length));
        }
        return tag[0] === "!" ? tag : `!<${tag}>`;
    }
    toString(doc) {
        const lines = this.yaml.explicit ? [
            `%YAML ${this.yaml.version || "1.2"}`
        ] : [];
        const tagEntries = Object.entries(this.tags);
        let tagNames;
        if (doc && tagEntries.length > 0 && $FOECb.isNode(doc.contents)) {
            const tags = {};
            $jkImy.visit(doc.contents, (_key, node)=>{
                if ($FOECb.isNode(node) && node.tag) tags[node.tag] = true;
            });
            tagNames = Object.keys(tags);
        } else tagNames = [];
        for (const [handle, prefix] of tagEntries){
            if (handle === "!!" && prefix === "tag:yaml.org,2002:") continue;
            if (!doc || tagNames.some((tn)=>tn.startsWith(prefix))) lines.push(`%TAG ${handle} ${prefix}`);
        }
        return lines.join("\n");
    }
}
$e111a882191a53c0$var$Directives.defaultYaml = {
    explicit: false,
    version: "1.2"
};
$e111a882191a53c0$var$Directives.defaultTags = {
    "!!": "tag:yaml.org,2002:"
};
$e111a882191a53c0$export$129646a0e1af8d85 = $e111a882191a53c0$var$Directives;

});
parcelRegister("FOECb", function(module, exports) {

$parcel$export(module.exports, "ALIAS", () => $07db1f4b8596be4e$export$6e16f50e77e6cb4d, (v) => $07db1f4b8596be4e$export$6e16f50e77e6cb4d = v);
$parcel$export(module.exports, "DOC", () => $07db1f4b8596be4e$export$c41a48f61a15d775, (v) => $07db1f4b8596be4e$export$c41a48f61a15d775 = v);
$parcel$export(module.exports, "MAP", () => $07db1f4b8596be4e$export$ce970371e0e850bc, (v) => $07db1f4b8596be4e$export$ce970371e0e850bc = v);
$parcel$export(module.exports, "NODE_TYPE", () => $07db1f4b8596be4e$export$accaa52ddae3fe58, (v) => $07db1f4b8596be4e$export$accaa52ddae3fe58 = v);
$parcel$export(module.exports, "PAIR", () => $07db1f4b8596be4e$export$c4eb1412cef9eb18, (v) => $07db1f4b8596be4e$export$c4eb1412cef9eb18 = v);
$parcel$export(module.exports, "SCALAR", () => $07db1f4b8596be4e$export$8dde1211cb7c9d16, (v) => $07db1f4b8596be4e$export$8dde1211cb7c9d16 = v);
$parcel$export(module.exports, "SEQ", () => $07db1f4b8596be4e$export$200ef2dcd45611c9, (v) => $07db1f4b8596be4e$export$200ef2dcd45611c9 = v);
$parcel$export(module.exports, "hasAnchor", () => $07db1f4b8596be4e$export$67947a995b37b771, (v) => $07db1f4b8596be4e$export$67947a995b37b771 = v);
$parcel$export(module.exports, "isAlias", () => $07db1f4b8596be4e$export$c6275352883a2b3e, (v) => $07db1f4b8596be4e$export$c6275352883a2b3e = v);
$parcel$export(module.exports, "isCollection", () => $07db1f4b8596be4e$export$cea7aa84e978eba5, (v) => $07db1f4b8596be4e$export$cea7aa84e978eba5 = v);
$parcel$export(module.exports, "isDocument", () => $07db1f4b8596be4e$export$62858bae88b53fd0, (v) => $07db1f4b8596be4e$export$62858bae88b53fd0 = v);
$parcel$export(module.exports, "isMap", () => $07db1f4b8596be4e$export$5c90113a285f2241, (v) => $07db1f4b8596be4e$export$5c90113a285f2241 = v);
$parcel$export(module.exports, "isNode", () => $07db1f4b8596be4e$export$8ee0fc9ee280b4ee, (v) => $07db1f4b8596be4e$export$8ee0fc9ee280b4ee = v);
$parcel$export(module.exports, "isPair", () => $07db1f4b8596be4e$export$7c8d445944656308, (v) => $07db1f4b8596be4e$export$7c8d445944656308 = v);
$parcel$export(module.exports, "isScalar", () => $07db1f4b8596be4e$export$8f3495e22775e76c, (v) => $07db1f4b8596be4e$export$8f3495e22775e76c = v);
$parcel$export(module.exports, "isSeq", () => $07db1f4b8596be4e$export$342ac1d101ffe14b, (v) => $07db1f4b8596be4e$export$342ac1d101ffe14b = v);
var $07db1f4b8596be4e$export$6e16f50e77e6cb4d;
var $07db1f4b8596be4e$export$c41a48f61a15d775;
var $07db1f4b8596be4e$export$ce970371e0e850bc;
var $07db1f4b8596be4e$export$accaa52ddae3fe58;
var $07db1f4b8596be4e$export$c4eb1412cef9eb18;
var $07db1f4b8596be4e$export$8dde1211cb7c9d16;
var $07db1f4b8596be4e$export$200ef2dcd45611c9;
var $07db1f4b8596be4e$export$67947a995b37b771;
var $07db1f4b8596be4e$export$c6275352883a2b3e;
var $07db1f4b8596be4e$export$cea7aa84e978eba5;
var $07db1f4b8596be4e$export$62858bae88b53fd0;
var $07db1f4b8596be4e$export$5c90113a285f2241;
var $07db1f4b8596be4e$export$8ee0fc9ee280b4ee;
var $07db1f4b8596be4e$export$7c8d445944656308;
var $07db1f4b8596be4e$export$8f3495e22775e76c;
var $07db1f4b8596be4e$export$342ac1d101ffe14b;
"use strict";
const $07db1f4b8596be4e$var$ALIAS = Symbol.for("yaml.alias");
const $07db1f4b8596be4e$var$DOC = Symbol.for("yaml.document");
const $07db1f4b8596be4e$var$MAP = Symbol.for("yaml.map");
const $07db1f4b8596be4e$var$PAIR = Symbol.for("yaml.pair");
const $07db1f4b8596be4e$var$SCALAR = Symbol.for("yaml.scalar");
const $07db1f4b8596be4e$var$SEQ = Symbol.for("yaml.seq");
const $07db1f4b8596be4e$var$NODE_TYPE = Symbol.for("yaml.node.type");
const $07db1f4b8596be4e$var$isAlias = (node)=>!!node && typeof node === "object" && node[$07db1f4b8596be4e$var$NODE_TYPE] === $07db1f4b8596be4e$var$ALIAS;
const $07db1f4b8596be4e$var$isDocument = (node)=>!!node && typeof node === "object" && node[$07db1f4b8596be4e$var$NODE_TYPE] === $07db1f4b8596be4e$var$DOC;
const $07db1f4b8596be4e$var$isMap = (node)=>!!node && typeof node === "object" && node[$07db1f4b8596be4e$var$NODE_TYPE] === $07db1f4b8596be4e$var$MAP;
const $07db1f4b8596be4e$var$isPair = (node)=>!!node && typeof node === "object" && node[$07db1f4b8596be4e$var$NODE_TYPE] === $07db1f4b8596be4e$var$PAIR;
const $07db1f4b8596be4e$var$isScalar = (node)=>!!node && typeof node === "object" && node[$07db1f4b8596be4e$var$NODE_TYPE] === $07db1f4b8596be4e$var$SCALAR;
const $07db1f4b8596be4e$var$isSeq = (node)=>!!node && typeof node === "object" && node[$07db1f4b8596be4e$var$NODE_TYPE] === $07db1f4b8596be4e$var$SEQ;
function $07db1f4b8596be4e$var$isCollection(node) {
    if (node && typeof node === "object") switch(node[$07db1f4b8596be4e$var$NODE_TYPE]){
        case $07db1f4b8596be4e$var$MAP:
        case $07db1f4b8596be4e$var$SEQ:
            return true;
    }
    return false;
}
function $07db1f4b8596be4e$var$isNode(node) {
    if (node && typeof node === "object") switch(node[$07db1f4b8596be4e$var$NODE_TYPE]){
        case $07db1f4b8596be4e$var$ALIAS:
        case $07db1f4b8596be4e$var$MAP:
        case $07db1f4b8596be4e$var$SCALAR:
        case $07db1f4b8596be4e$var$SEQ:
            return true;
    }
    return false;
}
const $07db1f4b8596be4e$var$hasAnchor = (node)=>($07db1f4b8596be4e$var$isScalar(node) || $07db1f4b8596be4e$var$isCollection(node)) && !!node.anchor;
$07db1f4b8596be4e$export$6e16f50e77e6cb4d = $07db1f4b8596be4e$var$ALIAS;
$07db1f4b8596be4e$export$c41a48f61a15d775 = $07db1f4b8596be4e$var$DOC;
$07db1f4b8596be4e$export$ce970371e0e850bc = $07db1f4b8596be4e$var$MAP;
$07db1f4b8596be4e$export$accaa52ddae3fe58 = $07db1f4b8596be4e$var$NODE_TYPE;
$07db1f4b8596be4e$export$c4eb1412cef9eb18 = $07db1f4b8596be4e$var$PAIR;
$07db1f4b8596be4e$export$8dde1211cb7c9d16 = $07db1f4b8596be4e$var$SCALAR;
$07db1f4b8596be4e$export$200ef2dcd45611c9 = $07db1f4b8596be4e$var$SEQ;
$07db1f4b8596be4e$export$67947a995b37b771 = $07db1f4b8596be4e$var$hasAnchor;
$07db1f4b8596be4e$export$c6275352883a2b3e = $07db1f4b8596be4e$var$isAlias;
$07db1f4b8596be4e$export$cea7aa84e978eba5 = $07db1f4b8596be4e$var$isCollection;
$07db1f4b8596be4e$export$62858bae88b53fd0 = $07db1f4b8596be4e$var$isDocument;
$07db1f4b8596be4e$export$5c90113a285f2241 = $07db1f4b8596be4e$var$isMap;
$07db1f4b8596be4e$export$8ee0fc9ee280b4ee = $07db1f4b8596be4e$var$isNode;
$07db1f4b8596be4e$export$7c8d445944656308 = $07db1f4b8596be4e$var$isPair;
$07db1f4b8596be4e$export$8f3495e22775e76c = $07db1f4b8596be4e$var$isScalar;
$07db1f4b8596be4e$export$342ac1d101ffe14b = $07db1f4b8596be4e$var$isSeq;

});

parcelRegister("jkImy", function(module, exports) {

$parcel$export(module.exports, "visit", () => $e1324c1be2696d77$export$bf638b60ea8b89b7, (v) => $e1324c1be2696d77$export$bf638b60ea8b89b7 = v);
$parcel$export(module.exports, "visitAsync", () => $e1324c1be2696d77$export$3c4f5d970a5e6a3b, (v) => $e1324c1be2696d77$export$3c4f5d970a5e6a3b = v);
var $e1324c1be2696d77$export$bf638b60ea8b89b7;
var $e1324c1be2696d77$export$3c4f5d970a5e6a3b;
"use strict";

var $FOECb = parcelRequire("FOECb");
const $e1324c1be2696d77$var$BREAK = Symbol("break visit");
const $e1324c1be2696d77$var$SKIP = Symbol("skip children");
const $e1324c1be2696d77$var$REMOVE = Symbol("remove node");
/**
 * Apply a visitor to an AST node or document.
 *
 * Walks through the tree (depth-first) starting from `node`, calling a
 * `visitor` function with three arguments:
 *   - `key`: For sequence values and map `Pair`, the node's index in the
 *     collection. Within a `Pair`, `'key'` or `'value'`, correspondingly.
 *     `null` for the root node.
 *   - `node`: The current node.
 *   - `path`: The ancestry of the current node.
 *
 * The return value of the visitor may be used to control the traversal:
 *   - `undefined` (default): Do nothing and continue
 *   - `visit.SKIP`: Do not visit the children of this node, continue with next
 *     sibling
 *   - `visit.BREAK`: Terminate traversal completely
 *   - `visit.REMOVE`: Remove the current node, then continue with the next one
 *   - `Node`: Replace the current node, then continue by visiting it
 *   - `number`: While iterating the items of a sequence or map, set the index
 *     of the next step. This is useful especially if the index of the current
 *     node has changed.
 *
 * If `visitor` is a single function, it will be called with all values
 * encountered in the tree, including e.g. `null` values. Alternatively,
 * separate visitor functions may be defined for each `Map`, `Pair`, `Seq`,
 * `Alias` and `Scalar` node. To define the same visitor function for more than
 * one node type, use the `Collection` (map and seq), `Value` (map, seq & scalar)
 * and `Node` (alias, map, seq & scalar) targets. Of all these, only the most
 * specific defined one will be used for each node.
 */ function $e1324c1be2696d77$var$visit(node, visitor) {
    const visitor_ = $e1324c1be2696d77$var$initVisitor(visitor);
    if ($FOECb.isDocument(node)) {
        const cd = $e1324c1be2696d77$var$visit_(null, node.contents, visitor_, Object.freeze([
            node
        ]));
        if (cd === $e1324c1be2696d77$var$REMOVE) node.contents = null;
    } else $e1324c1be2696d77$var$visit_(null, node, visitor_, Object.freeze([]));
}
// Without the `as symbol` casts, TS declares these in the `visit`
// namespace using `var`, but then complains about that because
// `unique symbol` must be `const`.
/** Terminate visit traversal completely */ $e1324c1be2696d77$var$visit.BREAK = $e1324c1be2696d77$var$BREAK;
/** Do not visit the children of the current node */ $e1324c1be2696d77$var$visit.SKIP = $e1324c1be2696d77$var$SKIP;
/** Remove the current node */ $e1324c1be2696d77$var$visit.REMOVE = $e1324c1be2696d77$var$REMOVE;
function $e1324c1be2696d77$var$visit_(key, node, visitor, path) {
    const ctrl = $e1324c1be2696d77$var$callVisitor(key, node, visitor, path);
    if ($FOECb.isNode(ctrl) || $FOECb.isPair(ctrl)) {
        $e1324c1be2696d77$var$replaceNode(key, path, ctrl);
        return $e1324c1be2696d77$var$visit_(key, ctrl, visitor, path);
    }
    if (typeof ctrl !== "symbol") {
        if ($FOECb.isCollection(node)) {
            path = Object.freeze(path.concat(node));
            for(let i = 0; i < node.items.length; ++i){
                const ci = $e1324c1be2696d77$var$visit_(i, node.items[i], visitor, path);
                if (typeof ci === "number") i = ci - 1;
                else if (ci === $e1324c1be2696d77$var$BREAK) return $e1324c1be2696d77$var$BREAK;
                else if (ci === $e1324c1be2696d77$var$REMOVE) {
                    node.items.splice(i, 1);
                    i -= 1;
                }
            }
        } else if ($FOECb.isPair(node)) {
            path = Object.freeze(path.concat(node));
            const ck = $e1324c1be2696d77$var$visit_("key", node.key, visitor, path);
            if (ck === $e1324c1be2696d77$var$BREAK) return $e1324c1be2696d77$var$BREAK;
            else if (ck === $e1324c1be2696d77$var$REMOVE) node.key = null;
            const cv = $e1324c1be2696d77$var$visit_("value", node.value, visitor, path);
            if (cv === $e1324c1be2696d77$var$BREAK) return $e1324c1be2696d77$var$BREAK;
            else if (cv === $e1324c1be2696d77$var$REMOVE) node.value = null;
        }
    }
    return ctrl;
}
/**
 * Apply an async visitor to an AST node or document.
 *
 * Walks through the tree (depth-first) starting from `node`, calling a
 * `visitor` function with three arguments:
 *   - `key`: For sequence values and map `Pair`, the node's index in the
 *     collection. Within a `Pair`, `'key'` or `'value'`, correspondingly.
 *     `null` for the root node.
 *   - `node`: The current node.
 *   - `path`: The ancestry of the current node.
 *
 * The return value of the visitor may be used to control the traversal:
 *   - `Promise`: Must resolve to one of the following values
 *   - `undefined` (default): Do nothing and continue
 *   - `visit.SKIP`: Do not visit the children of this node, continue with next
 *     sibling
 *   - `visit.BREAK`: Terminate traversal completely
 *   - `visit.REMOVE`: Remove the current node, then continue with the next one
 *   - `Node`: Replace the current node, then continue by visiting it
 *   - `number`: While iterating the items of a sequence or map, set the index
 *     of the next step. This is useful especially if the index of the current
 *     node has changed.
 *
 * If `visitor` is a single function, it will be called with all values
 * encountered in the tree, including e.g. `null` values. Alternatively,
 * separate visitor functions may be defined for each `Map`, `Pair`, `Seq`,
 * `Alias` and `Scalar` node. To define the same visitor function for more than
 * one node type, use the `Collection` (map and seq), `Value` (map, seq & scalar)
 * and `Node` (alias, map, seq & scalar) targets. Of all these, only the most
 * specific defined one will be used for each node.
 */ async function $e1324c1be2696d77$var$visitAsync(node, visitor) {
    const visitor_ = $e1324c1be2696d77$var$initVisitor(visitor);
    if ($FOECb.isDocument(node)) {
        const cd = await $e1324c1be2696d77$var$visitAsync_(null, node.contents, visitor_, Object.freeze([
            node
        ]));
        if (cd === $e1324c1be2696d77$var$REMOVE) node.contents = null;
    } else await $e1324c1be2696d77$var$visitAsync_(null, node, visitor_, Object.freeze([]));
}
// Without the `as symbol` casts, TS declares these in the `visit`
// namespace using `var`, but then complains about that because
// `unique symbol` must be `const`.
/** Terminate visit traversal completely */ $e1324c1be2696d77$var$visitAsync.BREAK = $e1324c1be2696d77$var$BREAK;
/** Do not visit the children of the current node */ $e1324c1be2696d77$var$visitAsync.SKIP = $e1324c1be2696d77$var$SKIP;
/** Remove the current node */ $e1324c1be2696d77$var$visitAsync.REMOVE = $e1324c1be2696d77$var$REMOVE;
async function $e1324c1be2696d77$var$visitAsync_(key, node, visitor, path) {
    const ctrl = await $e1324c1be2696d77$var$callVisitor(key, node, visitor, path);
    if ($FOECb.isNode(ctrl) || $FOECb.isPair(ctrl)) {
        $e1324c1be2696d77$var$replaceNode(key, path, ctrl);
        return $e1324c1be2696d77$var$visitAsync_(key, ctrl, visitor, path);
    }
    if (typeof ctrl !== "symbol") {
        if ($FOECb.isCollection(node)) {
            path = Object.freeze(path.concat(node));
            for(let i = 0; i < node.items.length; ++i){
                const ci = await $e1324c1be2696d77$var$visitAsync_(i, node.items[i], visitor, path);
                if (typeof ci === "number") i = ci - 1;
                else if (ci === $e1324c1be2696d77$var$BREAK) return $e1324c1be2696d77$var$BREAK;
                else if (ci === $e1324c1be2696d77$var$REMOVE) {
                    node.items.splice(i, 1);
                    i -= 1;
                }
            }
        } else if ($FOECb.isPair(node)) {
            path = Object.freeze(path.concat(node));
            const ck = await $e1324c1be2696d77$var$visitAsync_("key", node.key, visitor, path);
            if (ck === $e1324c1be2696d77$var$BREAK) return $e1324c1be2696d77$var$BREAK;
            else if (ck === $e1324c1be2696d77$var$REMOVE) node.key = null;
            const cv = await $e1324c1be2696d77$var$visitAsync_("value", node.value, visitor, path);
            if (cv === $e1324c1be2696d77$var$BREAK) return $e1324c1be2696d77$var$BREAK;
            else if (cv === $e1324c1be2696d77$var$REMOVE) node.value = null;
        }
    }
    return ctrl;
}
function $e1324c1be2696d77$var$initVisitor(visitor) {
    if (typeof visitor === "object" && (visitor.Collection || visitor.Node || visitor.Value)) return Object.assign({
        Alias: visitor.Node,
        Map: visitor.Node,
        Scalar: visitor.Node,
        Seq: visitor.Node
    }, visitor.Value && {
        Map: visitor.Value,
        Scalar: visitor.Value,
        Seq: visitor.Value
    }, visitor.Collection && {
        Map: visitor.Collection,
        Seq: visitor.Collection
    }, visitor);
    return visitor;
}
function $e1324c1be2696d77$var$callVisitor(key, node, visitor, path) {
    if (typeof visitor === "function") return visitor(key, node, path);
    if ($FOECb.isMap(node)) return visitor.Map?.(key, node, path);
    if ($FOECb.isSeq(node)) return visitor.Seq?.(key, node, path);
    if ($FOECb.isPair(node)) return visitor.Pair?.(key, node, path);
    if ($FOECb.isScalar(node)) return visitor.Scalar?.(key, node, path);
    if ($FOECb.isAlias(node)) return visitor.Alias?.(key, node, path);
    return undefined;
}
function $e1324c1be2696d77$var$replaceNode(key, path, node) {
    const parent = path[path.length - 1];
    if ($FOECb.isCollection(parent)) parent.items[key] = node;
    else if ($FOECb.isPair(parent)) {
        if (key === "key") parent.key = node;
        else parent.value = node;
    } else if ($FOECb.isDocument(parent)) parent.contents = node;
    else {
        const pt = $FOECb.isAlias(parent) ? "alias" : "scalar";
        throw new Error(`Cannot replace node with ${pt} parent`);
    }
}
$e1324c1be2696d77$export$bf638b60ea8b89b7 = $e1324c1be2696d77$var$visit;
$e1324c1be2696d77$export$3c4f5d970a5e6a3b = $e1324c1be2696d77$var$visitAsync;

});


parcelRegister("hfBM7", function(module, exports) {

$parcel$export(module.exports, "Document", () => $c8f123bca7d5f386$export$b34a105447964f9f, (v) => $c8f123bca7d5f386$export$b34a105447964f9f = v);
var $c8f123bca7d5f386$export$b34a105447964f9f;
"use strict";

var $jOHGy = parcelRequire("jOHGy");

var $fWhvR = parcelRequire("fWhvR");

var $FOECb = parcelRequire("FOECb");

var $5ff4n = parcelRequire("5ff4n");

var $jeFb3 = parcelRequire("jeFb3");

var $9Z3DY = parcelRequire("9Z3DY");

var $dRGsN = parcelRequire("dRGsN");

var $6JDBj = parcelRequire("6JDBj");

var $4ePQu = parcelRequire("4ePQu");

var $64cbc = parcelRequire("64cbc");

var $jk2hM = parcelRequire("jk2hM");
class $c8f123bca7d5f386$var$Document {
    constructor(value, replacer, options){
        /** A comment before this Document */ this.commentBefore = null;
        /** A comment immediately after this Document */ this.comment = null;
        /** Errors encountered during parsing. */ this.errors = [];
        /** Warnings encountered during parsing. */ this.warnings = [];
        Object.defineProperty(this, $FOECb.NODE_TYPE, {
            value: $FOECb.DOC
        });
        let _replacer = null;
        if (typeof replacer === "function" || Array.isArray(replacer)) _replacer = replacer;
        else if (options === undefined && replacer) {
            options = replacer;
            replacer = undefined;
        }
        const opt = Object.assign({
            intAsBigInt: false,
            keepSourceTokens: false,
            logLevel: "warn",
            prettyErrors: true,
            strict: true,
            stringKeys: false,
            uniqueKeys: true,
            version: "1.2"
        }, options);
        this.options = opt;
        let { version: version } = opt;
        if (options?._directives) {
            this.directives = options._directives.atDocument();
            if (this.directives.yaml.explicit) version = this.directives.yaml.version;
        } else this.directives = new $jk2hM.Directives({
            version: version
        });
        this.setSchema(version, options);
        // @ts-expect-error We can't really know that this matches Contents.
        this.contents = value === undefined ? null : this.createNode(value, _replacer, options);
    }
    /**
     * Create a deep copy of this Document and its contents.
     *
     * Custom Node values that inherit from `Object` still refer to their original instances.
     */ clone() {
        const copy = Object.create($c8f123bca7d5f386$var$Document.prototype, {
            [$FOECb.NODE_TYPE]: {
                value: $FOECb.DOC
            }
        });
        copy.commentBefore = this.commentBefore;
        copy.comment = this.comment;
        copy.errors = this.errors.slice();
        copy.warnings = this.warnings.slice();
        copy.options = Object.assign({}, this.options);
        if (this.directives) copy.directives = this.directives.clone();
        copy.schema = this.schema.clone();
        // @ts-expect-error We can't really know that this matches Contents.
        copy.contents = $FOECb.isNode(this.contents) ? this.contents.clone(copy.schema) : this.contents;
        if (this.range) copy.range = this.range.slice();
        return copy;
    }
    /** Adds a value to the document. */ add(value) {
        if ($c8f123bca7d5f386$var$assertCollection(this.contents)) this.contents.add(value);
    }
    /** Adds a value to the document. */ addIn(path, value) {
        if ($c8f123bca7d5f386$var$assertCollection(this.contents)) this.contents.addIn(path, value);
    }
    /**
     * Create a new `Alias` node, ensuring that the target `node` has the required anchor.
     *
     * If `node` already has an anchor, `name` is ignored.
     * Otherwise, the `node.anchor` value will be set to `name`,
     * or if an anchor with that name is already present in the document,
     * `name` will be used as a prefix for a new unique anchor.
     * If `name` is undefined, the generated anchor will use 'a' as a prefix.
     */ createAlias(node, name) {
        if (!node.anchor) {
            const prev = $6JDBj.anchorNames(this);
            node.anchor = // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
            !name || prev.has(name) ? $6JDBj.findNewAnchor(name || "a", prev) : name;
        }
        return new $jOHGy.Alias(node.anchor);
    }
    createNode(value, replacer, options) {
        let _replacer = undefined;
        if (typeof replacer === "function") {
            value = replacer.call({
                "": value
            }, "", value);
            _replacer = replacer;
        } else if (Array.isArray(replacer)) {
            const keyToStr = (v)=>typeof v === "number" || v instanceof String || v instanceof Number;
            const asStr = replacer.filter(keyToStr).map(String);
            if (asStr.length > 0) replacer = replacer.concat(asStr);
            _replacer = replacer;
        } else if (options === undefined && replacer) {
            options = replacer;
            replacer = undefined;
        }
        const { aliasDuplicateObjects: aliasDuplicateObjects, anchorPrefix: anchorPrefix, flow: flow, keepUndefined: keepUndefined, onTagObj: onTagObj, tag: tag } = options ?? {};
        const { onAnchor: onAnchor, setAnchors: setAnchors, sourceObjects: sourceObjects } = $6JDBj.createNodeAnchors(this, // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
        anchorPrefix || "a");
        const ctx = {
            aliasDuplicateObjects: aliasDuplicateObjects ?? true,
            keepUndefined: keepUndefined ?? false,
            onAnchor: onAnchor,
            onTagObj: onTagObj,
            replacer: _replacer,
            schema: this.schema,
            sourceObjects: sourceObjects
        };
        const node = $64cbc.createNode(value, tag, ctx);
        if (flow && $FOECb.isCollection(node)) node.flow = true;
        setAnchors();
        return node;
    }
    /**
     * Convert a key and a value into a `Pair` using the current schema,
     * recursively wrapping all values as `Scalar` or `Collection` nodes.
     */ createPair(key, value, options = {}) {
        const k = this.createNode(key, null, options);
        const v = this.createNode(value, null, options);
        return new $5ff4n.Pair(k, v);
    }
    /**
     * Removes a value from the document.
     * @returns `true` if the item was found and removed.
     */ delete(key) {
        return $c8f123bca7d5f386$var$assertCollection(this.contents) ? this.contents.delete(key) : false;
    }
    /**
     * Removes a value from the document.
     * @returns `true` if the item was found and removed.
     */ deleteIn(path) {
        if ($fWhvR.isEmptyPath(path)) {
            if (this.contents == null) return false;
            // @ts-expect-error Presumed impossible if Strict extends false
            this.contents = null;
            return true;
        }
        return $c8f123bca7d5f386$var$assertCollection(this.contents) ? this.contents.deleteIn(path) : false;
    }
    /**
     * Returns item at `key`, or `undefined` if not found. By default unwraps
     * scalar values from their surrounding node; to disable set `keepScalar` to
     * `true` (collections are always returned intact).
     */ get(key, keepScalar) {
        return $FOECb.isCollection(this.contents) ? this.contents.get(key, keepScalar) : undefined;
    }
    /**
     * Returns item at `path`, or `undefined` if not found. By default unwraps
     * scalar values from their surrounding node; to disable set `keepScalar` to
     * `true` (collections are always returned intact).
     */ getIn(path, keepScalar) {
        if ($fWhvR.isEmptyPath(path)) return !keepScalar && $FOECb.isScalar(this.contents) ? this.contents.value : this.contents;
        return $FOECb.isCollection(this.contents) ? this.contents.getIn(path, keepScalar) : undefined;
    }
    /**
     * Checks if the document includes a value with the key `key`.
     */ has(key) {
        return $FOECb.isCollection(this.contents) ? this.contents.has(key) : false;
    }
    /**
     * Checks if the document includes a value at `path`.
     */ hasIn(path) {
        if ($fWhvR.isEmptyPath(path)) return this.contents !== undefined;
        return $FOECb.isCollection(this.contents) ? this.contents.hasIn(path) : false;
    }
    /**
     * Sets a value in this document. For `!!set`, `value` needs to be a
     * boolean to add/remove the item from the set.
     */ set(key, value) {
        if (this.contents == null) // @ts-expect-error We can't really know that this matches Contents.
        this.contents = $fWhvR.collectionFromPath(this.schema, [
            key
        ], value);
        else if ($c8f123bca7d5f386$var$assertCollection(this.contents)) this.contents.set(key, value);
    }
    /**
     * Sets a value in this document. For `!!set`, `value` needs to be a
     * boolean to add/remove the item from the set.
     */ setIn(path, value) {
        if ($fWhvR.isEmptyPath(path)) // @ts-expect-error We can't really know that this matches Contents.
        this.contents = value;
        else if (this.contents == null) // @ts-expect-error We can't really know that this matches Contents.
        this.contents = $fWhvR.collectionFromPath(this.schema, Array.from(path), value);
        else if ($c8f123bca7d5f386$var$assertCollection(this.contents)) this.contents.setIn(path, value);
    }
    /**
     * Change the YAML version and schema used by the document.
     * A `null` version disables support for directives, explicit tags, anchors, and aliases.
     * It also requires the `schema` option to be given as a `Schema` instance value.
     *
     * Overrides all previously set schema options.
     */ setSchema(version, options = {}) {
        if (typeof version === "number") version = String(version);
        let opt;
        switch(version){
            case "1.1":
                if (this.directives) this.directives.yaml.version = "1.1";
                else this.directives = new $jk2hM.Directives({
                    version: "1.1"
                });
                opt = {
                    resolveKnownTags: false,
                    schema: "yaml-1.1"
                };
                break;
            case "1.2":
            case "next":
                if (this.directives) this.directives.yaml.version = version;
                else this.directives = new $jk2hM.Directives({
                    version: version
                });
                opt = {
                    resolveKnownTags: true,
                    schema: "core"
                };
                break;
            case null:
                if (this.directives) delete this.directives;
                opt = null;
                break;
            default:
                {
                    const sv = JSON.stringify(version);
                    throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
                }
        }
        // Not using `instanceof Schema` to allow for duck typing
        if (options.schema instanceof Object) this.schema = options.schema;
        else if (opt) this.schema = new $9Z3DY.Schema(Object.assign(opt, options));
        else throw new Error(`With a null YAML version, the { schema: Schema } option is required`);
    }
    // json & jsonArg are only used from toJSON()
    toJS({ json: json, jsonArg: jsonArg, mapAsMap: mapAsMap, maxAliasCount: maxAliasCount, onAnchor: onAnchor, reviver: reviver } = {}) {
        const ctx = {
            anchors: new Map(),
            doc: this,
            keep: !json,
            mapAsMap: mapAsMap === true,
            mapKeyWarned: false,
            maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
        };
        const res = $jeFb3.toJS(this.contents, jsonArg ?? "", ctx);
        if (typeof onAnchor === "function") for (const { count: count, res: res } of ctx.anchors.values())onAnchor(res, count);
        return typeof reviver === "function" ? $4ePQu.applyReviver(reviver, {
            "": res
        }, "", res) : res;
    }
    /**
     * A JSON representation of the document `contents`.
     *
     * @param jsonArg Used by `JSON.stringify` to indicate the array index or
     *   property name.
     */ toJSON(jsonArg, onAnchor) {
        return this.toJS({
            json: true,
            jsonArg: jsonArg,
            mapAsMap: false,
            onAnchor: onAnchor
        });
    }
    /** A YAML representation of the document. */ toString(options = {}) {
        if (this.errors.length > 0) throw new Error("Document with errors cannot be stringified");
        if ("indent" in options && (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {
            const s = JSON.stringify(options.indent);
            throw new Error(`"indent" option must be a positive integer, not ${s}`);
        }
        return $dRGsN.stringifyDocument(this, options);
    }
}
function $c8f123bca7d5f386$var$assertCollection(contents) {
    if ($FOECb.isCollection(contents)) return true;
    throw new Error("Expected a YAML collection as document contents");
}
$c8f123bca7d5f386$export$b34a105447964f9f = $c8f123bca7d5f386$var$Document;

});
parcelRegister("jOHGy", function(module, exports) {

$parcel$export(module.exports, "Alias", () => $e6d492d41dd9e25b$export$17b520249a85fe16, (v) => $e6d492d41dd9e25b$export$17b520249a85fe16 = v);
var $e6d492d41dd9e25b$export$17b520249a85fe16;
"use strict";

var $6JDBj = parcelRequire("6JDBj");

var $jkImy = parcelRequire("jkImy");

var $FOECb = parcelRequire("FOECb");

var $g3flb = parcelRequire("g3flb");

var $jeFb3 = parcelRequire("jeFb3");
class $e6d492d41dd9e25b$var$Alias extends $g3flb.NodeBase {
    constructor(source){
        super($FOECb.ALIAS);
        this.source = source;
        Object.defineProperty(this, "tag", {
            set () {
                throw new Error("Alias nodes cannot have tags");
            }
        });
    }
    /**
     * Resolve the value of this alias within `doc`, finding the last
     * instance of the `source` anchor before this node.
     */ resolve(doc) {
        let found = undefined;
        $jkImy.visit(doc, {
            Node: (_key, node)=>{
                if (node === this) return $jkImy.visit.BREAK;
                if (node.anchor === this.source) found = node;
            }
        });
        return found;
    }
    toJSON(_arg, ctx) {
        if (!ctx) return {
            source: this.source
        };
        const { anchors: anchors, doc: doc, maxAliasCount: maxAliasCount } = ctx;
        const source = this.resolve(doc);
        if (!source) {
            const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
            throw new ReferenceError(msg);
        }
        let data = anchors.get(source);
        if (!data) {
            // Resolve anchors for Node.prototype.toJS()
            $jeFb3.toJS(source, null, ctx);
            data = anchors.get(source);
        }
        /* istanbul ignore if */ if (!data || data.res === undefined) {
            const msg = "This should not happen: Alias anchor was not resolved?";
            throw new ReferenceError(msg);
        }
        if (maxAliasCount >= 0) {
            data.count += 1;
            if (data.aliasCount === 0) data.aliasCount = $e6d492d41dd9e25b$var$getAliasCount(doc, source, anchors);
            if (data.count * data.aliasCount > maxAliasCount) {
                const msg = "Excessive alias count indicates a resource exhaustion attack";
                throw new ReferenceError(msg);
            }
        }
        return data.res;
    }
    toString(ctx, _onComment, _onChompKeep) {
        const src = `*${this.source}`;
        if (ctx) {
            $6JDBj.anchorIsValid(this.source);
            if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
                const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
                throw new Error(msg);
            }
            if (ctx.implicitKey) return `${src} `;
        }
        return src;
    }
}
function $e6d492d41dd9e25b$var$getAliasCount(doc, node, anchors) {
    if ($FOECb.isAlias(node)) {
        const source = node.resolve(doc);
        const anchor = anchors && source && anchors.get(source);
        return anchor ? anchor.count * anchor.aliasCount : 0;
    } else if ($FOECb.isCollection(node)) {
        let count = 0;
        for (const item of node.items){
            const c = $e6d492d41dd9e25b$var$getAliasCount(doc, item, anchors);
            if (c > count) count = c;
        }
        return count;
    } else if ($FOECb.isPair(node)) {
        const kc = $e6d492d41dd9e25b$var$getAliasCount(doc, node.key, anchors);
        const vc = $e6d492d41dd9e25b$var$getAliasCount(doc, node.value, anchors);
        return Math.max(kc, vc);
    }
    return 1;
}
$e6d492d41dd9e25b$export$17b520249a85fe16 = $e6d492d41dd9e25b$var$Alias;

});
parcelRegister("6JDBj", function(module, exports) {

$parcel$export(module.exports, "anchorIsValid", () => $4e75a9f0fa53fa9c$export$67b774d238e24409, (v) => $4e75a9f0fa53fa9c$export$67b774d238e24409 = v);
$parcel$export(module.exports, "anchorNames", () => $4e75a9f0fa53fa9c$export$402f230d710ffb75, (v) => $4e75a9f0fa53fa9c$export$402f230d710ffb75 = v);
$parcel$export(module.exports, "createNodeAnchors", () => $4e75a9f0fa53fa9c$export$5498887d1e6c340c, (v) => $4e75a9f0fa53fa9c$export$5498887d1e6c340c = v);
$parcel$export(module.exports, "findNewAnchor", () => $4e75a9f0fa53fa9c$export$1a7f8f45ec43f9e4, (v) => $4e75a9f0fa53fa9c$export$1a7f8f45ec43f9e4 = v);
var $4e75a9f0fa53fa9c$export$67b774d238e24409;
var $4e75a9f0fa53fa9c$export$402f230d710ffb75;
var $4e75a9f0fa53fa9c$export$5498887d1e6c340c;
var $4e75a9f0fa53fa9c$export$1a7f8f45ec43f9e4;
"use strict";

var $FOECb = parcelRequire("FOECb");

var $jkImy = parcelRequire("jkImy");
/**
 * Verify that the input string is a valid anchor.
 *
 * Will throw on errors.
 */ function $4e75a9f0fa53fa9c$var$anchorIsValid(anchor) {
    if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
        const sa = JSON.stringify(anchor);
        const msg = `Anchor must not contain whitespace or control characters: ${sa}`;
        throw new Error(msg);
    }
    return true;
}
function $4e75a9f0fa53fa9c$var$anchorNames(root) {
    const anchors = new Set();
    $jkImy.visit(root, {
        Value (_key, node) {
            if (node.anchor) anchors.add(node.anchor);
        }
    });
    return anchors;
}
/** Find a new anchor name with the given `prefix` and a one-indexed suffix. */ function $4e75a9f0fa53fa9c$var$findNewAnchor(prefix, exclude) {
    for(let i = 1;; ++i){
        const name = `${prefix}${i}`;
        if (!exclude.has(name)) return name;
    }
}
function $4e75a9f0fa53fa9c$var$createNodeAnchors(doc, prefix) {
    const aliasObjects = [];
    const sourceObjects = new Map();
    let prevAnchors = null;
    return {
        onAnchor: (source)=>{
            aliasObjects.push(source);
            if (!prevAnchors) prevAnchors = $4e75a9f0fa53fa9c$var$anchorNames(doc);
            const anchor = $4e75a9f0fa53fa9c$var$findNewAnchor(prefix, prevAnchors);
            prevAnchors.add(anchor);
            return anchor;
        },
        /**
         * With circular references, the source node is only resolved after all
         * of its child nodes are. This is why anchors are set only after all of
         * the nodes have been created.
         */ setAnchors: ()=>{
            for (const source of aliasObjects){
                const ref = sourceObjects.get(source);
                if (typeof ref === "object" && ref.anchor && ($FOECb.isScalar(ref.node) || $FOECb.isCollection(ref.node))) ref.node.anchor = ref.anchor;
                else {
                    const error = new Error("Failed to resolve repeated object (this should not happen)");
                    error.source = source;
                    throw error;
                }
            }
        },
        sourceObjects: sourceObjects
    };
}
$4e75a9f0fa53fa9c$export$67b774d238e24409 = $4e75a9f0fa53fa9c$var$anchorIsValid;
$4e75a9f0fa53fa9c$export$402f230d710ffb75 = $4e75a9f0fa53fa9c$var$anchorNames;
$4e75a9f0fa53fa9c$export$5498887d1e6c340c = $4e75a9f0fa53fa9c$var$createNodeAnchors;
$4e75a9f0fa53fa9c$export$1a7f8f45ec43f9e4 = $4e75a9f0fa53fa9c$var$findNewAnchor;

});

parcelRegister("g3flb", function(module, exports) {

$parcel$export(module.exports, "NodeBase", () => $baf8d37d49e82d80$export$7cc40ad5cb33f2dc, (v) => $baf8d37d49e82d80$export$7cc40ad5cb33f2dc = v);
var $baf8d37d49e82d80$export$7cc40ad5cb33f2dc;
"use strict";

var $4ePQu = parcelRequire("4ePQu");

var $FOECb = parcelRequire("FOECb");

var $jeFb3 = parcelRequire("jeFb3");
class $baf8d37d49e82d80$var$NodeBase {
    constructor(type){
        Object.defineProperty(this, $FOECb.NODE_TYPE, {
            value: type
        });
    }
    /** Create a copy of this node.  */ clone() {
        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
        if (this.range) copy.range = this.range.slice();
        return copy;
    }
    /** A plain JavaScript representation of this node. */ toJS(doc, { mapAsMap: mapAsMap, maxAliasCount: maxAliasCount, onAnchor: onAnchor, reviver: reviver } = {}) {
        if (!$FOECb.isDocument(doc)) throw new TypeError("A document argument is required");
        const ctx = {
            anchors: new Map(),
            doc: doc,
            keep: true,
            mapAsMap: mapAsMap === true,
            mapKeyWarned: false,
            maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
        };
        const res = $jeFb3.toJS(this, "", ctx);
        if (typeof onAnchor === "function") for (const { count: count, res: res } of ctx.anchors.values())onAnchor(res, count);
        return typeof reviver === "function" ? $4ePQu.applyReviver(reviver, {
            "": res
        }, "", res) : res;
    }
}
$baf8d37d49e82d80$export$7cc40ad5cb33f2dc = $baf8d37d49e82d80$var$NodeBase;

});
parcelRegister("4ePQu", function(module, exports) {

$parcel$export(module.exports, "applyReviver", () => $3160afabc109419b$export$abc04374ac0ef535, (v) => $3160afabc109419b$export$abc04374ac0ef535 = v);
var $3160afabc109419b$export$abc04374ac0ef535;
"use strict";
/**
 * Applies the JSON.parse reviver algorithm as defined in the ECMA-262 spec,
 * in section 24.5.1.1 "Runtime Semantics: InternalizeJSONProperty" of the
 * 2021 edition: https://tc39.es/ecma262/#sec-json.parse
 *
 * Includes extensions for handling Map and Set objects.
 */ function $3160afabc109419b$var$applyReviver(reviver, obj, key, val) {
    if (val && typeof val === "object") {
        if (Array.isArray(val)) for(let i = 0, len = val.length; i < len; ++i){
            const v0 = val[i];
            const v1 = $3160afabc109419b$var$applyReviver(reviver, val, String(i), v0);
            // eslint-disable-next-line @typescript-eslint/no-array-delete
            if (v1 === undefined) delete val[i];
            else if (v1 !== v0) val[i] = v1;
        }
        else if (val instanceof Map) for (const k of Array.from(val.keys())){
            const v0 = val.get(k);
            const v1 = $3160afabc109419b$var$applyReviver(reviver, val, k, v0);
            if (v1 === undefined) val.delete(k);
            else if (v1 !== v0) val.set(k, v1);
        }
        else if (val instanceof Set) for (const v0 of Array.from(val)){
            const v1 = $3160afabc109419b$var$applyReviver(reviver, val, v0, v0);
            if (v1 === undefined) val.delete(v0);
            else if (v1 !== v0) {
                val.delete(v0);
                val.add(v1);
            }
        }
        else for (const [k, v0] of Object.entries(val)){
            const v1 = $3160afabc109419b$var$applyReviver(reviver, val, k, v0);
            if (v1 === undefined) delete val[k];
            else if (v1 !== v0) val[k] = v1;
        }
    }
    return reviver.call(obj, key, val);
}
$3160afabc109419b$export$abc04374ac0ef535 = $3160afabc109419b$var$applyReviver;

});

parcelRegister("jeFb3", function(module, exports) {

$parcel$export(module.exports, "toJS", () => $e00f44183828493b$export$f08965dd1304d490, (v) => $e00f44183828493b$export$f08965dd1304d490 = v);
var $e00f44183828493b$export$f08965dd1304d490;
"use strict";

var $FOECb = parcelRequire("FOECb");
/**
 * Recursively convert any node or its contents to native JavaScript
 *
 * @param value - The input value
 * @param arg - If `value` defines a `toJSON()` method, use this
 *   as its first argument
 * @param ctx - Conversion context, originally set in Document#toJS(). If
 *   `{ keep: true }` is not set, output should be suitable for JSON
 *   stringification.
 */ function $e00f44183828493b$var$toJS(value, arg, ctx) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
    if (Array.isArray(value)) return value.map((v, i)=>$e00f44183828493b$var$toJS(v, String(i), ctx));
    if (value && typeof value.toJSON === "function") {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-call
        if (!ctx || !$FOECb.hasAnchor(value)) return value.toJSON(arg, ctx);
        const data = {
            aliasCount: 0,
            count: 1,
            res: undefined
        };
        ctx.anchors.set(value, data);
        ctx.onCreate = (res)=>{
            data.res = res;
            delete ctx.onCreate;
        };
        const res = value.toJSON(arg, ctx);
        if (ctx.onCreate) ctx.onCreate(res);
        return res;
    }
    if (typeof value === "bigint" && !ctx?.keep) return Number(value);
    return value;
}
$e00f44183828493b$export$f08965dd1304d490 = $e00f44183828493b$var$toJS;

});



parcelRegister("fWhvR", function(module, exports) {

$parcel$export(module.exports, "Collection", () => $b9a9db7ddcce63c3$export$fb8073518f34e6ec, (v) => $b9a9db7ddcce63c3$export$fb8073518f34e6ec = v);
$parcel$export(module.exports, "collectionFromPath", () => $b9a9db7ddcce63c3$export$f5ac8bc6072340dd, (v) => $b9a9db7ddcce63c3$export$f5ac8bc6072340dd = v);
$parcel$export(module.exports, "isEmptyPath", () => $b9a9db7ddcce63c3$export$e3bfca790bd8f9da, (v) => $b9a9db7ddcce63c3$export$e3bfca790bd8f9da = v);
var $b9a9db7ddcce63c3$export$fb8073518f34e6ec;
var $b9a9db7ddcce63c3$export$f5ac8bc6072340dd;
var $b9a9db7ddcce63c3$export$e3bfca790bd8f9da;
"use strict";

var $64cbc = parcelRequire("64cbc");

var $FOECb = parcelRequire("FOECb");

var $g3flb = parcelRequire("g3flb");
function $b9a9db7ddcce63c3$var$collectionFromPath(schema, path, value) {
    let v = value;
    for(let i = path.length - 1; i >= 0; --i){
        const k = path[i];
        if (typeof k === "number" && Number.isInteger(k) && k >= 0) {
            const a = [];
            a[k] = v;
            v = a;
        } else v = new Map([
            [
                k,
                v
            ]
        ]);
    }
    return $64cbc.createNode(v, undefined, {
        aliasDuplicateObjects: false,
        keepUndefined: false,
        onAnchor: ()=>{
            throw new Error("This should not happen, please report a bug.");
        },
        schema: schema,
        sourceObjects: new Map()
    });
}
// Type guard is intentionally a little wrong so as to be more useful,
// as it does not cover untypable empty non-string iterables (e.g. []).
const $b9a9db7ddcce63c3$var$isEmptyPath = (path)=>path == null || typeof path === "object" && !!path[Symbol.iterator]().next().done;
class $b9a9db7ddcce63c3$var$Collection extends $g3flb.NodeBase {
    constructor(type, schema){
        super(type);
        Object.defineProperty(this, "schema", {
            value: schema,
            configurable: true,
            enumerable: false,
            writable: true
        });
    }
    /**
     * Create a copy of this collection.
     *
     * @param schema - If defined, overwrites the original's schema
     */ clone(schema) {
        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
        if (schema) copy.schema = schema;
        copy.items = copy.items.map((it)=>$FOECb.isNode(it) || $FOECb.isPair(it) ? it.clone(schema) : it);
        if (this.range) copy.range = this.range.slice();
        return copy;
    }
    /**
     * Adds a value to the collection. For `!!map` and `!!omap` the value must
     * be a Pair instance or a `{ key, value }` object, which may not have a key
     * that already exists in the map.
     */ addIn(path, value) {
        if ($b9a9db7ddcce63c3$var$isEmptyPath(path)) this.add(value);
        else {
            const [key, ...rest] = path;
            const node = this.get(key, true);
            if ($FOECb.isCollection(node)) node.addIn(rest, value);
            else if (node === undefined && this.schema) this.set(key, $b9a9db7ddcce63c3$var$collectionFromPath(this.schema, rest, value));
            else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
    }
    /**
     * Removes a value from the collection.
     * @returns `true` if the item was found and removed.
     */ deleteIn(path) {
        const [key, ...rest] = path;
        if (rest.length === 0) return this.delete(key);
        const node = this.get(key, true);
        if ($FOECb.isCollection(node)) return node.deleteIn(rest);
        else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
    }
    /**
     * Returns item at `key`, or `undefined` if not found. By default unwraps
     * scalar values from their surrounding node; to disable set `keepScalar` to
     * `true` (collections are always returned intact).
     */ getIn(path, keepScalar) {
        const [key, ...rest] = path;
        const node = this.get(key, true);
        if (rest.length === 0) return !keepScalar && $FOECb.isScalar(node) ? node.value : node;
        else return $FOECb.isCollection(node) ? node.getIn(rest, keepScalar) : undefined;
    }
    hasAllNullValues(allowScalar) {
        return this.items.every((node)=>{
            if (!$FOECb.isPair(node)) return false;
            const n = node.value;
            return n == null || allowScalar && $FOECb.isScalar(n) && n.value == null && !n.commentBefore && !n.comment && !n.tag;
        });
    }
    /**
     * Checks if the collection includes a value with the key `key`.
     */ hasIn(path) {
        const [key, ...rest] = path;
        if (rest.length === 0) return this.has(key);
        const node = this.get(key, true);
        return $FOECb.isCollection(node) ? node.hasIn(rest) : false;
    }
    /**
     * Sets a value in this collection. For `!!set`, `value` needs to be a
     * boolean to add/remove the item from the set.
     */ setIn(path, value) {
        const [key, ...rest] = path;
        if (rest.length === 0) this.set(key, value);
        else {
            const node = this.get(key, true);
            if ($FOECb.isCollection(node)) node.setIn(rest, value);
            else if (node === undefined && this.schema) this.set(key, $b9a9db7ddcce63c3$var$collectionFromPath(this.schema, rest, value));
            else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
    }
}
$b9a9db7ddcce63c3$export$fb8073518f34e6ec = $b9a9db7ddcce63c3$var$Collection;
$b9a9db7ddcce63c3$export$f5ac8bc6072340dd = $b9a9db7ddcce63c3$var$collectionFromPath;
$b9a9db7ddcce63c3$export$e3bfca790bd8f9da = $b9a9db7ddcce63c3$var$isEmptyPath;

});
parcelRegister("64cbc", function(module, exports) {

$parcel$export(module.exports, "createNode", () => $46ac9069b123df95$export$270e7ba5936d3c48, (v) => $46ac9069b123df95$export$270e7ba5936d3c48 = v);
var $46ac9069b123df95$export$270e7ba5936d3c48;
"use strict";

var $jOHGy = parcelRequire("jOHGy");

var $FOECb = parcelRequire("FOECb");

var $d6XNP = parcelRequire("d6XNP");
const $46ac9069b123df95$var$defaultTagPrefix = "tag:yaml.org,2002:";
function $46ac9069b123df95$var$findTagObject(value, tagName, tags) {
    if (tagName) {
        const match = tags.filter((t)=>t.tag === tagName);
        const tagObj = match.find((t)=>!t.format) ?? match[0];
        if (!tagObj) throw new Error(`Tag ${tagName} not found`);
        return tagObj;
    }
    return tags.find((t)=>t.identify?.(value) && !t.format);
}
function $46ac9069b123df95$var$createNode(value, tagName, ctx) {
    if ($FOECb.isDocument(value)) value = value.contents;
    if ($FOECb.isNode(value)) return value;
    if ($FOECb.isPair(value)) {
        const map = ctx.schema[$FOECb.MAP].createNode?.(ctx.schema, null, ctx);
        map.items.push(value);
        return map;
    }
    if (value instanceof String || value instanceof Number || value instanceof Boolean || typeof BigInt !== "undefined" && value instanceof BigInt // not supported everywhere
    ) // https://tc39.es/ecma262/#sec-serializejsonproperty
    value = value.valueOf();
    const { aliasDuplicateObjects: aliasDuplicateObjects, onAnchor: onAnchor, onTagObj: onTagObj, schema: schema, sourceObjects: sourceObjects } = ctx;
    // Detect duplicate references to the same object & use Alias nodes for all
    // after first. The `ref` wrapper allows for circular references to resolve.
    let ref = undefined;
    if (aliasDuplicateObjects && value && typeof value === "object") {
        ref = sourceObjects.get(value);
        if (ref) {
            if (!ref.anchor) ref.anchor = onAnchor(value);
            return new $jOHGy.Alias(ref.anchor);
        } else {
            ref = {
                anchor: null,
                node: null
            };
            sourceObjects.set(value, ref);
        }
    }
    if (tagName?.startsWith("!!")) tagName = $46ac9069b123df95$var$defaultTagPrefix + tagName.slice(2);
    let tagObj = $46ac9069b123df95$var$findTagObject(value, tagName, schema.tags);
    if (!tagObj) {
        if (value && typeof value.toJSON === "function") // eslint-disable-next-line @typescript-eslint/no-unsafe-call
        value = value.toJSON();
        if (!value || typeof value !== "object") {
            const node = new $d6XNP.Scalar(value);
            if (ref) ref.node = node;
            return node;
        }
        tagObj = value instanceof Map ? schema[$FOECb.MAP] : Symbol.iterator in Object(value) ? schema[$FOECb.SEQ] : schema[$FOECb.MAP];
    }
    if (onTagObj) {
        onTagObj(tagObj);
        delete ctx.onTagObj;
    }
    const node = tagObj?.createNode ? tagObj.createNode(ctx.schema, value, ctx) : typeof tagObj?.nodeClass?.from === "function" ? tagObj.nodeClass.from(ctx.schema, value, ctx) : new $d6XNP.Scalar(value);
    if (tagName) node.tag = tagName;
    else if (!tagObj.default) node.tag = tagObj.tag;
    if (ref) ref.node = node;
    return node;
}
$46ac9069b123df95$export$270e7ba5936d3c48 = $46ac9069b123df95$var$createNode;

});
parcelRegister("d6XNP", function(module, exports) {

$parcel$export(module.exports, "Scalar", () => $98ba397b2e34bd21$export$595dbf49c602a1f, (v) => $98ba397b2e34bd21$export$595dbf49c602a1f = v);
$parcel$export(module.exports, "isScalarValue", () => $98ba397b2e34bd21$export$dc071f102752d0eb, (v) => $98ba397b2e34bd21$export$dc071f102752d0eb = v);
var $98ba397b2e34bd21$export$595dbf49c602a1f;
var $98ba397b2e34bd21$export$dc071f102752d0eb;
"use strict";

var $FOECb = parcelRequire("FOECb");

var $g3flb = parcelRequire("g3flb");

var $jeFb3 = parcelRequire("jeFb3");
const $98ba397b2e34bd21$var$isScalarValue = (value)=>!value || typeof value !== "function" && typeof value !== "object";
class $98ba397b2e34bd21$var$Scalar extends $g3flb.NodeBase {
    constructor(value){
        super($FOECb.SCALAR);
        this.value = value;
    }
    toJSON(arg, ctx) {
        return ctx?.keep ? this.value : $jeFb3.toJS(this.value, arg, ctx);
    }
    toString() {
        return String(this.value);
    }
}
$98ba397b2e34bd21$var$Scalar.BLOCK_FOLDED = "BLOCK_FOLDED";
$98ba397b2e34bd21$var$Scalar.BLOCK_LITERAL = "BLOCK_LITERAL";
$98ba397b2e34bd21$var$Scalar.PLAIN = "PLAIN";
$98ba397b2e34bd21$var$Scalar.QUOTE_DOUBLE = "QUOTE_DOUBLE";
$98ba397b2e34bd21$var$Scalar.QUOTE_SINGLE = "QUOTE_SINGLE";
$98ba397b2e34bd21$export$595dbf49c602a1f = $98ba397b2e34bd21$var$Scalar;
$98ba397b2e34bd21$export$dc071f102752d0eb = $98ba397b2e34bd21$var$isScalarValue;

});



parcelRegister("5ff4n", function(module, exports) {

$parcel$export(module.exports, "Pair", () => $3d1a0af462083b0f$export$d63d7cff08fe4dc9, (v) => $3d1a0af462083b0f$export$d63d7cff08fe4dc9 = v);
$parcel$export(module.exports, "createPair", () => $3d1a0af462083b0f$export$afe19f123272774, (v) => $3d1a0af462083b0f$export$afe19f123272774 = v);
var $3d1a0af462083b0f$export$d63d7cff08fe4dc9;
var $3d1a0af462083b0f$export$afe19f123272774;
"use strict";

var $64cbc = parcelRequire("64cbc");

var $aH17W = parcelRequire("aH17W");

var $bz3cv = parcelRequire("bz3cv");

var $FOECb = parcelRequire("FOECb");
function $3d1a0af462083b0f$var$createPair(key, value, ctx) {
    const k = $64cbc.createNode(key, undefined, ctx);
    const v = $64cbc.createNode(value, undefined, ctx);
    return new $3d1a0af462083b0f$var$Pair(k, v);
}
class $3d1a0af462083b0f$var$Pair {
    constructor(key, value = null){
        Object.defineProperty(this, $FOECb.NODE_TYPE, {
            value: $FOECb.PAIR
        });
        this.key = key;
        this.value = value;
    }
    clone(schema) {
        let { key: key, value: value } = this;
        if ($FOECb.isNode(key)) key = key.clone(schema);
        if ($FOECb.isNode(value)) value = value.clone(schema);
        return new $3d1a0af462083b0f$var$Pair(key, value);
    }
    toJSON(_, ctx) {
        const pair = ctx?.mapAsMap ? new Map() : {};
        return $bz3cv.addPairToJSMap(ctx, pair, this);
    }
    toString(ctx, onComment, onChompKeep) {
        return ctx?.doc ? $aH17W.stringifyPair(this, ctx, onComment, onChompKeep) : JSON.stringify(this);
    }
}
$3d1a0af462083b0f$export$d63d7cff08fe4dc9 = $3d1a0af462083b0f$var$Pair;
$3d1a0af462083b0f$export$afe19f123272774 = $3d1a0af462083b0f$var$createPair;

});
parcelRegister("aH17W", function(module, exports) {

$parcel$export(module.exports, "stringifyPair", () => $7c8ecb5405315a44$export$fffacbb893c76683, (v) => $7c8ecb5405315a44$export$fffacbb893c76683 = v);
var $7c8ecb5405315a44$export$fffacbb893c76683;
"use strict";

var $FOECb = parcelRequire("FOECb");

var $d6XNP = parcelRequire("d6XNP");

var $l36TR = parcelRequire("l36TR");

var $4joNE = parcelRequire("4joNE");
function $7c8ecb5405315a44$var$stringifyPair({ key: key, value: value }, ctx, onComment, onChompKeep) {
    const { allNullValues: allNullValues, doc: doc, indent: indent, indentStep: indentStep, options: { commentString: commentString, indentSeq: indentSeq, simpleKeys: simpleKeys } } = ctx;
    let keyComment = $FOECb.isNode(key) && key.comment || null;
    if (simpleKeys) {
        if (keyComment) throw new Error("With simple keys, key nodes cannot have comments");
        if ($FOECb.isCollection(key) || !$FOECb.isNode(key) && typeof key === "object") {
            const msg = "With simple keys, collection cannot be used as a key value";
            throw new Error(msg);
        }
    }
    let explicitKey = !simpleKeys && (!key || keyComment && value == null && !ctx.inFlow || $FOECb.isCollection(key) || ($FOECb.isScalar(key) ? key.type === $d6XNP.Scalar.BLOCK_FOLDED || key.type === $d6XNP.Scalar.BLOCK_LITERAL : typeof key === "object"));
    ctx = Object.assign({}, ctx, {
        allNullValues: false,
        implicitKey: !explicitKey && (simpleKeys || !allNullValues),
        indent: indent + indentStep
    });
    let keyCommentDone = false;
    let chompKeep = false;
    let str = $l36TR.stringify(key, ctx, ()=>keyCommentDone = true, ()=>chompKeep = true);
    if (!explicitKey && !ctx.inFlow && str.length > 1024) {
        if (simpleKeys) throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
        explicitKey = true;
    }
    if (ctx.inFlow) {
        if (allNullValues || value == null) {
            if (keyCommentDone && onComment) onComment();
            return str === "" ? "?" : explicitKey ? `? ${str}` : str;
        }
    } else if (allNullValues && !simpleKeys || value == null && explicitKey) {
        str = `? ${str}`;
        if (keyComment && !keyCommentDone) str += $4joNE.lineComment(str, ctx.indent, commentString(keyComment));
        else if (chompKeep && onChompKeep) onChompKeep();
        return str;
    }
    if (keyCommentDone) keyComment = null;
    if (explicitKey) {
        if (keyComment) str += $4joNE.lineComment(str, ctx.indent, commentString(keyComment));
        str = `? ${str}\n${indent}:`;
    } else {
        str = `${str}:`;
        if (keyComment) str += $4joNE.lineComment(str, ctx.indent, commentString(keyComment));
    }
    let vsb, vcb, valueComment;
    if ($FOECb.isNode(value)) {
        vsb = !!value.spaceBefore;
        vcb = value.commentBefore;
        valueComment = value.comment;
    } else {
        vsb = false;
        vcb = null;
        valueComment = null;
        if (value && typeof value === "object") value = doc.createNode(value);
    }
    ctx.implicitKey = false;
    if (!explicitKey && !keyComment && $FOECb.isScalar(value)) ctx.indentAtStart = str.length + 1;
    chompKeep = false;
    if (!indentSeq && indentStep.length >= 2 && !ctx.inFlow && !explicitKey && $FOECb.isSeq(value) && !value.flow && !value.tag && !value.anchor) // If indentSeq === false, consider '- ' as part of indentation where possible
    ctx.indent = ctx.indent.substring(2);
    let valueCommentDone = false;
    const valueStr = $l36TR.stringify(value, ctx, ()=>valueCommentDone = true, ()=>chompKeep = true);
    let ws = " ";
    if (keyComment || vsb || vcb) {
        ws = vsb ? "\n" : "";
        if (vcb) {
            const cs = commentString(vcb);
            ws += `\n${$4joNE.indentComment(cs, ctx.indent)}`;
        }
        if (valueStr === "" && !ctx.inFlow) {
            if (ws === "\n") ws = "\n\n";
        } else ws += `\n${ctx.indent}`;
    } else if (!explicitKey && $FOECb.isCollection(value)) {
        const vs0 = valueStr[0];
        const nl0 = valueStr.indexOf("\n");
        const hasNewline = nl0 !== -1;
        const flow = ctx.inFlow ?? value.flow ?? value.items.length === 0;
        if (hasNewline || !flow) {
            let hasPropsLine = false;
            if (hasNewline && (vs0 === "&" || vs0 === "!")) {
                let sp0 = valueStr.indexOf(" ");
                if (vs0 === "&" && sp0 !== -1 && sp0 < nl0 && valueStr[sp0 + 1] === "!") sp0 = valueStr.indexOf(" ", sp0 + 1);
                if (sp0 === -1 || nl0 < sp0) hasPropsLine = true;
            }
            if (!hasPropsLine) ws = `\n${ctx.indent}`;
        }
    } else if (valueStr === "" || valueStr[0] === "\n") ws = "";
    str += ws + valueStr;
    if (ctx.inFlow) {
        if (valueCommentDone && onComment) onComment();
    } else if (valueComment && !valueCommentDone) str += $4joNE.lineComment(str, ctx.indent, commentString(valueComment));
    else if (chompKeep && onChompKeep) onChompKeep();
    return str;
}
$7c8ecb5405315a44$export$fffacbb893c76683 = $7c8ecb5405315a44$var$stringifyPair;

});
parcelRegister("l36TR", function(module, exports) {

$parcel$export(module.exports, "createStringifyContext", () => $f52f3afa4a5dfa45$export$829faaf53c257c4d, (v) => $f52f3afa4a5dfa45$export$829faaf53c257c4d = v);
$parcel$export(module.exports, "stringify", () => $f52f3afa4a5dfa45$export$fac44ee5b035f737, (v) => $f52f3afa4a5dfa45$export$fac44ee5b035f737 = v);
var $f52f3afa4a5dfa45$export$829faaf53c257c4d;
var $f52f3afa4a5dfa45$export$fac44ee5b035f737;
"use strict";

var $6JDBj = parcelRequire("6JDBj");

var $FOECb = parcelRequire("FOECb");

var $4joNE = parcelRequire("4joNE");

var $e5c0t = parcelRequire("e5c0t");
function $f52f3afa4a5dfa45$var$createStringifyContext(doc, options) {
    const opt = Object.assign({
        blockQuote: true,
        commentString: $4joNE.stringifyComment,
        defaultKeyType: null,
        defaultStringType: "PLAIN",
        directives: null,
        doubleQuotedAsJSON: false,
        doubleQuotedMinMultiLineLength: 40,
        falseStr: "false",
        flowCollectionPadding: true,
        indentSeq: true,
        lineWidth: 80,
        minContentWidth: 20,
        nullStr: "null",
        simpleKeys: false,
        singleQuote: null,
        trueStr: "true",
        verifyAliasOrder: true
    }, doc.schema.toStringOptions, options);
    let inFlow;
    switch(opt.collectionStyle){
        case "block":
            inFlow = false;
            break;
        case "flow":
            inFlow = true;
            break;
        default:
            inFlow = null;
    }
    return {
        anchors: new Set(),
        doc: doc,
        flowCollectionPadding: opt.flowCollectionPadding ? " " : "",
        indent: "",
        indentStep: typeof opt.indent === "number" ? " ".repeat(opt.indent) : "  ",
        inFlow: inFlow,
        options: opt
    };
}
function $f52f3afa4a5dfa45$var$getTagObject(tags, item) {
    if (item.tag) {
        const match = tags.filter((t)=>t.tag === item.tag);
        if (match.length > 0) return match.find((t)=>t.format === item.format) ?? match[0];
    }
    let tagObj = undefined;
    let obj;
    if ($FOECb.isScalar(item)) {
        obj = item.value;
        let match = tags.filter((t)=>t.identify?.(obj));
        if (match.length > 1) {
            const testMatch = match.filter((t)=>t.test);
            if (testMatch.length > 0) match = testMatch;
        }
        tagObj = match.find((t)=>t.format === item.format) ?? match.find((t)=>!t.format);
    } else {
        obj = item;
        tagObj = tags.find((t)=>t.nodeClass && obj instanceof t.nodeClass);
    }
    if (!tagObj) {
        const name = obj?.constructor?.name ?? typeof obj;
        throw new Error(`Tag not resolved for ${name} value`);
    }
    return tagObj;
}
// needs to be called before value stringifier to allow for circular anchor refs
function $f52f3afa4a5dfa45$var$stringifyProps(node, tagObj, { anchors: anchors$1, doc: doc }) {
    if (!doc.directives) return "";
    const props = [];
    const anchor = ($FOECb.isScalar(node) || $FOECb.isCollection(node)) && node.anchor;
    if (anchor && $6JDBj.anchorIsValid(anchor)) {
        anchors$1.add(anchor);
        props.push(`&${anchor}`);
    }
    const tag = node.tag ? node.tag : tagObj.default ? null : tagObj.tag;
    if (tag) props.push(doc.directives.tagString(tag));
    return props.join(" ");
}
function $f52f3afa4a5dfa45$var$stringify(item, ctx, onComment, onChompKeep) {
    if ($FOECb.isPair(item)) return item.toString(ctx, onComment, onChompKeep);
    if ($FOECb.isAlias(item)) {
        if (ctx.doc.directives) return item.toString(ctx);
        if (ctx.resolvedAliases?.has(item)) throw new TypeError(`Cannot stringify circular structure without alias nodes`);
        else {
            if (ctx.resolvedAliases) ctx.resolvedAliases.add(item);
            else ctx.resolvedAliases = new Set([
                item
            ]);
            item = item.resolve(ctx.doc);
        }
    }
    let tagObj = undefined;
    const node = $FOECb.isNode(item) ? item : ctx.doc.createNode(item, {
        onTagObj: (o)=>tagObj = o
    });
    if (!tagObj) tagObj = $f52f3afa4a5dfa45$var$getTagObject(ctx.doc.schema.tags, node);
    const props = $f52f3afa4a5dfa45$var$stringifyProps(node, tagObj, ctx);
    if (props.length > 0) ctx.indentAtStart = (ctx.indentAtStart ?? 0) + props.length + 1;
    const str = typeof tagObj.stringify === "function" ? tagObj.stringify(node, ctx, onComment, onChompKeep) : $FOECb.isScalar(node) ? $e5c0t.stringifyString(node, ctx, onComment, onChompKeep) : node.toString(ctx, onComment, onChompKeep);
    if (!props) return str;
    return $FOECb.isScalar(node) || str[0] === "{" || str[0] === "[" ? `${props} ${str}` : `${props}\n${ctx.indent}${str}`;
}
$f52f3afa4a5dfa45$export$829faaf53c257c4d = $f52f3afa4a5dfa45$var$createStringifyContext;
$f52f3afa4a5dfa45$export$fac44ee5b035f737 = $f52f3afa4a5dfa45$var$stringify;

});
parcelRegister("4joNE", function(module, exports) {

$parcel$export(module.exports, "indentComment", () => $323c2c7d4c154d4f$export$9933eb161eea191d, (v) => $323c2c7d4c154d4f$export$9933eb161eea191d = v);
$parcel$export(module.exports, "lineComment", () => $323c2c7d4c154d4f$export$5d080f5a78d4f5b3, (v) => $323c2c7d4c154d4f$export$5d080f5a78d4f5b3 = v);
$parcel$export(module.exports, "stringifyComment", () => $323c2c7d4c154d4f$export$bda2970260483e9e, (v) => $323c2c7d4c154d4f$export$bda2970260483e9e = v);
var $323c2c7d4c154d4f$export$9933eb161eea191d;
var $323c2c7d4c154d4f$export$5d080f5a78d4f5b3;
var $323c2c7d4c154d4f$export$bda2970260483e9e;
"use strict";
/**
 * Stringifies a comment.
 *
 * Empty comment lines are left empty,
 * lines consisting of a single space are replaced by `#`,
 * and all other lines are prefixed with a `#`.
 */ const $323c2c7d4c154d4f$var$stringifyComment = (str)=>str.replace(/^(?!$)(?: $)?/gm, "#");
function $323c2c7d4c154d4f$var$indentComment(comment, indent) {
    if (/^\n+$/.test(comment)) return comment.substring(1);
    return indent ? comment.replace(/^(?! *$)/gm, indent) : comment;
}
const $323c2c7d4c154d4f$var$lineComment = (str, indent, comment)=>str.endsWith("\n") ? $323c2c7d4c154d4f$var$indentComment(comment, indent) : comment.includes("\n") ? "\n" + $323c2c7d4c154d4f$var$indentComment(comment, indent) : (str.endsWith(" ") ? "" : " ") + comment;
$323c2c7d4c154d4f$export$9933eb161eea191d = $323c2c7d4c154d4f$var$indentComment;
$323c2c7d4c154d4f$export$5d080f5a78d4f5b3 = $323c2c7d4c154d4f$var$lineComment;
$323c2c7d4c154d4f$export$bda2970260483e9e = $323c2c7d4c154d4f$var$stringifyComment;

});

parcelRegister("e5c0t", function(module, exports) {

$parcel$export(module.exports, "stringifyString", () => $a40ad897a4e2a181$export$3457ffbf9a1af5aa, (v) => $a40ad897a4e2a181$export$3457ffbf9a1af5aa = v);
var $a40ad897a4e2a181$export$3457ffbf9a1af5aa;
"use strict";

var $d6XNP = parcelRequire("d6XNP");

var $4uly9 = parcelRequire("4uly9");
const $a40ad897a4e2a181$var$getFoldOptions = (ctx, isBlock)=>({
        indentAtStart: isBlock ? ctx.indent.length : ctx.indentAtStart,
        lineWidth: ctx.options.lineWidth,
        minContentWidth: ctx.options.minContentWidth
    });
// Also checks for lines starting with %, as parsing the output as YAML 1.1 will
// presume that's starting a new document.
const $a40ad897a4e2a181$var$containsDocumentMarker = (str)=>/^(%|---|\.\.\.)/m.test(str);
function $a40ad897a4e2a181$var$lineLengthOverLimit(str, lineWidth, indentLength) {
    if (!lineWidth || lineWidth < 0) return false;
    const limit = lineWidth - indentLength;
    const strLen = str.length;
    if (strLen <= limit) return false;
    for(let i = 0, start = 0; i < strLen; ++i)if (str[i] === "\n") {
        if (i - start > limit) return true;
        start = i + 1;
        if (strLen - start <= limit) return false;
    }
    return true;
}
function $a40ad897a4e2a181$var$doubleQuotedString(value, ctx) {
    const json = JSON.stringify(value);
    if (ctx.options.doubleQuotedAsJSON) return json;
    const { implicitKey: implicitKey } = ctx;
    const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
    const indent = ctx.indent || ($a40ad897a4e2a181$var$containsDocumentMarker(value) ? "  " : "");
    let str = "";
    let start = 0;
    for(let i = 0, ch = json[i]; ch; ch = json[++i]){
        if (ch === " " && json[i + 1] === "\\" && json[i + 2] === "n") {
            // space before newline needs to be escaped to not be folded
            str += json.slice(start, i) + "\\ ";
            i += 1;
            start = i;
            ch = "\\";
        }
        if (ch === "\\") switch(json[i + 1]){
            case "u":
                {
                    str += json.slice(start, i);
                    const code = json.substr(i + 2, 4);
                    switch(code){
                        case "0000":
                            str += "\\0";
                            break;
                        case "0007":
                            str += "\\a";
                            break;
                        case "000b":
                            str += "\\v";
                            break;
                        case "001b":
                            str += "\\e";
                            break;
                        case "0085":
                            str += "\\N";
                            break;
                        case "00a0":
                            str += "\\_";
                            break;
                        case "2028":
                            str += "\\L";
                            break;
                        case "2029":
                            str += "\\P";
                            break;
                        default:
                            if (code.substr(0, 2) === "00") str += "\\x" + code.substr(2);
                            else str += json.substr(i, 6);
                    }
                    i += 5;
                    start = i + 1;
                }
                break;
            case "n":
                if (implicitKey || json[i + 2] === '"' || json.length < minMultiLineLength) i += 1;
                else {
                    // folding will eat first newline
                    str += json.slice(start, i) + "\n\n";
                    while(json[i + 2] === "\\" && json[i + 3] === "n" && json[i + 4] !== '"'){
                        str += "\n";
                        i += 2;
                    }
                    str += indent;
                    // space after newline needs to be escaped to not be folded
                    if (json[i + 2] === " ") str += "\\";
                    i += 1;
                    start = i + 1;
                }
                break;
            default:
                i += 1;
        }
    }
    str = start ? str + json.slice(start) : json;
    return implicitKey ? str : $4uly9.foldFlowLines(str, indent, $4uly9.FOLD_QUOTED, $a40ad897a4e2a181$var$getFoldOptions(ctx, false));
}
function $a40ad897a4e2a181$var$singleQuotedString(value, ctx) {
    if (ctx.options.singleQuote === false || ctx.implicitKey && value.includes("\n") || /[ \t]\n|\n[ \t]/.test(value) // single quoted string can't have leading or trailing whitespace around newline
    ) return $a40ad897a4e2a181$var$doubleQuotedString(value, ctx);
    const indent = ctx.indent || ($a40ad897a4e2a181$var$containsDocumentMarker(value) ? "  " : "");
    const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&\n${indent}`) + "'";
    return ctx.implicitKey ? res : $4uly9.foldFlowLines(res, indent, $4uly9.FOLD_FLOW, $a40ad897a4e2a181$var$getFoldOptions(ctx, false));
}
function $a40ad897a4e2a181$var$quotedString(value, ctx) {
    const { singleQuote: singleQuote } = ctx.options;
    let qs;
    if (singleQuote === false) qs = $a40ad897a4e2a181$var$doubleQuotedString;
    else {
        const hasDouble = value.includes('"');
        const hasSingle = value.includes("'");
        if (hasDouble && !hasSingle) qs = $a40ad897a4e2a181$var$singleQuotedString;
        else if (hasSingle && !hasDouble) qs = $a40ad897a4e2a181$var$doubleQuotedString;
        else qs = singleQuote ? $a40ad897a4e2a181$var$singleQuotedString : $a40ad897a4e2a181$var$doubleQuotedString;
    }
    return qs(value, ctx);
}
// The negative lookbehind avoids a polynomial search,
// but isn't supported yet on Safari: https://caniuse.com/js-regexp-lookbehind
let $a40ad897a4e2a181$var$blockEndNewlines;
try {
    $a40ad897a4e2a181$var$blockEndNewlines = new RegExp("(^|(?<!\n))\n+(?!\n|$)", "g");
} catch  {
    $a40ad897a4e2a181$var$blockEndNewlines = /\n+(?!\n|$)/g;
}
function $a40ad897a4e2a181$var$blockString({ comment: comment, type: type, value: value }, ctx, onComment, onChompKeep) {
    const { blockQuote: blockQuote, commentString: commentString, lineWidth: lineWidth } = ctx.options;
    // 1. Block can't end in whitespace unless the last line is non-empty.
    // 2. Strings consisting of only whitespace are best rendered explicitly.
    if (!blockQuote || /\n[\t ]+$/.test(value) || /^\s*$/.test(value)) return $a40ad897a4e2a181$var$quotedString(value, ctx);
    const indent = ctx.indent || (ctx.forceBlockIndent || $a40ad897a4e2a181$var$containsDocumentMarker(value) ? "  " : "");
    const literal = blockQuote === "literal" ? true : blockQuote === "folded" || type === $d6XNP.Scalar.BLOCK_FOLDED ? false : type === $d6XNP.Scalar.BLOCK_LITERAL ? true : !$a40ad897a4e2a181$var$lineLengthOverLimit(value, lineWidth, indent.length);
    if (!value) return literal ? "|\n" : ">\n";
    // determine chomping from whitespace at value end
    let chomp;
    let endStart;
    for(endStart = value.length; endStart > 0; --endStart){
        const ch = value[endStart - 1];
        if (ch !== "\n" && ch !== "	" && ch !== " ") break;
    }
    let end = value.substring(endStart);
    const endNlPos = end.indexOf("\n");
    if (endNlPos === -1) chomp = "-"; // strip
    else if (value === end || endNlPos !== end.length - 1) {
        chomp = "+"; // keep
        if (onChompKeep) onChompKeep();
    } else chomp = ""; // clip
    if (end) {
        value = value.slice(0, -end.length);
        if (end[end.length - 1] === "\n") end = end.slice(0, -1);
        end = end.replace($a40ad897a4e2a181$var$blockEndNewlines, `$&${indent}`);
    }
    // determine indent indicator from whitespace at value start
    let startWithSpace = false;
    let startEnd;
    let startNlPos = -1;
    for(startEnd = 0; startEnd < value.length; ++startEnd){
        const ch = value[startEnd];
        if (ch === " ") startWithSpace = true;
        else if (ch === "\n") startNlPos = startEnd;
        else break;
    }
    let start = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
    if (start) {
        value = value.substring(start.length);
        start = start.replace(/\n+/g, `$&${indent}`);
    }
    const indentSize = indent ? "2" : "1"; // root is at -1
    let header = (literal ? "|" : ">") + (startWithSpace ? indentSize : "") + chomp;
    if (comment) {
        header += " " + commentString(comment.replace(/ ?[\r\n]+/g, " "));
        if (onComment) onComment();
    }
    if (literal) {
        value = value.replace(/\n+/g, `$&${indent}`);
        return `${header}\n${indent}${start}${value}${end}`;
    }
    value = value.replace(/\n+/g, "\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2") // more-indented lines aren't folded
    //                ^ more-ind. ^ empty     ^ capture next empty lines only at end of indent
    .replace(/\n+/g, `$&${indent}`);
    const body = $4uly9.foldFlowLines(`${start}${value}${end}`, indent, $4uly9.FOLD_BLOCK, $a40ad897a4e2a181$var$getFoldOptions(ctx, true));
    return `${header}\n${indent}${body}`;
}
function $a40ad897a4e2a181$var$plainString(item, ctx, onComment, onChompKeep) {
    const { type: type, value: value } = item;
    const { actualString: actualString, implicitKey: implicitKey, indent: indent, indentStep: indentStep, inFlow: inFlow } = ctx;
    if (implicitKey && value.includes("\n") || inFlow && /[[\]{},]/.test(value)) return $a40ad897a4e2a181$var$quotedString(value, ctx);
    if (!value || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) // not allowed:
    // - empty string, '-' or '?'
    // - start with an indicator character (except [?:-]) or /[?-] /
    // - '\n ', ': ' or ' \n' anywhere
    // - '#' not preceded by a non-space char
    // - end with ' ' or ':'
    return implicitKey || inFlow || !value.includes("\n") ? $a40ad897a4e2a181$var$quotedString(value, ctx) : $a40ad897a4e2a181$var$blockString(item, ctx, onComment, onChompKeep);
    if (!implicitKey && !inFlow && type !== $d6XNP.Scalar.PLAIN && value.includes("\n")) // Where allowed & type not set explicitly, prefer block style for multiline strings
    return $a40ad897a4e2a181$var$blockString(item, ctx, onComment, onChompKeep);
    if ($a40ad897a4e2a181$var$containsDocumentMarker(value)) {
        if (indent === "") {
            ctx.forceBlockIndent = true;
            return $a40ad897a4e2a181$var$blockString(item, ctx, onComment, onChompKeep);
        } else if (implicitKey && indent === indentStep) return $a40ad897a4e2a181$var$quotedString(value, ctx);
    }
    const str = value.replace(/\n+/g, `$&\n${indent}`);
    // Verify that output will be parsed as a string, as e.g. plain numbers and
    // booleans get parsed with those types in v1.2 (e.g. '42', 'true' & '0.9e-3'),
    // and others in v1.1.
    if (actualString) {
        const test = (tag)=>tag.default && tag.tag !== "tag:yaml.org,2002:str" && tag.test?.test(str);
        const { compat: compat, tags: tags } = ctx.doc.schema;
        if (tags.some(test) || compat?.some(test)) return $a40ad897a4e2a181$var$quotedString(value, ctx);
    }
    return implicitKey ? str : $4uly9.foldFlowLines(str, indent, $4uly9.FOLD_FLOW, $a40ad897a4e2a181$var$getFoldOptions(ctx, false));
}
function $a40ad897a4e2a181$var$stringifyString(item, ctx, onComment, onChompKeep) {
    const { implicitKey: implicitKey, inFlow: inFlow } = ctx;
    const ss = typeof item.value === "string" ? item : Object.assign({}, item, {
        value: String(item.value)
    });
    let { type: type } = item;
    if (type !== $d6XNP.Scalar.QUOTE_DOUBLE) // force double quotes on control characters & unpaired surrogates
    {
        if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value)) type = $d6XNP.Scalar.QUOTE_DOUBLE;
    }
    const _stringify = (_type)=>{
        switch(_type){
            case $d6XNP.Scalar.BLOCK_FOLDED:
            case $d6XNP.Scalar.BLOCK_LITERAL:
                return implicitKey || inFlow ? $a40ad897a4e2a181$var$quotedString(ss.value, ctx) // blocks are not valid inside flow containers
                 : $a40ad897a4e2a181$var$blockString(ss, ctx, onComment, onChompKeep);
            case $d6XNP.Scalar.QUOTE_DOUBLE:
                return $a40ad897a4e2a181$var$doubleQuotedString(ss.value, ctx);
            case $d6XNP.Scalar.QUOTE_SINGLE:
                return $a40ad897a4e2a181$var$singleQuotedString(ss.value, ctx);
            case $d6XNP.Scalar.PLAIN:
                return $a40ad897a4e2a181$var$plainString(ss, ctx, onComment, onChompKeep);
            default:
                return null;
        }
    };
    let res = _stringify(type);
    if (res === null) {
        const { defaultKeyType: defaultKeyType, defaultStringType: defaultStringType } = ctx.options;
        const t = implicitKey && defaultKeyType || defaultStringType;
        res = _stringify(t);
        if (res === null) throw new Error(`Unsupported default string type ${t}`);
    }
    return res;
}
$a40ad897a4e2a181$export$3457ffbf9a1af5aa = $a40ad897a4e2a181$var$stringifyString;

});
parcelRegister("4uly9", function(module, exports) {

$parcel$export(module.exports, "FOLD_BLOCK", () => $344aae1e4205c6b3$export$609fbd56c8a85825, (v) => $344aae1e4205c6b3$export$609fbd56c8a85825 = v);
$parcel$export(module.exports, "FOLD_FLOW", () => $344aae1e4205c6b3$export$dfafce8168b25546, (v) => $344aae1e4205c6b3$export$dfafce8168b25546 = v);
$parcel$export(module.exports, "FOLD_QUOTED", () => $344aae1e4205c6b3$export$74d9ae4055c4d6cf, (v) => $344aae1e4205c6b3$export$74d9ae4055c4d6cf = v);
$parcel$export(module.exports, "foldFlowLines", () => $344aae1e4205c6b3$export$e82a5ab0b770aa09, (v) => $344aae1e4205c6b3$export$e82a5ab0b770aa09 = v);
var $344aae1e4205c6b3$export$609fbd56c8a85825;
var $344aae1e4205c6b3$export$dfafce8168b25546;
var $344aae1e4205c6b3$export$74d9ae4055c4d6cf;
var $344aae1e4205c6b3$export$e82a5ab0b770aa09;
"use strict";
const $344aae1e4205c6b3$var$FOLD_FLOW = "flow";
const $344aae1e4205c6b3$var$FOLD_BLOCK = "block";
const $344aae1e4205c6b3$var$FOLD_QUOTED = "quoted";
/**
 * Tries to keep input at up to `lineWidth` characters, splitting only on spaces
 * not followed by newlines or spaces unless `mode` is `'quoted'`. Lines are
 * terminated with `\n` and started with `indent`.
 */ function $344aae1e4205c6b3$var$foldFlowLines(text, indent, mode = "flow", { indentAtStart: indentAtStart, lineWidth: lineWidth = 80, minContentWidth: minContentWidth = 20, onFold: onFold, onOverflow: onOverflow } = {}) {
    if (!lineWidth || lineWidth < 0) return text;
    if (lineWidth < minContentWidth) minContentWidth = 0;
    const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
    if (text.length <= endStep) return text;
    const folds = [];
    const escapedFolds = {};
    let end = lineWidth - indent.length;
    if (typeof indentAtStart === "number") {
        if (indentAtStart > lineWidth - Math.max(2, minContentWidth)) folds.push(0);
        else end = lineWidth - indentAtStart;
    }
    let split = undefined;
    let prev = undefined;
    let overflow = false;
    let i = -1;
    let escStart = -1;
    let escEnd = -1;
    if (mode === $344aae1e4205c6b3$var$FOLD_BLOCK) {
        i = $344aae1e4205c6b3$var$consumeMoreIndentedLines(text, i, indent.length);
        if (i !== -1) end = i + endStep;
    }
    for(let ch; ch = text[i += 1];){
        if (mode === $344aae1e4205c6b3$var$FOLD_QUOTED && ch === "\\") {
            escStart = i;
            switch(text[i + 1]){
                case "x":
                    i += 3;
                    break;
                case "u":
                    i += 5;
                    break;
                case "U":
                    i += 9;
                    break;
                default:
                    i += 1;
            }
            escEnd = i;
        }
        if (ch === "\n") {
            if (mode === $344aae1e4205c6b3$var$FOLD_BLOCK) i = $344aae1e4205c6b3$var$consumeMoreIndentedLines(text, i, indent.length);
            end = i + indent.length + endStep;
            split = undefined;
        } else {
            if (ch === " " && prev && prev !== " " && prev !== "\n" && prev !== "	") {
                // space surrounded by non-space can be replaced with newline + indent
                const next = text[i + 1];
                if (next && next !== " " && next !== "\n" && next !== "	") split = i;
            }
            if (i >= end) {
                if (split) {
                    folds.push(split);
                    end = split + endStep;
                    split = undefined;
                } else if (mode === $344aae1e4205c6b3$var$FOLD_QUOTED) {
                    // white-space collected at end may stretch past lineWidth
                    while(prev === " " || prev === "	"){
                        prev = ch;
                        ch = text[i += 1];
                        overflow = true;
                    }
                    // Account for newline escape, but don't break preceding escape
                    const j = i > escEnd + 1 ? i - 2 : escStart - 1;
                    // Bail out if lineWidth & minContentWidth are shorter than an escape string
                    if (escapedFolds[j]) return text;
                    folds.push(j);
                    escapedFolds[j] = true;
                    end = j + endStep;
                    split = undefined;
                } else overflow = true;
            }
        }
        prev = ch;
    }
    if (overflow && onOverflow) onOverflow();
    if (folds.length === 0) return text;
    if (onFold) onFold();
    let res = text.slice(0, folds[0]);
    for(let i = 0; i < folds.length; ++i){
        const fold = folds[i];
        const end = folds[i + 1] || text.length;
        if (fold === 0) res = `\n${indent}${text.slice(0, end)}`;
        else {
            if (mode === $344aae1e4205c6b3$var$FOLD_QUOTED && escapedFolds[fold]) res += `${text[fold]}\\`;
            res += `\n${indent}${text.slice(fold + 1, end)}`;
        }
    }
    return res;
}
/**
 * Presumes `i + 1` is at the start of a line
 * @returns index of last newline in more-indented block
 */ function $344aae1e4205c6b3$var$consumeMoreIndentedLines(text, i, indent) {
    let end = i;
    let start = i + 1;
    let ch = text[start];
    while(ch === " " || ch === "	")if (i < start + indent) ch = text[++i];
    else {
        do ch = text[++i];
        while (ch && ch !== "\n");
        end = i;
        start = i + 1;
        ch = text[start];
    }
    return end;
}
$344aae1e4205c6b3$export$609fbd56c8a85825 = $344aae1e4205c6b3$var$FOLD_BLOCK;
$344aae1e4205c6b3$export$dfafce8168b25546 = $344aae1e4205c6b3$var$FOLD_FLOW;
$344aae1e4205c6b3$export$74d9ae4055c4d6cf = $344aae1e4205c6b3$var$FOLD_QUOTED;
$344aae1e4205c6b3$export$e82a5ab0b770aa09 = $344aae1e4205c6b3$var$foldFlowLines;

});




parcelRegister("bz3cv", function(module, exports) {

$parcel$export(module.exports, "addPairToJSMap", () => $86b57234933ac4f8$export$fdef4d6a4585851d, (v) => $86b57234933ac4f8$export$fdef4d6a4585851d = v);
var $86b57234933ac4f8$export$fdef4d6a4585851d;
"use strict";

var $f9S3O = parcelRequire("f9S3O");

var $kaXef = parcelRequire("kaXef");

var $l36TR = parcelRequire("l36TR");

var $FOECb = parcelRequire("FOECb");

var $jeFb3 = parcelRequire("jeFb3");
function $86b57234933ac4f8$var$addPairToJSMap(ctx, map, { key: key, value: value }) {
    if ($FOECb.isNode(key) && key.addToJSMap) key.addToJSMap(ctx, map, value);
    else if ($kaXef.isMergeKey(ctx, key)) $kaXef.addMergeToJSMap(ctx, map, value);
    else {
        const jsKey = $jeFb3.toJS(key, "", ctx);
        if (map instanceof Map) map.set(jsKey, $jeFb3.toJS(value, jsKey, ctx));
        else if (map instanceof Set) map.add(jsKey);
        else {
            const stringKey = $86b57234933ac4f8$var$stringifyKey(key, jsKey, ctx);
            const jsValue = $jeFb3.toJS(value, stringKey, ctx);
            if (stringKey in map) Object.defineProperty(map, stringKey, {
                value: jsValue,
                writable: true,
                enumerable: true,
                configurable: true
            });
            else map[stringKey] = jsValue;
        }
    }
    return map;
}
function $86b57234933ac4f8$var$stringifyKey(key, jsKey, ctx) {
    if (jsKey === null) return "";
    if (typeof jsKey !== "object") return String(jsKey);
    if ($FOECb.isNode(key) && ctx?.doc) {
        const strCtx = $l36TR.createStringifyContext(ctx.doc, {});
        strCtx.anchors = new Set();
        for (const node of ctx.anchors.keys())strCtx.anchors.add(node.anchor);
        strCtx.inFlow = true;
        strCtx.inStringifyKey = true;
        const strKey = key.toString(strCtx);
        if (!ctx.mapKeyWarned) {
            let jsonStr = JSON.stringify(strKey);
            if (jsonStr.length > 40) jsonStr = jsonStr.substring(0, 36) + '..."';
            $f9S3O.warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
            ctx.mapKeyWarned = true;
        }
        return strKey;
    }
    return JSON.stringify(jsKey);
}
$86b57234933ac4f8$export$fdef4d6a4585851d = $86b57234933ac4f8$var$addPairToJSMap;

});
parcelRegister("f9S3O", function(module, exports) {

$parcel$export(module.exports, "warn", () => $b091a19116788589$export$c106dd0671a0fc2d, (v) => $b091a19116788589$export$c106dd0671a0fc2d = v);
var $b091a19116788589$export$1c9f709888824e05;
var $b091a19116788589$export$c106dd0671a0fc2d;
"use strict";
function $b091a19116788589$var$debug(logLevel, ...messages) {
    if (logLevel === "debug") console.log(...messages);
}
function $b091a19116788589$var$warn(logLevel, warning) {
    if (logLevel === "debug" || logLevel === "warn") {
        if (typeof process !== "undefined" && process.emitWarning) process.emitWarning(warning);
        else console.warn(warning);
    }
}
$b091a19116788589$export$1c9f709888824e05 = $b091a19116788589$var$debug;
$b091a19116788589$export$c106dd0671a0fc2d = $b091a19116788589$var$warn;

});

parcelRegister("kaXef", function(module, exports) {

$parcel$export(module.exports, "addMergeToJSMap", () => $eb02af6ae93df880$export$962e267f4dc38d0f, (v) => $eb02af6ae93df880$export$962e267f4dc38d0f = v);
$parcel$export(module.exports, "isMergeKey", () => $eb02af6ae93df880$export$b51e55b44fb829b2, (v) => $eb02af6ae93df880$export$b51e55b44fb829b2 = v);
$parcel$export(module.exports, "merge", () => $eb02af6ae93df880$export$4950aa0f605343fb, (v) => $eb02af6ae93df880$export$4950aa0f605343fb = v);
var $eb02af6ae93df880$export$962e267f4dc38d0f;
var $eb02af6ae93df880$export$b51e55b44fb829b2;
var $eb02af6ae93df880$export$4950aa0f605343fb;
"use strict";

var $FOECb = parcelRequire("FOECb");

var $d6XNP = parcelRequire("d6XNP");
// If the value associated with a merge key is a single mapping node, each of
// its key/value pairs is inserted into the current mapping, unless the key
// already exists in it. If the value associated with the merge key is a
// sequence, then this sequence is expected to contain mapping nodes and each
// of these nodes is merged in turn according to its order in the sequence.
// Keys in mapping nodes earlier in the sequence override keys specified in
// later mapping nodes. -- http://yaml.org/type/merge.html
const $eb02af6ae93df880$var$MERGE_KEY = "<<";
const $eb02af6ae93df880$var$merge = {
    identify: (value)=>value === $eb02af6ae93df880$var$MERGE_KEY || typeof value === "symbol" && value.description === $eb02af6ae93df880$var$MERGE_KEY,
    default: "key",
    tag: "tag:yaml.org,2002:merge",
    test: /^<<$/,
    resolve: ()=>Object.assign(new $d6XNP.Scalar(Symbol($eb02af6ae93df880$var$MERGE_KEY)), {
            addToJSMap: $eb02af6ae93df880$var$addMergeToJSMap
        }),
    stringify: ()=>$eb02af6ae93df880$var$MERGE_KEY
};
const $eb02af6ae93df880$var$isMergeKey = (ctx, key)=>($eb02af6ae93df880$var$merge.identify(key) || $FOECb.isScalar(key) && (!key.type || key.type === $d6XNP.Scalar.PLAIN) && $eb02af6ae93df880$var$merge.identify(key.value)) && ctx?.doc.schema.tags.some((tag)=>tag.tag === $eb02af6ae93df880$var$merge.tag && tag.default);
function $eb02af6ae93df880$var$addMergeToJSMap(ctx, map, value) {
    value = ctx && $FOECb.isAlias(value) ? value.resolve(ctx.doc) : value;
    if ($FOECb.isSeq(value)) for (const it of value.items)$eb02af6ae93df880$var$mergeValue(ctx, map, it);
    else if (Array.isArray(value)) for (const it of value)$eb02af6ae93df880$var$mergeValue(ctx, map, it);
    else $eb02af6ae93df880$var$mergeValue(ctx, map, value);
}
function $eb02af6ae93df880$var$mergeValue(ctx, map, value) {
    const source = ctx && $FOECb.isAlias(value) ? value.resolve(ctx.doc) : value;
    if (!$FOECb.isMap(source)) throw new Error("Merge sources must be maps or map aliases");
    const srcMap = source.toJSON(null, ctx, Map);
    for (const [key, value] of srcMap){
        if (map instanceof Map) {
            if (!map.has(key)) map.set(key, value);
        } else if (map instanceof Set) map.add(key);
        else if (!Object.prototype.hasOwnProperty.call(map, key)) Object.defineProperty(map, key, {
            value: value,
            writable: true,
            enumerable: true,
            configurable: true
        });
    }
    return map;
}
$eb02af6ae93df880$export$962e267f4dc38d0f = $eb02af6ae93df880$var$addMergeToJSMap;
$eb02af6ae93df880$export$b51e55b44fb829b2 = $eb02af6ae93df880$var$isMergeKey;
$eb02af6ae93df880$export$4950aa0f605343fb = $eb02af6ae93df880$var$merge;

});



parcelRegister("9Z3DY", function(module, exports) {

$parcel$export(module.exports, "Schema", () => $744ca3215a8b1490$export$19342e026b58ebb7, (v) => $744ca3215a8b1490$export$19342e026b58ebb7 = v);
var $744ca3215a8b1490$export$19342e026b58ebb7;
"use strict";

var $FOECb = parcelRequire("FOECb");

var $7y6ZU = parcelRequire("7y6ZU");

var $6jftB = parcelRequire("6jftB");

var $az0E7 = parcelRequire("az0E7");

var $kEaIJ = parcelRequire("kEaIJ");
const $744ca3215a8b1490$var$sortMapEntriesByKey = (a, b)=>a.key < b.key ? -1 : a.key > b.key ? 1 : 0;
class $744ca3215a8b1490$var$Schema {
    constructor({ compat: compat, customTags: customTags, merge: merge, resolveKnownTags: resolveKnownTags, schema: schema, sortMapEntries: sortMapEntries, toStringDefaults: toStringDefaults }){
        this.compat = Array.isArray(compat) ? $kEaIJ.getTags(compat, "compat") : compat ? $kEaIJ.getTags(null, compat) : null;
        this.name = typeof schema === "string" && schema || "core";
        this.knownTags = resolveKnownTags ? $kEaIJ.coreKnownTags : {};
        this.tags = $kEaIJ.getTags(customTags, this.name, merge);
        this.toStringOptions = toStringDefaults ?? null;
        Object.defineProperty(this, $FOECb.MAP, {
            value: $7y6ZU.map
        });
        Object.defineProperty(this, $FOECb.SCALAR, {
            value: $az0E7.string
        });
        Object.defineProperty(this, $FOECb.SEQ, {
            value: $6jftB.seq
        });
        // Used by createMap()
        this.sortMapEntries = typeof sortMapEntries === "function" ? sortMapEntries : sortMapEntries === true ? $744ca3215a8b1490$var$sortMapEntriesByKey : null;
    }
    clone() {
        const copy = Object.create($744ca3215a8b1490$var$Schema.prototype, Object.getOwnPropertyDescriptors(this));
        copy.tags = this.tags.slice();
        return copy;
    }
}
$744ca3215a8b1490$export$19342e026b58ebb7 = $744ca3215a8b1490$var$Schema;

});
parcelRegister("7y6ZU", function(module, exports) {

$parcel$export(module.exports, "map", () => $57f122f65103134a$export$871de8747c9eaa88, (v) => $57f122f65103134a$export$871de8747c9eaa88 = v);
var $57f122f65103134a$export$871de8747c9eaa88;
"use strict";

var $FOECb = parcelRequire("FOECb");

var $649pE = parcelRequire("649pE");
const $57f122f65103134a$var$map = {
    collection: "map",
    default: true,
    nodeClass: $649pE.YAMLMap,
    tag: "tag:yaml.org,2002:map",
    resolve (map, onError) {
        if (!$FOECb.isMap(map)) onError("Expected a mapping for this tag");
        return map;
    },
    createNode: (schema, obj, ctx)=>$649pE.YAMLMap.from(schema, obj, ctx)
};
$57f122f65103134a$export$871de8747c9eaa88 = $57f122f65103134a$var$map;

});
parcelRegister("649pE", function(module, exports) {

$parcel$export(module.exports, "YAMLMap", () => $46aa6af756ea0b44$export$eb1691c4b19bb5eb, (v) => $46aa6af756ea0b44$export$eb1691c4b19bb5eb = v);
$parcel$export(module.exports, "findPair", () => $46aa6af756ea0b44$export$cb7eebdbb143b550, (v) => $46aa6af756ea0b44$export$cb7eebdbb143b550 = v);
var $46aa6af756ea0b44$export$eb1691c4b19bb5eb;
var $46aa6af756ea0b44$export$cb7eebdbb143b550;
"use strict";

var $kKCzk = parcelRequire("kKCzk");

var $bz3cv = parcelRequire("bz3cv");

var $fWhvR = parcelRequire("fWhvR");

var $FOECb = parcelRequire("FOECb");

var $5ff4n = parcelRequire("5ff4n");

var $d6XNP = parcelRequire("d6XNP");
function $46aa6af756ea0b44$var$findPair(items, key) {
    const k = $FOECb.isScalar(key) ? key.value : key;
    for (const it of items)if ($FOECb.isPair(it)) {
        if (it.key === key || it.key === k) return it;
        if ($FOECb.isScalar(it.key) && it.key.value === k) return it;
    }
    return undefined;
}
class $46aa6af756ea0b44$var$YAMLMap extends $fWhvR.Collection {
    static get tagName() {
        return "tag:yaml.org,2002:map";
    }
    constructor(schema){
        super($FOECb.MAP, schema);
        this.items = [];
    }
    /**
     * A generic collection parsing method that can be extended
     * to other node classes that inherit from YAMLMap
     */ static from(schema, obj, ctx) {
        const { keepUndefined: keepUndefined, replacer: replacer } = ctx;
        const map = new this(schema);
        const add = (key, value)=>{
            if (typeof replacer === "function") value = replacer.call(obj, key, value);
            else if (Array.isArray(replacer) && !replacer.includes(key)) return;
            if (value !== undefined || keepUndefined) map.items.push($5ff4n.createPair(key, value, ctx));
        };
        if (obj instanceof Map) for (const [key, value] of obj)add(key, value);
        else if (obj && typeof obj === "object") for (const key of Object.keys(obj))add(key, obj[key]);
        if (typeof schema.sortMapEntries === "function") map.items.sort(schema.sortMapEntries);
        return map;
    }
    /**
     * Adds a value to the collection.
     *
     * @param overwrite - If not set `true`, using a key that is already in the
     *   collection will throw. Otherwise, overwrites the previous value.
     */ add(pair, overwrite) {
        let _pair;
        if ($FOECb.isPair(pair)) _pair = pair;
        else if (!pair || typeof pair !== "object" || !("key" in pair)) // In TypeScript, this never happens.
        _pair = new $5ff4n.Pair(pair, pair?.value);
        else _pair = new $5ff4n.Pair(pair.key, pair.value);
        const prev = $46aa6af756ea0b44$var$findPair(this.items, _pair.key);
        const sortEntries = this.schema?.sortMapEntries;
        if (prev) {
            if (!overwrite) throw new Error(`Key ${_pair.key} already set`);
            // For scalars, keep the old node & its comments and anchors
            if ($FOECb.isScalar(prev.value) && $d6XNP.isScalarValue(_pair.value)) prev.value.value = _pair.value;
            else prev.value = _pair.value;
        } else if (sortEntries) {
            const i = this.items.findIndex((item)=>sortEntries(_pair, item) < 0);
            if (i === -1) this.items.push(_pair);
            else this.items.splice(i, 0, _pair);
        } else this.items.push(_pair);
    }
    delete(key) {
        const it = $46aa6af756ea0b44$var$findPair(this.items, key);
        if (!it) return false;
        const del = this.items.splice(this.items.indexOf(it), 1);
        return del.length > 0;
    }
    get(key, keepScalar) {
        const it = $46aa6af756ea0b44$var$findPair(this.items, key);
        const node = it?.value;
        return (!keepScalar && $FOECb.isScalar(node) ? node.value : node) ?? undefined;
    }
    has(key) {
        return !!$46aa6af756ea0b44$var$findPair(this.items, key);
    }
    set(key, value) {
        this.add(new $5ff4n.Pair(key, value), true);
    }
    /**
     * @param ctx - Conversion context, originally set in Document#toJS()
     * @param {Class} Type - If set, forces the returned collection type
     * @returns Instance of Type, Map, or Object
     */ toJSON(_, ctx, Type) {
        const map = Type ? new Type() : ctx?.mapAsMap ? new Map() : {};
        if (ctx?.onCreate) ctx.onCreate(map);
        for (const item of this.items)$bz3cv.addPairToJSMap(ctx, map, item);
        return map;
    }
    toString(ctx, onComment, onChompKeep) {
        if (!ctx) return JSON.stringify(this);
        for (const item of this.items){
            if (!$FOECb.isPair(item)) throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
        }
        if (!ctx.allNullValues && this.hasAllNullValues(false)) ctx = Object.assign({}, ctx, {
            allNullValues: true
        });
        return $kKCzk.stringifyCollection(this, ctx, {
            blockItemPrefix: "",
            flowChars: {
                start: "{",
                end: "}"
            },
            itemIndent: ctx.indent || "",
            onChompKeep: onChompKeep,
            onComment: onComment
        });
    }
}
$46aa6af756ea0b44$export$eb1691c4b19bb5eb = $46aa6af756ea0b44$var$YAMLMap;
$46aa6af756ea0b44$export$cb7eebdbb143b550 = $46aa6af756ea0b44$var$findPair;

});
parcelRegister("kKCzk", function(module, exports) {

$parcel$export(module.exports, "stringifyCollection", () => $f1b6057cee7ae9dd$export$b570edac7df98594, (v) => $f1b6057cee7ae9dd$export$b570edac7df98594 = v);
var $f1b6057cee7ae9dd$export$b570edac7df98594;
"use strict";

var $FOECb = parcelRequire("FOECb");

var $l36TR = parcelRequire("l36TR");

var $4joNE = parcelRequire("4joNE");
function $f1b6057cee7ae9dd$var$stringifyCollection(collection, ctx, options) {
    const flow = ctx.inFlow ?? collection.flow;
    const stringify = flow ? $f1b6057cee7ae9dd$var$stringifyFlowCollection : $f1b6057cee7ae9dd$var$stringifyBlockCollection;
    return stringify(collection, ctx, options);
}
function $f1b6057cee7ae9dd$var$stringifyBlockCollection({ comment: comment, items: items }, ctx, { blockItemPrefix: blockItemPrefix, flowChars: flowChars, itemIndent: itemIndent, onChompKeep: onChompKeep, onComment: onComment }) {
    const { indent: indent, options: { commentString: commentString } } = ctx;
    const itemCtx = Object.assign({}, ctx, {
        indent: itemIndent,
        type: null
    });
    let chompKeep = false; // flag for the preceding node's status
    const lines = [];
    for(let i = 0; i < items.length; ++i){
        const item = items[i];
        let comment = null;
        if ($FOECb.isNode(item)) {
            if (!chompKeep && item.spaceBefore) lines.push("");
            $f1b6057cee7ae9dd$var$addCommentBefore(ctx, lines, item.commentBefore, chompKeep);
            if (item.comment) comment = item.comment;
        } else if ($FOECb.isPair(item)) {
            const ik = $FOECb.isNode(item.key) ? item.key : null;
            if (ik) {
                if (!chompKeep && ik.spaceBefore) lines.push("");
                $f1b6057cee7ae9dd$var$addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);
            }
        }
        chompKeep = false;
        let str = $l36TR.stringify(item, itemCtx, ()=>comment = null, ()=>chompKeep = true);
        if (comment) str += $4joNE.lineComment(str, itemIndent, commentString(comment));
        if (chompKeep && comment) chompKeep = false;
        lines.push(blockItemPrefix + str);
    }
    let str;
    if (lines.length === 0) str = flowChars.start + flowChars.end;
    else {
        str = lines[0];
        for(let i = 1; i < lines.length; ++i){
            const line = lines[i];
            str += line ? `\n${indent}${line}` : "\n";
        }
    }
    if (comment) {
        str += "\n" + $4joNE.indentComment(commentString(comment), indent);
        if (onComment) onComment();
    } else if (chompKeep && onChompKeep) onChompKeep();
    return str;
}
function $f1b6057cee7ae9dd$var$stringifyFlowCollection({ items: items }, ctx, { flowChars: flowChars, itemIndent: itemIndent }) {
    const { indent: indent, indentStep: indentStep, flowCollectionPadding: fcPadding, options: { commentString: commentString } } = ctx;
    itemIndent += indentStep;
    const itemCtx = Object.assign({}, ctx, {
        indent: itemIndent,
        inFlow: true,
        type: null
    });
    let reqNewline = false;
    let linesAtValue = 0;
    const lines = [];
    for(let i = 0; i < items.length; ++i){
        const item = items[i];
        let comment = null;
        if ($FOECb.isNode(item)) {
            if (item.spaceBefore) lines.push("");
            $f1b6057cee7ae9dd$var$addCommentBefore(ctx, lines, item.commentBefore, false);
            if (item.comment) comment = item.comment;
        } else if ($FOECb.isPair(item)) {
            const ik = $FOECb.isNode(item.key) ? item.key : null;
            if (ik) {
                if (ik.spaceBefore) lines.push("");
                $f1b6057cee7ae9dd$var$addCommentBefore(ctx, lines, ik.commentBefore, false);
                if (ik.comment) reqNewline = true;
            }
            const iv = $FOECb.isNode(item.value) ? item.value : null;
            if (iv) {
                if (iv.comment) comment = iv.comment;
                if (iv.commentBefore) reqNewline = true;
            } else if (item.value == null && ik?.comment) comment = ik.comment;
        }
        if (comment) reqNewline = true;
        let str = $l36TR.stringify(item, itemCtx, ()=>comment = null);
        if (i < items.length - 1) str += ",";
        if (comment) str += $4joNE.lineComment(str, itemIndent, commentString(comment));
        if (!reqNewline && (lines.length > linesAtValue || str.includes("\n"))) reqNewline = true;
        lines.push(str);
        linesAtValue = lines.length;
    }
    const { start: start, end: end } = flowChars;
    if (lines.length === 0) return start + end;
    else {
        if (!reqNewline) {
            const len = lines.reduce((sum, line)=>sum + line.length + 2, 2);
            reqNewline = ctx.options.lineWidth > 0 && len > ctx.options.lineWidth;
        }
        if (reqNewline) {
            let str = start;
            for (const line of lines)str += line ? `\n${indentStep}${indent}${line}` : "\n";
            return `${str}\n${indent}${end}`;
        } else return `${start}${fcPadding}${lines.join(" ")}${fcPadding}${end}`;
    }
}
function $f1b6057cee7ae9dd$var$addCommentBefore({ indent: indent, options: { commentString: commentString } }, lines, comment, chompKeep) {
    if (comment && chompKeep) comment = comment.replace(/^\n+/, "");
    if (comment) {
        const ic = $4joNE.indentComment(commentString(comment), indent);
        lines.push(ic.trimStart()); // Avoid double indent on first line
    }
}
$f1b6057cee7ae9dd$export$b570edac7df98594 = $f1b6057cee7ae9dd$var$stringifyCollection;

});



parcelRegister("6jftB", function(module, exports) {

$parcel$export(module.exports, "seq", () => $498085bc867a6042$export$1041d4276c328e4d, (v) => $498085bc867a6042$export$1041d4276c328e4d = v);
var $498085bc867a6042$export$1041d4276c328e4d;
"use strict";

var $FOECb = parcelRequire("FOECb");

var $hOWPS = parcelRequire("hOWPS");
const $498085bc867a6042$var$seq = {
    collection: "seq",
    default: true,
    nodeClass: $hOWPS.YAMLSeq,
    tag: "tag:yaml.org,2002:seq",
    resolve (seq, onError) {
        if (!$FOECb.isSeq(seq)) onError("Expected a sequence for this tag");
        return seq;
    },
    createNode: (schema, obj, ctx)=>$hOWPS.YAMLSeq.from(schema, obj, ctx)
};
$498085bc867a6042$export$1041d4276c328e4d = $498085bc867a6042$var$seq;

});
parcelRegister("hOWPS", function(module, exports) {

$parcel$export(module.exports, "YAMLSeq", () => $cf94bebf531c2d75$export$47adc25f769055b2, (v) => $cf94bebf531c2d75$export$47adc25f769055b2 = v);
var $cf94bebf531c2d75$export$47adc25f769055b2;
"use strict";

var $64cbc = parcelRequire("64cbc");

var $kKCzk = parcelRequire("kKCzk");

var $fWhvR = parcelRequire("fWhvR");

var $FOECb = parcelRequire("FOECb");

var $d6XNP = parcelRequire("d6XNP");

var $jeFb3 = parcelRequire("jeFb3");
class $cf94bebf531c2d75$var$YAMLSeq extends $fWhvR.Collection {
    static get tagName() {
        return "tag:yaml.org,2002:seq";
    }
    constructor(schema){
        super($FOECb.SEQ, schema);
        this.items = [];
    }
    add(value) {
        this.items.push(value);
    }
    /**
     * Removes a value from the collection.
     *
     * `key` must contain a representation of an integer for this to succeed.
     * It may be wrapped in a `Scalar`.
     *
     * @returns `true` if the item was found and removed.
     */ delete(key) {
        const idx = $cf94bebf531c2d75$var$asItemIndex(key);
        if (typeof idx !== "number") return false;
        const del = this.items.splice(idx, 1);
        return del.length > 0;
    }
    get(key, keepScalar) {
        const idx = $cf94bebf531c2d75$var$asItemIndex(key);
        if (typeof idx !== "number") return undefined;
        const it = this.items[idx];
        return !keepScalar && $FOECb.isScalar(it) ? it.value : it;
    }
    /**
     * Checks if the collection includes a value with the key `key`.
     *
     * `key` must contain a representation of an integer for this to succeed.
     * It may be wrapped in a `Scalar`.
     */ has(key) {
        const idx = $cf94bebf531c2d75$var$asItemIndex(key);
        return typeof idx === "number" && idx < this.items.length;
    }
    /**
     * Sets a value in this collection. For `!!set`, `value` needs to be a
     * boolean to add/remove the item from the set.
     *
     * If `key` does not contain a representation of an integer, this will throw.
     * It may be wrapped in a `Scalar`.
     */ set(key, value) {
        const idx = $cf94bebf531c2d75$var$asItemIndex(key);
        if (typeof idx !== "number") throw new Error(`Expected a valid index, not ${key}.`);
        const prev = this.items[idx];
        if ($FOECb.isScalar(prev) && $d6XNP.isScalarValue(value)) prev.value = value;
        else this.items[idx] = value;
    }
    toJSON(_, ctx) {
        const seq = [];
        if (ctx?.onCreate) ctx.onCreate(seq);
        let i = 0;
        for (const item of this.items)seq.push($jeFb3.toJS(item, String(i++), ctx));
        return seq;
    }
    toString(ctx, onComment, onChompKeep) {
        if (!ctx) return JSON.stringify(this);
        return $kKCzk.stringifyCollection(this, ctx, {
            blockItemPrefix: "- ",
            flowChars: {
                start: "[",
                end: "]"
            },
            itemIndent: (ctx.indent || "") + "  ",
            onChompKeep: onChompKeep,
            onComment: onComment
        });
    }
    static from(schema, obj, ctx) {
        const { replacer: replacer } = ctx;
        const seq = new this(schema);
        if (obj && Symbol.iterator in Object(obj)) {
            let i = 0;
            for (let it of obj){
                if (typeof replacer === "function") {
                    const key = obj instanceof Set ? it : String(i++);
                    it = replacer.call(obj, key, it);
                }
                seq.items.push($64cbc.createNode(it, undefined, ctx));
            }
        }
        return seq;
    }
}
function $cf94bebf531c2d75$var$asItemIndex(key) {
    let idx = $FOECb.isScalar(key) ? key.value : key;
    if (idx && typeof idx === "string") idx = Number(idx);
    return typeof idx === "number" && Number.isInteger(idx) && idx >= 0 ? idx : null;
}
$cf94bebf531c2d75$export$47adc25f769055b2 = $cf94bebf531c2d75$var$YAMLSeq;

});


parcelRegister("az0E7", function(module, exports) {

$parcel$export(module.exports, "string", () => $7b0dac919674dd86$export$22b082955e083ec3, (v) => $7b0dac919674dd86$export$22b082955e083ec3 = v);
var $7b0dac919674dd86$export$22b082955e083ec3;
"use strict";

var $e5c0t = parcelRequire("e5c0t");
const $7b0dac919674dd86$var$string = {
    identify: (value)=>typeof value === "string",
    default: true,
    tag: "tag:yaml.org,2002:str",
    resolve: (str)=>str,
    stringify (item, ctx, onComment, onChompKeep) {
        ctx = Object.assign({
            actualString: true
        }, ctx);
        return $e5c0t.stringifyString(item, ctx, onComment, onChompKeep);
    }
};
$7b0dac919674dd86$export$22b082955e083ec3 = $7b0dac919674dd86$var$string;

});

parcelRegister("kEaIJ", function(module, exports) {

$parcel$export(module.exports, "coreKnownTags", () => $f07fdbeb03de5b82$export$aa155beb708c8cc4, (v) => $f07fdbeb03de5b82$export$aa155beb708c8cc4 = v);
$parcel$export(module.exports, "getTags", () => $f07fdbeb03de5b82$export$af63d7414243dad3, (v) => $f07fdbeb03de5b82$export$af63d7414243dad3 = v);
var $f07fdbeb03de5b82$export$aa155beb708c8cc4;
var $f07fdbeb03de5b82$export$af63d7414243dad3;
"use strict";

var $7y6ZU = parcelRequire("7y6ZU");

var $5k7Mu = parcelRequire("5k7Mu");

var $6jftB = parcelRequire("6jftB");

var $az0E7 = parcelRequire("az0E7");

var $c1XeN = parcelRequire("c1XeN");

var $5NZAW = parcelRequire("5NZAW");

var $8lgG5 = parcelRequire("8lgG5");

var $1dvNK = parcelRequire("1dvNK");

var $ipmcq = parcelRequire("ipmcq");

var $dFTbV = parcelRequire("dFTbV");

var $kaXef = parcelRequire("kaXef");

var $ioP3Q = parcelRequire("ioP3Q");

var $jOP2g = parcelRequire("jOP2g");

var $868kw = parcelRequire("868kw");

var $eNrop = parcelRequire("eNrop");

var $9qleL = parcelRequire("9qleL");
const $f07fdbeb03de5b82$var$schemas = new Map([
    [
        "core",
        $1dvNK.schema
    ],
    [
        "failsafe",
        [
            $7y6ZU.map,
            $6jftB.seq,
            $az0E7.string
        ]
    ],
    [
        "json",
        $ipmcq.schema
    ],
    [
        "yaml11",
        $868kw.schema
    ],
    [
        "yaml-1.1",
        $868kw.schema
    ]
]);
const $f07fdbeb03de5b82$var$tagsByName = {
    binary: $dFTbV.binary,
    bool: $c1XeN.boolTag,
    float: $5NZAW.float,
    floatExp: $5NZAW.floatExp,
    floatNaN: $5NZAW.floatNaN,
    floatTime: $9qleL.floatTime,
    int: $8lgG5.int,
    intHex: $8lgG5.intHex,
    intOct: $8lgG5.intOct,
    intTime: $9qleL.intTime,
    map: $7y6ZU.map,
    merge: $kaXef.merge,
    null: $5k7Mu.nullTag,
    omap: $ioP3Q.omap,
    pairs: $jOP2g.pairs,
    seq: $6jftB.seq,
    set: $eNrop.set,
    timestamp: $9qleL.timestamp
};
const $f07fdbeb03de5b82$var$coreKnownTags = {
    "tag:yaml.org,2002:binary": $dFTbV.binary,
    "tag:yaml.org,2002:merge": $kaXef.merge,
    "tag:yaml.org,2002:omap": $ioP3Q.omap,
    "tag:yaml.org,2002:pairs": $jOP2g.pairs,
    "tag:yaml.org,2002:set": $eNrop.set,
    "tag:yaml.org,2002:timestamp": $9qleL.timestamp
};
function $f07fdbeb03de5b82$var$getTags(customTags, schemaName, addMergeTag) {
    const schemaTags = $f07fdbeb03de5b82$var$schemas.get(schemaName);
    if (schemaTags && !customTags) return addMergeTag && !schemaTags.includes($kaXef.merge) ? schemaTags.concat($kaXef.merge) : schemaTags.slice();
    let tags = schemaTags;
    if (!tags) {
        if (Array.isArray(customTags)) tags = [];
        else {
            const keys = Array.from($f07fdbeb03de5b82$var$schemas.keys()).filter((key)=>key !== "yaml11").map((key)=>JSON.stringify(key)).join(", ");
            throw new Error(`Unknown schema "${schemaName}"; use one of ${keys} or define customTags array`);
        }
    }
    if (Array.isArray(customTags)) for (const tag of customTags)tags = tags.concat(tag);
    else if (typeof customTags === "function") tags = customTags(tags.slice());
    if (addMergeTag) tags = tags.concat($kaXef.merge);
    return tags.reduce((tags, tag)=>{
        const tagObj = typeof tag === "string" ? $f07fdbeb03de5b82$var$tagsByName[tag] : tag;
        if (!tagObj) {
            const tagName = JSON.stringify(tag);
            const keys = Object.keys($f07fdbeb03de5b82$var$tagsByName).map((key)=>JSON.stringify(key)).join(", ");
            throw new Error(`Unknown custom tag ${tagName}; use one of ${keys}`);
        }
        if (!tags.includes(tagObj)) tags.push(tagObj);
        return tags;
    }, []);
}
$f07fdbeb03de5b82$export$aa155beb708c8cc4 = $f07fdbeb03de5b82$var$coreKnownTags;
$f07fdbeb03de5b82$export$af63d7414243dad3 = $f07fdbeb03de5b82$var$getTags;

});
parcelRegister("5k7Mu", function(module, exports) {

$parcel$export(module.exports, "nullTag", () => $3e04db286924455a$export$a4f9db1e8324ef6b, (v) => $3e04db286924455a$export$a4f9db1e8324ef6b = v);
var $3e04db286924455a$export$a4f9db1e8324ef6b;
"use strict";

var $d6XNP = parcelRequire("d6XNP");
const $3e04db286924455a$var$nullTag = {
    identify: (value)=>value == null,
    createNode: ()=>new $d6XNP.Scalar(null),
    default: true,
    tag: "tag:yaml.org,2002:null",
    test: /^(?:~|[Nn]ull|NULL)?$/,
    resolve: ()=>new $d6XNP.Scalar(null),
    stringify: ({ source: source }, ctx)=>typeof source === "string" && $3e04db286924455a$var$nullTag.test.test(source) ? source : ctx.options.nullStr
};
$3e04db286924455a$export$a4f9db1e8324ef6b = $3e04db286924455a$var$nullTag;

});

parcelRegister("c1XeN", function(module, exports) {

$parcel$export(module.exports, "boolTag", () => $8c23875ebaeb2afe$export$4f52eaca20f174c1, (v) => $8c23875ebaeb2afe$export$4f52eaca20f174c1 = v);
var $8c23875ebaeb2afe$export$4f52eaca20f174c1;
"use strict";

var $d6XNP = parcelRequire("d6XNP");
const $8c23875ebaeb2afe$var$boolTag = {
    identify: (value)=>typeof value === "boolean",
    default: true,
    tag: "tag:yaml.org,2002:bool",
    test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
    resolve: (str)=>new $d6XNP.Scalar(str[0] === "t" || str[0] === "T"),
    stringify ({ source: source, value: value }, ctx) {
        if (source && $8c23875ebaeb2afe$var$boolTag.test.test(source)) {
            const sv = source[0] === "t" || source[0] === "T";
            if (value === sv) return source;
        }
        return value ? ctx.options.trueStr : ctx.options.falseStr;
    }
};
$8c23875ebaeb2afe$export$4f52eaca20f174c1 = $8c23875ebaeb2afe$var$boolTag;

});

parcelRegister("5NZAW", function(module, exports) {

$parcel$export(module.exports, "float", () => $43a14ecbf3f37175$export$6b5cd3983e3ee5ab, (v) => $43a14ecbf3f37175$export$6b5cd3983e3ee5ab = v);
$parcel$export(module.exports, "floatExp", () => $43a14ecbf3f37175$export$d62805e4174324af, (v) => $43a14ecbf3f37175$export$d62805e4174324af = v);
$parcel$export(module.exports, "floatNaN", () => $43a14ecbf3f37175$export$37d6b822c496e154, (v) => $43a14ecbf3f37175$export$37d6b822c496e154 = v);
var $43a14ecbf3f37175$export$6b5cd3983e3ee5ab;
var $43a14ecbf3f37175$export$d62805e4174324af;
var $43a14ecbf3f37175$export$37d6b822c496e154;
"use strict";

var $d6XNP = parcelRequire("d6XNP");

var $gKqSX = parcelRequire("gKqSX");
const $43a14ecbf3f37175$var$floatNaN = {
    identify: (value)=>typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
    resolve: (str)=>str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
    stringify: $gKqSX.stringifyNumber
};
const $43a14ecbf3f37175$var$floatExp = {
    identify: (value)=>typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    format: "EXP",
    test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
    resolve: (str)=>parseFloat(str),
    stringify (node) {
        const num = Number(node.value);
        return isFinite(num) ? num.toExponential() : $gKqSX.stringifyNumber(node);
    }
};
const $43a14ecbf3f37175$var$float = {
    identify: (value)=>typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
    resolve (str) {
        const node = new $d6XNP.Scalar(parseFloat(str));
        const dot = str.indexOf(".");
        if (dot !== -1 && str[str.length - 1] === "0") node.minFractionDigits = str.length - dot - 1;
        return node;
    },
    stringify: $gKqSX.stringifyNumber
};
$43a14ecbf3f37175$export$6b5cd3983e3ee5ab = $43a14ecbf3f37175$var$float;
$43a14ecbf3f37175$export$d62805e4174324af = $43a14ecbf3f37175$var$floatExp;
$43a14ecbf3f37175$export$37d6b822c496e154 = $43a14ecbf3f37175$var$floatNaN;

});
parcelRegister("gKqSX", function(module, exports) {

$parcel$export(module.exports, "stringifyNumber", () => $0325834ad39df6cf$export$4c03b48e25071796, (v) => $0325834ad39df6cf$export$4c03b48e25071796 = v);
var $0325834ad39df6cf$export$4c03b48e25071796;
"use strict";
function $0325834ad39df6cf$var$stringifyNumber({ format: format, minFractionDigits: minFractionDigits, tag: tag, value: value }) {
    if (typeof value === "bigint") return String(value);
    const num = typeof value === "number" ? value : Number(value);
    if (!isFinite(num)) return isNaN(num) ? ".nan" : num < 0 ? "-.inf" : ".inf";
    let n = JSON.stringify(value);
    if (!format && minFractionDigits && (!tag || tag === "tag:yaml.org,2002:float") && /^\d/.test(n)) {
        let i = n.indexOf(".");
        if (i < 0) {
            i = n.length;
            n += ".";
        }
        let d = minFractionDigits - (n.length - i - 1);
        while(d-- > 0)n += "0";
    }
    return n;
}
$0325834ad39df6cf$export$4c03b48e25071796 = $0325834ad39df6cf$var$stringifyNumber;

});


parcelRegister("8lgG5", function(module, exports) {

$parcel$export(module.exports, "int", () => $612d38bdb97e9884$export$7d260a2a5f8bc19e, (v) => $612d38bdb97e9884$export$7d260a2a5f8bc19e = v);
$parcel$export(module.exports, "intHex", () => $612d38bdb97e9884$export$3aff77776319ec6e, (v) => $612d38bdb97e9884$export$3aff77776319ec6e = v);
$parcel$export(module.exports, "intOct", () => $612d38bdb97e9884$export$3d3e8b3bce028aae, (v) => $612d38bdb97e9884$export$3d3e8b3bce028aae = v);
var $612d38bdb97e9884$export$7d260a2a5f8bc19e;
var $612d38bdb97e9884$export$3aff77776319ec6e;
var $612d38bdb97e9884$export$3d3e8b3bce028aae;
"use strict";

var $gKqSX = parcelRequire("gKqSX");
const $612d38bdb97e9884$var$intIdentify = (value)=>typeof value === "bigint" || Number.isInteger(value);
const $612d38bdb97e9884$var$intResolve = (str, offset, radix, { intAsBigInt: intAsBigInt })=>intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix);
function $612d38bdb97e9884$var$intStringify(node, radix, prefix) {
    const { value: value } = node;
    if ($612d38bdb97e9884$var$intIdentify(value) && value >= 0) return prefix + value.toString(radix);
    return $gKqSX.stringifyNumber(node);
}
const $612d38bdb97e9884$var$intOct = {
    identify: (value)=>$612d38bdb97e9884$var$intIdentify(value) && value >= 0,
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "OCT",
    test: /^0o[0-7]+$/,
    resolve: (str, _onError, opt)=>$612d38bdb97e9884$var$intResolve(str, 2, 8, opt),
    stringify: (node)=>$612d38bdb97e9884$var$intStringify(node, 8, "0o")
};
const $612d38bdb97e9884$var$int = {
    identify: $612d38bdb97e9884$var$intIdentify,
    default: true,
    tag: "tag:yaml.org,2002:int",
    test: /^[-+]?[0-9]+$/,
    resolve: (str, _onError, opt)=>$612d38bdb97e9884$var$intResolve(str, 0, 10, opt),
    stringify: $gKqSX.stringifyNumber
};
const $612d38bdb97e9884$var$intHex = {
    identify: (value)=>$612d38bdb97e9884$var$intIdentify(value) && value >= 0,
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "HEX",
    test: /^0x[0-9a-fA-F]+$/,
    resolve: (str, _onError, opt)=>$612d38bdb97e9884$var$intResolve(str, 2, 16, opt),
    stringify: (node)=>$612d38bdb97e9884$var$intStringify(node, 16, "0x")
};
$612d38bdb97e9884$export$7d260a2a5f8bc19e = $612d38bdb97e9884$var$int;
$612d38bdb97e9884$export$3aff77776319ec6e = $612d38bdb97e9884$var$intHex;
$612d38bdb97e9884$export$3d3e8b3bce028aae = $612d38bdb97e9884$var$intOct;

});

parcelRegister("1dvNK", function(module, exports) {

$parcel$export(module.exports, "schema", () => $0e2fac7020b7ab2d$export$4902baddc787debb, (v) => $0e2fac7020b7ab2d$export$4902baddc787debb = v);
var $0e2fac7020b7ab2d$export$4902baddc787debb;
"use strict";

var $7y6ZU = parcelRequire("7y6ZU");

var $5k7Mu = parcelRequire("5k7Mu");

var $6jftB = parcelRequire("6jftB");

var $az0E7 = parcelRequire("az0E7");

var $c1XeN = parcelRequire("c1XeN");

var $5NZAW = parcelRequire("5NZAW");

var $8lgG5 = parcelRequire("8lgG5");
const $0e2fac7020b7ab2d$var$schema = [
    $7y6ZU.map,
    $6jftB.seq,
    $az0E7.string,
    $5k7Mu.nullTag,
    $c1XeN.boolTag,
    $8lgG5.intOct,
    $8lgG5.int,
    $8lgG5.intHex,
    $5NZAW.floatNaN,
    $5NZAW.floatExp,
    $5NZAW.float
];
$0e2fac7020b7ab2d$export$4902baddc787debb = $0e2fac7020b7ab2d$var$schema;

});

parcelRegister("ipmcq", function(module, exports) {

$parcel$export(module.exports, "schema", () => $d66bc826cf8b19e8$export$4902baddc787debb, (v) => $d66bc826cf8b19e8$export$4902baddc787debb = v);
var $d66bc826cf8b19e8$export$4902baddc787debb;
"use strict";

var $d6XNP = parcelRequire("d6XNP");

var $7y6ZU = parcelRequire("7y6ZU");

var $6jftB = parcelRequire("6jftB");
function $d66bc826cf8b19e8$var$intIdentify(value) {
    return typeof value === "bigint" || Number.isInteger(value);
}
const $d66bc826cf8b19e8$var$stringifyJSON = ({ value: value })=>JSON.stringify(value);
const $d66bc826cf8b19e8$var$jsonScalars = [
    {
        identify: (value)=>typeof value === "string",
        default: true,
        tag: "tag:yaml.org,2002:str",
        resolve: (str)=>str,
        stringify: $d66bc826cf8b19e8$var$stringifyJSON
    },
    {
        identify: (value)=>value == null,
        createNode: ()=>new $d6XNP.Scalar(null),
        default: true,
        tag: "tag:yaml.org,2002:null",
        test: /^null$/,
        resolve: ()=>null,
        stringify: $d66bc826cf8b19e8$var$stringifyJSON
    },
    {
        identify: (value)=>typeof value === "boolean",
        default: true,
        tag: "tag:yaml.org,2002:bool",
        test: /^true|false$/,
        resolve: (str)=>str === "true",
        stringify: $d66bc826cf8b19e8$var$stringifyJSON
    },
    {
        identify: $d66bc826cf8b19e8$var$intIdentify,
        default: true,
        tag: "tag:yaml.org,2002:int",
        test: /^-?(?:0|[1-9][0-9]*)$/,
        resolve: (str, _onError, { intAsBigInt: intAsBigInt })=>intAsBigInt ? BigInt(str) : parseInt(str, 10),
        stringify: ({ value: value })=>$d66bc826cf8b19e8$var$intIdentify(value) ? value.toString() : JSON.stringify(value)
    },
    {
        identify: (value)=>typeof value === "number",
        default: true,
        tag: "tag:yaml.org,2002:float",
        test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
        resolve: (str)=>parseFloat(str),
        stringify: $d66bc826cf8b19e8$var$stringifyJSON
    }
];
const $d66bc826cf8b19e8$var$jsonError = {
    default: true,
    tag: "",
    test: /^/,
    resolve (str, onError) {
        onError(`Unresolved plain scalar ${JSON.stringify(str)}`);
        return str;
    }
};
const $d66bc826cf8b19e8$var$schema = [
    $7y6ZU.map,
    $6jftB.seq
].concat($d66bc826cf8b19e8$var$jsonScalars, $d66bc826cf8b19e8$var$jsonError);
$d66bc826cf8b19e8$export$4902baddc787debb = $d66bc826cf8b19e8$var$schema;

});

parcelRegister("dFTbV", function(module, exports) {

$parcel$export(module.exports, "binary", () => $9f49ea8a933f7abe$export$33902b7329277358, (v) => $9f49ea8a933f7abe$export$33902b7329277358 = v);
var $9f49ea8a933f7abe$export$33902b7329277358;
"use strict";

var $d6XNP = parcelRequire("d6XNP");

var $e5c0t = parcelRequire("e5c0t");
const $9f49ea8a933f7abe$var$binary = {
    identify: (value)=>value instanceof Uint8Array,
    default: false,
    tag: "tag:yaml.org,2002:binary",
    /**
     * Returns a Buffer in node and an Uint8Array in browsers
     *
     * To use the resulting buffer as an image, you'll want to do something like:
     *
     *   const blob = new Blob([buffer], { type: 'image/jpeg' })
     *   document.querySelector('#photo').src = URL.createObjectURL(blob)
     */ resolve (src, onError) {
        if (typeof Buffer === "function") return Buffer.from(src, "base64");
        else if (typeof atob === "function") {
            // On IE 11, atob() can't handle newlines
            const str = atob(src.replace(/[\n\r]/g, ""));
            const buffer = new Uint8Array(str.length);
            for(let i = 0; i < str.length; ++i)buffer[i] = str.charCodeAt(i);
            return buffer;
        } else {
            onError("This environment does not support reading binary tags; either Buffer or atob is required");
            return src;
        }
    },
    stringify ({ comment: comment, type: type, value: value }, ctx, onComment, onChompKeep) {
        const buf = value; // checked earlier by binary.identify()
        let str;
        if (typeof Buffer === "function") str = buf instanceof Buffer ? buf.toString("base64") : Buffer.from(buf.buffer).toString("base64");
        else if (typeof btoa === "function") {
            let s = "";
            for(let i = 0; i < buf.length; ++i)s += String.fromCharCode(buf[i]);
            str = btoa(s);
        } else throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
        if (!type) type = $d6XNP.Scalar.BLOCK_LITERAL;
        if (type !== $d6XNP.Scalar.QUOTE_DOUBLE) {
            const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
            const n = Math.ceil(str.length / lineWidth);
            const lines = new Array(n);
            for(let i = 0, o = 0; i < n; ++i, o += lineWidth)lines[i] = str.substr(o, lineWidth);
            str = lines.join(type === $d6XNP.Scalar.BLOCK_LITERAL ? "\n" : " ");
        }
        return $e5c0t.stringifyString({
            comment: comment,
            type: type,
            value: str
        }, ctx, onComment, onChompKeep);
    }
};
$9f49ea8a933f7abe$export$33902b7329277358 = $9f49ea8a933f7abe$var$binary;

});

parcelRegister("ioP3Q", function(module, exports) {

$parcel$export(module.exports, "omap", () => $d652139008e7bfeb$export$5a6b5e3152d599a2, (v) => $d652139008e7bfeb$export$5a6b5e3152d599a2 = v);
var $d652139008e7bfeb$export$7006ac3fb49022d8;
var $d652139008e7bfeb$export$5a6b5e3152d599a2;
"use strict";

var $FOECb = parcelRequire("FOECb");

var $jeFb3 = parcelRequire("jeFb3");

var $649pE = parcelRequire("649pE");

var $hOWPS = parcelRequire("hOWPS");

var $jOP2g = parcelRequire("jOP2g");
class $d652139008e7bfeb$var$YAMLOMap extends $hOWPS.YAMLSeq {
    constructor(){
        super();
        this.add = $649pE.YAMLMap.prototype.add.bind(this);
        this.delete = $649pE.YAMLMap.prototype.delete.bind(this);
        this.get = $649pE.YAMLMap.prototype.get.bind(this);
        this.has = $649pE.YAMLMap.prototype.has.bind(this);
        this.set = $649pE.YAMLMap.prototype.set.bind(this);
        this.tag = $d652139008e7bfeb$var$YAMLOMap.tag;
    }
    /**
     * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,
     * but TypeScript won't allow widening the signature of a child method.
     */ toJSON(_, ctx) {
        if (!ctx) return super.toJSON(_);
        const map = new Map();
        if (ctx?.onCreate) ctx.onCreate(map);
        for (const pair of this.items){
            let key, value;
            if ($FOECb.isPair(pair)) {
                key = $jeFb3.toJS(pair.key, "", ctx);
                value = $jeFb3.toJS(pair.value, key, ctx);
            } else key = $jeFb3.toJS(pair, "", ctx);
            if (map.has(key)) throw new Error("Ordered maps must not include duplicate keys");
            map.set(key, value);
        }
        return map;
    }
    static from(schema, iterable, ctx) {
        const pairs$1 = $jOP2g.createPairs(schema, iterable, ctx);
        const omap = new this();
        omap.items = pairs$1.items;
        return omap;
    }
}
$d652139008e7bfeb$var$YAMLOMap.tag = "tag:yaml.org,2002:omap";
const $d652139008e7bfeb$var$omap = {
    collection: "seq",
    identify: (value)=>value instanceof Map,
    nodeClass: $d652139008e7bfeb$var$YAMLOMap,
    default: false,
    tag: "tag:yaml.org,2002:omap",
    resolve (seq, onError) {
        const pairs$1 = $jOP2g.resolvePairs(seq, onError);
        const seenKeys = [];
        for (const { key: key } of pairs$1.items)if ($FOECb.isScalar(key)) {
            if (seenKeys.includes(key.value)) onError(`Ordered maps must not include duplicate keys: ${key.value}`);
            else seenKeys.push(key.value);
        }
        return Object.assign(new $d652139008e7bfeb$var$YAMLOMap(), pairs$1);
    },
    createNode: (schema, iterable, ctx)=>$d652139008e7bfeb$var$YAMLOMap.from(schema, iterable, ctx)
};
$d652139008e7bfeb$export$7006ac3fb49022d8 = $d652139008e7bfeb$var$YAMLOMap;
$d652139008e7bfeb$export$5a6b5e3152d599a2 = $d652139008e7bfeb$var$omap;

});
parcelRegister("jOP2g", function(module, exports) {

$parcel$export(module.exports, "createPairs", () => $e6da4671bce8d727$export$27bb6a7978f1f74a, (v) => $e6da4671bce8d727$export$27bb6a7978f1f74a = v);
$parcel$export(module.exports, "pairs", () => $e6da4671bce8d727$export$589748d90c221be3, (v) => $e6da4671bce8d727$export$589748d90c221be3 = v);
$parcel$export(module.exports, "resolvePairs", () => $e6da4671bce8d727$export$f3d665c6925c05a1, (v) => $e6da4671bce8d727$export$f3d665c6925c05a1 = v);
var $e6da4671bce8d727$export$27bb6a7978f1f74a;
var $e6da4671bce8d727$export$589748d90c221be3;
var $e6da4671bce8d727$export$f3d665c6925c05a1;
"use strict";

var $FOECb = parcelRequire("FOECb");

var $5ff4n = parcelRequire("5ff4n");

var $d6XNP = parcelRequire("d6XNP");

var $hOWPS = parcelRequire("hOWPS");
function $e6da4671bce8d727$var$resolvePairs(seq, onError) {
    if ($FOECb.isSeq(seq)) for(let i = 0; i < seq.items.length; ++i){
        let item = seq.items[i];
        if ($FOECb.isPair(item)) continue;
        else if ($FOECb.isMap(item)) {
            if (item.items.length > 1) onError("Each pair must have its own sequence indicator");
            const pair = item.items[0] || new $5ff4n.Pair(new $d6XNP.Scalar(null));
            if (item.commentBefore) pair.key.commentBefore = pair.key.commentBefore ? `${item.commentBefore}\n${pair.key.commentBefore}` : item.commentBefore;
            if (item.comment) {
                const cn = pair.value ?? pair.key;
                cn.comment = cn.comment ? `${item.comment}\n${cn.comment}` : item.comment;
            }
            item = pair;
        }
        seq.items[i] = $FOECb.isPair(item) ? item : new $5ff4n.Pair(item);
    }
    else onError("Expected a sequence for this tag");
    return seq;
}
function $e6da4671bce8d727$var$createPairs(schema, iterable, ctx) {
    const { replacer: replacer } = ctx;
    const pairs = new $hOWPS.YAMLSeq(schema);
    pairs.tag = "tag:yaml.org,2002:pairs";
    let i = 0;
    if (iterable && Symbol.iterator in Object(iterable)) for (let it of iterable){
        if (typeof replacer === "function") it = replacer.call(iterable, String(i++), it);
        let key, value;
        if (Array.isArray(it)) {
            if (it.length === 2) {
                key = it[0];
                value = it[1];
            } else throw new TypeError(`Expected [key, value] tuple: ${it}`);
        } else if (it && it instanceof Object) {
            const keys = Object.keys(it);
            if (keys.length === 1) {
                key = keys[0];
                value = it[key];
            } else throw new TypeError(`Expected tuple with one key, not ${keys.length} keys`);
        } else key = it;
        pairs.items.push($5ff4n.createPair(key, value, ctx));
    }
    return pairs;
}
const $e6da4671bce8d727$var$pairs = {
    collection: "seq",
    default: false,
    tag: "tag:yaml.org,2002:pairs",
    resolve: $e6da4671bce8d727$var$resolvePairs,
    createNode: $e6da4671bce8d727$var$createPairs
};
$e6da4671bce8d727$export$27bb6a7978f1f74a = $e6da4671bce8d727$var$createPairs;
$e6da4671bce8d727$export$589748d90c221be3 = $e6da4671bce8d727$var$pairs;
$e6da4671bce8d727$export$f3d665c6925c05a1 = $e6da4671bce8d727$var$resolvePairs;

});


parcelRegister("868kw", function(module, exports) {

$parcel$export(module.exports, "schema", () => $5e5558689ae9c34c$export$4902baddc787debb, (v) => $5e5558689ae9c34c$export$4902baddc787debb = v);
var $5e5558689ae9c34c$export$4902baddc787debb;
"use strict";

var $7y6ZU = parcelRequire("7y6ZU");

var $5k7Mu = parcelRequire("5k7Mu");

var $6jftB = parcelRequire("6jftB");

var $az0E7 = parcelRequire("az0E7");

var $dFTbV = parcelRequire("dFTbV");

var $de7QB = parcelRequire("de7QB");

var $lE2Rs = parcelRequire("lE2Rs");

var $gQvA1 = parcelRequire("gQvA1");

var $kaXef = parcelRequire("kaXef");

var $ioP3Q = parcelRequire("ioP3Q");

var $jOP2g = parcelRequire("jOP2g");

var $eNrop = parcelRequire("eNrop");

var $9qleL = parcelRequire("9qleL");
const $5e5558689ae9c34c$var$schema = [
    $7y6ZU.map,
    $6jftB.seq,
    $az0E7.string,
    $5k7Mu.nullTag,
    $de7QB.trueTag,
    $de7QB.falseTag,
    $gQvA1.intBin,
    $gQvA1.intOct,
    $gQvA1.int,
    $gQvA1.intHex,
    $lE2Rs.floatNaN,
    $lE2Rs.floatExp,
    $lE2Rs.float,
    $dFTbV.binary,
    $kaXef.merge,
    $ioP3Q.omap,
    $jOP2g.pairs,
    $eNrop.set,
    $9qleL.intTime,
    $9qleL.floatTime,
    $9qleL.timestamp
];
$5e5558689ae9c34c$export$4902baddc787debb = $5e5558689ae9c34c$var$schema;

});
parcelRegister("de7QB", function(module, exports) {

$parcel$export(module.exports, "falseTag", () => $9a12ab7ea3fa00c5$export$250e1f5a64500a2e, (v) => $9a12ab7ea3fa00c5$export$250e1f5a64500a2e = v);
$parcel$export(module.exports, "trueTag", () => $9a12ab7ea3fa00c5$export$ae6fbb429290d2fa, (v) => $9a12ab7ea3fa00c5$export$ae6fbb429290d2fa = v);
var $9a12ab7ea3fa00c5$export$250e1f5a64500a2e;
var $9a12ab7ea3fa00c5$export$ae6fbb429290d2fa;
"use strict";

var $d6XNP = parcelRequire("d6XNP");
function $9a12ab7ea3fa00c5$var$boolStringify({ value: value, source: source }, ctx) {
    const boolObj = value ? $9a12ab7ea3fa00c5$var$trueTag : $9a12ab7ea3fa00c5$var$falseTag;
    if (source && boolObj.test.test(source)) return source;
    return value ? ctx.options.trueStr : ctx.options.falseStr;
}
const $9a12ab7ea3fa00c5$var$trueTag = {
    identify: (value)=>value === true,
    default: true,
    tag: "tag:yaml.org,2002:bool",
    test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
    resolve: ()=>new $d6XNP.Scalar(true),
    stringify: $9a12ab7ea3fa00c5$var$boolStringify
};
const $9a12ab7ea3fa00c5$var$falseTag = {
    identify: (value)=>value === false,
    default: true,
    tag: "tag:yaml.org,2002:bool",
    test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/,
    resolve: ()=>new $d6XNP.Scalar(false),
    stringify: $9a12ab7ea3fa00c5$var$boolStringify
};
$9a12ab7ea3fa00c5$export$250e1f5a64500a2e = $9a12ab7ea3fa00c5$var$falseTag;
$9a12ab7ea3fa00c5$export$ae6fbb429290d2fa = $9a12ab7ea3fa00c5$var$trueTag;

});

parcelRegister("lE2Rs", function(module, exports) {

$parcel$export(module.exports, "float", () => $fc1f8d96b81896c7$export$6b5cd3983e3ee5ab, (v) => $fc1f8d96b81896c7$export$6b5cd3983e3ee5ab = v);
$parcel$export(module.exports, "floatExp", () => $fc1f8d96b81896c7$export$d62805e4174324af, (v) => $fc1f8d96b81896c7$export$d62805e4174324af = v);
$parcel$export(module.exports, "floatNaN", () => $fc1f8d96b81896c7$export$37d6b822c496e154, (v) => $fc1f8d96b81896c7$export$37d6b822c496e154 = v);
var $fc1f8d96b81896c7$export$6b5cd3983e3ee5ab;
var $fc1f8d96b81896c7$export$d62805e4174324af;
var $fc1f8d96b81896c7$export$37d6b822c496e154;
"use strict";

var $d6XNP = parcelRequire("d6XNP");

var $gKqSX = parcelRequire("gKqSX");
const $fc1f8d96b81896c7$var$floatNaN = {
    identify: (value)=>typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
    resolve: (str)=>str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
    stringify: $gKqSX.stringifyNumber
};
const $fc1f8d96b81896c7$var$floatExp = {
    identify: (value)=>typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    format: "EXP",
    test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
    resolve: (str)=>parseFloat(str.replace(/_/g, "")),
    stringify (node) {
        const num = Number(node.value);
        return isFinite(num) ? num.toExponential() : $gKqSX.stringifyNumber(node);
    }
};
const $fc1f8d96b81896c7$var$float = {
    identify: (value)=>typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
    resolve (str) {
        const node = new $d6XNP.Scalar(parseFloat(str.replace(/_/g, "")));
        const dot = str.indexOf(".");
        if (dot !== -1) {
            const f = str.substring(dot + 1).replace(/_/g, "");
            if (f[f.length - 1] === "0") node.minFractionDigits = f.length;
        }
        return node;
    },
    stringify: $gKqSX.stringifyNumber
};
$fc1f8d96b81896c7$export$6b5cd3983e3ee5ab = $fc1f8d96b81896c7$var$float;
$fc1f8d96b81896c7$export$d62805e4174324af = $fc1f8d96b81896c7$var$floatExp;
$fc1f8d96b81896c7$export$37d6b822c496e154 = $fc1f8d96b81896c7$var$floatNaN;

});

parcelRegister("gQvA1", function(module, exports) {

$parcel$export(module.exports, "int", () => $c439ffccc60cb1b7$export$7d260a2a5f8bc19e, (v) => $c439ffccc60cb1b7$export$7d260a2a5f8bc19e = v);
$parcel$export(module.exports, "intBin", () => $c439ffccc60cb1b7$export$a0833348c72870ac, (v) => $c439ffccc60cb1b7$export$a0833348c72870ac = v);
$parcel$export(module.exports, "intHex", () => $c439ffccc60cb1b7$export$3aff77776319ec6e, (v) => $c439ffccc60cb1b7$export$3aff77776319ec6e = v);
$parcel$export(module.exports, "intOct", () => $c439ffccc60cb1b7$export$3d3e8b3bce028aae, (v) => $c439ffccc60cb1b7$export$3d3e8b3bce028aae = v);
var $c439ffccc60cb1b7$export$7d260a2a5f8bc19e;
var $c439ffccc60cb1b7$export$a0833348c72870ac;
var $c439ffccc60cb1b7$export$3aff77776319ec6e;
var $c439ffccc60cb1b7$export$3d3e8b3bce028aae;
"use strict";

var $gKqSX = parcelRequire("gKqSX");
const $c439ffccc60cb1b7$var$intIdentify = (value)=>typeof value === "bigint" || Number.isInteger(value);
function $c439ffccc60cb1b7$var$intResolve(str, offset, radix, { intAsBigInt: intAsBigInt }) {
    const sign = str[0];
    if (sign === "-" || sign === "+") offset += 1;
    str = str.substring(offset).replace(/_/g, "");
    if (intAsBigInt) {
        switch(radix){
            case 2:
                str = `0b${str}`;
                break;
            case 8:
                str = `0o${str}`;
                break;
            case 16:
                str = `0x${str}`;
                break;
        }
        const n = BigInt(str);
        return sign === "-" ? BigInt(-1) * n : n;
    }
    const n = parseInt(str, radix);
    return sign === "-" ? -1 * n : n;
}
function $c439ffccc60cb1b7$var$intStringify(node, radix, prefix) {
    const { value: value } = node;
    if ($c439ffccc60cb1b7$var$intIdentify(value)) {
        const str = value.toString(radix);
        return value < 0 ? "-" + prefix + str.substr(1) : prefix + str;
    }
    return $gKqSX.stringifyNumber(node);
}
const $c439ffccc60cb1b7$var$intBin = {
    identify: $c439ffccc60cb1b7$var$intIdentify,
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "BIN",
    test: /^[-+]?0b[0-1_]+$/,
    resolve: (str, _onError, opt)=>$c439ffccc60cb1b7$var$intResolve(str, 2, 2, opt),
    stringify: (node)=>$c439ffccc60cb1b7$var$intStringify(node, 2, "0b")
};
const $c439ffccc60cb1b7$var$intOct = {
    identify: $c439ffccc60cb1b7$var$intIdentify,
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "OCT",
    test: /^[-+]?0[0-7_]+$/,
    resolve: (str, _onError, opt)=>$c439ffccc60cb1b7$var$intResolve(str, 1, 8, opt),
    stringify: (node)=>$c439ffccc60cb1b7$var$intStringify(node, 8, "0")
};
const $c439ffccc60cb1b7$var$int = {
    identify: $c439ffccc60cb1b7$var$intIdentify,
    default: true,
    tag: "tag:yaml.org,2002:int",
    test: /^[-+]?[0-9][0-9_]*$/,
    resolve: (str, _onError, opt)=>$c439ffccc60cb1b7$var$intResolve(str, 0, 10, opt),
    stringify: $gKqSX.stringifyNumber
};
const $c439ffccc60cb1b7$var$intHex = {
    identify: $c439ffccc60cb1b7$var$intIdentify,
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "HEX",
    test: /^[-+]?0x[0-9a-fA-F_]+$/,
    resolve: (str, _onError, opt)=>$c439ffccc60cb1b7$var$intResolve(str, 2, 16, opt),
    stringify: (node)=>$c439ffccc60cb1b7$var$intStringify(node, 16, "0x")
};
$c439ffccc60cb1b7$export$7d260a2a5f8bc19e = $c439ffccc60cb1b7$var$int;
$c439ffccc60cb1b7$export$a0833348c72870ac = $c439ffccc60cb1b7$var$intBin;
$c439ffccc60cb1b7$export$3aff77776319ec6e = $c439ffccc60cb1b7$var$intHex;
$c439ffccc60cb1b7$export$3d3e8b3bce028aae = $c439ffccc60cb1b7$var$intOct;

});

parcelRegister("eNrop", function(module, exports) {

$parcel$export(module.exports, "set", () => $ac5ae3ea1c51a36f$export$adaa4cf7ef1b65be, (v) => $ac5ae3ea1c51a36f$export$adaa4cf7ef1b65be = v);
var $ac5ae3ea1c51a36f$export$d64eaa29dab13634;
var $ac5ae3ea1c51a36f$export$adaa4cf7ef1b65be;
"use strict";

var $FOECb = parcelRequire("FOECb");

var $5ff4n = parcelRequire("5ff4n");

var $649pE = parcelRequire("649pE");
class $ac5ae3ea1c51a36f$var$YAMLSet extends $649pE.YAMLMap {
    constructor(schema){
        super(schema);
        this.tag = $ac5ae3ea1c51a36f$var$YAMLSet.tag;
    }
    add(key) {
        let pair;
        if ($FOECb.isPair(key)) pair = key;
        else if (key && typeof key === "object" && "key" in key && "value" in key && key.value === null) pair = new $5ff4n.Pair(key.key, null);
        else pair = new $5ff4n.Pair(key, null);
        const prev = $649pE.findPair(this.items, pair.key);
        if (!prev) this.items.push(pair);
    }
    /**
     * If `keepPair` is `true`, returns the Pair matching `key`.
     * Otherwise, returns the value of that Pair's key.
     */ get(key, keepPair) {
        const pair = $649pE.findPair(this.items, key);
        return !keepPair && $FOECb.isPair(pair) ? $FOECb.isScalar(pair.key) ? pair.key.value : pair.key : pair;
    }
    set(key, value) {
        if (typeof value !== "boolean") throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
        const prev = $649pE.findPair(this.items, key);
        if (prev && !value) this.items.splice(this.items.indexOf(prev), 1);
        else if (!prev && value) this.items.push(new $5ff4n.Pair(key));
    }
    toJSON(_, ctx) {
        return super.toJSON(_, ctx, Set);
    }
    toString(ctx, onComment, onChompKeep) {
        if (!ctx) return JSON.stringify(this);
        if (this.hasAllNullValues(true)) return super.toString(Object.assign({}, ctx, {
            allNullValues: true
        }), onComment, onChompKeep);
        else throw new Error("Set items must all have null values");
    }
    static from(schema, iterable, ctx) {
        const { replacer: replacer } = ctx;
        const set = new this(schema);
        if (iterable && Symbol.iterator in Object(iterable)) for (let value of iterable){
            if (typeof replacer === "function") value = replacer.call(iterable, value, value);
            set.items.push($5ff4n.createPair(value, null, ctx));
        }
        return set;
    }
}
$ac5ae3ea1c51a36f$var$YAMLSet.tag = "tag:yaml.org,2002:set";
const $ac5ae3ea1c51a36f$var$set = {
    collection: "map",
    identify: (value)=>value instanceof Set,
    nodeClass: $ac5ae3ea1c51a36f$var$YAMLSet,
    default: false,
    tag: "tag:yaml.org,2002:set",
    createNode: (schema, iterable, ctx)=>$ac5ae3ea1c51a36f$var$YAMLSet.from(schema, iterable, ctx),
    resolve (map, onError) {
        if ($FOECb.isMap(map)) {
            if (map.hasAllNullValues(true)) return Object.assign(new $ac5ae3ea1c51a36f$var$YAMLSet(), map);
            else onError("Set items must all have null values");
        } else onError("Expected a mapping for this tag");
        return map;
    }
};
$ac5ae3ea1c51a36f$export$d64eaa29dab13634 = $ac5ae3ea1c51a36f$var$YAMLSet;
$ac5ae3ea1c51a36f$export$adaa4cf7ef1b65be = $ac5ae3ea1c51a36f$var$set;

});

parcelRegister("9qleL", function(module, exports) {

$parcel$export(module.exports, "floatTime", () => $6dc703ff85d2e03c$export$1ca419aed578763e, (v) => $6dc703ff85d2e03c$export$1ca419aed578763e = v);
$parcel$export(module.exports, "intTime", () => $6dc703ff85d2e03c$export$14aedb0832cb7538, (v) => $6dc703ff85d2e03c$export$14aedb0832cb7538 = v);
$parcel$export(module.exports, "timestamp", () => $6dc703ff85d2e03c$export$fc00ee57782020aa, (v) => $6dc703ff85d2e03c$export$fc00ee57782020aa = v);
var $6dc703ff85d2e03c$export$1ca419aed578763e;
var $6dc703ff85d2e03c$export$14aedb0832cb7538;
var $6dc703ff85d2e03c$export$fc00ee57782020aa;
"use strict";

var $gKqSX = parcelRequire("gKqSX");
/** Internal types handle bigint as number, because TS can't figure it out. */ function $6dc703ff85d2e03c$var$parseSexagesimal(str, asBigInt) {
    const sign = str[0];
    const parts = sign === "-" || sign === "+" ? str.substring(1) : str;
    const num = (n)=>asBigInt ? BigInt(n) : Number(n);
    const res = parts.replace(/_/g, "").split(":").reduce((res, p)=>res * num(60) + num(p), num(0));
    return sign === "-" ? num(-1) * res : res;
}
/**
 * hhhh:mm:ss.sss
 *
 * Internal types handle bigint as number, because TS can't figure it out.
 */ function $6dc703ff85d2e03c$var$stringifySexagesimal(node) {
    let { value: value } = node;
    let num = (n)=>n;
    if (typeof value === "bigint") num = (n)=>BigInt(n);
    else if (isNaN(value) || !isFinite(value)) return $gKqSX.stringifyNumber(node);
    let sign = "";
    if (value < 0) {
        sign = "-";
        value *= num(-1);
    }
    const _60 = num(60);
    const parts = [
        value % _60
    ]; // seconds, including ms
    if (value < 60) parts.unshift(0); // at least one : is required
    else {
        value = (value - parts[0]) / _60;
        parts.unshift(value % _60); // minutes
        if (value >= 60) {
            value = (value - parts[0]) / _60;
            parts.unshift(value); // hours
        }
    }
    return sign + parts.map((n)=>String(n).padStart(2, "0")).join(":").replace(/000000\d*$/, "") // % 60 may introduce error
    ;
}
const $6dc703ff85d2e03c$var$intTime = {
    identify: (value)=>typeof value === "bigint" || Number.isInteger(value),
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "TIME",
    test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
    resolve: (str, _onError, { intAsBigInt: intAsBigInt })=>$6dc703ff85d2e03c$var$parseSexagesimal(str, intAsBigInt),
    stringify: $6dc703ff85d2e03c$var$stringifySexagesimal
};
const $6dc703ff85d2e03c$var$floatTime = {
    identify: (value)=>typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    format: "TIME",
    test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
    resolve: (str)=>$6dc703ff85d2e03c$var$parseSexagesimal(str, false),
    stringify: $6dc703ff85d2e03c$var$stringifySexagesimal
};
const $6dc703ff85d2e03c$var$timestamp = {
    identify: (value)=>value instanceof Date,
    default: true,
    tag: "tag:yaml.org,2002:timestamp",
    // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
    // may be omitted altogether, resulting in a date format. In such a case, the time part is
    // assumed to be 00:00:00Z (start of day, UTC).
    test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),
    resolve (str) {
        const match = str.match($6dc703ff85d2e03c$var$timestamp.test);
        if (!match) throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
        const [, year, month, day, hour, minute, second] = match.map(Number);
        const millisec = match[7] ? Number((match[7] + "00").substr(1, 3)) : 0;
        let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);
        const tz = match[8];
        if (tz && tz !== "Z") {
            let d = $6dc703ff85d2e03c$var$parseSexagesimal(tz, false);
            if (Math.abs(d) < 30) d *= 60;
            date -= 60000 * d;
        }
        return new Date(date);
    },
    stringify: ({ value: value })=>value.toISOString().replace(/((T00:00)?:00)?\.000Z$/, "")
};
$6dc703ff85d2e03c$export$1ca419aed578763e = $6dc703ff85d2e03c$var$floatTime;
$6dc703ff85d2e03c$export$14aedb0832cb7538 = $6dc703ff85d2e03c$var$intTime;
$6dc703ff85d2e03c$export$fc00ee57782020aa = $6dc703ff85d2e03c$var$timestamp;

});




parcelRegister("dRGsN", function(module, exports) {

$parcel$export(module.exports, "stringifyDocument", () => $a18129f773881524$export$4ad5e7f5f7ff7493, (v) => $a18129f773881524$export$4ad5e7f5f7ff7493 = v);
var $a18129f773881524$export$4ad5e7f5f7ff7493;
"use strict";

var $FOECb = parcelRequire("FOECb");

var $l36TR = parcelRequire("l36TR");

var $4joNE = parcelRequire("4joNE");
function $a18129f773881524$var$stringifyDocument(doc, options) {
    const lines = [];
    let hasDirectives = options.directives === true;
    if (options.directives !== false && doc.directives) {
        const dir = doc.directives.toString(doc);
        if (dir) {
            lines.push(dir);
            hasDirectives = true;
        } else if (doc.directives.docStart) hasDirectives = true;
    }
    if (hasDirectives) lines.push("---");
    const ctx = $l36TR.createStringifyContext(doc, options);
    const { commentString: commentString } = ctx.options;
    if (doc.commentBefore) {
        if (lines.length !== 1) lines.unshift("");
        const cs = commentString(doc.commentBefore);
        lines.unshift($4joNE.indentComment(cs, ""));
    }
    let chompKeep = false;
    let contentComment = null;
    if (doc.contents) {
        if ($FOECb.isNode(doc.contents)) {
            if (doc.contents.spaceBefore && hasDirectives) lines.push("");
            if (doc.contents.commentBefore) {
                const cs = commentString(doc.contents.commentBefore);
                lines.push($4joNE.indentComment(cs, ""));
            }
            // top-level block scalars need to be indented if followed by a comment
            ctx.forceBlockIndent = !!doc.comment;
            contentComment = doc.contents.comment;
        }
        const onChompKeep = contentComment ? undefined : ()=>chompKeep = true;
        let body = $l36TR.stringify(doc.contents, ctx, ()=>contentComment = null, onChompKeep);
        if (contentComment) body += $4joNE.lineComment(body, "", commentString(contentComment));
        if ((body[0] === "|" || body[0] === ">") && lines[lines.length - 1] === "---") // Top-level block scalars with a preceding doc marker ought to use the
        // same line for their header.
        lines[lines.length - 1] = `--- ${body}`;
        else lines.push(body);
    } else lines.push($l36TR.stringify(doc.contents, ctx));
    if (doc.directives?.docEnd) {
        if (doc.comment) {
            const cs = commentString(doc.comment);
            if (cs.includes("\n")) {
                lines.push("...");
                lines.push($4joNE.indentComment(cs, ""));
            } else lines.push(`... ${cs}`);
        } else lines.push("...");
    } else {
        let dc = doc.comment;
        if (dc && chompKeep) dc = dc.replace(/^\n+/, "");
        if (dc) {
            if ((!chompKeep || contentComment) && lines[lines.length - 1] !== "") lines.push("");
            lines.push($4joNE.indentComment(commentString(dc), ""));
        }
    }
    return lines.join("\n") + "\n";
}
$a18129f773881524$export$4ad5e7f5f7ff7493 = $a18129f773881524$var$stringifyDocument;

});


parcelRegister("9DvMJ", function(module, exports) {

$parcel$export(module.exports, "YAMLError", () => $7040696fe19e8f0e$export$699cd54d617b337f, (v) => $7040696fe19e8f0e$export$699cd54d617b337f = v);
$parcel$export(module.exports, "YAMLParseError", () => $7040696fe19e8f0e$export$c1188aaa49090a5c, (v) => $7040696fe19e8f0e$export$c1188aaa49090a5c = v);
$parcel$export(module.exports, "YAMLWarning", () => $7040696fe19e8f0e$export$856b463bac79f971, (v) => $7040696fe19e8f0e$export$856b463bac79f971 = v);
$parcel$export(module.exports, "prettifyError", () => $7040696fe19e8f0e$export$44eaaa72d914fe8c, (v) => $7040696fe19e8f0e$export$44eaaa72d914fe8c = v);
var $7040696fe19e8f0e$export$699cd54d617b337f;
var $7040696fe19e8f0e$export$c1188aaa49090a5c;
var $7040696fe19e8f0e$export$856b463bac79f971;
var $7040696fe19e8f0e$export$44eaaa72d914fe8c;
"use strict";
class $7040696fe19e8f0e$var$YAMLError extends Error {
    constructor(name, pos, code, message){
        super();
        this.name = name;
        this.code = code;
        this.message = message;
        this.pos = pos;
    }
}
class $7040696fe19e8f0e$var$YAMLParseError extends $7040696fe19e8f0e$var$YAMLError {
    constructor(pos, code, message){
        super("YAMLParseError", pos, code, message);
    }
}
class $7040696fe19e8f0e$var$YAMLWarning extends $7040696fe19e8f0e$var$YAMLError {
    constructor(pos, code, message){
        super("YAMLWarning", pos, code, message);
    }
}
const $7040696fe19e8f0e$var$prettifyError = (src, lc)=>(error)=>{
        if (error.pos[0] === -1) return;
        error.linePos = error.pos.map((pos)=>lc.linePos(pos));
        const { line: line, col: col } = error.linePos[0];
        error.message += ` at line ${line}, column ${col}`;
        let ci = col - 1;
        let lineStr = src.substring(lc.lineStarts[line - 1], lc.lineStarts[line]).replace(/[\n\r]+$/, "");
        // Trim to max 80 chars, keeping col position near the middle
        if (ci >= 60 && lineStr.length > 80) {
            const trimStart = Math.min(ci - 39, lineStr.length - 79);
            lineStr = "\u2026" + lineStr.substring(trimStart);
            ci -= trimStart - 1;
        }
        if (lineStr.length > 80) lineStr = lineStr.substring(0, 79) + "\u2026";
        // Include previous line in context if pointing at line start
        if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
            // Regexp won't match if start is trimmed
            let prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);
            if (prev.length > 80) prev = prev.substring(0, 79) + "\u2026\n";
            lineStr = prev + lineStr;
        }
        if (/[^ ]/.test(lineStr)) {
            let count = 1;
            const end = error.linePos[1];
            if (end && end.line === line && end.col > col) count = Math.max(1, Math.min(end.col - col, 80 - ci));
            const pointer = " ".repeat(ci) + "^".repeat(count);
            error.message += `:\n\n${lineStr}\n${pointer}\n`;
        }
    };
$7040696fe19e8f0e$export$699cd54d617b337f = $7040696fe19e8f0e$var$YAMLError;
$7040696fe19e8f0e$export$c1188aaa49090a5c = $7040696fe19e8f0e$var$YAMLParseError;
$7040696fe19e8f0e$export$856b463bac79f971 = $7040696fe19e8f0e$var$YAMLWarning;
$7040696fe19e8f0e$export$44eaaa72d914fe8c = $7040696fe19e8f0e$var$prettifyError;

});

parcelRegister("bF1yA", function(module, exports) {

$parcel$export(module.exports, "composeDoc", () => $87d4bb36ffd6b16f$export$5456c7d031a42a2a, (v) => $87d4bb36ffd6b16f$export$5456c7d031a42a2a = v);
var $87d4bb36ffd6b16f$export$5456c7d031a42a2a;
"use strict";

var $hfBM7 = parcelRequire("hfBM7");

var $kmmlz = parcelRequire("kmmlz");

var $9WEdM = parcelRequire("9WEdM");

var $lmRaV = parcelRequire("lmRaV");
function $87d4bb36ffd6b16f$var$composeDoc(options, directives, { offset: offset, start: start, value: value, end: end }, onError) {
    const opts = Object.assign({
        _directives: directives
    }, options);
    const doc = new $hfBM7.Document(undefined, opts);
    const ctx = {
        atKey: false,
        atRoot: true,
        directives: doc.directives,
        options: doc.options,
        schema: doc.schema
    };
    const props = $lmRaV.resolveProps(start, {
        indicator: "doc-start",
        next: value ?? end?.[0],
        offset: offset,
        onError: onError,
        parentIndent: 0,
        startOnNewline: true
    });
    if (props.found) {
        doc.directives.docStart = true;
        if (value && (value.type === "block-map" || value.type === "block-seq") && !props.hasNewline) onError(props.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker");
    }
    // @ts-expect-error If Contents is set, let's trust the user
    doc.contents = value ? $kmmlz.composeNode(ctx, value, props, onError) : $kmmlz.composeEmptyNode(ctx, props.end, start, null, props, onError);
    const contentEnd = doc.contents.range[2];
    const re = $9WEdM.resolveEnd(end, contentEnd, false, onError);
    if (re.comment) doc.comment = re.comment;
    doc.range = [
        offset,
        contentEnd,
        re.offset
    ];
    return doc;
}
$87d4bb36ffd6b16f$export$5456c7d031a42a2a = $87d4bb36ffd6b16f$var$composeDoc;

});
parcelRegister("kmmlz", function(module, exports) {

$parcel$export(module.exports, "composeEmptyNode", () => $ed27325fdeb3438b$export$ca2a6312a2caa181, (v) => $ed27325fdeb3438b$export$ca2a6312a2caa181 = v);
$parcel$export(module.exports, "composeNode", () => $ed27325fdeb3438b$export$9247f8d3b1b759e0, (v) => $ed27325fdeb3438b$export$9247f8d3b1b759e0 = v);
var $ed27325fdeb3438b$export$ca2a6312a2caa181;
var $ed27325fdeb3438b$export$9247f8d3b1b759e0;
"use strict";

var $jOHGy = parcelRequire("jOHGy");

var $FOECb = parcelRequire("FOECb");

var $fGa03 = parcelRequire("fGa03");

var $ifG8N = parcelRequire("ifG8N");

var $9WEdM = parcelRequire("9WEdM");

var $bkmny = parcelRequire("bkmny");
const $ed27325fdeb3438b$var$CN = {
    composeNode: $ed27325fdeb3438b$var$composeNode,
    composeEmptyNode: $ed27325fdeb3438b$var$composeEmptyNode
};
function $ed27325fdeb3438b$var$composeNode(ctx, token, props, onError) {
    const atKey = ctx.atKey;
    const { spaceBefore: spaceBefore, comment: comment, anchor: anchor, tag: tag } = props;
    let node;
    let isSrcToken = true;
    switch(token.type){
        case "alias":
            node = $ed27325fdeb3438b$var$composeAlias(ctx, token, onError);
            if (anchor || tag) onError(token, "ALIAS_PROPS", "An alias node must not specify any properties");
            break;
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
        case "block-scalar":
            node = $ifG8N.composeScalar(ctx, token, tag, onError);
            if (anchor) node.anchor = anchor.source.substring(1);
            break;
        case "block-map":
        case "block-seq":
        case "flow-collection":
            node = $fGa03.composeCollection($ed27325fdeb3438b$var$CN, ctx, token, props, onError);
            if (anchor) node.anchor = anchor.source.substring(1);
            break;
        default:
            {
                const message = token.type === "error" ? token.message : `Unsupported token (type: ${token.type})`;
                onError(token, "UNEXPECTED_TOKEN", message);
                node = $ed27325fdeb3438b$var$composeEmptyNode(ctx, token.offset, undefined, null, props, onError);
                isSrcToken = false;
            }
    }
    if (anchor && node.anchor === "") onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
    if (atKey && ctx.options.stringKeys && (!$FOECb.isScalar(node) || typeof node.value !== "string" || node.tag && node.tag !== "tag:yaml.org,2002:str")) {
        const msg = "With stringKeys, all keys must be strings";
        onError(tag ?? token, "NON_STRING_KEY", msg);
    }
    if (spaceBefore) node.spaceBefore = true;
    if (comment) {
        if (token.type === "scalar" && token.source === "") node.comment = comment;
        else node.commentBefore = comment;
    }
    // @ts-expect-error Type checking misses meaning of isSrcToken
    if (ctx.options.keepSourceTokens && isSrcToken) node.srcToken = token;
    return node;
}
function $ed27325fdeb3438b$var$composeEmptyNode(ctx, offset, before, pos, { spaceBefore: spaceBefore, comment: comment, anchor: anchor, tag: tag, end: end }, onError) {
    const token = {
        type: "scalar",
        offset: $bkmny.emptyScalarPosition(offset, before, pos),
        indent: -1,
        source: ""
    };
    const node = $ifG8N.composeScalar(ctx, token, tag, onError);
    if (anchor) {
        node.anchor = anchor.source.substring(1);
        if (node.anchor === "") onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
    }
    if (spaceBefore) node.spaceBefore = true;
    if (comment) {
        node.comment = comment;
        node.range[2] = end;
    }
    return node;
}
function $ed27325fdeb3438b$var$composeAlias({ options: options }, { offset: offset, source: source, end: end }, onError) {
    const alias = new $jOHGy.Alias(source.substring(1));
    if (alias.source === "") onError(offset, "BAD_ALIAS", "Alias cannot be an empty string");
    if (alias.source.endsWith(":")) onError(offset + source.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", true);
    const valueEnd = offset + source.length;
    const re = $9WEdM.resolveEnd(end, valueEnd, options.strict, onError);
    alias.range = [
        offset,
        valueEnd,
        re.offset
    ];
    if (re.comment) alias.comment = re.comment;
    return alias;
}
$ed27325fdeb3438b$export$ca2a6312a2caa181 = $ed27325fdeb3438b$var$composeEmptyNode;
$ed27325fdeb3438b$export$9247f8d3b1b759e0 = $ed27325fdeb3438b$var$composeNode;

});
parcelRegister("fGa03", function(module, exports) {

$parcel$export(module.exports, "composeCollection", () => $b6a2890cdb0164bb$export$670d412b724aec43, (v) => $b6a2890cdb0164bb$export$670d412b724aec43 = v);
var $b6a2890cdb0164bb$export$670d412b724aec43;
"use strict";

var $FOECb = parcelRequire("FOECb");

var $d6XNP = parcelRequire("d6XNP");

var $649pE = parcelRequire("649pE");

var $hOWPS = parcelRequire("hOWPS");

var $51Dtx = parcelRequire("51Dtx");

var $kZxEa = parcelRequire("kZxEa");

var $1VkPN = parcelRequire("1VkPN");
function $b6a2890cdb0164bb$var$resolveCollection(CN, ctx, token, onError, tagName, tag) {
    const coll = token.type === "block-map" ? $51Dtx.resolveBlockMap(CN, ctx, token, onError, tag) : token.type === "block-seq" ? $kZxEa.resolveBlockSeq(CN, ctx, token, onError, tag) : $1VkPN.resolveFlowCollection(CN, ctx, token, onError, tag);
    const Coll = coll.constructor;
    // If we got a tagName matching the class, or the tag name is '!',
    // then use the tagName from the node class used to create it.
    if (tagName === "!" || tagName === Coll.tagName) {
        coll.tag = Coll.tagName;
        return coll;
    }
    if (tagName) coll.tag = tagName;
    return coll;
}
function $b6a2890cdb0164bb$var$composeCollection(CN, ctx, token, props, onError) {
    const tagToken = props.tag;
    const tagName = !tagToken ? null : ctx.directives.tagName(tagToken.source, (msg)=>onError(tagToken, "TAG_RESOLVE_FAILED", msg));
    if (token.type === "block-seq") {
        const { anchor: anchor, newlineAfterProp: nl } = props;
        const lastProp = anchor && tagToken ? anchor.offset > tagToken.offset ? anchor : tagToken : anchor ?? tagToken;
        if (lastProp && (!nl || nl.offset < lastProp.offset)) {
            const message = "Missing newline after block sequence props";
            onError(lastProp, "MISSING_CHAR", message);
        }
    }
    const expType = token.type === "block-map" ? "map" : token.type === "block-seq" ? "seq" : token.start.source === "{" ? "map" : "seq";
    // shortcut: check if it's a generic YAMLMap or YAMLSeq
    // before jumping into the custom tag logic.
    if (!tagToken || !tagName || tagName === "!" || tagName === $649pE.YAMLMap.tagName && expType === "map" || tagName === $hOWPS.YAMLSeq.tagName && expType === "seq") return $b6a2890cdb0164bb$var$resolveCollection(CN, ctx, token, onError, tagName);
    let tag = ctx.schema.tags.find((t)=>t.tag === tagName && t.collection === expType);
    if (!tag) {
        const kt = ctx.schema.knownTags[tagName];
        if (kt && kt.collection === expType) {
            ctx.schema.tags.push(Object.assign({}, kt, {
                default: false
            }));
            tag = kt;
        } else {
            if (kt?.collection) onError(tagToken, "BAD_COLLECTION_TYPE", `${kt.tag} used for ${expType} collection, but expects ${kt.collection}`, true);
            else onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, true);
            return $b6a2890cdb0164bb$var$resolveCollection(CN, ctx, token, onError, tagName);
        }
    }
    const coll = $b6a2890cdb0164bb$var$resolveCollection(CN, ctx, token, onError, tagName, tag);
    const res = tag.resolve?.(coll, (msg)=>onError(tagToken, "TAG_RESOLVE_FAILED", msg), ctx.options) ?? coll;
    const node = $FOECb.isNode(res) ? res : new $d6XNP.Scalar(res);
    node.range = coll.range;
    node.tag = tagName;
    if (tag?.format) node.format = tag.format;
    return node;
}
$b6a2890cdb0164bb$export$670d412b724aec43 = $b6a2890cdb0164bb$var$composeCollection;

});
parcelRegister("51Dtx", function(module, exports) {

$parcel$export(module.exports, "resolveBlockMap", () => $3a8baabf6d645924$export$9c415700b1dbff3b, (v) => $3a8baabf6d645924$export$9c415700b1dbff3b = v);
var $3a8baabf6d645924$export$9c415700b1dbff3b;
"use strict";

var $5ff4n = parcelRequire("5ff4n");

var $649pE = parcelRequire("649pE");

var $lmRaV = parcelRequire("lmRaV");

var $5w7Zq = parcelRequire("5w7Zq");

var $9PxMI = parcelRequire("9PxMI");

var $6ljVA = parcelRequire("6ljVA");
const $3a8baabf6d645924$var$startColMsg = "All mapping items must start at the same column";
function $3a8baabf6d645924$var$resolveBlockMap({ composeNode: composeNode, composeEmptyNode: composeEmptyNode }, ctx, bm, onError, tag) {
    const NodeClass = tag?.nodeClass ?? $649pE.YAMLMap;
    const map = new NodeClass(ctx.schema);
    if (ctx.atRoot) ctx.atRoot = false;
    let offset = bm.offset;
    let commentEnd = null;
    for (const collItem of bm.items){
        const { start: start, key: key, sep: sep, value: value } = collItem;
        // key properties
        const keyProps = $lmRaV.resolveProps(start, {
            indicator: "explicit-key-ind",
            next: key ?? sep?.[0],
            offset: offset,
            onError: onError,
            parentIndent: bm.indent,
            startOnNewline: true
        });
        const implicitKey = !keyProps.found;
        if (implicitKey) {
            if (key) {
                if (key.type === "block-seq") onError(offset, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key");
                else if ("indent" in key && key.indent !== bm.indent) onError(offset, "BAD_INDENT", $3a8baabf6d645924$var$startColMsg);
            }
            if (!keyProps.anchor && !keyProps.tag && !sep) {
                commentEnd = keyProps.end;
                if (keyProps.comment) {
                    if (map.comment) map.comment += "\n" + keyProps.comment;
                    else map.comment = keyProps.comment;
                }
                continue;
            }
            if (keyProps.newlineAfterProp || $5w7Zq.containsNewline(key)) onError(key ?? start[start.length - 1], "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
        } else if (keyProps.found?.indent !== bm.indent) onError(offset, "BAD_INDENT", $3a8baabf6d645924$var$startColMsg);
        // key value
        ctx.atKey = true;
        const keyStart = keyProps.end;
        const keyNode = key ? composeNode(ctx, key, keyProps, onError) : composeEmptyNode(ctx, keyStart, start, null, keyProps, onError);
        if (ctx.schema.compat) $9PxMI.flowIndentCheck(bm.indent, key, onError);
        ctx.atKey = false;
        if ($6ljVA.mapIncludes(ctx, map.items, keyNode)) onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
        // value properties
        const valueProps = $lmRaV.resolveProps(sep ?? [], {
            indicator: "map-value-ind",
            next: value,
            offset: keyNode.range[2],
            onError: onError,
            parentIndent: bm.indent,
            startOnNewline: !key || key.type === "block-scalar"
        });
        offset = valueProps.end;
        if (valueProps.found) {
            if (implicitKey) {
                if (value?.type === "block-map" && !valueProps.hasNewline) onError(offset, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings");
                if (ctx.options.strict && keyProps.start < valueProps.found.offset - 1024) onError(keyNode.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key");
            }
            // value value
            const valueNode = value ? composeNode(ctx, value, valueProps, onError) : composeEmptyNode(ctx, offset, sep, null, valueProps, onError);
            if (ctx.schema.compat) $9PxMI.flowIndentCheck(bm.indent, value, onError);
            offset = valueNode.range[2];
            const pair = new $5ff4n.Pair(keyNode, valueNode);
            if (ctx.options.keepSourceTokens) pair.srcToken = collItem;
            map.items.push(pair);
        } else {
            // key with no value
            if (implicitKey) onError(keyNode.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values");
            if (valueProps.comment) {
                if (keyNode.comment) keyNode.comment += "\n" + valueProps.comment;
                else keyNode.comment = valueProps.comment;
            }
            const pair = new $5ff4n.Pair(keyNode);
            if (ctx.options.keepSourceTokens) pair.srcToken = collItem;
            map.items.push(pair);
        }
    }
    if (commentEnd && commentEnd < offset) onError(commentEnd, "IMPOSSIBLE", "Map comment with trailing content");
    map.range = [
        bm.offset,
        offset,
        commentEnd ?? offset
    ];
    return map;
}
$3a8baabf6d645924$export$9c415700b1dbff3b = $3a8baabf6d645924$var$resolveBlockMap;

});
parcelRegister("lmRaV", function(module, exports) {

$parcel$export(module.exports, "resolveProps", () => $f8e4e68e72449d03$export$3947d67c7569cd22, (v) => $f8e4e68e72449d03$export$3947d67c7569cd22 = v);
var $f8e4e68e72449d03$export$3947d67c7569cd22;
"use strict";
function $f8e4e68e72449d03$var$resolveProps(tokens, { flow: flow, indicator: indicator, next: next, offset: offset, onError: onError, parentIndent: parentIndent, startOnNewline: startOnNewline }) {
    let spaceBefore = false;
    let atNewline = startOnNewline;
    let hasSpace = startOnNewline;
    let comment = "";
    let commentSep = "";
    let hasNewline = false;
    let reqSpace = false;
    let tab = null;
    let anchor = null;
    let tag = null;
    let newlineAfterProp = null;
    let comma = null;
    let found = null;
    let start = null;
    for (const token of tokens){
        if (reqSpace) {
            if (token.type !== "space" && token.type !== "newline" && token.type !== "comma") onError(token.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
            reqSpace = false;
        }
        if (tab) {
            if (atNewline && token.type !== "comment" && token.type !== "newline") onError(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
            tab = null;
        }
        switch(token.type){
            case "space":
                // At the doc level, tabs at line start may be parsed
                // as leading white space rather than indentation.
                // In a flow collection, only the parser handles indent.
                if (!flow && (indicator !== "doc-start" || next?.type !== "flow-collection") && token.source.includes("	")) tab = token;
                hasSpace = true;
                break;
            case "comment":
                {
                    if (!hasSpace) onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
                    const cb = token.source.substring(1) || " ";
                    if (!comment) comment = cb;
                    else comment += commentSep + cb;
                    commentSep = "";
                    atNewline = false;
                    break;
                }
            case "newline":
                if (atNewline) {
                    if (comment) comment += token.source;
                    else spaceBefore = true;
                } else commentSep += token.source;
                atNewline = true;
                hasNewline = true;
                if (anchor || tag) newlineAfterProp = token;
                hasSpace = true;
                break;
            case "anchor":
                if (anchor) onError(token, "MULTIPLE_ANCHORS", "A node can have at most one anchor");
                if (token.source.endsWith(":")) onError(token.offset + token.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", true);
                anchor = token;
                if (start === null) start = token.offset;
                atNewline = false;
                hasSpace = false;
                reqSpace = true;
                break;
            case "tag":
                if (tag) onError(token, "MULTIPLE_TAGS", "A node can have at most one tag");
                tag = token;
                if (start === null) start = token.offset;
                atNewline = false;
                hasSpace = false;
                reqSpace = true;
                break;
            case indicator:
                // Could here handle preceding comments differently
                if (anchor || tag) onError(token, "BAD_PROP_ORDER", `Anchors and tags must be after the ${token.source} indicator`);
                if (found) onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.source} in ${flow ?? "collection"}`);
                found = token;
                atNewline = indicator === "seq-item-ind" || indicator === "explicit-key-ind";
                hasSpace = false;
                break;
            case "comma":
                if (flow) {
                    if (comma) onError(token, "UNEXPECTED_TOKEN", `Unexpected , in ${flow}`);
                    comma = token;
                    atNewline = false;
                    hasSpace = false;
                    break;
                }
            // else fallthrough
            default:
                onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.type} token`);
                atNewline = false;
                hasSpace = false;
        }
    }
    const last = tokens[tokens.length - 1];
    const end = last ? last.offset + last.source.length : offset;
    if (reqSpace && next && next.type !== "space" && next.type !== "newline" && next.type !== "comma" && (next.type !== "scalar" || next.source !== "")) onError(next.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
    if (tab && (atNewline && tab.indent <= parentIndent || next?.type === "block-map" || next?.type === "block-seq")) onError(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
    return {
        comma: comma,
        found: found,
        spaceBefore: spaceBefore,
        comment: comment,
        hasNewline: hasNewline,
        anchor: anchor,
        tag: tag,
        newlineAfterProp: newlineAfterProp,
        end: end,
        start: start ?? end
    };
}
$f8e4e68e72449d03$export$3947d67c7569cd22 = $f8e4e68e72449d03$var$resolveProps;

});

parcelRegister("5w7Zq", function(module, exports) {

$parcel$export(module.exports, "containsNewline", () => $404623842a75c7b8$export$72c4c19842d44e03, (v) => $404623842a75c7b8$export$72c4c19842d44e03 = v);
var $404623842a75c7b8$export$72c4c19842d44e03;
"use strict";
function $404623842a75c7b8$var$containsNewline(key) {
    if (!key) return null;
    switch(key.type){
        case "alias":
        case "scalar":
        case "double-quoted-scalar":
        case "single-quoted-scalar":
            if (key.source.includes("\n")) return true;
            if (key.end) {
                for (const st of key.end)if (st.type === "newline") return true;
            }
            return false;
        case "flow-collection":
            for (const it of key.items){
                for (const st of it.start)if (st.type === "newline") return true;
                if (it.sep) {
                    for (const st of it.sep)if (st.type === "newline") return true;
                }
                if ($404623842a75c7b8$var$containsNewline(it.key) || $404623842a75c7b8$var$containsNewline(it.value)) return true;
            }
            return false;
        default:
            return true;
    }
}
$404623842a75c7b8$export$72c4c19842d44e03 = $404623842a75c7b8$var$containsNewline;

});

parcelRegister("9PxMI", function(module, exports) {

$parcel$export(module.exports, "flowIndentCheck", () => $7283156b9090807b$export$6195a21984b7a892, (v) => $7283156b9090807b$export$6195a21984b7a892 = v);
var $7283156b9090807b$export$6195a21984b7a892;
"use strict";

var $5w7Zq = parcelRequire("5w7Zq");
function $7283156b9090807b$var$flowIndentCheck(indent, fc, onError) {
    if (fc?.type === "flow-collection") {
        const end = fc.end[0];
        if (end.indent === indent && (end.source === "]" || end.source === "}") && $5w7Zq.containsNewline(fc)) {
            const msg = "Flow end indicator should be more indented than parent";
            onError(end, "BAD_INDENT", msg, true);
        }
    }
}
$7283156b9090807b$export$6195a21984b7a892 = $7283156b9090807b$var$flowIndentCheck;

});

parcelRegister("6ljVA", function(module, exports) {

$parcel$export(module.exports, "mapIncludes", () => $49e4298054cd03cb$export$ab8ef54c273a4fc3, (v) => $49e4298054cd03cb$export$ab8ef54c273a4fc3 = v);
var $49e4298054cd03cb$export$ab8ef54c273a4fc3;
"use strict";

var $FOECb = parcelRequire("FOECb");
function $49e4298054cd03cb$var$mapIncludes(ctx, items, search) {
    const { uniqueKeys: uniqueKeys } = ctx.options;
    if (uniqueKeys === false) return false;
    const isEqual = typeof uniqueKeys === "function" ? uniqueKeys : (a, b)=>a === b || $FOECb.isScalar(a) && $FOECb.isScalar(b) && a.value === b.value;
    return items.some((pair)=>isEqual(pair.key, search));
}
$49e4298054cd03cb$export$ab8ef54c273a4fc3 = $49e4298054cd03cb$var$mapIncludes;

});


parcelRegister("kZxEa", function(module, exports) {

$parcel$export(module.exports, "resolveBlockSeq", () => $f4839ab493d3143d$export$2db6dd42184ff7ac, (v) => $f4839ab493d3143d$export$2db6dd42184ff7ac = v);
var $f4839ab493d3143d$export$2db6dd42184ff7ac;
"use strict";

var $hOWPS = parcelRequire("hOWPS");

var $lmRaV = parcelRequire("lmRaV");

var $9PxMI = parcelRequire("9PxMI");
function $f4839ab493d3143d$var$resolveBlockSeq({ composeNode: composeNode, composeEmptyNode: composeEmptyNode }, ctx, bs, onError, tag) {
    const NodeClass = tag?.nodeClass ?? $hOWPS.YAMLSeq;
    const seq = new NodeClass(ctx.schema);
    if (ctx.atRoot) ctx.atRoot = false;
    if (ctx.atKey) ctx.atKey = false;
    let offset = bs.offset;
    let commentEnd = null;
    for (const { start: start, value: value } of bs.items){
        const props = $lmRaV.resolveProps(start, {
            indicator: "seq-item-ind",
            next: value,
            offset: offset,
            onError: onError,
            parentIndent: bs.indent,
            startOnNewline: true
        });
        if (!props.found) {
            if (props.anchor || props.tag || value) {
                if (value && value.type === "block-seq") onError(props.end, "BAD_INDENT", "All sequence items must start at the same column");
                else onError(offset, "MISSING_CHAR", "Sequence item without - indicator");
            } else {
                commentEnd = props.end;
                if (props.comment) seq.comment = props.comment;
                continue;
            }
        }
        const node = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, start, null, props, onError);
        if (ctx.schema.compat) $9PxMI.flowIndentCheck(bs.indent, value, onError);
        offset = node.range[2];
        seq.items.push(node);
    }
    seq.range = [
        bs.offset,
        offset,
        commentEnd ?? offset
    ];
    return seq;
}
$f4839ab493d3143d$export$2db6dd42184ff7ac = $f4839ab493d3143d$var$resolveBlockSeq;

});

parcelRegister("1VkPN", function(module, exports) {

$parcel$export(module.exports, "resolveFlowCollection", () => $166b4696425452c2$export$fdd70fe10aa6d63e, (v) => $166b4696425452c2$export$fdd70fe10aa6d63e = v);
var $166b4696425452c2$export$fdd70fe10aa6d63e;
"use strict";

var $FOECb = parcelRequire("FOECb");

var $5ff4n = parcelRequire("5ff4n");

var $649pE = parcelRequire("649pE");

var $hOWPS = parcelRequire("hOWPS");

var $9WEdM = parcelRequire("9WEdM");

var $lmRaV = parcelRequire("lmRaV");

var $5w7Zq = parcelRequire("5w7Zq");

var $6ljVA = parcelRequire("6ljVA");
const $166b4696425452c2$var$blockMsg = "Block collections are not allowed within flow collections";
const $166b4696425452c2$var$isBlock = (token)=>token && (token.type === "block-map" || token.type === "block-seq");
function $166b4696425452c2$var$resolveFlowCollection({ composeNode: composeNode, composeEmptyNode: composeEmptyNode }, ctx, fc, onError, tag) {
    const isMap = fc.start.source === "{";
    const fcName = isMap ? "flow map" : "flow sequence";
    const NodeClass = tag?.nodeClass ?? (isMap ? $649pE.YAMLMap : $hOWPS.YAMLSeq);
    const coll = new NodeClass(ctx.schema);
    coll.flow = true;
    const atRoot = ctx.atRoot;
    if (atRoot) ctx.atRoot = false;
    if (ctx.atKey) ctx.atKey = false;
    let offset = fc.offset + fc.start.source.length;
    for(let i = 0; i < fc.items.length; ++i){
        const collItem = fc.items[i];
        const { start: start, key: key, sep: sep, value: value } = collItem;
        const props = $lmRaV.resolveProps(start, {
            flow: fcName,
            indicator: "explicit-key-ind",
            next: key ?? sep?.[0],
            offset: offset,
            onError: onError,
            parentIndent: fc.indent,
            startOnNewline: false
        });
        if (!props.found) {
            if (!props.anchor && !props.tag && !sep && !value) {
                if (i === 0 && props.comma) onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
                else if (i < fc.items.length - 1) onError(props.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${fcName}`);
                if (props.comment) {
                    if (coll.comment) coll.comment += "\n" + props.comment;
                    else coll.comment = props.comment;
                }
                offset = props.end;
                continue;
            }
            if (!isMap && ctx.options.strict && $5w7Zq.containsNewline(key)) onError(key, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
        }
        if (i === 0) {
            if (props.comma) onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
        } else {
            if (!props.comma) onError(props.start, "MISSING_CHAR", `Missing , between ${fcName} items`);
            if (props.comment) {
                let prevItemComment = "";
                loop: for (const st of start)switch(st.type){
                    case "comma":
                    case "space":
                        break;
                    case "comment":
                        prevItemComment = st.source.substring(1);
                        break loop;
                    default:
                        break loop;
                }
                if (prevItemComment) {
                    let prev = coll.items[coll.items.length - 1];
                    if ($FOECb.isPair(prev)) prev = prev.value ?? prev.key;
                    if (prev.comment) prev.comment += "\n" + prevItemComment;
                    else prev.comment = prevItemComment;
                    props.comment = props.comment.substring(prevItemComment.length + 1);
                }
            }
        }
        if (!isMap && !sep && !props.found) {
            // item is a value in a seq
            // → key & sep are empty, start does not include ? or :
            const valueNode = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, sep, null, props, onError);
            coll.items.push(valueNode);
            offset = valueNode.range[2];
            if ($166b4696425452c2$var$isBlock(value)) onError(valueNode.range, "BLOCK_IN_FLOW", $166b4696425452c2$var$blockMsg);
        } else {
            // item is a key+value pair
            // key value
            ctx.atKey = true;
            const keyStart = props.end;
            const keyNode = key ? composeNode(ctx, key, props, onError) : composeEmptyNode(ctx, keyStart, start, null, props, onError);
            if ($166b4696425452c2$var$isBlock(key)) onError(keyNode.range, "BLOCK_IN_FLOW", $166b4696425452c2$var$blockMsg);
            ctx.atKey = false;
            // value properties
            const valueProps = $lmRaV.resolveProps(sep ?? [], {
                flow: fcName,
                indicator: "map-value-ind",
                next: value,
                offset: keyNode.range[2],
                onError: onError,
                parentIndent: fc.indent,
                startOnNewline: false
            });
            if (valueProps.found) {
                if (!isMap && !props.found && ctx.options.strict) {
                    if (sep) for (const st of sep){
                        if (st === valueProps.found) break;
                        if (st.type === "newline") {
                            onError(st, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                            break;
                        }
                    }
                    if (props.start < valueProps.found.offset - 1024) onError(valueProps.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
                }
            } else if (value) {
                if ("source" in value && value.source && value.source[0] === ":") onError(value, "MISSING_CHAR", `Missing space after : in ${fcName}`);
                else onError(valueProps.start, "MISSING_CHAR", `Missing , or : between ${fcName} items`);
            }
            // value value
            const valueNode = value ? composeNode(ctx, value, valueProps, onError) : valueProps.found ? composeEmptyNode(ctx, valueProps.end, sep, null, valueProps, onError) : null;
            if (valueNode) {
                if ($166b4696425452c2$var$isBlock(value)) onError(valueNode.range, "BLOCK_IN_FLOW", $166b4696425452c2$var$blockMsg);
            } else if (valueProps.comment) {
                if (keyNode.comment) keyNode.comment += "\n" + valueProps.comment;
                else keyNode.comment = valueProps.comment;
            }
            const pair = new $5ff4n.Pair(keyNode, valueNode);
            if (ctx.options.keepSourceTokens) pair.srcToken = collItem;
            if (isMap) {
                const map = coll;
                if ($6ljVA.mapIncludes(ctx, map.items, keyNode)) onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
                map.items.push(pair);
            } else {
                const map = new $649pE.YAMLMap(ctx.schema);
                map.flow = true;
                map.items.push(pair);
                const endRange = (valueNode ?? keyNode).range;
                map.range = [
                    keyNode.range[0],
                    endRange[1],
                    endRange[2]
                ];
                coll.items.push(map);
            }
            offset = valueNode ? valueNode.range[2] : valueProps.end;
        }
    }
    const expectedEnd = isMap ? "}" : "]";
    const [ce, ...ee] = fc.end;
    let cePos = offset;
    if (ce && ce.source === expectedEnd) cePos = ce.offset + ce.source.length;
    else {
        const name = fcName[0].toUpperCase() + fcName.substring(1);
        const msg = atRoot ? `${name} must end with a ${expectedEnd}` : `${name} in block collection must be sufficiently indented and end with a ${expectedEnd}`;
        onError(offset, atRoot ? "MISSING_CHAR" : "BAD_INDENT", msg);
        if (ce && ce.source.length !== 1) ee.unshift(ce);
    }
    if (ee.length > 0) {
        const end = $9WEdM.resolveEnd(ee, cePos, ctx.options.strict, onError);
        if (end.comment) {
            if (coll.comment) coll.comment += "\n" + end.comment;
            else coll.comment = end.comment;
        }
        coll.range = [
            fc.offset,
            cePos,
            end.offset
        ];
    } else coll.range = [
        fc.offset,
        cePos,
        cePos
    ];
    return coll;
}
$166b4696425452c2$export$fdd70fe10aa6d63e = $166b4696425452c2$var$resolveFlowCollection;

});
parcelRegister("9WEdM", function(module, exports) {

$parcel$export(module.exports, "resolveEnd", () => $73d8baf6707bd64c$export$9be3172c55e482a, (v) => $73d8baf6707bd64c$export$9be3172c55e482a = v);
var $73d8baf6707bd64c$export$9be3172c55e482a;
"use strict";
function $73d8baf6707bd64c$var$resolveEnd(end, offset, reqSpace, onError) {
    let comment = "";
    if (end) {
        let hasSpace = false;
        let sep = "";
        for (const token of end){
            const { source: source, type: type } = token;
            switch(type){
                case "space":
                    hasSpace = true;
                    break;
                case "comment":
                    {
                        if (reqSpace && !hasSpace) onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
                        const cb = source.substring(1) || " ";
                        if (!comment) comment = cb;
                        else comment += sep + cb;
                        sep = "";
                        break;
                    }
                case "newline":
                    if (comment) sep += source;
                    hasSpace = true;
                    break;
                default:
                    onError(token, "UNEXPECTED_TOKEN", `Unexpected ${type} at node end`);
            }
            offset += source.length;
        }
    }
    return {
        comment: comment,
        offset: offset
    };
}
$73d8baf6707bd64c$export$9be3172c55e482a = $73d8baf6707bd64c$var$resolveEnd;

});



parcelRegister("ifG8N", function(module, exports) {

$parcel$export(module.exports, "composeScalar", () => $d49a50fec138e2e5$export$1fb1e480165041ec, (v) => $d49a50fec138e2e5$export$1fb1e480165041ec = v);
var $d49a50fec138e2e5$export$1fb1e480165041ec;
"use strict";

var $FOECb = parcelRequire("FOECb");

var $d6XNP = parcelRequire("d6XNP");

var $2O2j0 = parcelRequire("2O2j0");

var $hIwT2 = parcelRequire("hIwT2");
function $d49a50fec138e2e5$var$composeScalar(ctx, token, tagToken, onError) {
    const { value: value, type: type, comment: comment, range: range } = token.type === "block-scalar" ? $2O2j0.resolveBlockScalar(ctx, token, onError) : $hIwT2.resolveFlowScalar(token, ctx.options.strict, onError);
    const tagName = tagToken ? ctx.directives.tagName(tagToken.source, (msg)=>onError(tagToken, "TAG_RESOLVE_FAILED", msg)) : null;
    let tag;
    if (ctx.options.stringKeys && ctx.atKey) tag = ctx.schema[$FOECb.SCALAR];
    else if (tagName) tag = $d49a50fec138e2e5$var$findScalarTagByName(ctx.schema, value, tagName, tagToken, onError);
    else if (token.type === "scalar") tag = $d49a50fec138e2e5$var$findScalarTagByTest(ctx, value, token, onError);
    else tag = ctx.schema[$FOECb.SCALAR];
    let scalar;
    try {
        const res = tag.resolve(value, (msg)=>onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg), ctx.options);
        scalar = $FOECb.isScalar(res) ? res : new $d6XNP.Scalar(res);
    } catch (error) {
        const msg = error instanceof Error ? error.message : String(error);
        onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg);
        scalar = new $d6XNP.Scalar(value);
    }
    scalar.range = range;
    scalar.source = value;
    if (type) scalar.type = type;
    if (tagName) scalar.tag = tagName;
    if (tag.format) scalar.format = tag.format;
    if (comment) scalar.comment = comment;
    return scalar;
}
function $d49a50fec138e2e5$var$findScalarTagByName(schema, value, tagName, tagToken, onError) {
    if (tagName === "!") return schema[$FOECb.SCALAR]; // non-specific tag
    const matchWithTest = [];
    for (const tag of schema.tags)if (!tag.collection && tag.tag === tagName) {
        if (tag.default && tag.test) matchWithTest.push(tag);
        else return tag;
    }
    for (const tag of matchWithTest)if (tag.test?.test(value)) return tag;
    const kt = schema.knownTags[tagName];
    if (kt && !kt.collection) {
        // Ensure that the known tag is available for stringifying,
        // but does not get used by default.
        schema.tags.push(Object.assign({}, kt, {
            default: false,
            test: undefined
        }));
        return kt;
    }
    onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, tagName !== "tag:yaml.org,2002:str");
    return schema[$FOECb.SCALAR];
}
function $d49a50fec138e2e5$var$findScalarTagByTest({ atKey: atKey, directives: directives, schema: schema }, value, token, onError) {
    const tag = schema.tags.find((tag)=>(tag.default === true || atKey && tag.default === "key") && tag.test?.test(value)) || schema[$FOECb.SCALAR];
    if (schema.compat) {
        const compat = schema.compat.find((tag)=>tag.default && tag.test?.test(value)) ?? schema[$FOECb.SCALAR];
        if (tag.tag !== compat.tag) {
            const ts = directives.tagString(tag.tag);
            const cs = directives.tagString(compat.tag);
            const msg = `Value may be parsed as either ${ts} or ${cs}`;
            onError(token, "TAG_RESOLVE_FAILED", msg, true);
        }
    }
    return tag;
}
$d49a50fec138e2e5$export$1fb1e480165041ec = $d49a50fec138e2e5$var$composeScalar;

});
parcelRegister("2O2j0", function(module, exports) {

$parcel$export(module.exports, "resolveBlockScalar", () => $20b20a1a0d0cb59d$export$14aaa50a76ee848f, (v) => $20b20a1a0d0cb59d$export$14aaa50a76ee848f = v);
var $20b20a1a0d0cb59d$export$14aaa50a76ee848f;
"use strict";

var $d6XNP = parcelRequire("d6XNP");
function $20b20a1a0d0cb59d$var$resolveBlockScalar(ctx, scalar, onError) {
    const start = scalar.offset;
    const header = $20b20a1a0d0cb59d$var$parseBlockScalarHeader(scalar, ctx.options.strict, onError);
    if (!header) return {
        value: "",
        type: null,
        comment: "",
        range: [
            start,
            start,
            start
        ]
    };
    const type = header.mode === ">" ? $d6XNP.Scalar.BLOCK_FOLDED : $d6XNP.Scalar.BLOCK_LITERAL;
    const lines = scalar.source ? $20b20a1a0d0cb59d$var$splitLines(scalar.source) : [];
    // determine the end of content & start of chomping
    let chompStart = lines.length;
    for(let i = lines.length - 1; i >= 0; --i){
        const content = lines[i][1];
        if (content === "" || content === "\r") chompStart = i;
        else break;
    }
    // shortcut for empty contents
    if (chompStart === 0) {
        const value = header.chomp === "+" && lines.length > 0 ? "\n".repeat(Math.max(1, lines.length - 1)) : "";
        let end = start + header.length;
        if (scalar.source) end += scalar.source.length;
        return {
            value: value,
            type: type,
            comment: header.comment,
            range: [
                start,
                end,
                end
            ]
        };
    }
    // find the indentation level to trim from start
    let trimIndent = scalar.indent + header.indent;
    let offset = scalar.offset + header.length;
    let contentStart = 0;
    for(let i = 0; i < chompStart; ++i){
        const [indent, content] = lines[i];
        if (content === "" || content === "\r") {
            if (header.indent === 0 && indent.length > trimIndent) trimIndent = indent.length;
        } else {
            if (indent.length < trimIndent) {
                const message = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
                onError(offset + indent.length, "MISSING_CHAR", message);
            }
            if (header.indent === 0) trimIndent = indent.length;
            contentStart = i;
            if (trimIndent === 0 && !ctx.atRoot) {
                const message = "Block scalar values in collections must be indented";
                onError(offset, "BAD_INDENT", message);
            }
            break;
        }
        offset += indent.length + content.length + 1;
    }
    // include trailing more-indented empty lines in content
    for(let i = lines.length - 1; i >= chompStart; --i)if (lines[i][0].length > trimIndent) chompStart = i + 1;
    let value = "";
    let sep = "";
    let prevMoreIndented = false;
    // leading whitespace is kept intact
    for(let i = 0; i < contentStart; ++i)value += lines[i][0].slice(trimIndent) + "\n";
    for(let i = contentStart; i < chompStart; ++i){
        let [indent, content] = lines[i];
        offset += indent.length + content.length + 1;
        const crlf = content[content.length - 1] === "\r";
        if (crlf) content = content.slice(0, -1);
        /* istanbul ignore if already caught in lexer */ if (content && indent.length < trimIndent) {
            const src = header.indent ? "explicit indentation indicator" : "first line";
            const message = `Block scalar lines must not be less indented than their ${src}`;
            onError(offset - content.length - (crlf ? 2 : 1), "BAD_INDENT", message);
            indent = "";
        }
        if (type === $d6XNP.Scalar.BLOCK_LITERAL) {
            value += sep + indent.slice(trimIndent) + content;
            sep = "\n";
        } else if (indent.length > trimIndent || content[0] === "	") {
            // more-indented content within a folded block
            if (sep === " ") sep = "\n";
            else if (!prevMoreIndented && sep === "\n") sep = "\n\n";
            value += sep + indent.slice(trimIndent) + content;
            sep = "\n";
            prevMoreIndented = true;
        } else if (content === "") {
            // empty line
            if (sep === "\n") value += "\n";
            else sep = "\n";
        } else {
            value += sep + content;
            sep = " ";
            prevMoreIndented = false;
        }
    }
    switch(header.chomp){
        case "-":
            break;
        case "+":
            for(let i = chompStart; i < lines.length; ++i)value += "\n" + lines[i][0].slice(trimIndent);
            if (value[value.length - 1] !== "\n") value += "\n";
            break;
        default:
            value += "\n";
    }
    const end = start + header.length + scalar.source.length;
    return {
        value: value,
        type: type,
        comment: header.comment,
        range: [
            start,
            end,
            end
        ]
    };
}
function $20b20a1a0d0cb59d$var$parseBlockScalarHeader({ offset: offset, props: props }, strict, onError) {
    /* istanbul ignore if should not happen */ if (props[0].type !== "block-scalar-header") {
        onError(props[0], "IMPOSSIBLE", "Block scalar header not found");
        return null;
    }
    const { source: source } = props[0];
    const mode = source[0];
    let indent = 0;
    let chomp = "";
    let error = -1;
    for(let i = 1; i < source.length; ++i){
        const ch = source[i];
        if (!chomp && (ch === "-" || ch === "+")) chomp = ch;
        else {
            const n = Number(ch);
            if (!indent && n) indent = n;
            else if (error === -1) error = offset + i;
        }
    }
    if (error !== -1) onError(error, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${source}`);
    let hasSpace = false;
    let comment = "";
    let length = source.length;
    for(let i = 1; i < props.length; ++i){
        const token = props[i];
        switch(token.type){
            case "space":
                hasSpace = true;
            // fallthrough
            case "newline":
                length += token.source.length;
                break;
            case "comment":
                if (strict && !hasSpace) {
                    const message = "Comments must be separated from other tokens by white space characters";
                    onError(token, "MISSING_CHAR", message);
                }
                length += token.source.length;
                comment = token.source.substring(1);
                break;
            case "error":
                onError(token, "UNEXPECTED_TOKEN", token.message);
                length += token.source.length;
                break;
            /* istanbul ignore next should not happen */ default:
                {
                    const message = `Unexpected token in block scalar header: ${token.type}`;
                    onError(token, "UNEXPECTED_TOKEN", message);
                    const ts = token.source;
                    if (ts && typeof ts === "string") length += ts.length;
                }
        }
    }
    return {
        mode: mode,
        indent: indent,
        chomp: chomp,
        comment: comment,
        length: length
    };
}
/** @returns Array of lines split up as `[indent, content]` */ function $20b20a1a0d0cb59d$var$splitLines(source) {
    const split = source.split(/\n( *)/);
    const first = split[0];
    const m = first.match(/^( *)/);
    const line0 = m?.[1] ? [
        m[1],
        first.slice(m[1].length)
    ] : [
        "",
        first
    ];
    const lines = [
        line0
    ];
    for(let i = 1; i < split.length; i += 2)lines.push([
        split[i],
        split[i + 1]
    ]);
    return lines;
}
$20b20a1a0d0cb59d$export$14aaa50a76ee848f = $20b20a1a0d0cb59d$var$resolveBlockScalar;

});

parcelRegister("hIwT2", function(module, exports) {

$parcel$export(module.exports, "resolveFlowScalar", () => $ce600e557ae96d9c$export$2f1c3b16290da8c8, (v) => $ce600e557ae96d9c$export$2f1c3b16290da8c8 = v);
var $ce600e557ae96d9c$export$2f1c3b16290da8c8;
"use strict";

var $d6XNP = parcelRequire("d6XNP");

var $9WEdM = parcelRequire("9WEdM");
function $ce600e557ae96d9c$var$resolveFlowScalar(scalar, strict, onError) {
    const { offset: offset, type: type, source: source, end: end } = scalar;
    let _type;
    let value;
    const _onError = (rel, code, msg)=>onError(offset + rel, code, msg);
    switch(type){
        case "scalar":
            _type = $d6XNP.Scalar.PLAIN;
            value = $ce600e557ae96d9c$var$plainValue(source, _onError);
            break;
        case "single-quoted-scalar":
            _type = $d6XNP.Scalar.QUOTE_SINGLE;
            value = $ce600e557ae96d9c$var$singleQuotedValue(source, _onError);
            break;
        case "double-quoted-scalar":
            _type = $d6XNP.Scalar.QUOTE_DOUBLE;
            value = $ce600e557ae96d9c$var$doubleQuotedValue(source, _onError);
            break;
        /* istanbul ignore next should not happen */ default:
            onError(scalar, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${type}`);
            return {
                value: "",
                type: null,
                comment: "",
                range: [
                    offset,
                    offset + source.length,
                    offset + source.length
                ]
            };
    }
    const valueEnd = offset + source.length;
    const re = $9WEdM.resolveEnd(end, valueEnd, strict, onError);
    return {
        value: value,
        type: _type,
        comment: re.comment,
        range: [
            offset,
            valueEnd,
            re.offset
        ]
    };
}
function $ce600e557ae96d9c$var$plainValue(source, onError) {
    let badChar = "";
    switch(source[0]){
        /* istanbul ignore next should not happen */ case "	":
            badChar = "a tab character";
            break;
        case ",":
            badChar = "flow indicator character ,";
            break;
        case "%":
            badChar = "directive indicator character %";
            break;
        case "|":
        case ">":
            badChar = `block scalar indicator ${source[0]}`;
            break;
        case "@":
        case "`":
            badChar = `reserved character ${source[0]}`;
            break;
    }
    if (badChar) onError(0, "BAD_SCALAR_START", `Plain value cannot start with ${badChar}`);
    return $ce600e557ae96d9c$var$foldLines(source);
}
function $ce600e557ae96d9c$var$singleQuotedValue(source, onError) {
    if (source[source.length - 1] !== "'" || source.length === 1) onError(source.length, "MISSING_CHAR", "Missing closing 'quote");
    return $ce600e557ae96d9c$var$foldLines(source.slice(1, -1)).replace(/''/g, "'");
}
function $ce600e557ae96d9c$var$foldLines(source) {
    /**
     * The negative lookbehind here and in the `re` RegExp is to
     * prevent causing a polynomial search time in certain cases.
     *
     * The try-catch is for Safari, which doesn't support this yet:
     * https://caniuse.com/js-regexp-lookbehind
     */ let first, line;
    try {
        first = new RegExp("(.*?)(?<![ 	])[ 	]*\r?\n", "sy");
        line = new RegExp("[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?\n", "sy");
    } catch  {
        first = /(.*?)[ \t]*\r?\n/sy;
        line = /[ \t]*(.*?)[ \t]*\r?\n/sy;
    }
    let match = first.exec(source);
    if (!match) return source;
    let res = match[1];
    let sep = " ";
    let pos = first.lastIndex;
    line.lastIndex = pos;
    while(match = line.exec(source)){
        if (match[1] === "") {
            if (sep === "\n") res += sep;
            else sep = "\n";
        } else {
            res += sep + match[1];
            sep = " ";
        }
        pos = line.lastIndex;
    }
    const last = /[ \t]*(.*)/sy;
    last.lastIndex = pos;
    match = last.exec(source);
    return res + sep + (match?.[1] ?? "");
}
function $ce600e557ae96d9c$var$doubleQuotedValue(source, onError) {
    let res = "";
    for(let i = 1; i < source.length - 1; ++i){
        const ch = source[i];
        if (ch === "\r" && source[i + 1] === "\n") continue;
        if (ch === "\n") {
            const { fold: fold, offset: offset } = $ce600e557ae96d9c$var$foldNewline(source, i);
            res += fold;
            i = offset;
        } else if (ch === "\\") {
            let next = source[++i];
            const cc = $ce600e557ae96d9c$var$escapeCodes[next];
            if (cc) res += cc;
            else if (next === "\n") {
                // skip escaped newlines, but still trim the following line
                next = source[i + 1];
                while(next === " " || next === "	")next = source[++i + 1];
            } else if (next === "\r" && source[i + 1] === "\n") {
                // skip escaped CRLF newlines, but still trim the following line
                next = source[++i + 1];
                while(next === " " || next === "	")next = source[++i + 1];
            } else if (next === "x" || next === "u" || next === "U") {
                const length = {
                    x: 2,
                    u: 4,
                    U: 8
                }[next];
                res += $ce600e557ae96d9c$var$parseCharCode(source, i + 1, length, onError);
                i += length;
            } else {
                const raw = source.substr(i - 1, 2);
                onError(i - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
                res += raw;
            }
        } else if (ch === " " || ch === "	") {
            // trim trailing whitespace
            const wsStart = i;
            let next = source[i + 1];
            while(next === " " || next === "	")next = source[++i + 1];
            if (next !== "\n" && !(next === "\r" && source[i + 2] === "\n")) res += i > wsStart ? source.slice(wsStart, i + 1) : ch;
        } else res += ch;
    }
    if (source[source.length - 1] !== '"' || source.length === 1) onError(source.length, "MISSING_CHAR", 'Missing closing "quote');
    return res;
}
/**
 * Fold a single newline into a space, multiple newlines to N - 1 newlines.
 * Presumes `source[offset] === '\n'`
 */ function $ce600e557ae96d9c$var$foldNewline(source, offset) {
    let fold = "";
    let ch = source[offset + 1];
    while(ch === " " || ch === "	" || ch === "\n" || ch === "\r"){
        if (ch === "\r" && source[offset + 2] !== "\n") break;
        if (ch === "\n") fold += "\n";
        offset += 1;
        ch = source[offset + 1];
    }
    if (!fold) fold = " ";
    return {
        fold: fold,
        offset: offset
    };
}
const $ce600e557ae96d9c$var$escapeCodes = {
    "0": "\0",
    a: "\x07",
    b: "\b",
    e: "\x1b",
    f: "\f",
    n: "\n",
    r: "\r",
    t: "	",
    v: "\v",
    N: "\x85",
    _: "\xa0",
    L: "\u2028",
    P: "\u2029",
    " ": " ",
    '"': '"',
    "/": "/",
    "\\": "\\",
    "	": "	"
};
function $ce600e557ae96d9c$var$parseCharCode(source, offset, length, onError) {
    const cc = source.substr(offset, length);
    const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
    const code = ok ? parseInt(cc, 16) : NaN;
    if (isNaN(code)) {
        const raw = source.substr(offset - 2, length + 2);
        onError(offset - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
        return raw;
    }
    return String.fromCodePoint(code);
}
$ce600e557ae96d9c$export$2f1c3b16290da8c8 = $ce600e557ae96d9c$var$resolveFlowScalar;

});


parcelRegister("bkmny", function(module, exports) {

$parcel$export(module.exports, "emptyScalarPosition", () => $83f2ebede2a4d3c1$export$b4be549696a70562, (v) => $83f2ebede2a4d3c1$export$b4be549696a70562 = v);
var $83f2ebede2a4d3c1$export$b4be549696a70562;
"use strict";
function $83f2ebede2a4d3c1$var$emptyScalarPosition(offset, before, pos) {
    if (before) {
        if (pos === null) pos = before.length;
        for(let i = pos - 1; i >= 0; --i){
            let st = before[i];
            switch(st.type){
                case "space":
                case "comment":
                case "newline":
                    offset -= st.source.length;
                    continue;
            }
            // Technically, an empty scalar is immediately after the last non-empty
            // node, but it's more useful to place it after any whitespace.
            st = before[++i];
            while(st?.type === "space"){
                offset += st.source.length;
                st = before[++i];
            }
            break;
        }
    }
    return offset;
}
$83f2ebede2a4d3c1$export$b4be549696a70562 = $83f2ebede2a4d3c1$var$emptyScalarPosition;

});




parcelRegister("cJNRU", function(module, exports) {

$parcel$export(module.exports, "createScalarToken", () => $94605ed900209ac4$export$bc6e7c97bb928c0c, (v) => $94605ed900209ac4$export$bc6e7c97bb928c0c = v);
$parcel$export(module.exports, "resolveAsScalar", () => $94605ed900209ac4$export$2606595716b8fd6d, (v) => $94605ed900209ac4$export$2606595716b8fd6d = v);
$parcel$export(module.exports, "setScalarValue", () => $94605ed900209ac4$export$ca02adc222d12536, (v) => $94605ed900209ac4$export$ca02adc222d12536 = v);
$parcel$export(module.exports, "stringify", () => $94605ed900209ac4$export$fac44ee5b035f737, (v) => $94605ed900209ac4$export$fac44ee5b035f737 = v);
$parcel$export(module.exports, "visit", () => $94605ed900209ac4$export$bf638b60ea8b89b7, (v) => $94605ed900209ac4$export$bf638b60ea8b89b7 = v);
$parcel$export(module.exports, "BOM", () => $94605ed900209ac4$export$159b0f4ed2e9d663, (v) => $94605ed900209ac4$export$159b0f4ed2e9d663 = v);
$parcel$export(module.exports, "DOCUMENT", () => $94605ed900209ac4$export$ef011b4e114b1fba, (v) => $94605ed900209ac4$export$ef011b4e114b1fba = v);
$parcel$export(module.exports, "FLOW_END", () => $94605ed900209ac4$export$f3c6ac4b8e8fc405, (v) => $94605ed900209ac4$export$f3c6ac4b8e8fc405 = v);
$parcel$export(module.exports, "SCALAR", () => $94605ed900209ac4$export$8dde1211cb7c9d16, (v) => $94605ed900209ac4$export$8dde1211cb7c9d16 = v);
$parcel$export(module.exports, "isCollection", () => $94605ed900209ac4$export$cea7aa84e978eba5, (v) => $94605ed900209ac4$export$cea7aa84e978eba5 = v);
$parcel$export(module.exports, "isScalar", () => $94605ed900209ac4$export$8f3495e22775e76c, (v) => $94605ed900209ac4$export$8f3495e22775e76c = v);
$parcel$export(module.exports, "prettyToken", () => $94605ed900209ac4$export$a7c32ec3dbc53b0d, (v) => $94605ed900209ac4$export$a7c32ec3dbc53b0d = v);
$parcel$export(module.exports, "tokenType", () => $94605ed900209ac4$export$290cf9fbadf470bd, (v) => $94605ed900209ac4$export$290cf9fbadf470bd = v);
var $94605ed900209ac4$export$bc6e7c97bb928c0c;
var $94605ed900209ac4$export$2606595716b8fd6d;
var $94605ed900209ac4$export$ca02adc222d12536;
var $94605ed900209ac4$export$fac44ee5b035f737;
var $94605ed900209ac4$export$bf638b60ea8b89b7;
var $94605ed900209ac4$export$159b0f4ed2e9d663;
var $94605ed900209ac4$export$ef011b4e114b1fba;
var $94605ed900209ac4$export$f3c6ac4b8e8fc405;
var $94605ed900209ac4$export$8dde1211cb7c9d16;
var $94605ed900209ac4$export$cea7aa84e978eba5;
var $94605ed900209ac4$export$8f3495e22775e76c;
var $94605ed900209ac4$export$a7c32ec3dbc53b0d;
var $94605ed900209ac4$export$290cf9fbadf470bd;
"use strict";

var $kr6E7 = parcelRequire("kr6E7");

var $9oOrr = parcelRequire("9oOrr");

var $37pld = parcelRequire("37pld");
/** The byte order mark */ const $94605ed900209ac4$var$BOM = "\uFEFF";
/** Start of doc-mode */ const $94605ed900209ac4$var$DOCUMENT = "\x02"; // C0: Start of Text
/** Unexpected end of flow-mode */ const $94605ed900209ac4$var$FLOW_END = "\x18"; // C0: Cancel
/** Next token is a scalar value */ const $94605ed900209ac4$var$SCALAR = "\x1f"; // C0: Unit Separator
/** @returns `true` if `token` is a flow or block collection */ const $94605ed900209ac4$var$isCollection = (token)=>!!token && "items" in token;
/** @returns `true` if `token` is a flow or block scalar; not an alias */ const $94605ed900209ac4$var$isScalar = (token)=>!!token && (token.type === "scalar" || token.type === "single-quoted-scalar" || token.type === "double-quoted-scalar" || token.type === "block-scalar");
/* istanbul ignore next */ /** Get a printable representation of a lexer token */ function $94605ed900209ac4$var$prettyToken(token) {
    switch(token){
        case $94605ed900209ac4$var$BOM:
            return "<BOM>";
        case $94605ed900209ac4$var$DOCUMENT:
            return "<DOC>";
        case $94605ed900209ac4$var$FLOW_END:
            return "<FLOW_END>";
        case $94605ed900209ac4$var$SCALAR:
            return "<SCALAR>";
        default:
            return JSON.stringify(token);
    }
}
/** Identify the type of a lexer token. May return `null` for unknown tokens. */ function $94605ed900209ac4$var$tokenType(source) {
    switch(source){
        case $94605ed900209ac4$var$BOM:
            return "byte-order-mark";
        case $94605ed900209ac4$var$DOCUMENT:
            return "doc-mode";
        case $94605ed900209ac4$var$FLOW_END:
            return "flow-error-end";
        case $94605ed900209ac4$var$SCALAR:
            return "scalar";
        case "---":
            return "doc-start";
        case "...":
            return "doc-end";
        case "":
        case "\n":
        case "\r\n":
            return "newline";
        case "-":
            return "seq-item-ind";
        case "?":
            return "explicit-key-ind";
        case ":":
            return "map-value-ind";
        case "{":
            return "flow-map-start";
        case "}":
            return "flow-map-end";
        case "[":
            return "flow-seq-start";
        case "]":
            return "flow-seq-end";
        case ",":
            return "comma";
    }
    switch(source[0]){
        case " ":
        case "	":
            return "space";
        case "#":
            return "comment";
        case "%":
            return "directive-line";
        case "*":
            return "alias";
        case "&":
            return "anchor";
        case "!":
            return "tag";
        case "'":
            return "single-quoted-scalar";
        case '"':
            return "double-quoted-scalar";
        case "|":
        case ">":
            return "block-scalar-header";
    }
    return null;
}
$94605ed900209ac4$export$bc6e7c97bb928c0c = $kr6E7.createScalarToken;
$94605ed900209ac4$export$2606595716b8fd6d = $kr6E7.resolveAsScalar;
$94605ed900209ac4$export$ca02adc222d12536 = $kr6E7.setScalarValue;
$94605ed900209ac4$export$fac44ee5b035f737 = $9oOrr.stringify;
$94605ed900209ac4$export$bf638b60ea8b89b7 = $37pld.visit;
$94605ed900209ac4$export$159b0f4ed2e9d663 = $94605ed900209ac4$var$BOM;
$94605ed900209ac4$export$ef011b4e114b1fba = $94605ed900209ac4$var$DOCUMENT;
$94605ed900209ac4$export$f3c6ac4b8e8fc405 = $94605ed900209ac4$var$FLOW_END;
$94605ed900209ac4$export$8dde1211cb7c9d16 = $94605ed900209ac4$var$SCALAR;
$94605ed900209ac4$export$cea7aa84e978eba5 = $94605ed900209ac4$var$isCollection;
$94605ed900209ac4$export$8f3495e22775e76c = $94605ed900209ac4$var$isScalar;
$94605ed900209ac4$export$a7c32ec3dbc53b0d = $94605ed900209ac4$var$prettyToken;
$94605ed900209ac4$export$290cf9fbadf470bd = $94605ed900209ac4$var$tokenType;

});
parcelRegister("kr6E7", function(module, exports) {

$parcel$export(module.exports, "createScalarToken", () => $ee0b7c0db4d2a478$export$bc6e7c97bb928c0c, (v) => $ee0b7c0db4d2a478$export$bc6e7c97bb928c0c = v);
$parcel$export(module.exports, "resolveAsScalar", () => $ee0b7c0db4d2a478$export$2606595716b8fd6d, (v) => $ee0b7c0db4d2a478$export$2606595716b8fd6d = v);
$parcel$export(module.exports, "setScalarValue", () => $ee0b7c0db4d2a478$export$ca02adc222d12536, (v) => $ee0b7c0db4d2a478$export$ca02adc222d12536 = v);
var $ee0b7c0db4d2a478$export$bc6e7c97bb928c0c;
var $ee0b7c0db4d2a478$export$2606595716b8fd6d;
var $ee0b7c0db4d2a478$export$ca02adc222d12536;
"use strict";

var $2O2j0 = parcelRequire("2O2j0");

var $hIwT2 = parcelRequire("hIwT2");

var $9DvMJ = parcelRequire("9DvMJ");

var $e5c0t = parcelRequire("e5c0t");
function $ee0b7c0db4d2a478$var$resolveAsScalar(token, strict = true, onError) {
    if (token) {
        const _onError = (pos, code, message)=>{
            const offset = typeof pos === "number" ? pos : Array.isArray(pos) ? pos[0] : pos.offset;
            if (onError) onError(offset, code, message);
            else throw new $9DvMJ.YAMLParseError([
                offset,
                offset + 1
            ], code, message);
        };
        switch(token.type){
            case "scalar":
            case "single-quoted-scalar":
            case "double-quoted-scalar":
                return $hIwT2.resolveFlowScalar(token, strict, _onError);
            case "block-scalar":
                return $2O2j0.resolveBlockScalar({
                    options: {
                        strict: strict
                    }
                }, token, _onError);
        }
    }
    return null;
}
/**
 * Create a new scalar token with `value`
 *
 * Values that represent an actual string but may be parsed as a different type should use a `type` other than `'PLAIN'`,
 * as this function does not support any schema operations and won't check for such conflicts.
 *
 * @param value The string representation of the value, which will have its content properly indented.
 * @param context.end Comments and whitespace after the end of the value, or after the block scalar header. If undefined, a newline will be added.
 * @param context.implicitKey Being within an implicit key may affect the resolved type of the token's value.
 * @param context.indent The indent level of the token.
 * @param context.inFlow Is this scalar within a flow collection? This may affect the resolved type of the token's value.
 * @param context.offset The offset position of the token.
 * @param context.type The preferred type of the scalar token. If undefined, the previous type of the `token` will be used, defaulting to `'PLAIN'`.
 */ function $ee0b7c0db4d2a478$var$createScalarToken(value, context) {
    const { implicitKey: implicitKey = false, indent: indent, inFlow: inFlow = false, offset: offset = -1, type: type = "PLAIN" } = context;
    const source = $e5c0t.stringifyString({
        type: type,
        value: value
    }, {
        implicitKey: implicitKey,
        indent: indent > 0 ? " ".repeat(indent) : "",
        inFlow: inFlow,
        options: {
            blockQuote: true,
            lineWidth: -1
        }
    });
    const end = context.end ?? [
        {
            type: "newline",
            offset: -1,
            indent: indent,
            source: "\n"
        }
    ];
    switch(source[0]){
        case "|":
        case ">":
            {
                const he = source.indexOf("\n");
                const head = source.substring(0, he);
                const body = source.substring(he + 1) + "\n";
                const props = [
                    {
                        type: "block-scalar-header",
                        offset: offset,
                        indent: indent,
                        source: head
                    }
                ];
                if (!$ee0b7c0db4d2a478$var$addEndtoBlockProps(props, end)) props.push({
                    type: "newline",
                    offset: -1,
                    indent: indent,
                    source: "\n"
                });
                return {
                    type: "block-scalar",
                    offset: offset,
                    indent: indent,
                    props: props,
                    source: body
                };
            }
        case '"':
            return {
                type: "double-quoted-scalar",
                offset: offset,
                indent: indent,
                source: source,
                end: end
            };
        case "'":
            return {
                type: "single-quoted-scalar",
                offset: offset,
                indent: indent,
                source: source,
                end: end
            };
        default:
            return {
                type: "scalar",
                offset: offset,
                indent: indent,
                source: source,
                end: end
            };
    }
}
/**
 * Set the value of `token` to the given string `value`, overwriting any previous contents and type that it may have.
 *
 * Best efforts are made to retain any comments previously associated with the `token`,
 * though all contents within a collection's `items` will be overwritten.
 *
 * Values that represent an actual string but may be parsed as a different type should use a `type` other than `'PLAIN'`,
 * as this function does not support any schema operations and won't check for such conflicts.
 *
 * @param token Any token. If it does not include an `indent` value, the value will be stringified as if it were an implicit key.
 * @param value The string representation of the value, which will have its content properly indented.
 * @param context.afterKey In most cases, values after a key should have an additional level of indentation.
 * @param context.implicitKey Being within an implicit key may affect the resolved type of the token's value.
 * @param context.inFlow Being within a flow collection may affect the resolved type of the token's value.
 * @param context.type The preferred type of the scalar token. If undefined, the previous type of the `token` will be used, defaulting to `'PLAIN'`.
 */ function $ee0b7c0db4d2a478$var$setScalarValue(token, value, context = {}) {
    let { afterKey: afterKey = false, implicitKey: implicitKey = false, inFlow: inFlow = false, type: type } = context;
    let indent = "indent" in token ? token.indent : null;
    if (afterKey && typeof indent === "number") indent += 2;
    if (!type) switch(token.type){
        case "single-quoted-scalar":
            type = "QUOTE_SINGLE";
            break;
        case "double-quoted-scalar":
            type = "QUOTE_DOUBLE";
            break;
        case "block-scalar":
            {
                const header = token.props[0];
                if (header.type !== "block-scalar-header") throw new Error("Invalid block scalar header");
                type = header.source[0] === ">" ? "BLOCK_FOLDED" : "BLOCK_LITERAL";
                break;
            }
        default:
            type = "PLAIN";
    }
    const source = $e5c0t.stringifyString({
        type: type,
        value: value
    }, {
        implicitKey: implicitKey || indent === null,
        indent: indent !== null && indent > 0 ? " ".repeat(indent) : "",
        inFlow: inFlow,
        options: {
            blockQuote: true,
            lineWidth: -1
        }
    });
    switch(source[0]){
        case "|":
        case ">":
            $ee0b7c0db4d2a478$var$setBlockScalarValue(token, source);
            break;
        case '"':
            $ee0b7c0db4d2a478$var$setFlowScalarValue(token, source, "double-quoted-scalar");
            break;
        case "'":
            $ee0b7c0db4d2a478$var$setFlowScalarValue(token, source, "single-quoted-scalar");
            break;
        default:
            $ee0b7c0db4d2a478$var$setFlowScalarValue(token, source, "scalar");
    }
}
function $ee0b7c0db4d2a478$var$setBlockScalarValue(token, source) {
    const he = source.indexOf("\n");
    const head = source.substring(0, he);
    const body = source.substring(he + 1) + "\n";
    if (token.type === "block-scalar") {
        const header = token.props[0];
        if (header.type !== "block-scalar-header") throw new Error("Invalid block scalar header");
        header.source = head;
        token.source = body;
    } else {
        const { offset: offset } = token;
        const indent = "indent" in token ? token.indent : -1;
        const props = [
            {
                type: "block-scalar-header",
                offset: offset,
                indent: indent,
                source: head
            }
        ];
        if (!$ee0b7c0db4d2a478$var$addEndtoBlockProps(props, "end" in token ? token.end : undefined)) props.push({
            type: "newline",
            offset: -1,
            indent: indent,
            source: "\n"
        });
        for (const key of Object.keys(token))if (key !== "type" && key !== "offset") delete token[key];
        Object.assign(token, {
            type: "block-scalar",
            indent: indent,
            props: props,
            source: body
        });
    }
}
/** @returns `true` if last token is a newline */ function $ee0b7c0db4d2a478$var$addEndtoBlockProps(props, end) {
    if (end) for (const st of end)switch(st.type){
        case "space":
        case "comment":
            props.push(st);
            break;
        case "newline":
            props.push(st);
            return true;
    }
    return false;
}
function $ee0b7c0db4d2a478$var$setFlowScalarValue(token, source, type) {
    switch(token.type){
        case "scalar":
        case "double-quoted-scalar":
        case "single-quoted-scalar":
            token.type = type;
            token.source = source;
            break;
        case "block-scalar":
            {
                const end = token.props.slice(1);
                let oa = source.length;
                if (token.props[0].type === "block-scalar-header") oa -= token.props[0].source.length;
                for (const tok of end)tok.offset += oa;
                delete token.props;
                Object.assign(token, {
                    type: type,
                    source: source,
                    end: end
                });
                break;
            }
        case "block-map":
        case "block-seq":
            {
                const offset = token.offset + source.length;
                const nl = {
                    type: "newline",
                    offset: offset,
                    indent: token.indent,
                    source: "\n"
                };
                delete token.items;
                Object.assign(token, {
                    type: type,
                    source: source,
                    end: [
                        nl
                    ]
                });
                break;
            }
        default:
            {
                const indent = "indent" in token ? token.indent : -1;
                const end = "end" in token && Array.isArray(token.end) ? token.end.filter((st)=>st.type === "space" || st.type === "comment" || st.type === "newline") : [];
                for (const key of Object.keys(token))if (key !== "type" && key !== "offset") delete token[key];
                Object.assign(token, {
                    type: type,
                    indent: indent,
                    source: source,
                    end: end
                });
            }
    }
}
$ee0b7c0db4d2a478$export$bc6e7c97bb928c0c = $ee0b7c0db4d2a478$var$createScalarToken;
$ee0b7c0db4d2a478$export$2606595716b8fd6d = $ee0b7c0db4d2a478$var$resolveAsScalar;
$ee0b7c0db4d2a478$export$ca02adc222d12536 = $ee0b7c0db4d2a478$var$setScalarValue;

});

parcelRegister("9oOrr", function(module, exports) {

$parcel$export(module.exports, "stringify", () => $6d7d7b9e7b5c2748$export$fac44ee5b035f737, (v) => $6d7d7b9e7b5c2748$export$fac44ee5b035f737 = v);
var $6d7d7b9e7b5c2748$export$fac44ee5b035f737;
"use strict";
/**
 * Stringify a CST document, token, or collection item
 *
 * Fair warning: This applies no validation whatsoever, and
 * simply concatenates the sources in their logical order.
 */ const $6d7d7b9e7b5c2748$var$stringify = (cst)=>"type" in cst ? $6d7d7b9e7b5c2748$var$stringifyToken(cst) : $6d7d7b9e7b5c2748$var$stringifyItem(cst);
function $6d7d7b9e7b5c2748$var$stringifyToken(token) {
    switch(token.type){
        case "block-scalar":
            {
                let res = "";
                for (const tok of token.props)res += $6d7d7b9e7b5c2748$var$stringifyToken(tok);
                return res + token.source;
            }
        case "block-map":
        case "block-seq":
            {
                let res = "";
                for (const item of token.items)res += $6d7d7b9e7b5c2748$var$stringifyItem(item);
                return res;
            }
        case "flow-collection":
            {
                let res = token.start.source;
                for (const item of token.items)res += $6d7d7b9e7b5c2748$var$stringifyItem(item);
                for (const st of token.end)res += st.source;
                return res;
            }
        case "document":
            {
                let res = $6d7d7b9e7b5c2748$var$stringifyItem(token);
                if (token.end) for (const st of token.end)res += st.source;
                return res;
            }
        default:
            {
                let res = token.source;
                if ("end" in token && token.end) for (const st of token.end)res += st.source;
                return res;
            }
    }
}
function $6d7d7b9e7b5c2748$var$stringifyItem({ start: start, key: key, sep: sep, value: value }) {
    let res = "";
    for (const st of start)res += st.source;
    if (key) res += $6d7d7b9e7b5c2748$var$stringifyToken(key);
    if (sep) for (const st of sep)res += st.source;
    if (value) res += $6d7d7b9e7b5c2748$var$stringifyToken(value);
    return res;
}
$6d7d7b9e7b5c2748$export$fac44ee5b035f737 = $6d7d7b9e7b5c2748$var$stringify;

});

parcelRegister("37pld", function(module, exports) {

$parcel$export(module.exports, "visit", () => $2455aecd1eff2783$export$bf638b60ea8b89b7, (v) => $2455aecd1eff2783$export$bf638b60ea8b89b7 = v);
var $2455aecd1eff2783$export$bf638b60ea8b89b7;
"use strict";
const $2455aecd1eff2783$var$BREAK = Symbol("break visit");
const $2455aecd1eff2783$var$SKIP = Symbol("skip children");
const $2455aecd1eff2783$var$REMOVE = Symbol("remove item");
/**
 * Apply a visitor to a CST document or item.
 *
 * Walks through the tree (depth-first) starting from the root, calling a
 * `visitor` function with two arguments when entering each item:
 *   - `item`: The current item, which included the following members:
 *     - `start: SourceToken[]` – Source tokens before the key or value,
 *       possibly including its anchor or tag.
 *     - `key?: Token | null` – Set for pair values. May then be `null`, if
 *       the key before the `:` separator is empty.
 *     - `sep?: SourceToken[]` – Source tokens between the key and the value,
 *       which should include the `:` map value indicator if `value` is set.
 *     - `value?: Token` – The value of a sequence item, or of a map pair.
 *   - `path`: The steps from the root to the current node, as an array of
 *     `['key' | 'value', number]` tuples.
 *
 * The return value of the visitor may be used to control the traversal:
 *   - `undefined` (default): Do nothing and continue
 *   - `visit.SKIP`: Do not visit the children of this token, continue with
 *      next sibling
 *   - `visit.BREAK`: Terminate traversal completely
 *   - `visit.REMOVE`: Remove the current item, then continue with the next one
 *   - `number`: Set the index of the next step. This is useful especially if
 *     the index of the current token has changed.
 *   - `function`: Define the next visitor for this item. After the original
 *     visitor is called on item entry, next visitors are called after handling
 *     a non-empty `key` and when exiting the item.
 */ function $2455aecd1eff2783$var$visit(cst, visitor) {
    if ("type" in cst && cst.type === "document") cst = {
        start: cst.start,
        value: cst.value
    };
    $2455aecd1eff2783$var$_visit(Object.freeze([]), cst, visitor);
}
// Without the `as symbol` casts, TS declares these in the `visit`
// namespace using `var`, but then complains about that because
// `unique symbol` must be `const`.
/** Terminate visit traversal completely */ $2455aecd1eff2783$var$visit.BREAK = $2455aecd1eff2783$var$BREAK;
/** Do not visit the children of the current item */ $2455aecd1eff2783$var$visit.SKIP = $2455aecd1eff2783$var$SKIP;
/** Remove the current item */ $2455aecd1eff2783$var$visit.REMOVE = $2455aecd1eff2783$var$REMOVE;
/** Find the item at `path` from `cst` as the root */ $2455aecd1eff2783$var$visit.itemAtPath = (cst, path)=>{
    let item = cst;
    for (const [field, index] of path){
        const tok = item?.[field];
        if (tok && "items" in tok) item = tok.items[index];
        else return undefined;
    }
    return item;
};
/**
 * Get the immediate parent collection of the item at `path` from `cst` as the root.
 *
 * Throws an error if the collection is not found, which should never happen if the item itself exists.
 */ $2455aecd1eff2783$var$visit.parentCollection = (cst, path)=>{
    const parent = $2455aecd1eff2783$var$visit.itemAtPath(cst, path.slice(0, -1));
    const field = path[path.length - 1][0];
    const coll = parent?.[field];
    if (coll && "items" in coll) return coll;
    throw new Error("Parent collection not found");
};
function $2455aecd1eff2783$var$_visit(path, item, visitor) {
    let ctrl = visitor(item, path);
    if (typeof ctrl === "symbol") return ctrl;
    for (const field of [
        "key",
        "value"
    ]){
        const token = item[field];
        if (token && "items" in token) {
            for(let i = 0; i < token.items.length; ++i){
                const ci = $2455aecd1eff2783$var$_visit(Object.freeze(path.concat([
                    [
                        field,
                        i
                    ]
                ])), token.items[i], visitor);
                if (typeof ci === "number") i = ci - 1;
                else if (ci === $2455aecd1eff2783$var$BREAK) return $2455aecd1eff2783$var$BREAK;
                else if (ci === $2455aecd1eff2783$var$REMOVE) {
                    token.items.splice(i, 1);
                    i -= 1;
                }
            }
            if (typeof ctrl === "function" && field === "key") ctrl = ctrl(item, path);
        }
    }
    return typeof ctrl === "function" ? ctrl(item, path) : ctrl;
}
$2455aecd1eff2783$export$bf638b60ea8b89b7 = $2455aecd1eff2783$var$visit;

});


parcelRegister("dHsHc", function(module, exports) {

$parcel$export(module.exports, "Lexer", () => $9f958cea0283f85f$export$6168dc8908a6c652, (v) => $9f958cea0283f85f$export$6168dc8908a6c652 = v);
var $9f958cea0283f85f$export$6168dc8908a6c652;
"use strict";

var $cJNRU = parcelRequire("cJNRU");
/*
START -> stream

stream
  directive -> line-end -> stream
  indent + line-end -> stream
  [else] -> line-start

line-end
  comment -> line-end
  newline -> .
  input-end -> END

line-start
  doc-start -> doc
  doc-end -> stream
  [else] -> indent -> block-start

block-start
  seq-item-start -> block-start
  explicit-key-start -> block-start
  map-value-start -> block-start
  [else] -> doc

doc
  line-end -> line-start
  spaces -> doc
  anchor -> doc
  tag -> doc
  flow-start -> flow -> doc
  flow-end -> error -> doc
  seq-item-start -> error -> doc
  explicit-key-start -> error -> doc
  map-value-start -> doc
  alias -> doc
  quote-start -> quoted-scalar -> doc
  block-scalar-header -> line-end -> block-scalar(min) -> line-start
  [else] -> plain-scalar(false, min) -> doc

flow
  line-end -> flow
  spaces -> flow
  anchor -> flow
  tag -> flow
  flow-start -> flow -> flow
  flow-end -> .
  seq-item-start -> error -> flow
  explicit-key-start -> flow
  map-value-start -> flow
  alias -> flow
  quote-start -> quoted-scalar -> flow
  comma -> flow
  [else] -> plain-scalar(true, 0) -> flow

quoted-scalar
  quote-end -> .
  [else] -> quoted-scalar

block-scalar(min)
  newline + peek(indent < min) -> .
  [else] -> block-scalar(min)

plain-scalar(is-flow, min)
  scalar-end(is-flow) -> .
  peek(newline + (indent < min)) -> .
  [else] -> plain-scalar(min)
*/ function $9f958cea0283f85f$var$isEmpty(ch) {
    switch(ch){
        case undefined:
        case " ":
        case "\n":
        case "\r":
        case "	":
            return true;
        default:
            return false;
    }
}
const $9f958cea0283f85f$var$hexDigits = new Set("0123456789ABCDEFabcdef");
const $9f958cea0283f85f$var$tagChars = new Set("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()");
const $9f958cea0283f85f$var$flowIndicatorChars = new Set(",[]{}");
const $9f958cea0283f85f$var$invalidAnchorChars = new Set(" ,[]{}\n\r	");
const $9f958cea0283f85f$var$isNotAnchorChar = (ch)=>!ch || $9f958cea0283f85f$var$invalidAnchorChars.has(ch);
/**
 * Splits an input string into lexical tokens, i.e. smaller strings that are
 * easily identifiable by `tokens.tokenType()`.
 *
 * Lexing starts always in a "stream" context. Incomplete input may be buffered
 * until a complete token can be emitted.
 *
 * In addition to slices of the original input, the following control characters
 * may also be emitted:
 *
 * - `\x02` (Start of Text): A document starts with the next token
 * - `\x18` (Cancel): Unexpected end of flow-mode (indicates an error)
 * - `\x1f` (Unit Separator): Next token is a scalar value
 * - `\u{FEFF}` (Byte order mark): Emitted separately outside documents
 */ class $9f958cea0283f85f$var$Lexer {
    constructor(){
        /**
         * Flag indicating whether the end of the current buffer marks the end of
         * all input
         */ this.atEnd = false;
        /**
         * Explicit indent set in block scalar header, as an offset from the current
         * minimum indent, so e.g. set to 1 from a header `|2+`. Set to -1 if not
         * explicitly set.
         */ this.blockScalarIndent = -1;
        /**
         * Block scalars that include a + (keep) chomping indicator in their header
         * include trailing empty lines, which are otherwise excluded from the
         * scalar's contents.
         */ this.blockScalarKeep = false;
        /** Current input */ this.buffer = "";
        /**
         * Flag noting whether the map value indicator : can immediately follow this
         * node within a flow context.
         */ this.flowKey = false;
        /** Count of surrounding flow collection levels. */ this.flowLevel = 0;
        /**
         * Minimum level of indentation required for next lines to be parsed as a
         * part of the current scalar value.
         */ this.indentNext = 0;
        /** Indentation level of the current line. */ this.indentValue = 0;
        /** Position of the next \n character. */ this.lineEndPos = null;
        /** Stores the state of the lexer if reaching the end of incpomplete input */ this.next = null;
        /** A pointer to `buffer`; the current position of the lexer. */ this.pos = 0;
    }
    /**
     * Generate YAML tokens from the `source` string. If `incomplete`,
     * a part of the last line may be left as a buffer for the next call.
     *
     * @returns A generator of lexical tokens
     */ *lex(source, incomplete = false) {
        if (source) {
            if (typeof source !== "string") throw TypeError("source is not a string");
            this.buffer = this.buffer ? this.buffer + source : source;
            this.lineEndPos = null;
        }
        this.atEnd = !incomplete;
        let next = this.next ?? "stream";
        while(next && (incomplete || this.hasChars(1)))next = yield* this.parseNext(next);
    }
    atLineEnd() {
        let i = this.pos;
        let ch = this.buffer[i];
        while(ch === " " || ch === "	")ch = this.buffer[++i];
        if (!ch || ch === "#" || ch === "\n") return true;
        if (ch === "\r") return this.buffer[i + 1] === "\n";
        return false;
    }
    charAt(n) {
        return this.buffer[this.pos + n];
    }
    continueScalar(offset) {
        let ch = this.buffer[offset];
        if (this.indentNext > 0) {
            let indent = 0;
            while(ch === " ")ch = this.buffer[++indent + offset];
            if (ch === "\r") {
                const next = this.buffer[indent + offset + 1];
                if (next === "\n" || !next && !this.atEnd) return offset + indent + 1;
            }
            return ch === "\n" || indent >= this.indentNext || !ch && !this.atEnd ? offset + indent : -1;
        }
        if (ch === "-" || ch === ".") {
            const dt = this.buffer.substr(offset, 3);
            if ((dt === "---" || dt === "...") && $9f958cea0283f85f$var$isEmpty(this.buffer[offset + 3])) return -1;
        }
        return offset;
    }
    getLine() {
        let end = this.lineEndPos;
        if (typeof end !== "number" || end !== -1 && end < this.pos) {
            end = this.buffer.indexOf("\n", this.pos);
            this.lineEndPos = end;
        }
        if (end === -1) return this.atEnd ? this.buffer.substring(this.pos) : null;
        if (this.buffer[end - 1] === "\r") end -= 1;
        return this.buffer.substring(this.pos, end);
    }
    hasChars(n) {
        return this.pos + n <= this.buffer.length;
    }
    setNext(state) {
        this.buffer = this.buffer.substring(this.pos);
        this.pos = 0;
        this.lineEndPos = null;
        this.next = state;
        return null;
    }
    peek(n) {
        return this.buffer.substr(this.pos, n);
    }
    *parseNext(next) {
        switch(next){
            case "stream":
                return yield* this.parseStream();
            case "line-start":
                return yield* this.parseLineStart();
            case "block-start":
                return yield* this.parseBlockStart();
            case "doc":
                return yield* this.parseDocument();
            case "flow":
                return yield* this.parseFlowCollection();
            case "quoted-scalar":
                return yield* this.parseQuotedScalar();
            case "block-scalar":
                return yield* this.parseBlockScalar();
            case "plain-scalar":
                return yield* this.parsePlainScalar();
        }
    }
    *parseStream() {
        let line = this.getLine();
        if (line === null) return this.setNext("stream");
        if (line[0] === $cJNRU.BOM) {
            yield* this.pushCount(1);
            line = line.substring(1);
        }
        if (line[0] === "%") {
            let dirEnd = line.length;
            let cs = line.indexOf("#");
            while(cs !== -1){
                const ch = line[cs - 1];
                if (ch === " " || ch === "	") {
                    dirEnd = cs - 1;
                    break;
                } else cs = line.indexOf("#", cs + 1);
            }
            while(true){
                const ch = line[dirEnd - 1];
                if (ch === " " || ch === "	") dirEnd -= 1;
                else break;
            }
            const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
            yield* this.pushCount(line.length - n); // possible comment
            this.pushNewline();
            return "stream";
        }
        if (this.atLineEnd()) {
            const sp = yield* this.pushSpaces(true);
            yield* this.pushCount(line.length - sp);
            yield* this.pushNewline();
            return "stream";
        }
        yield $cJNRU.DOCUMENT;
        return yield* this.parseLineStart();
    }
    *parseLineStart() {
        const ch = this.charAt(0);
        if (!ch && !this.atEnd) return this.setNext("line-start");
        if (ch === "-" || ch === ".") {
            if (!this.atEnd && !this.hasChars(4)) return this.setNext("line-start");
            const s = this.peek(3);
            if ((s === "---" || s === "...") && $9f958cea0283f85f$var$isEmpty(this.charAt(3))) {
                yield* this.pushCount(3);
                this.indentValue = 0;
                this.indentNext = 0;
                return s === "---" ? "doc" : "stream";
            }
        }
        this.indentValue = yield* this.pushSpaces(false);
        if (this.indentNext > this.indentValue && !$9f958cea0283f85f$var$isEmpty(this.charAt(1))) this.indentNext = this.indentValue;
        return yield* this.parseBlockStart();
    }
    *parseBlockStart() {
        const [ch0, ch1] = this.peek(2);
        if (!ch1 && !this.atEnd) return this.setNext("block-start");
        if ((ch0 === "-" || ch0 === "?" || ch0 === ":") && $9f958cea0283f85f$var$isEmpty(ch1)) {
            const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
            this.indentNext = this.indentValue + 1;
            this.indentValue += n;
            return yield* this.parseBlockStart();
        }
        return "doc";
    }
    *parseDocument() {
        yield* this.pushSpaces(true);
        const line = this.getLine();
        if (line === null) return this.setNext("doc");
        let n = yield* this.pushIndicators();
        switch(line[n]){
            case "#":
                yield* this.pushCount(line.length - n);
            // fallthrough
            case undefined:
                yield* this.pushNewline();
                return yield* this.parseLineStart();
            case "{":
            case "[":
                yield* this.pushCount(1);
                this.flowKey = false;
                this.flowLevel = 1;
                return "flow";
            case "}":
            case "]":
                // this is an error
                yield* this.pushCount(1);
                return "doc";
            case "*":
                yield* this.pushUntil($9f958cea0283f85f$var$isNotAnchorChar);
                return "doc";
            case '"':
            case "'":
                return yield* this.parseQuotedScalar();
            case "|":
            case ">":
                n += yield* this.parseBlockScalarHeader();
                n += yield* this.pushSpaces(true);
                yield* this.pushCount(line.length - n);
                yield* this.pushNewline();
                return yield* this.parseBlockScalar();
            default:
                return yield* this.parsePlainScalar();
        }
    }
    *parseFlowCollection() {
        let nl, sp;
        let indent = -1;
        do {
            nl = yield* this.pushNewline();
            if (nl > 0) {
                sp = yield* this.pushSpaces(false);
                this.indentValue = indent = sp;
            } else sp = 0;
            sp += yield* this.pushSpaces(true);
        }while (nl + sp > 0);
        const line = this.getLine();
        if (line === null) return this.setNext("flow");
        if (indent !== -1 && indent < this.indentNext && line[0] !== "#" || indent === 0 && (line.startsWith("---") || line.startsWith("...")) && $9f958cea0283f85f$var$isEmpty(line[3])) {
            // Allowing for the terminal ] or } at the same (rather than greater)
            // indent level as the initial [ or { is technically invalid, but
            // failing here would be surprising to users.
            const atFlowEndMarker = indent === this.indentNext - 1 && this.flowLevel === 1 && (line[0] === "]" || line[0] === "}");
            if (!atFlowEndMarker) {
                // this is an error
                this.flowLevel = 0;
                yield $cJNRU.FLOW_END;
                return yield* this.parseLineStart();
            }
        }
        let n = 0;
        while(line[n] === ","){
            n += yield* this.pushCount(1);
            n += yield* this.pushSpaces(true);
            this.flowKey = false;
        }
        n += yield* this.pushIndicators();
        switch(line[n]){
            case undefined:
                return "flow";
            case "#":
                yield* this.pushCount(line.length - n);
                return "flow";
            case "{":
            case "[":
                yield* this.pushCount(1);
                this.flowKey = false;
                this.flowLevel += 1;
                return "flow";
            case "}":
            case "]":
                yield* this.pushCount(1);
                this.flowKey = true;
                this.flowLevel -= 1;
                return this.flowLevel ? "flow" : "doc";
            case "*":
                yield* this.pushUntil($9f958cea0283f85f$var$isNotAnchorChar);
                return "flow";
            case '"':
            case "'":
                this.flowKey = true;
                return yield* this.parseQuotedScalar();
            case ":":
                {
                    const next = this.charAt(1);
                    if (this.flowKey || $9f958cea0283f85f$var$isEmpty(next) || next === ",") {
                        this.flowKey = false;
                        yield* this.pushCount(1);
                        yield* this.pushSpaces(true);
                        return "flow";
                    }
                }
            // fallthrough
            default:
                this.flowKey = false;
                return yield* this.parsePlainScalar();
        }
    }
    *parseQuotedScalar() {
        const quote = this.charAt(0);
        let end = this.buffer.indexOf(quote, this.pos + 1);
        if (quote === "'") while(end !== -1 && this.buffer[end + 1] === "'")end = this.buffer.indexOf("'", end + 2);
        else // double-quote
        while(end !== -1){
            let n = 0;
            while(this.buffer[end - 1 - n] === "\\")n += 1;
            if (n % 2 === 0) break;
            end = this.buffer.indexOf('"', end + 1);
        }
        // Only looking for newlines within the quotes
        const qb = this.buffer.substring(0, end);
        let nl = qb.indexOf("\n", this.pos);
        if (nl !== -1) {
            while(nl !== -1){
                const cs = this.continueScalar(nl + 1);
                if (cs === -1) break;
                nl = qb.indexOf("\n", cs);
            }
            if (nl !== -1) // this is an error caused by an unexpected unindent
            end = nl - (qb[nl - 1] === "\r" ? 2 : 1);
        }
        if (end === -1) {
            if (!this.atEnd) return this.setNext("quoted-scalar");
            end = this.buffer.length;
        }
        yield* this.pushToIndex(end + 1, false);
        return this.flowLevel ? "flow" : "doc";
    }
    *parseBlockScalarHeader() {
        this.blockScalarIndent = -1;
        this.blockScalarKeep = false;
        let i = this.pos;
        while(true){
            const ch = this.buffer[++i];
            if (ch === "+") this.blockScalarKeep = true;
            else if (ch > "0" && ch <= "9") this.blockScalarIndent = Number(ch) - 1;
            else if (ch !== "-") break;
        }
        return yield* this.pushUntil((ch)=>$9f958cea0283f85f$var$isEmpty(ch) || ch === "#");
    }
    *parseBlockScalar() {
        let nl = this.pos - 1; // may be -1 if this.pos === 0
        let indent = 0;
        let ch;
        loop: for(let i = this.pos; ch = this.buffer[i]; ++i)switch(ch){
            case " ":
                indent += 1;
                break;
            case "\n":
                nl = i;
                indent = 0;
                break;
            case "\r":
                {
                    const next = this.buffer[i + 1];
                    if (!next && !this.atEnd) return this.setNext("block-scalar");
                    if (next === "\n") break;
                }
            default:
                break loop;
        }
        if (!ch && !this.atEnd) return this.setNext("block-scalar");
        if (indent >= this.indentNext) {
            if (this.blockScalarIndent === -1) this.indentNext = indent;
            else this.indentNext = this.blockScalarIndent + (this.indentNext === 0 ? 1 : this.indentNext);
            do {
                const cs = this.continueScalar(nl + 1);
                if (cs === -1) break;
                nl = this.buffer.indexOf("\n", cs);
            }while (nl !== -1);
            if (nl === -1) {
                if (!this.atEnd) return this.setNext("block-scalar");
                nl = this.buffer.length;
            }
        }
        // Trailing insufficiently indented tabs are invalid.
        // To catch that during parsing, we include them in the block scalar value.
        let i = nl + 1;
        ch = this.buffer[i];
        while(ch === " ")ch = this.buffer[++i];
        if (ch === "	") {
            while(ch === "	" || ch === " " || ch === "\r" || ch === "\n")ch = this.buffer[++i];
            nl = i - 1;
        } else if (!this.blockScalarKeep) do {
            let i = nl - 1;
            let ch = this.buffer[i];
            if (ch === "\r") ch = this.buffer[--i];
            const lastChar = i; // Drop the line if last char not more indented
            while(ch === " ")ch = this.buffer[--i];
            if (ch === "\n" && i >= this.pos && i + 1 + indent > lastChar) nl = i;
            else break;
        }while (true);
        yield $cJNRU.SCALAR;
        yield* this.pushToIndex(nl + 1, true);
        return yield* this.parseLineStart();
    }
    *parsePlainScalar() {
        const inFlow = this.flowLevel > 0;
        let end = this.pos - 1;
        let i = this.pos - 1;
        let ch;
        while(ch = this.buffer[++i]){
            if (ch === ":") {
                const next = this.buffer[i + 1];
                if ($9f958cea0283f85f$var$isEmpty(next) || inFlow && $9f958cea0283f85f$var$flowIndicatorChars.has(next)) break;
                end = i;
            } else if ($9f958cea0283f85f$var$isEmpty(ch)) {
                let next = this.buffer[i + 1];
                if (ch === "\r") {
                    if (next === "\n") {
                        i += 1;
                        ch = "\n";
                        next = this.buffer[i + 1];
                    } else end = i;
                }
                if (next === "#" || inFlow && $9f958cea0283f85f$var$flowIndicatorChars.has(next)) break;
                if (ch === "\n") {
                    const cs = this.continueScalar(i + 1);
                    if (cs === -1) break;
                    i = Math.max(i, cs - 2); // to advance, but still account for ' #'
                }
            } else {
                if (inFlow && $9f958cea0283f85f$var$flowIndicatorChars.has(ch)) break;
                end = i;
            }
        }
        if (!ch && !this.atEnd) return this.setNext("plain-scalar");
        yield $cJNRU.SCALAR;
        yield* this.pushToIndex(end + 1, true);
        return inFlow ? "flow" : "doc";
    }
    *pushCount(n) {
        if (n > 0) {
            yield this.buffer.substr(this.pos, n);
            this.pos += n;
            return n;
        }
        return 0;
    }
    *pushToIndex(i, allowEmpty) {
        const s = this.buffer.slice(this.pos, i);
        if (s) {
            yield s;
            this.pos += s.length;
            return s.length;
        } else if (allowEmpty) yield "";
        return 0;
    }
    *pushIndicators() {
        switch(this.charAt(0)){
            case "!":
                return (yield* this.pushTag()) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
            case "&":
                return (yield* this.pushUntil($9f958cea0283f85f$var$isNotAnchorChar)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
            case "-":
            case "?":
            case ":":
                {
                    const inFlow = this.flowLevel > 0;
                    const ch1 = this.charAt(1);
                    if ($9f958cea0283f85f$var$isEmpty(ch1) || inFlow && $9f958cea0283f85f$var$flowIndicatorChars.has(ch1)) {
                        if (!inFlow) this.indentNext = this.indentValue + 1;
                        else if (this.flowKey) this.flowKey = false;
                        return (yield* this.pushCount(1)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
                    }
                }
        }
        return 0;
    }
    *pushTag() {
        if (this.charAt(1) === "<") {
            let i = this.pos + 2;
            let ch = this.buffer[i];
            while(!$9f958cea0283f85f$var$isEmpty(ch) && ch !== ">")ch = this.buffer[++i];
            return yield* this.pushToIndex(ch === ">" ? i + 1 : i, false);
        } else {
            let i = this.pos + 1;
            let ch = this.buffer[i];
            while(ch){
                if ($9f958cea0283f85f$var$tagChars.has(ch)) ch = this.buffer[++i];
                else if (ch === "%" && $9f958cea0283f85f$var$hexDigits.has(this.buffer[i + 1]) && $9f958cea0283f85f$var$hexDigits.has(this.buffer[i + 2])) ch = this.buffer[i += 3];
                else break;
            }
            return yield* this.pushToIndex(i, false);
        }
    }
    *pushNewline() {
        const ch = this.buffer[this.pos];
        if (ch === "\n") return yield* this.pushCount(1);
        else if (ch === "\r" && this.charAt(1) === "\n") return yield* this.pushCount(2);
        else return 0;
    }
    *pushSpaces(allowTabs) {
        let i = this.pos - 1;
        let ch;
        do ch = this.buffer[++i];
        while (ch === " " || allowTabs && ch === "	");
        const n = i - this.pos;
        if (n > 0) {
            yield this.buffer.substr(this.pos, n);
            this.pos = i;
        }
        return n;
    }
    *pushUntil(test) {
        let i = this.pos;
        let ch = this.buffer[i];
        while(!test(ch))ch = this.buffer[++i];
        return yield* this.pushToIndex(i, false);
    }
}
$9f958cea0283f85f$export$6168dc8908a6c652 = $9f958cea0283f85f$var$Lexer;

});

parcelRegister("4Fp6h", function(module, exports) {

$parcel$export(module.exports, "LineCounter", () => $365e762d219d6e02$export$c8a6f24ae2865e59, (v) => $365e762d219d6e02$export$c8a6f24ae2865e59 = v);
var $365e762d219d6e02$export$c8a6f24ae2865e59;
"use strict";
/**
 * Tracks newlines during parsing in order to provide an efficient API for
 * determining the one-indexed `{ line, col }` position for any offset
 * within the input.
 */ class $365e762d219d6e02$var$LineCounter {
    constructor(){
        this.lineStarts = [];
        /**
         * Should be called in ascending order. Otherwise, call
         * `lineCounter.lineStarts.sort()` before calling `linePos()`.
         */ this.addNewLine = (offset)=>this.lineStarts.push(offset);
        /**
         * Performs a binary search and returns the 1-indexed { line, col }
         * position of `offset`. If `line === 0`, `addNewLine` has never been
         * called or `offset` is before the first known newline.
         */ this.linePos = (offset)=>{
            let low = 0;
            let high = this.lineStarts.length;
            while(low < high){
                const mid = low + high >> 1; // Math.floor((low + high) / 2)
                if (this.lineStarts[mid] < offset) low = mid + 1;
                else high = mid;
            }
            if (this.lineStarts[low] === offset) return {
                line: low + 1,
                col: 1
            };
            if (low === 0) return {
                line: 0,
                col: offset
            };
            const start = this.lineStarts[low - 1];
            return {
                line: low,
                col: offset - start + 1
            };
        };
    }
}
$365e762d219d6e02$export$c8a6f24ae2865e59 = $365e762d219d6e02$var$LineCounter;

});

parcelRegister("ltR1M", function(module, exports) {

$parcel$export(module.exports, "Parser", () => $fa35709562608a97$export$7acfa6ed01010e37, (v) => $fa35709562608a97$export$7acfa6ed01010e37 = v);
var $fa35709562608a97$export$7acfa6ed01010e37;
"use strict";

var $cJNRU = parcelRequire("cJNRU");

var $dHsHc = parcelRequire("dHsHc");
function $fa35709562608a97$var$includesToken(list, type) {
    for(let i = 0; i < list.length; ++i)if (list[i].type === type) return true;
    return false;
}
function $fa35709562608a97$var$findNonEmptyIndex(list) {
    for(let i = 0; i < list.length; ++i)switch(list[i].type){
        case "space":
        case "comment":
        case "newline":
            break;
        default:
            return i;
    }
    return -1;
}
function $fa35709562608a97$var$isFlowToken(token) {
    switch(token?.type){
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
        case "flow-collection":
            return true;
        default:
            return false;
    }
}
function $fa35709562608a97$var$getPrevProps(parent) {
    switch(parent.type){
        case "document":
            return parent.start;
        case "block-map":
            {
                const it = parent.items[parent.items.length - 1];
                return it.sep ?? it.start;
            }
        case "block-seq":
            return parent.items[parent.items.length - 1].start;
        /* istanbul ignore next should not happen */ default:
            return [];
    }
}
/** Note: May modify input array */ function $fa35709562608a97$var$getFirstKeyStartProps(prev) {
    if (prev.length === 0) return [];
    let i = prev.length;
    loop: while(--i >= 0)switch(prev[i].type){
        case "doc-start":
        case "explicit-key-ind":
        case "map-value-ind":
        case "seq-item-ind":
        case "newline":
            break loop;
    }
    while(prev[++i]?.type === "space");
    return prev.splice(i, prev.length);
}
function $fa35709562608a97$var$fixFlowSeqItems(fc) {
    if (fc.start.type === "flow-seq-start") {
        for (const it of fc.items)if (it.sep && !it.value && !$fa35709562608a97$var$includesToken(it.start, "explicit-key-ind") && !$fa35709562608a97$var$includesToken(it.sep, "map-value-ind")) {
            if (it.key) it.value = it.key;
            delete it.key;
            if ($fa35709562608a97$var$isFlowToken(it.value)) {
                if (it.value.end) Array.prototype.push.apply(it.value.end, it.sep);
                else it.value.end = it.sep;
            } else Array.prototype.push.apply(it.start, it.sep);
            delete it.sep;
        }
    }
}
/**
 * A YAML concrete syntax tree (CST) parser
 *
 * ```ts
 * const src: string = ...
 * for (const token of new Parser().parse(src)) {
 *   // token: Token
 * }
 * ```
 *
 * To use the parser with a user-provided lexer:
 *
 * ```ts
 * function* parse(source: string, lexer: Lexer) {
 *   const parser = new Parser()
 *   for (const lexeme of lexer.lex(source))
 *     yield* parser.next(lexeme)
 *   yield* parser.end()
 * }
 *
 * const src: string = ...
 * const lexer = new Lexer()
 * for (const token of parse(src, lexer)) {
 *   // token: Token
 * }
 * ```
 */ class $fa35709562608a97$var$Parser {
    /**
     * @param onNewLine - If defined, called separately with the start position of
     *   each new line (in `parse()`, including the start of input).
     */ constructor(onNewLine){
        /** If true, space and sequence indicators count as indentation */ this.atNewLine = true;
        /** If true, next token is a scalar value */ this.atScalar = false;
        /** Current indentation level */ this.indent = 0;
        /** Current offset since the start of parsing */ this.offset = 0;
        /** On the same line with a block map key */ this.onKeyLine = false;
        /** Top indicates the node that's currently being built */ this.stack = [];
        /** The source of the current token, set in parse() */ this.source = "";
        /** The type of the current token, set in parse() */ this.type = "";
        // Must be defined after `next()`
        this.lexer = new $dHsHc.Lexer();
        this.onNewLine = onNewLine;
    }
    /**
     * Parse `source` as a YAML stream.
     * If `incomplete`, a part of the last line may be left as a buffer for the next call.
     *
     * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
     *
     * @returns A generator of tokens representing each directive, document, and other structure.
     */ *parse(source, incomplete = false) {
        if (this.onNewLine && this.offset === 0) this.onNewLine(0);
        for (const lexeme of this.lexer.lex(source, incomplete))yield* this.next(lexeme);
        if (!incomplete) yield* this.end();
    }
    /**
     * Advance the parser by the `source` of one lexical token.
     */ *next(source) {
        this.source = source;
        if (process.env.LOG_TOKENS) console.log("|", $cJNRU.prettyToken(source));
        if (this.atScalar) {
            this.atScalar = false;
            yield* this.step();
            this.offset += source.length;
            return;
        }
        const type = $cJNRU.tokenType(source);
        if (!type) {
            const message = `Not a YAML token: ${source}`;
            yield* this.pop({
                type: "error",
                offset: this.offset,
                message: message,
                source: source
            });
            this.offset += source.length;
        } else if (type === "scalar") {
            this.atNewLine = false;
            this.atScalar = true;
            this.type = "scalar";
        } else {
            this.type = type;
            yield* this.step();
            switch(type){
                case "newline":
                    this.atNewLine = true;
                    this.indent = 0;
                    if (this.onNewLine) this.onNewLine(this.offset + source.length);
                    break;
                case "space":
                    if (this.atNewLine && source[0] === " ") this.indent += source.length;
                    break;
                case "explicit-key-ind":
                case "map-value-ind":
                case "seq-item-ind":
                    if (this.atNewLine) this.indent += source.length;
                    break;
                case "doc-mode":
                case "flow-error-end":
                    return;
                default:
                    this.atNewLine = false;
            }
            this.offset += source.length;
        }
    }
    /** Call at end of input to push out any remaining constructions */ *end() {
        while(this.stack.length > 0)yield* this.pop();
    }
    get sourceToken() {
        const st = {
            type: this.type,
            offset: this.offset,
            indent: this.indent,
            source: this.source
        };
        return st;
    }
    *step() {
        const top = this.peek(1);
        if (this.type === "doc-end" && (!top || top.type !== "doc-end")) {
            while(this.stack.length > 0)yield* this.pop();
            this.stack.push({
                type: "doc-end",
                offset: this.offset,
                source: this.source
            });
            return;
        }
        if (!top) return yield* this.stream();
        switch(top.type){
            case "document":
                return yield* this.document(top);
            case "alias":
            case "scalar":
            case "single-quoted-scalar":
            case "double-quoted-scalar":
                return yield* this.scalar(top);
            case "block-scalar":
                return yield* this.blockScalar(top);
            case "block-map":
                return yield* this.blockMap(top);
            case "block-seq":
                return yield* this.blockSequence(top);
            case "flow-collection":
                return yield* this.flowCollection(top);
            case "doc-end":
                return yield* this.documentEnd(top);
        }
        /* istanbul ignore next should not happen */ yield* this.pop();
    }
    peek(n) {
        return this.stack[this.stack.length - n];
    }
    *pop(error) {
        const token = error ?? this.stack.pop();
        /* istanbul ignore if should not happen */ if (!token) {
            const message = "Tried to pop an empty stack";
            yield {
                type: "error",
                offset: this.offset,
                source: "",
                message: message
            };
        } else if (this.stack.length === 0) yield token;
        else {
            const top = this.peek(1);
            if (token.type === "block-scalar") // Block scalars use their parent rather than header indent
            token.indent = "indent" in top ? top.indent : 0;
            else if (token.type === "flow-collection" && top.type === "document") // Ignore all indent for top-level flow collections
            token.indent = 0;
            if (token.type === "flow-collection") $fa35709562608a97$var$fixFlowSeqItems(token);
            switch(top.type){
                case "document":
                    top.value = token;
                    break;
                case "block-scalar":
                    top.props.push(token); // error
                    break;
                case "block-map":
                    {
                        const it = top.items[top.items.length - 1];
                        if (it.value) {
                            top.items.push({
                                start: [],
                                key: token,
                                sep: []
                            });
                            this.onKeyLine = true;
                            return;
                        } else if (it.sep) it.value = token;
                        else {
                            Object.assign(it, {
                                key: token,
                                sep: []
                            });
                            this.onKeyLine = !it.explicitKey;
                            return;
                        }
                        break;
                    }
                case "block-seq":
                    {
                        const it = top.items[top.items.length - 1];
                        if (it.value) top.items.push({
                            start: [],
                            value: token
                        });
                        else it.value = token;
                        break;
                    }
                case "flow-collection":
                    {
                        const it = top.items[top.items.length - 1];
                        if (!it || it.value) top.items.push({
                            start: [],
                            key: token,
                            sep: []
                        });
                        else if (it.sep) it.value = token;
                        else Object.assign(it, {
                            key: token,
                            sep: []
                        });
                        return;
                    }
                /* istanbul ignore next should not happen */ default:
                    yield* this.pop();
                    yield* this.pop(token);
            }
            if ((top.type === "document" || top.type === "block-map" || top.type === "block-seq") && (token.type === "block-map" || token.type === "block-seq")) {
                const last = token.items[token.items.length - 1];
                if (last && !last.sep && !last.value && last.start.length > 0 && $fa35709562608a97$var$findNonEmptyIndex(last.start) === -1 && (token.indent === 0 || last.start.every((st)=>st.type !== "comment" || st.indent < token.indent))) {
                    if (top.type === "document") top.end = last.start;
                    else top.items.push({
                        start: last.start
                    });
                    token.items.splice(-1, 1);
                }
            }
        }
    }
    *stream() {
        switch(this.type){
            case "directive-line":
                yield {
                    type: "directive",
                    offset: this.offset,
                    source: this.source
                };
                return;
            case "byte-order-mark":
            case "space":
            case "comment":
            case "newline":
                yield this.sourceToken;
                return;
            case "doc-mode":
            case "doc-start":
                {
                    const doc = {
                        type: "document",
                        offset: this.offset,
                        start: []
                    };
                    if (this.type === "doc-start") doc.start.push(this.sourceToken);
                    this.stack.push(doc);
                    return;
                }
        }
        yield {
            type: "error",
            offset: this.offset,
            message: `Unexpected ${this.type} token in YAML stream`,
            source: this.source
        };
    }
    *document(doc) {
        if (doc.value) return yield* this.lineEnd(doc);
        switch(this.type){
            case "doc-start":
                if ($fa35709562608a97$var$findNonEmptyIndex(doc.start) !== -1) {
                    yield* this.pop();
                    yield* this.step();
                } else doc.start.push(this.sourceToken);
                return;
            case "anchor":
            case "tag":
            case "space":
            case "comment":
            case "newline":
                doc.start.push(this.sourceToken);
                return;
        }
        const bv = this.startBlockValue(doc);
        if (bv) this.stack.push(bv);
        else yield {
            type: "error",
            offset: this.offset,
            message: `Unexpected ${this.type} token in YAML document`,
            source: this.source
        };
    }
    *scalar(scalar) {
        if (this.type === "map-value-ind") {
            const prev = $fa35709562608a97$var$getPrevProps(this.peek(2));
            const start = $fa35709562608a97$var$getFirstKeyStartProps(prev);
            let sep;
            if (scalar.end) {
                sep = scalar.end;
                sep.push(this.sourceToken);
                delete scalar.end;
            } else sep = [
                this.sourceToken
            ];
            const map = {
                type: "block-map",
                offset: scalar.offset,
                indent: scalar.indent,
                items: [
                    {
                        start: start,
                        key: scalar,
                        sep: sep
                    }
                ]
            };
            this.onKeyLine = true;
            this.stack[this.stack.length - 1] = map;
        } else yield* this.lineEnd(scalar);
    }
    *blockScalar(scalar) {
        switch(this.type){
            case "space":
            case "comment":
            case "newline":
                scalar.props.push(this.sourceToken);
                return;
            case "scalar":
                scalar.source = this.source;
                // block-scalar source includes trailing newline
                this.atNewLine = true;
                this.indent = 0;
                if (this.onNewLine) {
                    let nl = this.source.indexOf("\n") + 1;
                    while(nl !== 0){
                        this.onNewLine(this.offset + nl);
                        nl = this.source.indexOf("\n", nl) + 1;
                    }
                }
                yield* this.pop();
                break;
            /* istanbul ignore next should not happen */ default:
                yield* this.pop();
                yield* this.step();
        }
    }
    *blockMap(map) {
        const it = map.items[map.items.length - 1];
        // it.sep is true-ish if pair already has key or : separator
        switch(this.type){
            case "newline":
                this.onKeyLine = false;
                if (it.value) {
                    const end = "end" in it.value ? it.value.end : undefined;
                    const last = Array.isArray(end) ? end[end.length - 1] : undefined;
                    if (last?.type === "comment") end?.push(this.sourceToken);
                    else map.items.push({
                        start: [
                            this.sourceToken
                        ]
                    });
                } else if (it.sep) it.sep.push(this.sourceToken);
                else it.start.push(this.sourceToken);
                return;
            case "space":
            case "comment":
                if (it.value) map.items.push({
                    start: [
                        this.sourceToken
                    ]
                });
                else if (it.sep) it.sep.push(this.sourceToken);
                else {
                    if (this.atIndentedComment(it.start, map.indent)) {
                        const prev = map.items[map.items.length - 2];
                        const end = prev?.value?.end;
                        if (Array.isArray(end)) {
                            Array.prototype.push.apply(end, it.start);
                            end.push(this.sourceToken);
                            map.items.pop();
                            return;
                        }
                    }
                    it.start.push(this.sourceToken);
                }
                return;
        }
        if (this.indent >= map.indent) {
            const atMapIndent = !this.onKeyLine && this.indent === map.indent;
            const atNextItem = atMapIndent && (it.sep || it.explicitKey) && this.type !== "seq-item-ind";
            // For empty nodes, assign newline-separated not indented empty tokens to following node
            let start = [];
            if (atNextItem && it.sep && !it.value) {
                const nl = [];
                for(let i = 0; i < it.sep.length; ++i){
                    const st = it.sep[i];
                    switch(st.type){
                        case "newline":
                            nl.push(i);
                            break;
                        case "space":
                            break;
                        case "comment":
                            if (st.indent > map.indent) nl.length = 0;
                            break;
                        default:
                            nl.length = 0;
                    }
                }
                if (nl.length >= 2) start = it.sep.splice(nl[1]);
            }
            switch(this.type){
                case "anchor":
                case "tag":
                    if (atNextItem || it.value) {
                        start.push(this.sourceToken);
                        map.items.push({
                            start: start
                        });
                        this.onKeyLine = true;
                    } else if (it.sep) it.sep.push(this.sourceToken);
                    else it.start.push(this.sourceToken);
                    return;
                case "explicit-key-ind":
                    if (!it.sep && !it.explicitKey) {
                        it.start.push(this.sourceToken);
                        it.explicitKey = true;
                    } else if (atNextItem || it.value) {
                        start.push(this.sourceToken);
                        map.items.push({
                            start: start,
                            explicitKey: true
                        });
                    } else this.stack.push({
                        type: "block-map",
                        offset: this.offset,
                        indent: this.indent,
                        items: [
                            {
                                start: [
                                    this.sourceToken
                                ],
                                explicitKey: true
                            }
                        ]
                    });
                    this.onKeyLine = true;
                    return;
                case "map-value-ind":
                    if (it.explicitKey) {
                        if (!it.sep) {
                            if ($fa35709562608a97$var$includesToken(it.start, "newline")) Object.assign(it, {
                                key: null,
                                sep: [
                                    this.sourceToken
                                ]
                            });
                            else {
                                const start = $fa35709562608a97$var$getFirstKeyStartProps(it.start);
                                this.stack.push({
                                    type: "block-map",
                                    offset: this.offset,
                                    indent: this.indent,
                                    items: [
                                        {
                                            start: start,
                                            key: null,
                                            sep: [
                                                this.sourceToken
                                            ]
                                        }
                                    ]
                                });
                            }
                        } else if (it.value) map.items.push({
                            start: [],
                            key: null,
                            sep: [
                                this.sourceToken
                            ]
                        });
                        else if ($fa35709562608a97$var$includesToken(it.sep, "map-value-ind")) this.stack.push({
                            type: "block-map",
                            offset: this.offset,
                            indent: this.indent,
                            items: [
                                {
                                    start: start,
                                    key: null,
                                    sep: [
                                        this.sourceToken
                                    ]
                                }
                            ]
                        });
                        else if ($fa35709562608a97$var$isFlowToken(it.key) && !$fa35709562608a97$var$includesToken(it.sep, "newline")) {
                            const start = $fa35709562608a97$var$getFirstKeyStartProps(it.start);
                            const key = it.key;
                            const sep = it.sep;
                            sep.push(this.sourceToken);
                            // @ts-expect-error type guard is wrong here
                            delete it.key;
                            // @ts-expect-error type guard is wrong here
                            delete it.sep;
                            this.stack.push({
                                type: "block-map",
                                offset: this.offset,
                                indent: this.indent,
                                items: [
                                    {
                                        start: start,
                                        key: key,
                                        sep: sep
                                    }
                                ]
                            });
                        } else if (start.length > 0) // Not actually at next item
                        it.sep = it.sep.concat(start, this.sourceToken);
                        else it.sep.push(this.sourceToken);
                    } else {
                        if (!it.sep) Object.assign(it, {
                            key: null,
                            sep: [
                                this.sourceToken
                            ]
                        });
                        else if (it.value || atNextItem) map.items.push({
                            start: start,
                            key: null,
                            sep: [
                                this.sourceToken
                            ]
                        });
                        else if ($fa35709562608a97$var$includesToken(it.sep, "map-value-ind")) this.stack.push({
                            type: "block-map",
                            offset: this.offset,
                            indent: this.indent,
                            items: [
                                {
                                    start: [],
                                    key: null,
                                    sep: [
                                        this.sourceToken
                                    ]
                                }
                            ]
                        });
                        else it.sep.push(this.sourceToken);
                    }
                    this.onKeyLine = true;
                    return;
                case "alias":
                case "scalar":
                case "single-quoted-scalar":
                case "double-quoted-scalar":
                    {
                        const fs = this.flowScalar(this.type);
                        if (atNextItem || it.value) {
                            map.items.push({
                                start: start,
                                key: fs,
                                sep: []
                            });
                            this.onKeyLine = true;
                        } else if (it.sep) this.stack.push(fs);
                        else {
                            Object.assign(it, {
                                key: fs,
                                sep: []
                            });
                            this.onKeyLine = true;
                        }
                        return;
                    }
                default:
                    {
                        const bv = this.startBlockValue(map);
                        if (bv) {
                            if (atMapIndent && bv.type !== "block-seq") map.items.push({
                                start: start
                            });
                            this.stack.push(bv);
                            return;
                        }
                    }
            }
        }
        yield* this.pop();
        yield* this.step();
    }
    *blockSequence(seq) {
        const it = seq.items[seq.items.length - 1];
        switch(this.type){
            case "newline":
                if (it.value) {
                    const end = "end" in it.value ? it.value.end : undefined;
                    const last = Array.isArray(end) ? end[end.length - 1] : undefined;
                    if (last?.type === "comment") end?.push(this.sourceToken);
                    else seq.items.push({
                        start: [
                            this.sourceToken
                        ]
                    });
                } else it.start.push(this.sourceToken);
                return;
            case "space":
            case "comment":
                if (it.value) seq.items.push({
                    start: [
                        this.sourceToken
                    ]
                });
                else {
                    if (this.atIndentedComment(it.start, seq.indent)) {
                        const prev = seq.items[seq.items.length - 2];
                        const end = prev?.value?.end;
                        if (Array.isArray(end)) {
                            Array.prototype.push.apply(end, it.start);
                            end.push(this.sourceToken);
                            seq.items.pop();
                            return;
                        }
                    }
                    it.start.push(this.sourceToken);
                }
                return;
            case "anchor":
            case "tag":
                if (it.value || this.indent <= seq.indent) break;
                it.start.push(this.sourceToken);
                return;
            case "seq-item-ind":
                if (this.indent !== seq.indent) break;
                if (it.value || $fa35709562608a97$var$includesToken(it.start, "seq-item-ind")) seq.items.push({
                    start: [
                        this.sourceToken
                    ]
                });
                else it.start.push(this.sourceToken);
                return;
        }
        if (this.indent > seq.indent) {
            const bv = this.startBlockValue(seq);
            if (bv) {
                this.stack.push(bv);
                return;
            }
        }
        yield* this.pop();
        yield* this.step();
    }
    *flowCollection(fc) {
        const it = fc.items[fc.items.length - 1];
        if (this.type === "flow-error-end") {
            let top;
            do {
                yield* this.pop();
                top = this.peek(1);
            }while (top && top.type === "flow-collection");
        } else if (fc.end.length === 0) {
            switch(this.type){
                case "comma":
                case "explicit-key-ind":
                    if (!it || it.sep) fc.items.push({
                        start: [
                            this.sourceToken
                        ]
                    });
                    else it.start.push(this.sourceToken);
                    return;
                case "map-value-ind":
                    if (!it || it.value) fc.items.push({
                        start: [],
                        key: null,
                        sep: [
                            this.sourceToken
                        ]
                    });
                    else if (it.sep) it.sep.push(this.sourceToken);
                    else Object.assign(it, {
                        key: null,
                        sep: [
                            this.sourceToken
                        ]
                    });
                    return;
                case "space":
                case "comment":
                case "newline":
                case "anchor":
                case "tag":
                    if (!it || it.value) fc.items.push({
                        start: [
                            this.sourceToken
                        ]
                    });
                    else if (it.sep) it.sep.push(this.sourceToken);
                    else it.start.push(this.sourceToken);
                    return;
                case "alias":
                case "scalar":
                case "single-quoted-scalar":
                case "double-quoted-scalar":
                    {
                        const fs = this.flowScalar(this.type);
                        if (!it || it.value) fc.items.push({
                            start: [],
                            key: fs,
                            sep: []
                        });
                        else if (it.sep) this.stack.push(fs);
                        else Object.assign(it, {
                            key: fs,
                            sep: []
                        });
                        return;
                    }
                case "flow-map-end":
                case "flow-seq-end":
                    fc.end.push(this.sourceToken);
                    return;
            }
            const bv = this.startBlockValue(fc);
            /* istanbul ignore else should not happen */ if (bv) this.stack.push(bv);
            else {
                yield* this.pop();
                yield* this.step();
            }
        } else {
            const parent = this.peek(2);
            if (parent.type === "block-map" && (this.type === "map-value-ind" && parent.indent === fc.indent || this.type === "newline" && !parent.items[parent.items.length - 1].sep)) {
                yield* this.pop();
                yield* this.step();
            } else if (this.type === "map-value-ind" && parent.type !== "flow-collection") {
                const prev = $fa35709562608a97$var$getPrevProps(parent);
                const start = $fa35709562608a97$var$getFirstKeyStartProps(prev);
                $fa35709562608a97$var$fixFlowSeqItems(fc);
                const sep = fc.end.splice(1, fc.end.length);
                sep.push(this.sourceToken);
                const map = {
                    type: "block-map",
                    offset: fc.offset,
                    indent: fc.indent,
                    items: [
                        {
                            start: start,
                            key: fc,
                            sep: sep
                        }
                    ]
                };
                this.onKeyLine = true;
                this.stack[this.stack.length - 1] = map;
            } else yield* this.lineEnd(fc);
        }
    }
    flowScalar(type) {
        if (this.onNewLine) {
            let nl = this.source.indexOf("\n") + 1;
            while(nl !== 0){
                this.onNewLine(this.offset + nl);
                nl = this.source.indexOf("\n", nl) + 1;
            }
        }
        return {
            type: type,
            offset: this.offset,
            indent: this.indent,
            source: this.source
        };
    }
    startBlockValue(parent) {
        switch(this.type){
            case "alias":
            case "scalar":
            case "single-quoted-scalar":
            case "double-quoted-scalar":
                return this.flowScalar(this.type);
            case "block-scalar-header":
                return {
                    type: "block-scalar",
                    offset: this.offset,
                    indent: this.indent,
                    props: [
                        this.sourceToken
                    ],
                    source: ""
                };
            case "flow-map-start":
            case "flow-seq-start":
                return {
                    type: "flow-collection",
                    offset: this.offset,
                    indent: this.indent,
                    start: this.sourceToken,
                    items: [],
                    end: []
                };
            case "seq-item-ind":
                return {
                    type: "block-seq",
                    offset: this.offset,
                    indent: this.indent,
                    items: [
                        {
                            start: [
                                this.sourceToken
                            ]
                        }
                    ]
                };
            case "explicit-key-ind":
                {
                    this.onKeyLine = true;
                    const prev = $fa35709562608a97$var$getPrevProps(parent);
                    const start = $fa35709562608a97$var$getFirstKeyStartProps(prev);
                    start.push(this.sourceToken);
                    return {
                        type: "block-map",
                        offset: this.offset,
                        indent: this.indent,
                        items: [
                            {
                                start: start,
                                explicitKey: true
                            }
                        ]
                    };
                }
            case "map-value-ind":
                {
                    this.onKeyLine = true;
                    const prev = $fa35709562608a97$var$getPrevProps(parent);
                    const start = $fa35709562608a97$var$getFirstKeyStartProps(prev);
                    return {
                        type: "block-map",
                        offset: this.offset,
                        indent: this.indent,
                        items: [
                            {
                                start: start,
                                key: null,
                                sep: [
                                    this.sourceToken
                                ]
                            }
                        ]
                    };
                }
        }
        return null;
    }
    atIndentedComment(start, indent) {
        if (this.type !== "comment") return false;
        if (this.indent <= indent) return false;
        return start.every((st)=>st.type === "newline" || st.type === "space");
    }
    *documentEnd(docEnd) {
        if (this.type !== "doc-mode") {
            if (docEnd.end) docEnd.end.push(this.sourceToken);
            else docEnd.end = [
                this.sourceToken
            ];
            if (this.type === "newline") yield* this.pop();
        }
    }
    *lineEnd(token) {
        switch(this.type){
            case "comma":
            case "doc-start":
            case "doc-end":
            case "flow-seq-end":
            case "flow-map-end":
            case "map-value-ind":
                yield* this.pop();
                yield* this.step();
                break;
            case "newline":
                this.onKeyLine = false;
            // fallthrough
            case "space":
            case "comment":
            default:
                // all other values are errors
                if (token.end) token.end.push(this.sourceToken);
                else token.end = [
                    this.sourceToken
                ];
                if (this.type === "newline") yield* this.pop();
        }
    }
}
$fa35709562608a97$export$7acfa6ed01010e37 = $fa35709562608a97$var$Parser;

});

parcelRegister("bVh0N", function(module, exports) {

$parcel$export(module.exports, "parse", () => $8ae236c5cb916ca0$export$98e6a39c04603d36, (v) => $8ae236c5cb916ca0$export$98e6a39c04603d36 = v);
$parcel$export(module.exports, "parseAllDocuments", () => $8ae236c5cb916ca0$export$643da2570c3b3d01, (v) => $8ae236c5cb916ca0$export$643da2570c3b3d01 = v);
$parcel$export(module.exports, "parseDocument", () => $8ae236c5cb916ca0$export$b6a9369736b19f4d, (v) => $8ae236c5cb916ca0$export$b6a9369736b19f4d = v);
$parcel$export(module.exports, "stringify", () => $8ae236c5cb916ca0$export$fac44ee5b035f737, (v) => $8ae236c5cb916ca0$export$fac44ee5b035f737 = v);
var $8ae236c5cb916ca0$export$98e6a39c04603d36;
var $8ae236c5cb916ca0$export$643da2570c3b3d01;
var $8ae236c5cb916ca0$export$b6a9369736b19f4d;
var $8ae236c5cb916ca0$export$fac44ee5b035f737;
"use strict";

var $e6LZ8 = parcelRequire("e6LZ8");

var $hfBM7 = parcelRequire("hfBM7");

var $9DvMJ = parcelRequire("9DvMJ");

var $f9S3O = parcelRequire("f9S3O");

var $FOECb = parcelRequire("FOECb");

var $4Fp6h = parcelRequire("4Fp6h");

var $ltR1M = parcelRequire("ltR1M");
function $8ae236c5cb916ca0$var$parseOptions(options) {
    const prettyErrors = options.prettyErrors !== false;
    const lineCounter$1 = options.lineCounter || prettyErrors && new $4Fp6h.LineCounter() || null;
    return {
        lineCounter: lineCounter$1,
        prettyErrors: prettyErrors
    };
}
/**
 * Parse the input as a stream of YAML documents.
 *
 * Documents should be separated from each other by `...` or `---` marker lines.
 *
 * @returns If an empty `docs` array is returned, it will be of type
 *   EmptyStream and contain additional stream information. In
 *   TypeScript, you should use `'empty' in docs` as a type guard for it.
 */ function $8ae236c5cb916ca0$var$parseAllDocuments(source, options = {}) {
    const { lineCounter: lineCounter, prettyErrors: prettyErrors } = $8ae236c5cb916ca0$var$parseOptions(options);
    const parser$1 = new $ltR1M.Parser(lineCounter?.addNewLine);
    const composer$1 = new $e6LZ8.Composer(options);
    const docs = Array.from(composer$1.compose(parser$1.parse(source)));
    if (prettyErrors && lineCounter) for (const doc of docs){
        doc.errors.forEach($9DvMJ.prettifyError(source, lineCounter));
        doc.warnings.forEach($9DvMJ.prettifyError(source, lineCounter));
    }
    if (docs.length > 0) return docs;
    return Object.assign([], {
        empty: true
    }, composer$1.streamInfo());
}
/** Parse an input string into a single YAML.Document */ function $8ae236c5cb916ca0$var$parseDocument(source, options = {}) {
    const { lineCounter: lineCounter, prettyErrors: prettyErrors } = $8ae236c5cb916ca0$var$parseOptions(options);
    const parser$1 = new $ltR1M.Parser(lineCounter?.addNewLine);
    const composer$1 = new $e6LZ8.Composer(options);
    // `doc` is always set by compose.end(true) at the very latest
    let doc = null;
    for (const _doc of composer$1.compose(parser$1.parse(source), true, source.length)){
        if (!doc) doc = _doc;
        else if (doc.options.logLevel !== "silent") {
            doc.errors.push(new $9DvMJ.YAMLParseError(_doc.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
            break;
        }
    }
    if (prettyErrors && lineCounter) {
        doc.errors.forEach($9DvMJ.prettifyError(source, lineCounter));
        doc.warnings.forEach($9DvMJ.prettifyError(source, lineCounter));
    }
    return doc;
}
function $8ae236c5cb916ca0$var$parse(src, reviver, options) {
    let _reviver = undefined;
    if (typeof reviver === "function") _reviver = reviver;
    else if (options === undefined && reviver && typeof reviver === "object") options = reviver;
    const doc = $8ae236c5cb916ca0$var$parseDocument(src, options);
    if (!doc) return null;
    doc.warnings.forEach((warning)=>$f9S3O.warn(doc.options.logLevel, warning));
    if (doc.errors.length > 0) {
        if (doc.options.logLevel !== "silent") throw doc.errors[0];
        else doc.errors = [];
    }
    return doc.toJS(Object.assign({
        reviver: _reviver
    }, options));
}
function $8ae236c5cb916ca0$var$stringify(value, replacer, options) {
    let _replacer = null;
    if (typeof replacer === "function" || Array.isArray(replacer)) _replacer = replacer;
    else if (options === undefined && replacer) options = replacer;
    if (typeof options === "string") options = options.length;
    if (typeof options === "number") {
        const indent = Math.round(options);
        options = indent < 1 ? undefined : indent > 8 ? {
            indent: 8
        } : {
            indent: indent
        };
    }
    if (value === undefined) {
        const { keepUndefined: keepUndefined } = options ?? replacer ?? {};
        if (!keepUndefined) return undefined;
    }
    if ($FOECb.isDocument(value) && !_replacer) return value.toString(options);
    return new $hfBM7.Document(value, _replacer, options).toString(options);
}
$8ae236c5cb916ca0$export$98e6a39c04603d36 = $8ae236c5cb916ca0$var$parse;
$8ae236c5cb916ca0$export$643da2570c3b3d01 = $8ae236c5cb916ca0$var$parseAllDocuments;
$8ae236c5cb916ca0$export$b6a9369736b19f4d = $8ae236c5cb916ca0$var$parseDocument;
$8ae236c5cb916ca0$export$fac44ee5b035f737 = $8ae236c5cb916ca0$var$stringify;

});


parcelRegister("gJ8VZ", function(module, exports) {
const $02e0c265535d7456$var$frontmatterRegex = /^\s*---((?:.|\s)+?)---/;
/**
 * @param {string} toCheck
 * @returns {string | false}
 */ const $02e0c265535d7456$var$containsFrontmatter = (toCheck)=>$02e0c265535d7456$var$frontmatterRegex.exec(toCheck)?.[1] ?? false;
module.exports = {
    frontmatterRegex: $02e0c265535d7456$var$frontmatterRegex,
    containsFrontmatter: $02e0c265535d7456$var$containsFrontmatter
};

});


parcelRegister("21oST", function(module, exports) {
"use strict";
const wrapAnsi16 = (fn, offset)=>(...args)=>{
        const code = fn(...args);
        return `\u001B[${code + offset}m`;
    };
const wrapAnsi256 = (fn, offset)=>(...args)=>{
        const code = fn(...args);
        return `\u001B[${38 + offset};5;${code}m`;
    };
const wrapAnsi16m = (fn, offset)=>(...args)=>{
        const rgb = fn(...args);
        return `\u001B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
    };
const ansi2ansi = (n)=>n;
const rgb2rgb = (r, g, b)=>[
        r,
        g,
        b
    ];
const setLazyProperty = (object, property, get)=>{
    Object.defineProperty(object, property, {
        get: ()=>{
            const value = get();
            Object.defineProperty(object, property, {
                value: value,
                enumerable: true,
                configurable: true
            });
            return value;
        },
        enumerable: true,
        configurable: true
    });
};
/** @type {typeof import('color-convert')} */ let colorConvert;

const makeDynamicStyles = (wrap, targetSpace, identity, isBackground)=>{
    if (colorConvert === undefined) colorConvert = (parcelRequire("2McJ5"));
    const offset = isBackground ? 10 : 0;
    const styles = {};
    for (const [sourceSpace, suite] of Object.entries(colorConvert)){
        const name = sourceSpace === "ansi16" ? "ansi" : sourceSpace;
        if (sourceSpace === targetSpace) styles[name] = wrap(identity, offset);
        else if (typeof suite === "object") styles[name] = wrap(suite[targetSpace], offset);
    }
    return styles;
};
function assembleStyles() {
    const codes = new Map();
    const styles = {
        modifier: {
            reset: [
                0,
                0
            ],
            // 21 isn't widely supported and 22 does the same thing
            bold: [
                1,
                22
            ],
            dim: [
                2,
                22
            ],
            italic: [
                3,
                23
            ],
            underline: [
                4,
                24
            ],
            inverse: [
                7,
                27
            ],
            hidden: [
                8,
                28
            ],
            strikethrough: [
                9,
                29
            ]
        },
        color: {
            black: [
                30,
                39
            ],
            red: [
                31,
                39
            ],
            green: [
                32,
                39
            ],
            yellow: [
                33,
                39
            ],
            blue: [
                34,
                39
            ],
            magenta: [
                35,
                39
            ],
            cyan: [
                36,
                39
            ],
            white: [
                37,
                39
            ],
            // Bright color
            blackBright: [
                90,
                39
            ],
            redBright: [
                91,
                39
            ],
            greenBright: [
                92,
                39
            ],
            yellowBright: [
                93,
                39
            ],
            blueBright: [
                94,
                39
            ],
            magentaBright: [
                95,
                39
            ],
            cyanBright: [
                96,
                39
            ],
            whiteBright: [
                97,
                39
            ]
        },
        bgColor: {
            bgBlack: [
                40,
                49
            ],
            bgRed: [
                41,
                49
            ],
            bgGreen: [
                42,
                49
            ],
            bgYellow: [
                43,
                49
            ],
            bgBlue: [
                44,
                49
            ],
            bgMagenta: [
                45,
                49
            ],
            bgCyan: [
                46,
                49
            ],
            bgWhite: [
                47,
                49
            ],
            // Bright color
            bgBlackBright: [
                100,
                49
            ],
            bgRedBright: [
                101,
                49
            ],
            bgGreenBright: [
                102,
                49
            ],
            bgYellowBright: [
                103,
                49
            ],
            bgBlueBright: [
                104,
                49
            ],
            bgMagentaBright: [
                105,
                49
            ],
            bgCyanBright: [
                106,
                49
            ],
            bgWhiteBright: [
                107,
                49
            ]
        }
    };
    // Alias bright black as gray (and grey)
    styles.color.gray = styles.color.blackBright;
    styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
    styles.color.grey = styles.color.blackBright;
    styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
    for (const [groupName, group] of Object.entries(styles)){
        for (const [styleName, style] of Object.entries(group)){
            styles[styleName] = {
                open: `\u001B[${style[0]}m`,
                close: `\u001B[${style[1]}m`
            };
            group[styleName] = styles[styleName];
            codes.set(style[0], style[1]);
        }
        Object.defineProperty(styles, groupName, {
            value: group,
            enumerable: false
        });
    }
    Object.defineProperty(styles, "codes", {
        value: codes,
        enumerable: false
    });
    styles.color.close = "\x1b[39m";
    styles.bgColor.close = "\x1b[49m";
    setLazyProperty(styles.color, "ansi", ()=>makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, false));
    setLazyProperty(styles.color, "ansi256", ()=>makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, false));
    setLazyProperty(styles.color, "ansi16m", ()=>makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, false));
    setLazyProperty(styles.bgColor, "ansi", ()=>makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, true));
    setLazyProperty(styles.bgColor, "ansi256", ()=>makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, true));
    setLazyProperty(styles.bgColor, "ansi16m", ()=>makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, true));
    return styles;
}
// Make the export immutable
Object.defineProperty(module, "exports", {
    enumerable: true,
    get: assembleStyles
});

});
parcelRegister("2McJ5", function(module, exports) {

var $ggCZr = parcelRequire("ggCZr");

var $21ZsB = parcelRequire("21ZsB");
const $2059ef9fd76e9d13$var$convert = {};
const $2059ef9fd76e9d13$var$models = Object.keys($ggCZr);
function $2059ef9fd76e9d13$var$wrapRaw(fn) {
    const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === undefined || arg0 === null) return arg0;
        if (arg0.length > 1) args = arg0;
        return fn(args);
    };
    // Preserve .conversion property if there is one
    if ("conversion" in fn) wrappedFn.conversion = fn.conversion;
    return wrappedFn;
}
function $2059ef9fd76e9d13$var$wrapRounded(fn) {
    const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === undefined || arg0 === null) return arg0;
        if (arg0.length > 1) args = arg0;
        const result = fn(args);
        // We're assuming the result is an array here.
        // see notice in conversions.js; don't use box types
        // in conversion functions.
        if (typeof result === "object") for(let len = result.length, i = 0; i < len; i++)result[i] = Math.round(result[i]);
        return result;
    };
    // Preserve .conversion property if there is one
    if ("conversion" in fn) wrappedFn.conversion = fn.conversion;
    return wrappedFn;
}
$2059ef9fd76e9d13$var$models.forEach((fromModel)=>{
    $2059ef9fd76e9d13$var$convert[fromModel] = {};
    Object.defineProperty($2059ef9fd76e9d13$var$convert[fromModel], "channels", {
        value: $ggCZr[fromModel].channels
    });
    Object.defineProperty($2059ef9fd76e9d13$var$convert[fromModel], "labels", {
        value: $ggCZr[fromModel].labels
    });
    const routes = $21ZsB(fromModel);
    const routeModels = Object.keys(routes);
    routeModels.forEach((toModel)=>{
        const fn = routes[toModel];
        $2059ef9fd76e9d13$var$convert[fromModel][toModel] = $2059ef9fd76e9d13$var$wrapRounded(fn);
        $2059ef9fd76e9d13$var$convert[fromModel][toModel].raw = $2059ef9fd76e9d13$var$wrapRaw(fn);
    });
});
module.exports = $2059ef9fd76e9d13$var$convert;

});
parcelRegister("ggCZr", function(module, exports) {
/* MIT license */ /* eslint-disable no-mixed-operators */ 
var $7v5Iv = parcelRequire("7v5Iv");
// NOTE: conversions should only return primitive values (i.e. arrays, or
//       values that give correct `typeof` results).
//       do not use box values types (i.e. Number(), String(), etc.)
const $bd7c62960af01ee7$var$reverseKeywords = {};
for (const key of Object.keys($7v5Iv))$bd7c62960af01ee7$var$reverseKeywords[$7v5Iv[key]] = key;
const $bd7c62960af01ee7$var$convert = {
    rgb: {
        channels: 3,
        labels: "rgb"
    },
    hsl: {
        channels: 3,
        labels: "hsl"
    },
    hsv: {
        channels: 3,
        labels: "hsv"
    },
    hwb: {
        channels: 3,
        labels: "hwb"
    },
    cmyk: {
        channels: 4,
        labels: "cmyk"
    },
    xyz: {
        channels: 3,
        labels: "xyz"
    },
    lab: {
        channels: 3,
        labels: "lab"
    },
    lch: {
        channels: 3,
        labels: "lch"
    },
    hex: {
        channels: 1,
        labels: [
            "hex"
        ]
    },
    keyword: {
        channels: 1,
        labels: [
            "keyword"
        ]
    },
    ansi16: {
        channels: 1,
        labels: [
            "ansi16"
        ]
    },
    ansi256: {
        channels: 1,
        labels: [
            "ansi256"
        ]
    },
    hcg: {
        channels: 3,
        labels: [
            "h",
            "c",
            "g"
        ]
    },
    apple: {
        channels: 3,
        labels: [
            "r16",
            "g16",
            "b16"
        ]
    },
    gray: {
        channels: 1,
        labels: [
            "gray"
        ]
    }
};
module.exports = $bd7c62960af01ee7$var$convert;
// Hide .channels and .labels properties
for (const model of Object.keys($bd7c62960af01ee7$var$convert)){
    if (!("channels" in $bd7c62960af01ee7$var$convert[model])) throw new Error("missing channels property: " + model);
    if (!("labels" in $bd7c62960af01ee7$var$convert[model])) throw new Error("missing channel labels property: " + model);
    if ($bd7c62960af01ee7$var$convert[model].labels.length !== $bd7c62960af01ee7$var$convert[model].channels) throw new Error("channel and label counts mismatch: " + model);
    const { channels: channels, labels: labels } = $bd7c62960af01ee7$var$convert[model];
    delete $bd7c62960af01ee7$var$convert[model].channels;
    delete $bd7c62960af01ee7$var$convert[model].labels;
    Object.defineProperty($bd7c62960af01ee7$var$convert[model], "channels", {
        value: channels
    });
    Object.defineProperty($bd7c62960af01ee7$var$convert[model], "labels", {
        value: labels
    });
}
$bd7c62960af01ee7$var$convert.rgb.hsl = function(rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const min = Math.min(r, g, b);
    const max = Math.max(r, g, b);
    const delta = max - min;
    let h;
    let s;
    if (max === min) h = 0;
    else if (r === max) h = (g - b) / delta;
    else if (g === max) h = 2 + (b - r) / delta;
    else if (b === max) h = 4 + (r - g) / delta;
    h = Math.min(h * 60, 360);
    if (h < 0) h += 360;
    const l = (min + max) / 2;
    if (max === min) s = 0;
    else if (l <= 0.5) s = delta / (max + min);
    else s = delta / (2 - max - min);
    return [
        h,
        s * 100,
        l * 100
    ];
};
$bd7c62960af01ee7$var$convert.rgb.hsv = function(rgb) {
    let rdif;
    let gdif;
    let bdif;
    let h;
    let s;
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const v = Math.max(r, g, b);
    const diff = v - Math.min(r, g, b);
    const diffc = function(c) {
        return (v - c) / 6 / diff + 0.5;
    };
    if (diff === 0) {
        h = 0;
        s = 0;
    } else {
        s = diff / v;
        rdif = diffc(r);
        gdif = diffc(g);
        bdif = diffc(b);
        if (r === v) h = bdif - gdif;
        else if (g === v) h = 1 / 3 + rdif - bdif;
        else if (b === v) h = 2 / 3 + gdif - rdif;
        if (h < 0) h += 1;
        else if (h > 1) h -= 1;
    }
    return [
        h * 360,
        s * 100,
        v * 100
    ];
};
$bd7c62960af01ee7$var$convert.rgb.hwb = function(rgb) {
    const r = rgb[0];
    const g = rgb[1];
    let b = rgb[2];
    const h = $bd7c62960af01ee7$var$convert.rgb.hsl(rgb)[0];
    const w = 1 / 255 * Math.min(r, Math.min(g, b));
    b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
    return [
        h,
        w * 100,
        b * 100
    ];
};
$bd7c62960af01ee7$var$convert.rgb.cmyk = function(rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const k = Math.min(1 - r, 1 - g, 1 - b);
    const c = (1 - r - k) / (1 - k) || 0;
    const m = (1 - g - k) / (1 - k) || 0;
    const y = (1 - b - k) / (1 - k) || 0;
    return [
        c * 100,
        m * 100,
        y * 100,
        k * 100
    ];
};
function $bd7c62960af01ee7$var$comparativeDistance(x, y) {
    /*
		See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance
	*/ return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
}
$bd7c62960af01ee7$var$convert.rgb.keyword = function(rgb) {
    const reversed = $bd7c62960af01ee7$var$reverseKeywords[rgb];
    if (reversed) return reversed;
    let currentClosestDistance = Infinity;
    let currentClosestKeyword;
    for (const keyword of Object.keys($7v5Iv)){
        const value = $7v5Iv[keyword];
        // Compute comparative distance
        const distance = $bd7c62960af01ee7$var$comparativeDistance(rgb, value);
        // Check if its less, if so set as closest
        if (distance < currentClosestDistance) {
            currentClosestDistance = distance;
            currentClosestKeyword = keyword;
        }
    }
    return currentClosestKeyword;
};
$bd7c62960af01ee7$var$convert.keyword.rgb = function(keyword) {
    return $7v5Iv[keyword];
};
$bd7c62960af01ee7$var$convert.rgb.xyz = function(rgb) {
    let r = rgb[0] / 255;
    let g = rgb[1] / 255;
    let b = rgb[2] / 255;
    // Assume sRGB
    r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
    g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
    b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
    const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
    const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
    const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
    return [
        x * 100,
        y * 100,
        z * 100
    ];
};
$bd7c62960af01ee7$var$convert.rgb.lab = function(rgb) {
    const xyz = $bd7c62960af01ee7$var$convert.rgb.xyz(rgb);
    let x = xyz[0];
    let y = xyz[1];
    let z = xyz[2];
    x /= 95.047;
    y /= 100;
    z /= 108.883;
    x = x > 0.008856 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
    y = y > 0.008856 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
    z = z > 0.008856 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
    const l = 116 * y - 16;
    const a = 500 * (x - y);
    const b = 200 * (y - z);
    return [
        l,
        a,
        b
    ];
};
$bd7c62960af01ee7$var$convert.hsl.rgb = function(hsl) {
    const h = hsl[0] / 360;
    const s = hsl[1] / 100;
    const l = hsl[2] / 100;
    let t2;
    let t3;
    let val;
    if (s === 0) {
        val = l * 255;
        return [
            val,
            val,
            val
        ];
    }
    if (l < 0.5) t2 = l * (1 + s);
    else t2 = l + s - l * s;
    const t1 = 2 * l - t2;
    const rgb = [
        0,
        0,
        0
    ];
    for(let i = 0; i < 3; i++){
        t3 = h + 1 / 3 * -(i - 1);
        if (t3 < 0) t3++;
        if (t3 > 1) t3--;
        if (6 * t3 < 1) val = t1 + (t2 - t1) * 6 * t3;
        else if (2 * t3 < 1) val = t2;
        else if (3 * t3 < 2) val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        else val = t1;
        rgb[i] = val * 255;
    }
    return rgb;
};
$bd7c62960af01ee7$var$convert.hsl.hsv = function(hsl) {
    const h = hsl[0];
    let s = hsl[1] / 100;
    let l = hsl[2] / 100;
    let smin = s;
    const lmin = Math.max(l, 0.01);
    l *= 2;
    s *= l <= 1 ? l : 2 - l;
    smin *= lmin <= 1 ? lmin : 2 - lmin;
    const v = (l + s) / 2;
    const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
    return [
        h,
        sv * 100,
        v * 100
    ];
};
$bd7c62960af01ee7$var$convert.hsv.rgb = function(hsv) {
    const h = hsv[0] / 60;
    const s = hsv[1] / 100;
    let v = hsv[2] / 100;
    const hi = Math.floor(h) % 6;
    const f = h - Math.floor(h);
    const p = 255 * v * (1 - s);
    const q = 255 * v * (1 - s * f);
    const t = 255 * v * (1 - s * (1 - f));
    v *= 255;
    switch(hi){
        case 0:
            return [
                v,
                t,
                p
            ];
        case 1:
            return [
                q,
                v,
                p
            ];
        case 2:
            return [
                p,
                v,
                t
            ];
        case 3:
            return [
                p,
                q,
                v
            ];
        case 4:
            return [
                t,
                p,
                v
            ];
        case 5:
            return [
                v,
                p,
                q
            ];
    }
};
$bd7c62960af01ee7$var$convert.hsv.hsl = function(hsv) {
    const h = hsv[0];
    const s = hsv[1] / 100;
    const v = hsv[2] / 100;
    const vmin = Math.max(v, 0.01);
    let sl;
    let l;
    l = (2 - s) * v;
    const lmin = (2 - s) * vmin;
    sl = s * vmin;
    sl /= lmin <= 1 ? lmin : 2 - lmin;
    sl = sl || 0;
    l /= 2;
    return [
        h,
        sl * 100,
        l * 100
    ];
};
// http://dev.w3.org/csswg/css-color/#hwb-to-rgb
$bd7c62960af01ee7$var$convert.hwb.rgb = function(hwb) {
    const h = hwb[0] / 360;
    let wh = hwb[1] / 100;
    let bl = hwb[2] / 100;
    const ratio = wh + bl;
    let f;
    // Wh + bl cant be > 1
    if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
    }
    const i = Math.floor(6 * h);
    const v = 1 - bl;
    f = 6 * h - i;
    if ((i & 0x01) !== 0) f = 1 - f;
    const n = wh + f * (v - wh); // Linear interpolation
    let r;
    let g;
    let b;
    /* eslint-disable max-statements-per-line,no-multi-spaces */ switch(i){
        default:
        case 6:
        case 0:
            r = v;
            g = n;
            b = wh;
            break;
        case 1:
            r = n;
            g = v;
            b = wh;
            break;
        case 2:
            r = wh;
            g = v;
            b = n;
            break;
        case 3:
            r = wh;
            g = n;
            b = v;
            break;
        case 4:
            r = n;
            g = wh;
            b = v;
            break;
        case 5:
            r = v;
            g = wh;
            b = n;
            break;
    }
    /* eslint-enable max-statements-per-line,no-multi-spaces */ return [
        r * 255,
        g * 255,
        b * 255
    ];
};
$bd7c62960af01ee7$var$convert.cmyk.rgb = function(cmyk) {
    const c = cmyk[0] / 100;
    const m = cmyk[1] / 100;
    const y = cmyk[2] / 100;
    const k = cmyk[3] / 100;
    const r = 1 - Math.min(1, c * (1 - k) + k);
    const g = 1 - Math.min(1, m * (1 - k) + k);
    const b = 1 - Math.min(1, y * (1 - k) + k);
    return [
        r * 255,
        g * 255,
        b * 255
    ];
};
$bd7c62960af01ee7$var$convert.xyz.rgb = function(xyz) {
    const x = xyz[0] / 100;
    const y = xyz[1] / 100;
    const z = xyz[2] / 100;
    let r;
    let g;
    let b;
    r = x * 3.2406 + y * -1.5372 + z * -0.4986;
    g = x * -0.9689 + y * 1.8758 + z * 0.0415;
    b = x * 0.0557 + y * -0.204 + z * 1.0570;
    // Assume sRGB
    r = r > 0.0031308 ? 1.055 * r ** (1.0 / 2.4) - 0.055 : r * 12.92;
    g = g > 0.0031308 ? 1.055 * g ** (1.0 / 2.4) - 0.055 : g * 12.92;
    b = b > 0.0031308 ? 1.055 * b ** (1.0 / 2.4) - 0.055 : b * 12.92;
    r = Math.min(Math.max(0, r), 1);
    g = Math.min(Math.max(0, g), 1);
    b = Math.min(Math.max(0, b), 1);
    return [
        r * 255,
        g * 255,
        b * 255
    ];
};
$bd7c62960af01ee7$var$convert.xyz.lab = function(xyz) {
    let x = xyz[0];
    let y = xyz[1];
    let z = xyz[2];
    x /= 95.047;
    y /= 100;
    z /= 108.883;
    x = x > 0.008856 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
    y = y > 0.008856 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
    z = z > 0.008856 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
    const l = 116 * y - 16;
    const a = 500 * (x - y);
    const b = 200 * (y - z);
    return [
        l,
        a,
        b
    ];
};
$bd7c62960af01ee7$var$convert.lab.xyz = function(lab) {
    const l = lab[0];
    const a = lab[1];
    const b = lab[2];
    let x;
    let y;
    let z;
    y = (l + 16) / 116;
    x = a / 500 + y;
    z = y - b / 200;
    const y2 = y ** 3;
    const x2 = x ** 3;
    const z2 = z ** 3;
    y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
    x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
    z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;
    x *= 95.047;
    y *= 100;
    z *= 108.883;
    return [
        x,
        y,
        z
    ];
};
$bd7c62960af01ee7$var$convert.lab.lch = function(lab) {
    const l = lab[0];
    const a = lab[1];
    const b = lab[2];
    let h;
    const hr = Math.atan2(b, a);
    h = hr * 360 / 2 / Math.PI;
    if (h < 0) h += 360;
    const c = Math.sqrt(a * a + b * b);
    return [
        l,
        c,
        h
    ];
};
$bd7c62960af01ee7$var$convert.lch.lab = function(lch) {
    const l = lch[0];
    const c = lch[1];
    const h = lch[2];
    const hr = h / 360 * 2 * Math.PI;
    const a = c * Math.cos(hr);
    const b = c * Math.sin(hr);
    return [
        l,
        a,
        b
    ];
};
$bd7c62960af01ee7$var$convert.rgb.ansi16 = function(args, saturation = null) {
    const [r, g, b] = args;
    let value = saturation === null ? $bd7c62960af01ee7$var$convert.rgb.hsv(args)[2] : saturation; // Hsv -> ansi16 optimization
    value = Math.round(value / 50);
    if (value === 0) return 30;
    let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
    if (value === 2) ansi += 60;
    return ansi;
};
$bd7c62960af01ee7$var$convert.hsv.ansi16 = function(args) {
    // Optimization here; we already know the value and don't need to get
    // it converted for us.
    return $bd7c62960af01ee7$var$convert.rgb.ansi16($bd7c62960af01ee7$var$convert.hsv.rgb(args), args[2]);
};
$bd7c62960af01ee7$var$convert.rgb.ansi256 = function(args) {
    const r = args[0];
    const g = args[1];
    const b = args[2];
    // We use the extended greyscale palette here, with the exception of
    // black and white. normal palette only has 4 greyscale shades.
    if (r === g && g === b) {
        if (r < 8) return 16;
        if (r > 248) return 231;
        return Math.round((r - 8) / 247 * 24) + 232;
    }
    const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
    return ansi;
};
$bd7c62960af01ee7$var$convert.ansi16.rgb = function(args) {
    let color = args % 10;
    // Handle greyscale
    if (color === 0 || color === 7) {
        if (args > 50) color += 3.5;
        color = color / 10.5 * 255;
        return [
            color,
            color,
            color
        ];
    }
    const mult = (~~(args > 50) + 1) * 0.5;
    const r = (color & 1) * mult * 255;
    const g = (color >> 1 & 1) * mult * 255;
    const b = (color >> 2 & 1) * mult * 255;
    return [
        r,
        g,
        b
    ];
};
$bd7c62960af01ee7$var$convert.ansi256.rgb = function(args) {
    // Handle greyscale
    if (args >= 232) {
        const c = (args - 232) * 10 + 8;
        return [
            c,
            c,
            c
        ];
    }
    args -= 16;
    let rem;
    const r = Math.floor(args / 36) / 5 * 255;
    const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
    const b = rem % 6 / 5 * 255;
    return [
        r,
        g,
        b
    ];
};
$bd7c62960af01ee7$var$convert.rgb.hex = function(args) {
    const integer = ((Math.round(args[0]) & 0xFF) << 16) + ((Math.round(args[1]) & 0xFF) << 8) + (Math.round(args[2]) & 0xFF);
    const string = integer.toString(16).toUpperCase();
    return "000000".substring(string.length) + string;
};
$bd7c62960af01ee7$var$convert.hex.rgb = function(args) {
    const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
    if (!match) return [
        0,
        0,
        0
    ];
    let colorString = match[0];
    if (match[0].length === 3) colorString = colorString.split("").map((char)=>{
        return char + char;
    }).join("");
    const integer = parseInt(colorString, 16);
    const r = integer >> 16 & 0xFF;
    const g = integer >> 8 & 0xFF;
    const b = integer & 0xFF;
    return [
        r,
        g,
        b
    ];
};
$bd7c62960af01ee7$var$convert.rgb.hcg = function(rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const max = Math.max(Math.max(r, g), b);
    const min = Math.min(Math.min(r, g), b);
    const chroma = max - min;
    let grayscale;
    let hue;
    if (chroma < 1) grayscale = min / (1 - chroma);
    else grayscale = 0;
    if (chroma <= 0) hue = 0;
    else if (max === r) hue = (g - b) / chroma % 6;
    else if (max === g) hue = 2 + (b - r) / chroma;
    else hue = 4 + (r - g) / chroma;
    hue /= 6;
    hue %= 1;
    return [
        hue * 360,
        chroma * 100,
        grayscale * 100
    ];
};
$bd7c62960af01ee7$var$convert.hsl.hcg = function(hsl) {
    const s = hsl[1] / 100;
    const l = hsl[2] / 100;
    const c = l < 0.5 ? 2.0 * s * l : 2.0 * s * (1.0 - l);
    let f = 0;
    if (c < 1.0) f = (l - 0.5 * c) / (1.0 - c);
    return [
        hsl[0],
        c * 100,
        f * 100
    ];
};
$bd7c62960af01ee7$var$convert.hsv.hcg = function(hsv) {
    const s = hsv[1] / 100;
    const v = hsv[2] / 100;
    const c = s * v;
    let f = 0;
    if (c < 1.0) f = (v - c) / (1 - c);
    return [
        hsv[0],
        c * 100,
        f * 100
    ];
};
$bd7c62960af01ee7$var$convert.hcg.rgb = function(hcg) {
    const h = hcg[0] / 360;
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    if (c === 0.0) return [
        g * 255,
        g * 255,
        g * 255
    ];
    const pure = [
        0,
        0,
        0
    ];
    const hi = h % 1 * 6;
    const v = hi % 1;
    const w = 1 - v;
    let mg = 0;
    /* eslint-disable max-statements-per-line */ switch(Math.floor(hi)){
        case 0:
            pure[0] = 1;
            pure[1] = v;
            pure[2] = 0;
            break;
        case 1:
            pure[0] = w;
            pure[1] = 1;
            pure[2] = 0;
            break;
        case 2:
            pure[0] = 0;
            pure[1] = 1;
            pure[2] = v;
            break;
        case 3:
            pure[0] = 0;
            pure[1] = w;
            pure[2] = 1;
            break;
        case 4:
            pure[0] = v;
            pure[1] = 0;
            pure[2] = 1;
            break;
        default:
            pure[0] = 1;
            pure[1] = 0;
            pure[2] = w;
    }
    /* eslint-enable max-statements-per-line */ mg = (1.0 - c) * g;
    return [
        (c * pure[0] + mg) * 255,
        (c * pure[1] + mg) * 255,
        (c * pure[2] + mg) * 255
    ];
};
$bd7c62960af01ee7$var$convert.hcg.hsv = function(hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const v = c + g * (1.0 - c);
    let f = 0;
    if (v > 0.0) f = c / v;
    return [
        hcg[0],
        f * 100,
        v * 100
    ];
};
$bd7c62960af01ee7$var$convert.hcg.hsl = function(hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const l = g * (1.0 - c) + 0.5 * c;
    let s = 0;
    if (l > 0.0 && l < 0.5) s = c / (2 * l);
    else if (l >= 0.5 && l < 1.0) s = c / (2 * (1 - l));
    return [
        hcg[0],
        s * 100,
        l * 100
    ];
};
$bd7c62960af01ee7$var$convert.hcg.hwb = function(hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const v = c + g * (1.0 - c);
    return [
        hcg[0],
        (v - c) * 100,
        (1 - v) * 100
    ];
};
$bd7c62960af01ee7$var$convert.hwb.hcg = function(hwb) {
    const w = hwb[1] / 100;
    const b = hwb[2] / 100;
    const v = 1 - b;
    const c = v - w;
    let g = 0;
    if (c < 1) g = (v - c) / (1 - c);
    return [
        hwb[0],
        c * 100,
        g * 100
    ];
};
$bd7c62960af01ee7$var$convert.apple.rgb = function(apple) {
    return [
        apple[0] / 65535 * 255,
        apple[1] / 65535 * 255,
        apple[2] / 65535 * 255
    ];
};
$bd7c62960af01ee7$var$convert.rgb.apple = function(rgb) {
    return [
        rgb[0] / 255 * 65535,
        rgb[1] / 255 * 65535,
        rgb[2] / 255 * 65535
    ];
};
$bd7c62960af01ee7$var$convert.gray.rgb = function(args) {
    return [
        args[0] / 100 * 255,
        args[0] / 100 * 255,
        args[0] / 100 * 255
    ];
};
$bd7c62960af01ee7$var$convert.gray.hsl = function(args) {
    return [
        0,
        0,
        args[0]
    ];
};
$bd7c62960af01ee7$var$convert.gray.hsv = $bd7c62960af01ee7$var$convert.gray.hsl;
$bd7c62960af01ee7$var$convert.gray.hwb = function(gray) {
    return [
        0,
        100,
        gray[0]
    ];
};
$bd7c62960af01ee7$var$convert.gray.cmyk = function(gray) {
    return [
        0,
        0,
        0,
        gray[0]
    ];
};
$bd7c62960af01ee7$var$convert.gray.lab = function(gray) {
    return [
        gray[0],
        0,
        0
    ];
};
$bd7c62960af01ee7$var$convert.gray.hex = function(gray) {
    const val = Math.round(gray[0] / 100 * 255) & 0xFF;
    const integer = (val << 16) + (val << 8) + val;
    const string = integer.toString(16).toUpperCase();
    return "000000".substring(string.length) + string;
};
$bd7c62960af01ee7$var$convert.rgb.gray = function(rgb) {
    const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
    return [
        val / 255 * 100
    ];
};

});
parcelRegister("7v5Iv", function(module, exports) {
"use strict";
module.exports = {
    "aliceblue": [
        240,
        248,
        255
    ],
    "antiquewhite": [
        250,
        235,
        215
    ],
    "aqua": [
        0,
        255,
        255
    ],
    "aquamarine": [
        127,
        255,
        212
    ],
    "azure": [
        240,
        255,
        255
    ],
    "beige": [
        245,
        245,
        220
    ],
    "bisque": [
        255,
        228,
        196
    ],
    "black": [
        0,
        0,
        0
    ],
    "blanchedalmond": [
        255,
        235,
        205
    ],
    "blue": [
        0,
        0,
        255
    ],
    "blueviolet": [
        138,
        43,
        226
    ],
    "brown": [
        165,
        42,
        42
    ],
    "burlywood": [
        222,
        184,
        135
    ],
    "cadetblue": [
        95,
        158,
        160
    ],
    "chartreuse": [
        127,
        255,
        0
    ],
    "chocolate": [
        210,
        105,
        30
    ],
    "coral": [
        255,
        127,
        80
    ],
    "cornflowerblue": [
        100,
        149,
        237
    ],
    "cornsilk": [
        255,
        248,
        220
    ],
    "crimson": [
        220,
        20,
        60
    ],
    "cyan": [
        0,
        255,
        255
    ],
    "darkblue": [
        0,
        0,
        139
    ],
    "darkcyan": [
        0,
        139,
        139
    ],
    "darkgoldenrod": [
        184,
        134,
        11
    ],
    "darkgray": [
        169,
        169,
        169
    ],
    "darkgreen": [
        0,
        100,
        0
    ],
    "darkgrey": [
        169,
        169,
        169
    ],
    "darkkhaki": [
        189,
        183,
        107
    ],
    "darkmagenta": [
        139,
        0,
        139
    ],
    "darkolivegreen": [
        85,
        107,
        47
    ],
    "darkorange": [
        255,
        140,
        0
    ],
    "darkorchid": [
        153,
        50,
        204
    ],
    "darkred": [
        139,
        0,
        0
    ],
    "darksalmon": [
        233,
        150,
        122
    ],
    "darkseagreen": [
        143,
        188,
        143
    ],
    "darkslateblue": [
        72,
        61,
        139
    ],
    "darkslategray": [
        47,
        79,
        79
    ],
    "darkslategrey": [
        47,
        79,
        79
    ],
    "darkturquoise": [
        0,
        206,
        209
    ],
    "darkviolet": [
        148,
        0,
        211
    ],
    "deeppink": [
        255,
        20,
        147
    ],
    "deepskyblue": [
        0,
        191,
        255
    ],
    "dimgray": [
        105,
        105,
        105
    ],
    "dimgrey": [
        105,
        105,
        105
    ],
    "dodgerblue": [
        30,
        144,
        255
    ],
    "firebrick": [
        178,
        34,
        34
    ],
    "floralwhite": [
        255,
        250,
        240
    ],
    "forestgreen": [
        34,
        139,
        34
    ],
    "fuchsia": [
        255,
        0,
        255
    ],
    "gainsboro": [
        220,
        220,
        220
    ],
    "ghostwhite": [
        248,
        248,
        255
    ],
    "gold": [
        255,
        215,
        0
    ],
    "goldenrod": [
        218,
        165,
        32
    ],
    "gray": [
        128,
        128,
        128
    ],
    "green": [
        0,
        128,
        0
    ],
    "greenyellow": [
        173,
        255,
        47
    ],
    "grey": [
        128,
        128,
        128
    ],
    "honeydew": [
        240,
        255,
        240
    ],
    "hotpink": [
        255,
        105,
        180
    ],
    "indianred": [
        205,
        92,
        92
    ],
    "indigo": [
        75,
        0,
        130
    ],
    "ivory": [
        255,
        255,
        240
    ],
    "khaki": [
        240,
        230,
        140
    ],
    "lavender": [
        230,
        230,
        250
    ],
    "lavenderblush": [
        255,
        240,
        245
    ],
    "lawngreen": [
        124,
        252,
        0
    ],
    "lemonchiffon": [
        255,
        250,
        205
    ],
    "lightblue": [
        173,
        216,
        230
    ],
    "lightcoral": [
        240,
        128,
        128
    ],
    "lightcyan": [
        224,
        255,
        255
    ],
    "lightgoldenrodyellow": [
        250,
        250,
        210
    ],
    "lightgray": [
        211,
        211,
        211
    ],
    "lightgreen": [
        144,
        238,
        144
    ],
    "lightgrey": [
        211,
        211,
        211
    ],
    "lightpink": [
        255,
        182,
        193
    ],
    "lightsalmon": [
        255,
        160,
        122
    ],
    "lightseagreen": [
        32,
        178,
        170
    ],
    "lightskyblue": [
        135,
        206,
        250
    ],
    "lightslategray": [
        119,
        136,
        153
    ],
    "lightslategrey": [
        119,
        136,
        153
    ],
    "lightsteelblue": [
        176,
        196,
        222
    ],
    "lightyellow": [
        255,
        255,
        224
    ],
    "lime": [
        0,
        255,
        0
    ],
    "limegreen": [
        50,
        205,
        50
    ],
    "linen": [
        250,
        240,
        230
    ],
    "magenta": [
        255,
        0,
        255
    ],
    "maroon": [
        128,
        0,
        0
    ],
    "mediumaquamarine": [
        102,
        205,
        170
    ],
    "mediumblue": [
        0,
        0,
        205
    ],
    "mediumorchid": [
        186,
        85,
        211
    ],
    "mediumpurple": [
        147,
        112,
        219
    ],
    "mediumseagreen": [
        60,
        179,
        113
    ],
    "mediumslateblue": [
        123,
        104,
        238
    ],
    "mediumspringgreen": [
        0,
        250,
        154
    ],
    "mediumturquoise": [
        72,
        209,
        204
    ],
    "mediumvioletred": [
        199,
        21,
        133
    ],
    "midnightblue": [
        25,
        25,
        112
    ],
    "mintcream": [
        245,
        255,
        250
    ],
    "mistyrose": [
        255,
        228,
        225
    ],
    "moccasin": [
        255,
        228,
        181
    ],
    "navajowhite": [
        255,
        222,
        173
    ],
    "navy": [
        0,
        0,
        128
    ],
    "oldlace": [
        253,
        245,
        230
    ],
    "olive": [
        128,
        128,
        0
    ],
    "olivedrab": [
        107,
        142,
        35
    ],
    "orange": [
        255,
        165,
        0
    ],
    "orangered": [
        255,
        69,
        0
    ],
    "orchid": [
        218,
        112,
        214
    ],
    "palegoldenrod": [
        238,
        232,
        170
    ],
    "palegreen": [
        152,
        251,
        152
    ],
    "paleturquoise": [
        175,
        238,
        238
    ],
    "palevioletred": [
        219,
        112,
        147
    ],
    "papayawhip": [
        255,
        239,
        213
    ],
    "peachpuff": [
        255,
        218,
        185
    ],
    "peru": [
        205,
        133,
        63
    ],
    "pink": [
        255,
        192,
        203
    ],
    "plum": [
        221,
        160,
        221
    ],
    "powderblue": [
        176,
        224,
        230
    ],
    "purple": [
        128,
        0,
        128
    ],
    "rebeccapurple": [
        102,
        51,
        153
    ],
    "red": [
        255,
        0,
        0
    ],
    "rosybrown": [
        188,
        143,
        143
    ],
    "royalblue": [
        65,
        105,
        225
    ],
    "saddlebrown": [
        139,
        69,
        19
    ],
    "salmon": [
        250,
        128,
        114
    ],
    "sandybrown": [
        244,
        164,
        96
    ],
    "seagreen": [
        46,
        139,
        87
    ],
    "seashell": [
        255,
        245,
        238
    ],
    "sienna": [
        160,
        82,
        45
    ],
    "silver": [
        192,
        192,
        192
    ],
    "skyblue": [
        135,
        206,
        235
    ],
    "slateblue": [
        106,
        90,
        205
    ],
    "slategray": [
        112,
        128,
        144
    ],
    "slategrey": [
        112,
        128,
        144
    ],
    "snow": [
        255,
        250,
        250
    ],
    "springgreen": [
        0,
        255,
        127
    ],
    "steelblue": [
        70,
        130,
        180
    ],
    "tan": [
        210,
        180,
        140
    ],
    "teal": [
        0,
        128,
        128
    ],
    "thistle": [
        216,
        191,
        216
    ],
    "tomato": [
        255,
        99,
        71
    ],
    "turquoise": [
        64,
        224,
        208
    ],
    "violet": [
        238,
        130,
        238
    ],
    "wheat": [
        245,
        222,
        179
    ],
    "white": [
        255,
        255,
        255
    ],
    "whitesmoke": [
        245,
        245,
        245
    ],
    "yellow": [
        255,
        255,
        0
    ],
    "yellowgreen": [
        154,
        205,
        50
    ]
};

});


parcelRegister("21ZsB", function(module, exports) {

var $ggCZr = parcelRequire("ggCZr");
/*
	This function routes a model to all other models.

	all functions that are routed have a property `.conversion` attached
	to the returned synthetic function. This property is an array
	of strings, each with the steps in between the 'from' and 'to'
	color models (inclusive).

	conversions that are not possible simply are not included.
*/ function $17ab598276276b4b$var$buildGraph() {
    const graph = {};
    // https://jsperf.com/object-keys-vs-for-in-with-closure/3
    const models = Object.keys($ggCZr);
    for(let len = models.length, i = 0; i < len; i++)graph[models[i]] = {
        // http://jsperf.com/1-vs-infinity
        // micro-opt, but this is simple.
        distance: -1,
        parent: null
    };
    return graph;
}
// https://en.wikipedia.org/wiki/Breadth-first_search
function $17ab598276276b4b$var$deriveBFS(fromModel) {
    const graph = $17ab598276276b4b$var$buildGraph();
    const queue = [
        fromModel
    ]; // Unshift -> queue -> pop
    graph[fromModel].distance = 0;
    while(queue.length){
        const current = queue.pop();
        const adjacents = Object.keys($ggCZr[current]);
        for(let len = adjacents.length, i = 0; i < len; i++){
            const adjacent = adjacents[i];
            const node = graph[adjacent];
            if (node.distance === -1) {
                node.distance = graph[current].distance + 1;
                node.parent = current;
                queue.unshift(adjacent);
            }
        }
    }
    return graph;
}
function $17ab598276276b4b$var$link(from, to) {
    return function(args) {
        return to(from(args));
    };
}
function $17ab598276276b4b$var$wrapConversion(toModel, graph) {
    const path = [
        graph[toModel].parent,
        toModel
    ];
    let fn = $ggCZr[graph[toModel].parent][toModel];
    let cur = graph[toModel].parent;
    while(graph[cur].parent){
        path.unshift(graph[cur].parent);
        fn = $17ab598276276b4b$var$link($ggCZr[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
    }
    fn.conversion = path;
    return fn;
}
module.exports = function(fromModel) {
    const graph = $17ab598276276b4b$var$deriveBFS(fromModel);
    const conversion = {};
    const models = Object.keys(graph);
    for(let len = models.length, i = 0; i < len; i++){
        const toModel = models[i];
        const node = graph[toModel];
        if (node.parent === null) continue;
        conversion[toModel] = $17ab598276276b4b$var$wrapConversion(toModel, graph);
    }
    return conversion;
};

});



parcelRegister("kuMYa", function(module, exports) {
"use strict";
const $eebc984dd8652ef2$var$TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
const $eebc984dd8652ef2$var$STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
const $eebc984dd8652ef2$var$STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
const $eebc984dd8652ef2$var$ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi;
const $eebc984dd8652ef2$var$ESCAPES = new Map([
    [
        "n",
        "\n"
    ],
    [
        "r",
        "\r"
    ],
    [
        "t",
        "	"
    ],
    [
        "b",
        "\b"
    ],
    [
        "f",
        "\f"
    ],
    [
        "v",
        "\v"
    ],
    [
        "0",
        "\0"
    ],
    [
        "\\",
        "\\"
    ],
    [
        "e",
        "\x1b"
    ],
    [
        "a",
        "\x07"
    ]
]);
function $eebc984dd8652ef2$var$unescape(c) {
    const u = c[0] === "u";
    const bracket = c[1] === "{";
    if (u && !bracket && c.length === 5 || c[0] === "x" && c.length === 3) return String.fromCharCode(parseInt(c.slice(1), 16));
    if (u && bracket) return String.fromCodePoint(parseInt(c.slice(2, -1), 16));
    return $eebc984dd8652ef2$var$ESCAPES.get(c) || c;
}
function $eebc984dd8652ef2$var$parseArguments(name, arguments_) {
    const results = [];
    const chunks = arguments_.trim().split(/\s*,\s*/g);
    let matches;
    for (const chunk of chunks){
        const number = Number(chunk);
        if (!Number.isNaN(number)) results.push(number);
        else if (matches = chunk.match($eebc984dd8652ef2$var$STRING_REGEX)) results.push(matches[2].replace($eebc984dd8652ef2$var$ESCAPE_REGEX, (m, escape, character)=>escape ? $eebc984dd8652ef2$var$unescape(escape) : character));
        else throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
    }
    return results;
}
function $eebc984dd8652ef2$var$parseStyle(style) {
    $eebc984dd8652ef2$var$STYLE_REGEX.lastIndex = 0;
    const results = [];
    let matches;
    while((matches = $eebc984dd8652ef2$var$STYLE_REGEX.exec(style)) !== null){
        const name = matches[1];
        if (matches[2]) {
            const args = $eebc984dd8652ef2$var$parseArguments(name, matches[2]);
            results.push([
                name
            ].concat(args));
        } else results.push([
            name
        ]);
    }
    return results;
}
function $eebc984dd8652ef2$var$buildStyle(chalk, styles) {
    const enabled = {};
    for (const layer of styles)for (const style of layer.styles)enabled[style[0]] = layer.inverse ? null : style.slice(1);
    let current = chalk;
    for (const [styleName, styles] of Object.entries(enabled)){
        if (!Array.isArray(styles)) continue;
        if (!(styleName in current)) throw new Error(`Unknown Chalk style: ${styleName}`);
        current = styles.length > 0 ? current[styleName](...styles) : current[styleName];
    }
    return current;
}
module.exports = (chalk, temporary)=>{
    const styles = [];
    const chunks = [];
    let chunk = [];
    // eslint-disable-next-line max-params
    temporary.replace($eebc984dd8652ef2$var$TEMPLATE_REGEX, (m, escapeCharacter, inverse, style, close, character)=>{
        if (escapeCharacter) chunk.push($eebc984dd8652ef2$var$unescape(escapeCharacter));
        else if (style) {
            const string = chunk.join("");
            chunk = [];
            chunks.push(styles.length === 0 ? string : $eebc984dd8652ef2$var$buildStyle(chalk, styles)(string));
            styles.push({
                inverse: inverse,
                styles: $eebc984dd8652ef2$var$parseStyle(style)
            });
        } else if (close) {
            if (styles.length === 0) throw new Error("Found extraneous } in Chalk template literal");
            chunks.push($eebc984dd8652ef2$var$buildStyle(chalk, styles)(chunk.join("")));
            chunk = [];
            styles.pop();
        } else chunk.push(character);
    });
    chunks.push(chunk.join(""));
    if (styles.length > 0) {
        const errMessage = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\`}\`)`;
        throw new Error(errMessage);
    }
    return chunks.join("");
};

});

parcelRegister("9FTVY", function(module, exports) {
module.exports = `
<!-- 
    MDSvex comes in handy here because it takes frontmatter and shoves it into the metadata object.
    This means that all we need to do is build out the expected page metadata
-->
<!-- Show title as h1 if defined, and not hidden -->
{#if typeof metadata !== "undefined" && (metadata.title || metadata.og?.title) && metadata.hide_title !== true}
<h1 class="title">{metadata.title ?? metadata.og?.title}</h1>
{/if}
<svelte:head>
<!-- Title has a default case; so we need to handle it in a special way -->
{#if typeof metadata !== "undefined" && (metadata.title || metadata.og?.title)}
<title>{metadata.title ?? metadata.og?.title}</title>
<meta property="og:title" content={metadata.og?.title ?? metadata.title} />
<meta name="twitter:title" content={metadata.og?.title ?? metadata.title} />
{:else}
<!-- EITHER there is no metadata, or there is no specified style -->
<title>Evidence</title>
{/if}

<!-- default twitter cardtags -->
<meta name="twitter:card" content="summary" />
<meta name="twitter:site" content="@evidence_dev" />

{#if typeof metadata === "object"}
{#if metadata.description || metadata.og?.description}
  <meta
    name="description"
    content={metadata.description ?? metadata.og?.description}
  />
  <meta
    property="og:description"
    content={metadata.og?.description ?? metadata.description}
  />
  <meta
    name="twitter:description"
    content={metadata.og?.description ?? metadata.description}
  />
{/if}
{#if metadata.og?.image}
  <meta property="og:image" content={addBasePath(metadata.og?.image)} />
  <meta name="twitter:image" content={addBasePath(metadata.og?.image)} />
{/if}
{/if}
</svelte:head>
`;

});

parcelRegister("gZwsz", function(module, exports) {

var $QOi1y = parcelRequire("QOi1y");
module.exports = $c5eb85b458a076f1$var$BananaSlug;
const $c5eb85b458a076f1$var$own = Object.hasOwnProperty;
function $c5eb85b458a076f1$var$BananaSlug() {
    const self = this;
    if (!(self instanceof $c5eb85b458a076f1$var$BananaSlug)) return new $c5eb85b458a076f1$var$BananaSlug();
    self.reset();
}
/**
 * Generate a unique slug.
 * @param  {string} value String of text to slugify
 * @param  {boolean} [false] Keep the current case, otherwise make all lowercase
 * @return {string}       A unique slug string
 */ $c5eb85b458a076f1$var$BananaSlug.prototype.slug = function(value, maintainCase) {
    const self = this;
    let slug = $c5eb85b458a076f1$var$slugger(value, maintainCase === true);
    const originalSlug = slug;
    while($c5eb85b458a076f1$var$own.call(self.occurrences, slug)){
        self.occurrences[originalSlug]++;
        slug = originalSlug + "-" + self.occurrences[originalSlug];
    }
    self.occurrences[slug] = 0;
    return slug;
};
/**
 * Reset - Forget all previous slugs
 * @return void
 */ $c5eb85b458a076f1$var$BananaSlug.prototype.reset = function() {
    this.occurrences = Object.create(null);
};
function $c5eb85b458a076f1$var$slugger(string, maintainCase) {
    if (typeof string !== "string") return "";
    if (!maintainCase) string = string.toLowerCase();
    return string.replace($QOi1y, "").replace(/ /g, "-");
}
$c5eb85b458a076f1$var$BananaSlug.slug = $c5eb85b458a076f1$var$slugger;

});
parcelRegister("QOi1y", function(module, exports) {
// This module is generated by `script/`.
/* eslint-disable no-control-regex, no-misleading-character-class, no-useless-escape */ module.exports = /[\0-\x1F!-,\.\/:-@\[-\^`\{-\xA9\xAB-\xB4\xB6-\xB9\xBB-\xBF\xD7\xF7\u02C2-\u02C5\u02D2-\u02DF\u02E5-\u02EB\u02ED\u02EF-\u02FF\u0375\u0378\u0379\u037E\u0380-\u0385\u0387\u038B\u038D\u03A2\u03F6\u0482\u0530\u0557\u0558\u055A-\u055F\u0589-\u0590\u05BE\u05C0\u05C3\u05C6\u05C8-\u05CF\u05EB-\u05EE\u05F3-\u060F\u061B-\u061F\u066A-\u066D\u06D4\u06DD\u06DE\u06E9\u06FD\u06FE\u0700-\u070F\u074B\u074C\u07B2-\u07BF\u07F6-\u07F9\u07FB\u07FC\u07FE\u07FF\u082E-\u083F\u085C-\u085F\u086B-\u089F\u08B5\u08C8-\u08D2\u08E2\u0964\u0965\u0970\u0984\u098D\u098E\u0991\u0992\u09A9\u09B1\u09B3-\u09B5\u09BA\u09BB\u09C5\u09C6\u09C9\u09CA\u09CF-\u09D6\u09D8-\u09DB\u09DE\u09E4\u09E5\u09F2-\u09FB\u09FD\u09FF\u0A00\u0A04\u0A0B-\u0A0E\u0A11\u0A12\u0A29\u0A31\u0A34\u0A37\u0A3A\u0A3B\u0A3D\u0A43-\u0A46\u0A49\u0A4A\u0A4E-\u0A50\u0A52-\u0A58\u0A5D\u0A5F-\u0A65\u0A76-\u0A80\u0A84\u0A8E\u0A92\u0AA9\u0AB1\u0AB4\u0ABA\u0ABB\u0AC6\u0ACA\u0ACE\u0ACF\u0AD1-\u0ADF\u0AE4\u0AE5\u0AF0-\u0AF8\u0B00\u0B04\u0B0D\u0B0E\u0B11\u0B12\u0B29\u0B31\u0B34\u0B3A\u0B3B\u0B45\u0B46\u0B49\u0B4A\u0B4E-\u0B54\u0B58-\u0B5B\u0B5E\u0B64\u0B65\u0B70\u0B72-\u0B81\u0B84\u0B8B-\u0B8D\u0B91\u0B96-\u0B98\u0B9B\u0B9D\u0BA0-\u0BA2\u0BA5-\u0BA7\u0BAB-\u0BAD\u0BBA-\u0BBD\u0BC3-\u0BC5\u0BC9\u0BCE\u0BCF\u0BD1-\u0BD6\u0BD8-\u0BE5\u0BF0-\u0BFF\u0C0D\u0C11\u0C29\u0C3A-\u0C3C\u0C45\u0C49\u0C4E-\u0C54\u0C57\u0C5B-\u0C5F\u0C64\u0C65\u0C70-\u0C7F\u0C84\u0C8D\u0C91\u0CA9\u0CB4\u0CBA\u0CBB\u0CC5\u0CC9\u0CCE-\u0CD4\u0CD7-\u0CDD\u0CDF\u0CE4\u0CE5\u0CF0\u0CF3-\u0CFF\u0D0D\u0D11\u0D45\u0D49\u0D4F-\u0D53\u0D58-\u0D5E\u0D64\u0D65\u0D70-\u0D79\u0D80\u0D84\u0D97-\u0D99\u0DB2\u0DBC\u0DBE\u0DBF\u0DC7-\u0DC9\u0DCB-\u0DCE\u0DD5\u0DD7\u0DE0-\u0DE5\u0DF0\u0DF1\u0DF4-\u0E00\u0E3B-\u0E3F\u0E4F\u0E5A-\u0E80\u0E83\u0E85\u0E8B\u0EA4\u0EA6\u0EBE\u0EBF\u0EC5\u0EC7\u0ECE\u0ECF\u0EDA\u0EDB\u0EE0-\u0EFF\u0F01-\u0F17\u0F1A-\u0F1F\u0F2A-\u0F34\u0F36\u0F38\u0F3A-\u0F3D\u0F48\u0F6D-\u0F70\u0F85\u0F98\u0FBD-\u0FC5\u0FC7-\u0FFF\u104A-\u104F\u109E\u109F\u10C6\u10C8-\u10CC\u10CE\u10CF\u10FB\u1249\u124E\u124F\u1257\u1259\u125E\u125F\u1289\u128E\u128F\u12B1\u12B6\u12B7\u12BF\u12C1\u12C6\u12C7\u12D7\u1311\u1316\u1317\u135B\u135C\u1360-\u137F\u1390-\u139F\u13F6\u13F7\u13FE-\u1400\u166D\u166E\u1680\u169B-\u169F\u16EB-\u16ED\u16F9-\u16FF\u170D\u1715-\u171F\u1735-\u173F\u1754-\u175F\u176D\u1771\u1774-\u177F\u17D4-\u17D6\u17D8-\u17DB\u17DE\u17DF\u17EA-\u180A\u180E\u180F\u181A-\u181F\u1879-\u187F\u18AB-\u18AF\u18F6-\u18FF\u191F\u192C-\u192F\u193C-\u1945\u196E\u196F\u1975-\u197F\u19AC-\u19AF\u19CA-\u19CF\u19DA-\u19FF\u1A1C-\u1A1F\u1A5F\u1A7D\u1A7E\u1A8A-\u1A8F\u1A9A-\u1AA6\u1AA8-\u1AAF\u1AC1-\u1AFF\u1B4C-\u1B4F\u1B5A-\u1B6A\u1B74-\u1B7F\u1BF4-\u1BFF\u1C38-\u1C3F\u1C4A-\u1C4C\u1C7E\u1C7F\u1C89-\u1C8F\u1CBB\u1CBC\u1CC0-\u1CCF\u1CD3\u1CFB-\u1CFF\u1DFA\u1F16\u1F17\u1F1E\u1F1F\u1F46\u1F47\u1F4E\u1F4F\u1F58\u1F5A\u1F5C\u1F5E\u1F7E\u1F7F\u1FB5\u1FBD\u1FBF-\u1FC1\u1FC5\u1FCD-\u1FCF\u1FD4\u1FD5\u1FDC-\u1FDF\u1FED-\u1FF1\u1FF5\u1FFD-\u203E\u2041-\u2053\u2055-\u2070\u2072-\u207E\u2080-\u208F\u209D-\u20CF\u20F1-\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u2140-\u2144\u214A-\u214D\u214F-\u215F\u2189-\u24B5\u24EA-\u2BFF\u2C2F\u2C5F\u2CE5-\u2CEA\u2CF4-\u2CFF\u2D26\u2D28-\u2D2C\u2D2E\u2D2F\u2D68-\u2D6E\u2D70-\u2D7E\u2D97-\u2D9F\u2DA7\u2DAF\u2DB7\u2DBF\u2DC7\u2DCF\u2DD7\u2DDF\u2E00-\u2E2E\u2E30-\u3004\u3008-\u3020\u3030\u3036\u3037\u303D-\u3040\u3097\u3098\u309B\u309C\u30A0\u30FB\u3100-\u3104\u3130\u318F-\u319F\u31C0-\u31EF\u3200-\u33FF\u4DC0-\u4DFF\u9FFD-\u9FFF\uA48D-\uA4CF\uA4FE\uA4FF\uA60D-\uA60F\uA62C-\uA63F\uA673\uA67E\uA6F2-\uA716\uA720\uA721\uA789\uA78A\uA7C0\uA7C1\uA7CB-\uA7F4\uA828-\uA82B\uA82D-\uA83F\uA874-\uA87F\uA8C6-\uA8CF\uA8DA-\uA8DF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA954-\uA95F\uA97D-\uA97F\uA9C1-\uA9CE\uA9DA-\uA9DF\uA9FF\uAA37-\uAA3F\uAA4E\uAA4F\uAA5A-\uAA5F\uAA77-\uAA79\uAAC3-\uAADA\uAADE\uAADF\uAAF0\uAAF1\uAAF7-\uAB00\uAB07\uAB08\uAB0F\uAB10\uAB17-\uAB1F\uAB27\uAB2F\uAB5B\uAB6A-\uAB6F\uABEB\uABEE\uABEF\uABFA-\uABFF\uD7A4-\uD7AF\uD7C7-\uD7CA\uD7FC-\uD7FF\uE000-\uF8FF\uFA6E\uFA6F\uFADA-\uFAFF\uFB07-\uFB12\uFB18-\uFB1C\uFB29\uFB37\uFB3D\uFB3F\uFB42\uFB45\uFBB2-\uFBD2\uFD3E-\uFD4F\uFD90\uFD91\uFDC8-\uFDEF\uFDFC-\uFDFF\uFE10-\uFE1F\uFE30-\uFE32\uFE35-\uFE4C\uFE50-\uFE6F\uFE75\uFEFD-\uFF0F\uFF1A-\uFF20\uFF3B-\uFF3E\uFF40\uFF5B-\uFF65\uFFBF-\uFFC1\uFFC8\uFFC9\uFFD0\uFFD1\uFFD8\uFFD9\uFFDD-\uFFFF]|\uD800[\uDC0C\uDC27\uDC3B\uDC3E\uDC4E\uDC4F\uDC5E-\uDC7F\uDCFB-\uDD3F\uDD75-\uDDFC\uDDFE-\uDE7F\uDE9D-\uDE9F\uDED1-\uDEDF\uDEE1-\uDEFF\uDF20-\uDF2C\uDF4B-\uDF4F\uDF7B-\uDF7F\uDF9E\uDF9F\uDFC4-\uDFC7\uDFD0\uDFD6-\uDFFF]|\uD801[\uDC9E\uDC9F\uDCAA-\uDCAF\uDCD4-\uDCD7\uDCFC-\uDCFF\uDD28-\uDD2F\uDD64-\uDDFF\uDF37-\uDF3F\uDF56-\uDF5F\uDF68-\uDFFF]|\uD802[\uDC06\uDC07\uDC09\uDC36\uDC39-\uDC3B\uDC3D\uDC3E\uDC56-\uDC5F\uDC77-\uDC7F\uDC9F-\uDCDF\uDCF3\uDCF6-\uDCFF\uDD16-\uDD1F\uDD3A-\uDD7F\uDDB8-\uDDBD\uDDC0-\uDDFF\uDE04\uDE07-\uDE0B\uDE14\uDE18\uDE36\uDE37\uDE3B-\uDE3E\uDE40-\uDE5F\uDE7D-\uDE7F\uDE9D-\uDEBF\uDEC8\uDEE7-\uDEFF\uDF36-\uDF3F\uDF56-\uDF5F\uDF73-\uDF7F\uDF92-\uDFFF]|\uD803[\uDC49-\uDC7F\uDCB3-\uDCBF\uDCF3-\uDCFF\uDD28-\uDD2F\uDD3A-\uDE7F\uDEAA\uDEAD-\uDEAF\uDEB2-\uDEFF\uDF1D-\uDF26\uDF28-\uDF2F\uDF51-\uDFAF\uDFC5-\uDFDF\uDFF7-\uDFFF]|\uD804[\uDC47-\uDC65\uDC70-\uDC7E\uDCBB-\uDCCF\uDCE9-\uDCEF\uDCFA-\uDCFF\uDD35\uDD40-\uDD43\uDD48-\uDD4F\uDD74\uDD75\uDD77-\uDD7F\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDFF\uDE12\uDE38-\uDE3D\uDE3F-\uDE7F\uDE87\uDE89\uDE8E\uDE9E\uDEA9-\uDEAF\uDEEB-\uDEEF\uDEFA-\uDEFF\uDF04\uDF0D\uDF0E\uDF11\uDF12\uDF29\uDF31\uDF34\uDF3A\uDF45\uDF46\uDF49\uDF4A\uDF4E\uDF4F\uDF51-\uDF56\uDF58-\uDF5C\uDF64\uDF65\uDF6D-\uDF6F\uDF75-\uDFFF]|\uD805[\uDC4B-\uDC4F\uDC5A-\uDC5D\uDC62-\uDC7F\uDCC6\uDCC8-\uDCCF\uDCDA-\uDD7F\uDDB6\uDDB7\uDDC1-\uDDD7\uDDDE-\uDDFF\uDE41-\uDE43\uDE45-\uDE4F\uDE5A-\uDE7F\uDEB9-\uDEBF\uDECA-\uDEFF\uDF1B\uDF1C\uDF2C-\uDF2F\uDF3A-\uDFFF]|\uD806[\uDC3B-\uDC9F\uDCEA-\uDCFE\uDD07\uDD08\uDD0A\uDD0B\uDD14\uDD17\uDD36\uDD39\uDD3A\uDD44-\uDD4F\uDD5A-\uDD9F\uDDA8\uDDA9\uDDD8\uDDD9\uDDE2\uDDE5-\uDDFF\uDE3F-\uDE46\uDE48-\uDE4F\uDE9A-\uDE9C\uDE9E-\uDEBF\uDEF9-\uDFFF]|\uD807[\uDC09\uDC37\uDC41-\uDC4F\uDC5A-\uDC71\uDC90\uDC91\uDCA8\uDCB7-\uDCFF\uDD07\uDD0A\uDD37-\uDD39\uDD3B\uDD3E\uDD48-\uDD4F\uDD5A-\uDD5F\uDD66\uDD69\uDD8F\uDD92\uDD99-\uDD9F\uDDAA-\uDEDF\uDEF7-\uDFAF\uDFB1-\uDFFF]|\uD808[\uDF9A-\uDFFF]|\uD809[\uDC6F-\uDC7F\uDD44-\uDFFF]|[\uD80A\uD80B\uD80E-\uD810\uD812-\uD819\uD824-\uD82B\uD82D\uD82E\uD830-\uD833\uD837\uD839\uD83D\uD83F\uD87B-\uD87D\uD87F\uD885-\uDB3F\uDB41-\uDBFF][\uDC00-\uDFFF]|\uD80D[\uDC2F-\uDFFF]|\uD811[\uDE47-\uDFFF]|\uD81A[\uDE39-\uDE3F\uDE5F\uDE6A-\uDECF\uDEEE\uDEEF\uDEF5-\uDEFF\uDF37-\uDF3F\uDF44-\uDF4F\uDF5A-\uDF62\uDF78-\uDF7C\uDF90-\uDFFF]|\uD81B[\uDC00-\uDE3F\uDE80-\uDEFF\uDF4B-\uDF4E\uDF88-\uDF8E\uDFA0-\uDFDF\uDFE2\uDFE5-\uDFEF\uDFF2-\uDFFF]|\uD821[\uDFF8-\uDFFF]|\uD823[\uDCD6-\uDCFF\uDD09-\uDFFF]|\uD82C[\uDD1F-\uDD4F\uDD53-\uDD63\uDD68-\uDD6F\uDEFC-\uDFFF]|\uD82F[\uDC6B-\uDC6F\uDC7D-\uDC7F\uDC89-\uDC8F\uDC9A-\uDC9C\uDC9F-\uDFFF]|\uD834[\uDC00-\uDD64\uDD6A-\uDD6C\uDD73-\uDD7A\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDE41\uDE45-\uDFFF]|\uD835[\uDC55\uDC9D\uDCA0\uDCA1\uDCA3\uDCA4\uDCA7\uDCA8\uDCAD\uDCBA\uDCBC\uDCC4\uDD06\uDD0B\uDD0C\uDD15\uDD1D\uDD3A\uDD3F\uDD45\uDD47-\uDD49\uDD51\uDEA6\uDEA7\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3\uDFCC\uDFCD]|\uD836[\uDC00-\uDDFF\uDE37-\uDE3A\uDE6D-\uDE74\uDE76-\uDE83\uDE85-\uDE9A\uDEA0\uDEB0-\uDFFF]|\uD838[\uDC07\uDC19\uDC1A\uDC22\uDC25\uDC2B-\uDCFF\uDD2D-\uDD2F\uDD3E\uDD3F\uDD4A-\uDD4D\uDD4F-\uDEBF\uDEFA-\uDFFF]|\uD83A[\uDCC5-\uDCCF\uDCD7-\uDCFF\uDD4C-\uDD4F\uDD5A-\uDFFF]|\uD83B[\uDC00-\uDDFF\uDE04\uDE20\uDE23\uDE25\uDE26\uDE28\uDE33\uDE38\uDE3A\uDE3C-\uDE41\uDE43-\uDE46\uDE48\uDE4A\uDE4C\uDE50\uDE53\uDE55\uDE56\uDE58\uDE5A\uDE5C\uDE5E\uDE60\uDE63\uDE65\uDE66\uDE6B\uDE73\uDE78\uDE7D\uDE7F\uDE8A\uDE9C-\uDEA0\uDEA4\uDEAA\uDEBC-\uDFFF]|\uD83C[\uDC00-\uDD2F\uDD4A-\uDD4F\uDD6A-\uDD6F\uDD8A-\uDFFF]|\uD83E[\uDC00-\uDFEF\uDFFA-\uDFFF]|\uD869[\uDEDE-\uDEFF]|\uD86D[\uDF35-\uDF3F]|\uD86E[\uDC1E\uDC1F]|\uD873[\uDEA2-\uDEAF]|\uD87A[\uDFE1-\uDFFF]|\uD87E[\uDE1E-\uDFFF]|\uD884[\uDF4B-\uDFFF]|\uDB40[\uDC00-\uDCFF\uDDF0-\uDFFF]/g;

});


var $57a4462a49c99b67$exports = {};


var $371cbf9bf2e321d1$exports = {};
(function(global, factory) {
    factory($371cbf9bf2e321d1$exports);
})($371cbf9bf2e321d1$exports, function(exports1) {
    "use strict";
    const now = ()=>performance.now();
    /** @param {any} timings */ function collapse_timings(timings) {
        const result = {};
        timings.forEach((timing)=>{
            result[timing.label] = Object.assign({
                total: timing.end - timing.start
            }, timing.children && collapse_timings(timing.children));
        });
        return result;
    }
    class Stats {
        /**
	 * @typedef {Object} Timing
	 * @property {string} label
	 * @property {number} start
	 * @property {number} end
	 * @property {Timing[]} children
	 */ /** @type {number} */ start_time;
        /** @type {Timing} */ current_timing;
        /** @type {Timing[]} */ current_children;
        /** @type {Timing[]} */ timings;
        /** @type {Timing[]} */ stack;
        constructor(){
            this.start_time = now();
            this.stack = [];
            this.current_children = this.timings = [];
        }
        /** @param {any} label */ start(label) {
            const timing = {
                label: label,
                start: now(),
                end: null,
                children: []
            };
            this.current_children.push(timing);
            this.stack.push(timing);
            this.current_timing = timing;
            this.current_children = timing.children;
        }
        /** @param {any} label */ stop(label) {
            if (label !== this.current_timing.label) throw new Error(`Mismatched timing labels (expected ${this.current_timing.label}, got ${label})`);
            this.current_timing.end = now();
            this.stack.pop();
            this.current_timing = this.stack[this.stack.length - 1];
            this.current_children = this.current_timing ? this.current_timing.children : this.timings;
        }
        render() {
            const timings = Object.assign({
                total: now() - this.start_time
            }, collapse_timings(this.timings));
            return {
                timings: timings
            };
        }
    }
    // This file was generated. Do not modify manually!
    var astralIdentifierCodes = [
        509,
        0,
        227,
        0,
        150,
        4,
        294,
        9,
        1368,
        2,
        2,
        1,
        6,
        3,
        41,
        2,
        5,
        0,
        166,
        1,
        574,
        3,
        9,
        9,
        370,
        1,
        81,
        2,
        71,
        10,
        50,
        3,
        123,
        2,
        54,
        14,
        32,
        10,
        3,
        1,
        11,
        3,
        46,
        10,
        8,
        0,
        46,
        9,
        7,
        2,
        37,
        13,
        2,
        9,
        6,
        1,
        45,
        0,
        13,
        2,
        49,
        13,
        9,
        3,
        2,
        11,
        83,
        11,
        7,
        0,
        3,
        0,
        158,
        11,
        6,
        9,
        7,
        3,
        56,
        1,
        2,
        6,
        3,
        1,
        3,
        2,
        10,
        0,
        11,
        1,
        3,
        6,
        4,
        4,
        193,
        17,
        10,
        9,
        5,
        0,
        82,
        19,
        13,
        9,
        214,
        6,
        3,
        8,
        28,
        1,
        83,
        16,
        16,
        9,
        82,
        12,
        9,
        9,
        84,
        14,
        5,
        9,
        243,
        14,
        166,
        9,
        71,
        5,
        2,
        1,
        3,
        3,
        2,
        0,
        2,
        1,
        13,
        9,
        120,
        6,
        3,
        6,
        4,
        0,
        29,
        9,
        41,
        6,
        2,
        3,
        9,
        0,
        10,
        10,
        47,
        15,
        406,
        7,
        2,
        7,
        17,
        9,
        57,
        21,
        2,
        13,
        123,
        5,
        4,
        0,
        2,
        1,
        2,
        6,
        2,
        0,
        9,
        9,
        49,
        4,
        2,
        1,
        2,
        4,
        9,
        9,
        330,
        3,
        10,
        1,
        2,
        0,
        49,
        6,
        4,
        4,
        14,
        9,
        5351,
        0,
        7,
        14,
        13835,
        9,
        87,
        9,
        39,
        4,
        60,
        6,
        26,
        9,
        1014,
        0,
        2,
        54,
        8,
        3,
        82,
        0,
        12,
        1,
        19628,
        1,
        4706,
        45,
        3,
        22,
        543,
        4,
        4,
        5,
        9,
        7,
        3,
        6,
        31,
        3,
        149,
        2,
        1418,
        49,
        513,
        54,
        5,
        49,
        9,
        0,
        15,
        0,
        23,
        4,
        2,
        14,
        1361,
        6,
        2,
        16,
        3,
        6,
        2,
        1,
        2,
        4,
        101,
        0,
        161,
        6,
        10,
        9,
        357,
        0,
        62,
        13,
        499,
        13,
        983,
        6,
        110,
        6,
        6,
        9,
        4759,
        9,
        787719,
        239
    ];
    // This file was generated. Do not modify manually!
    var astralIdentifierStartCodes = [
        0,
        11,
        2,
        25,
        2,
        18,
        2,
        1,
        2,
        14,
        3,
        13,
        35,
        122,
        70,
        52,
        268,
        28,
        4,
        48,
        48,
        31,
        14,
        29,
        6,
        37,
        11,
        29,
        3,
        35,
        5,
        7,
        2,
        4,
        43,
        157,
        19,
        35,
        5,
        35,
        5,
        39,
        9,
        51,
        13,
        10,
        2,
        14,
        2,
        6,
        2,
        1,
        2,
        10,
        2,
        14,
        2,
        6,
        2,
        1,
        68,
        310,
        10,
        21,
        11,
        7,
        25,
        5,
        2,
        41,
        2,
        8,
        70,
        5,
        3,
        0,
        2,
        43,
        2,
        1,
        4,
        0,
        3,
        22,
        11,
        22,
        10,
        30,
        66,
        18,
        2,
        1,
        11,
        21,
        11,
        25,
        71,
        55,
        7,
        1,
        65,
        0,
        16,
        3,
        2,
        2,
        2,
        28,
        43,
        28,
        4,
        28,
        36,
        7,
        2,
        27,
        28,
        53,
        11,
        21,
        11,
        18,
        14,
        17,
        111,
        72,
        56,
        50,
        14,
        50,
        14,
        35,
        349,
        41,
        7,
        1,
        79,
        28,
        11,
        0,
        9,
        21,
        43,
        17,
        47,
        20,
        28,
        22,
        13,
        52,
        58,
        1,
        3,
        0,
        14,
        44,
        33,
        24,
        27,
        35,
        30,
        0,
        3,
        0,
        9,
        34,
        4,
        0,
        13,
        47,
        15,
        3,
        22,
        0,
        2,
        0,
        36,
        17,
        2,
        24,
        20,
        1,
        64,
        6,
        2,
        0,
        2,
        3,
        2,
        14,
        2,
        9,
        8,
        46,
        39,
        7,
        3,
        1,
        3,
        21,
        2,
        6,
        2,
        1,
        2,
        4,
        4,
        0,
        19,
        0,
        13,
        4,
        159,
        52,
        19,
        3,
        21,
        2,
        31,
        47,
        21,
        1,
        2,
        0,
        185,
        46,
        42,
        3,
        37,
        47,
        21,
        0,
        60,
        42,
        14,
        0,
        72,
        26,
        38,
        6,
        186,
        43,
        117,
        63,
        32,
        7,
        3,
        0,
        3,
        7,
        2,
        1,
        2,
        23,
        16,
        0,
        2,
        0,
        95,
        7,
        3,
        38,
        17,
        0,
        2,
        0,
        29,
        0,
        11,
        39,
        8,
        0,
        22,
        0,
        12,
        45,
        20,
        0,
        19,
        72,
        264,
        8,
        2,
        36,
        18,
        0,
        50,
        29,
        113,
        6,
        2,
        1,
        2,
        37,
        22,
        0,
        26,
        5,
        2,
        1,
        2,
        31,
        15,
        0,
        328,
        18,
        16,
        0,
        2,
        12,
        2,
        33,
        125,
        0,
        80,
        921,
        103,
        110,
        18,
        195,
        2637,
        96,
        16,
        1071,
        18,
        5,
        4026,
        582,
        8634,
        568,
        8,
        30,
        18,
        78,
        18,
        29,
        19,
        47,
        17,
        3,
        32,
        20,
        6,
        18,
        689,
        63,
        129,
        74,
        6,
        0,
        67,
        12,
        65,
        1,
        2,
        0,
        29,
        6135,
        9,
        1237,
        43,
        8,
        8936,
        3,
        2,
        6,
        2,
        1,
        2,
        290,
        16,
        0,
        30,
        2,
        3,
        0,
        15,
        3,
        9,
        395,
        2309,
        106,
        6,
        12,
        4,
        8,
        8,
        9,
        5991,
        84,
        2,
        70,
        2,
        1,
        3,
        0,
        3,
        1,
        3,
        3,
        2,
        11,
        2,
        0,
        2,
        6,
        2,
        64,
        2,
        3,
        3,
        7,
        2,
        6,
        2,
        27,
        2,
        3,
        2,
        4,
        2,
        0,
        4,
        6,
        2,
        339,
        3,
        24,
        2,
        24,
        2,
        30,
        2,
        24,
        2,
        30,
        2,
        24,
        2,
        30,
        2,
        24,
        2,
        30,
        2,
        24,
        2,
        7,
        1845,
        30,
        7,
        5,
        262,
        61,
        147,
        44,
        11,
        6,
        17,
        0,
        322,
        29,
        19,
        43,
        485,
        27,
        757,
        6,
        2,
        3,
        2,
        1,
        2,
        14,
        2,
        196,
        60,
        67,
        8,
        0,
        1205,
        3,
        2,
        26,
        2,
        1,
        2,
        0,
        3,
        0,
        2,
        9,
        2,
        3,
        2,
        0,
        2,
        0,
        7,
        0,
        5,
        0,
        2,
        0,
        2,
        0,
        2,
        2,
        2,
        1,
        2,
        0,
        3,
        0,
        2,
        0,
        2,
        0,
        2,
        0,
        2,
        0,
        2,
        1,
        2,
        0,
        3,
        3,
        2,
        6,
        2,
        3,
        2,
        3,
        2,
        0,
        2,
        9,
        2,
        16,
        6,
        2,
        2,
        4,
        2,
        16,
        4421,
        42719,
        33,
        4153,
        7,
        221,
        3,
        5761,
        15,
        7472,
        16,
        621,
        2467,
        541,
        1507,
        4938,
        6,
        4191
    ];
    // This file was generated. Do not modify manually!
    var nonASCIIidentifierChars = "\u200C\u200D\xb7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65";
    // This file was generated. Do not modify manually!
    var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
    // These are a run-length and offset encoded representation of the
    // >0xffff code points that are a valid part of identifiers. The
    // offset starts at 0x10000, and each pair of numbers represents an
    // offset to the next range, and then a size of the range.
    // Reserved word lists for various dialects of the language
    var reservedWords = {
        3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
        5: "class enum extends super const export import",
        6: "enum",
        strict: "implements interface let package private protected public static yield",
        strictBind: "eval arguments"
    };
    // And the keywords
    var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
    var keywords$1 = {
        5: ecma5AndLessKeywords,
        "5module": ecma5AndLessKeywords + " export import",
        6: ecma5AndLessKeywords + " const class extends export import super"
    };
    var keywordRelationalOperator = /^in(stanceof)?$/;
    // ## Character categories
    var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
    var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
    // This has a complexity linear to the value of the code. The
    // assumption is that looking up astral identifier characters is
    // rare.
    function isInAstralSet(code, set) {
        var pos = 0x10000;
        for(var i = 0; i < set.length; i += 2){
            pos += set[i];
            if (pos > code) return false;
            pos += set[i + 1];
            if (pos >= code) return true;
        }
        return false;
    }
    // Test whether a given character code starts an identifier.
    function isIdentifierStart(code, astral) {
        if (code < 65) return code === 36;
        if (code < 91) return true;
        if (code < 97) return code === 95;
        if (code < 123) return true;
        if (code <= 0xffff) return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
        if (astral === false) return false;
        return isInAstralSet(code, astralIdentifierStartCodes);
    }
    // Test whether a given character is part of an identifier.
    function isIdentifierChar(code, astral) {
        if (code < 48) return code === 36;
        if (code < 58) return true;
        if (code < 65) return false;
        if (code < 91) return true;
        if (code < 97) return code === 95;
        if (code < 123) return true;
        if (code <= 0xffff) return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
        if (astral === false) return false;
        return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
    }
    // ## Token types
    // The assignment of fine-grained, information-carrying type objects
    // allows the tokenizer to store the information it has about a
    // token in a way that is very cheap for the parser to look up.
    // All token type variables start with an underscore, to make them
    // easy to recognize.
    // The `beforeExpr` property is used to disambiguate between regular
    // expressions and divisions. It is set on all token types that can
    // be followed by an expression (thus, a slash after them would be a
    // regular expression).
    //
    // The `startsExpr` property is used to check if the token ends a
    // `yield` expression. It is set on all token types that either can
    // directly start an expression (like a quotation mark) or can
    // continue an expression (like the body of a string).
    //
    // `isLoop` marks a keyword as starting a loop, which is important
    // to know when parsing a label, in order to allow or disallow
    // continue jumps to that label.
    var TokenType = function TokenType(label, conf) {
        if (conf === void 0) conf = {};
        this.label = label;
        this.keyword = conf.keyword;
        this.beforeExpr = !!conf.beforeExpr;
        this.startsExpr = !!conf.startsExpr;
        this.isLoop = !!conf.isLoop;
        this.isAssign = !!conf.isAssign;
        this.prefix = !!conf.prefix;
        this.postfix = !!conf.postfix;
        this.binop = conf.binop || null;
        this.updateContext = null;
    };
    function binop(name, prec) {
        return new TokenType(name, {
            beforeExpr: true,
            binop: prec
        });
    }
    var beforeExpr = {
        beforeExpr: true
    }, startsExpr = {
        startsExpr: true
    };
    // Map keyword names to token types.
    var keywords = {};
    // Succinct definitions of keyword token types
    function kw(name, options) {
        if (options === void 0) options = {};
        options.keyword = name;
        return keywords[name] = new TokenType(name, options);
    }
    var types$1 = {
        num: new TokenType("num", startsExpr),
        regexp: new TokenType("regexp", startsExpr),
        string: new TokenType("string", startsExpr),
        name: new TokenType("name", startsExpr),
        privateId: new TokenType("privateId", startsExpr),
        eof: new TokenType("eof"),
        // Punctuation token types.
        bracketL: new TokenType("[", {
            beforeExpr: true,
            startsExpr: true
        }),
        bracketR: new TokenType("]"),
        braceL: new TokenType("{", {
            beforeExpr: true,
            startsExpr: true
        }),
        braceR: new TokenType("}"),
        parenL: new TokenType("(", {
            beforeExpr: true,
            startsExpr: true
        }),
        parenR: new TokenType(")"),
        comma: new TokenType(",", beforeExpr),
        semi: new TokenType(";", beforeExpr),
        colon: new TokenType(":", beforeExpr),
        dot: new TokenType("."),
        question: new TokenType("?", beforeExpr),
        questionDot: new TokenType("?."),
        arrow: new TokenType("=>", beforeExpr),
        template: new TokenType("template"),
        invalidTemplate: new TokenType("invalidTemplate"),
        ellipsis: new TokenType("...", beforeExpr),
        backQuote: new TokenType("`", startsExpr),
        dollarBraceL: new TokenType("${", {
            beforeExpr: true,
            startsExpr: true
        }),
        // Operators. These carry several kinds of properties to help the
        // parser use them properly (the presence of these properties is
        // what categorizes them as operators).
        //
        // `binop`, when present, specifies that this operator is a binary
        // operator, and will refer to its precedence.
        //
        // `prefix` and `postfix` mark the operator as a prefix or postfix
        // unary operator.
        //
        // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
        // binary operators with a very low precedence, that should result
        // in AssignmentExpression nodes.
        eq: new TokenType("=", {
            beforeExpr: true,
            isAssign: true
        }),
        assign: new TokenType("_=", {
            beforeExpr: true,
            isAssign: true
        }),
        incDec: new TokenType("++/--", {
            prefix: true,
            postfix: true,
            startsExpr: true
        }),
        prefix: new TokenType("!/~", {
            beforeExpr: true,
            prefix: true,
            startsExpr: true
        }),
        logicalOR: binop("||", 1),
        logicalAND: binop("&&", 2),
        bitwiseOR: binop("|", 3),
        bitwiseXOR: binop("^", 4),
        bitwiseAND: binop("&", 5),
        equality: binop("==/!=/===/!==", 6),
        relational: binop("</>/<=/>=", 7),
        bitShift: binop("<</>>/>>>", 8),
        plusMin: new TokenType("+/-", {
            beforeExpr: true,
            binop: 9,
            prefix: true,
            startsExpr: true
        }),
        modulo: binop("%", 10),
        star: binop("*", 10),
        slash: binop("/", 10),
        starstar: new TokenType("**", {
            beforeExpr: true
        }),
        coalesce: binop("??", 1),
        // Keyword token types.
        _break: kw("break"),
        _case: kw("case", beforeExpr),
        _catch: kw("catch"),
        _continue: kw("continue"),
        _debugger: kw("debugger"),
        _default: kw("default", beforeExpr),
        _do: kw("do", {
            isLoop: true,
            beforeExpr: true
        }),
        _else: kw("else", beforeExpr),
        _finally: kw("finally"),
        _for: kw("for", {
            isLoop: true
        }),
        _function: kw("function", startsExpr),
        _if: kw("if"),
        _return: kw("return", beforeExpr),
        _switch: kw("switch"),
        _throw: kw("throw", beforeExpr),
        _try: kw("try"),
        _var: kw("var"),
        _const: kw("const"),
        _while: kw("while", {
            isLoop: true
        }),
        _with: kw("with"),
        _new: kw("new", {
            beforeExpr: true,
            startsExpr: true
        }),
        _this: kw("this", startsExpr),
        _super: kw("super", startsExpr),
        _class: kw("class", startsExpr),
        _extends: kw("extends", beforeExpr),
        _export: kw("export"),
        _import: kw("import", startsExpr),
        _null: kw("null", startsExpr),
        _true: kw("true", startsExpr),
        _false: kw("false", startsExpr),
        _in: kw("in", {
            beforeExpr: true,
            binop: 7
        }),
        _instanceof: kw("instanceof", {
            beforeExpr: true,
            binop: 7
        }),
        _typeof: kw("typeof", {
            beforeExpr: true,
            prefix: true,
            startsExpr: true
        }),
        _void: kw("void", {
            beforeExpr: true,
            prefix: true,
            startsExpr: true
        }),
        _delete: kw("delete", {
            beforeExpr: true,
            prefix: true,
            startsExpr: true
        })
    };
    // Matches a whole line break (where CRLF is considered a single
    // line break). Used to count lines.
    var lineBreak = /\r\n?|\n|\u2028|\u2029/;
    var lineBreakG = new RegExp(lineBreak.source, "g");
    function isNewLine(code) {
        return code === 10 || code === 13 || code === 0x2028 || code === 0x2029;
    }
    function nextLineBreak(code, from, end) {
        if (end === void 0) end = code.length;
        for(var i = from; i < end; i++){
            var next = code.charCodeAt(i);
            if (isNewLine(next)) return i < end - 1 && next === 13 && code.charCodeAt(i + 1) === 10 ? i + 2 : i + 1;
        }
        return -1;
    }
    var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
    var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
    var ref = Object.prototype;
    var hasOwnProperty$1 = ref.hasOwnProperty;
    var toString$1 = ref.toString;
    var hasOwn = Object.hasOwn || function(obj, propName) {
        return hasOwnProperty$1.call(obj, propName);
    };
    var isArray = Array.isArray || function(obj) {
        return toString$1.call(obj) === "[object Array]";
    };
    var regexpCache = Object.create(null);
    function wordsRegexp(words) {
        return regexpCache[words] || (regexpCache[words] = new RegExp("^(?:" + words.replace(/ /g, "|") + ")$"));
    }
    function codePointToString(code) {
        // UTF-16 Decoding
        if (code <= 0xFFFF) return String.fromCharCode(code);
        code -= 0x10000;
        return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00);
    }
    var loneSurrogate = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;
    // These are used when `options.locations` is on, for the
    // `startLoc` and `endLoc` properties.
    var Position = function Position(line, col) {
        this.line = line;
        this.column = col;
    };
    Position.prototype.offset = function offset(n) {
        return new Position(this.line, this.column + n);
    };
    var SourceLocation = function SourceLocation(p, start, end) {
        this.start = start;
        this.end = end;
        if (p.sourceFile !== null) this.source = p.sourceFile;
    };
    // The `getLineInfo` function is mostly useful when the
    // `locations` option is off (for performance reasons) and you
    // want to find the line/column position for a given character
    // offset. `input` should be the code string that the offset refers
    // into.
    function getLineInfo(input, offset) {
        for(var line = 1, cur = 0;;){
            var nextBreak = nextLineBreak(input, cur, offset);
            if (nextBreak < 0) return new Position(line, offset - cur);
            ++line;
            cur = nextBreak;
        }
    }
    // A second argument must be given to configure the parser process.
    // These options are recognized (only `ecmaVersion` is required):
    var defaultOptions = {
        // `ecmaVersion` indicates the ECMAScript version to parse. Must be
        // either 3, 5, 6 (or 2015), 7 (2016), 8 (2017), 9 (2018), 10
        // (2019), 11 (2020), 12 (2021), 13 (2022), 14 (2023), or `"latest"`
        // (the latest version the library supports). This influences
        // support for strict mode, the set of reserved words, and support
        // for new syntax features.
        ecmaVersion: null,
        // `sourceType` indicates the mode the code should be parsed in.
        // Can be either `"script"` or `"module"`. This influences global
        // strict mode and parsing of `import` and `export` declarations.
        sourceType: "script",
        // `onInsertedSemicolon` can be a callback that will be called when
        // a semicolon is automatically inserted. It will be passed the
        // position of the inserted semicolon as an offset, and if
        // `locations` is enabled, it is given the location as a `{line,
        // column}` object as second argument.
        onInsertedSemicolon: null,
        // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
        // trailing commas.
        onTrailingComma: null,
        // By default, reserved words are only enforced if ecmaVersion >= 5.
        // Set `allowReserved` to a boolean value to explicitly turn this on
        // an off. When this option has the value "never", reserved words
        // and keywords can also not be used as property names.
        allowReserved: null,
        // When enabled, a return at the top level is not considered an
        // error.
        allowReturnOutsideFunction: false,
        // When enabled, import/export statements are not constrained to
        // appearing at the top of the program, and an import.meta expression
        // in a script isn't considered an error.
        allowImportExportEverywhere: false,
        // By default, await identifiers are allowed to appear at the top-level scope only if ecmaVersion >= 2022.
        // When enabled, await identifiers are allowed to appear at the top-level scope,
        // but they are still not allowed in non-async functions.
        allowAwaitOutsideFunction: null,
        // When enabled, super identifiers are not constrained to
        // appearing in methods and do not raise an error when they appear elsewhere.
        allowSuperOutsideMethod: null,
        // When enabled, hashbang directive in the beginning of file is
        // allowed and treated as a line comment. Enabled by default when
        // `ecmaVersion` >= 2023.
        allowHashBang: false,
        // By default, the parser will verify that private properties are
        // only used in places where they are valid and have been declared.
        // Set this to false to turn such checks off.
        checkPrivateFields: true,
        // When `locations` is on, `loc` properties holding objects with
        // `start` and `end` properties in `{line, column}` form (with
        // line being 1-based and column 0-based) will be attached to the
        // nodes.
        locations: false,
        // A function can be passed as `onToken` option, which will
        // cause Acorn to call that function with object in the same
        // format as tokens returned from `tokenizer().getToken()`. Note
        // that you are not allowed to call the parser from the
        // callback—that will corrupt its internal state.
        onToken: null,
        // A function can be passed as `onComment` option, which will
        // cause Acorn to call that function with `(block, text, start,
        // end)` parameters whenever a comment is skipped. `block` is a
        // boolean indicating whether this is a block (`/* */`) comment,
        // `text` is the content of the comment, and `start` and `end` are
        // character offsets that denote the start and end of the comment.
        // When the `locations` option is on, two more parameters are
        // passed, the full `{line, column}` locations of the start and
        // end of the comments. Note that you are not allowed to call the
        // parser from the callback—that will corrupt its internal state.
        // When this option has an array as value, objects representing the
        // comments are pushed to it.
        onComment: null,
        // Nodes have their start and end characters offsets recorded in
        // `start` and `end` properties (directly on the node, rather than
        // the `loc` object, which holds line/column data. To also add a
        // [semi-standardized][range] `range` property holding a `[start,
        // end]` array with the same numbers, set the `ranges` option to
        // `true`.
        //
        // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
        ranges: false,
        // It is possible to parse multiple files into a single AST by
        // passing the tree produced by parsing the first file as
        // `program` option in subsequent parses. This will add the
        // toplevel forms of the parsed file to the `Program` (top) node
        // of an existing parse tree.
        program: null,
        // When `locations` is on, you can pass this to record the source
        // file in every node's `loc` object.
        sourceFile: null,
        // This value, if given, is stored in every node, whether
        // `locations` is on or off.
        directSourceFile: null,
        // When enabled, parenthesized expressions are represented by
        // (non-standard) ParenthesizedExpression nodes
        preserveParens: false
    };
    // Interpret and default an options object
    var warnedAboutEcmaVersion = false;
    function getOptions(opts) {
        var options = {};
        for(var opt in defaultOptions)options[opt] = opts && hasOwn(opts, opt) ? opts[opt] : defaultOptions[opt];
        if (options.ecmaVersion === "latest") options.ecmaVersion = 1e8;
        else if (options.ecmaVersion == null) {
            if (!warnedAboutEcmaVersion && typeof console === "object" && console.warn) {
                warnedAboutEcmaVersion = true;
                console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.");
            }
            options.ecmaVersion = 11;
        } else if (options.ecmaVersion >= 2015) options.ecmaVersion -= 2009;
        if (options.allowReserved == null) options.allowReserved = options.ecmaVersion < 5;
        if (!opts || opts.allowHashBang == null) options.allowHashBang = options.ecmaVersion >= 14;
        if (isArray(options.onToken)) {
            var tokens = options.onToken;
            options.onToken = function(token) {
                return tokens.push(token);
            };
        }
        if (isArray(options.onComment)) options.onComment = pushComment(options, options.onComment);
        return options;
    }
    function pushComment(options, array) {
        return function(block, text, start, end, startLoc, endLoc) {
            var comment = {
                type: block ? "Block" : "Line",
                value: text,
                start: start,
                end: end
            };
            if (options.locations) comment.loc = new SourceLocation(this, startLoc, endLoc);
            if (options.ranges) comment.range = [
                start,
                end
            ];
            array.push(comment);
        };
    }
    // Each scope gets a bitset that may contain these flags
    var SCOPE_TOP = 1, SCOPE_FUNCTION = 2, SCOPE_ASYNC = 4, SCOPE_GENERATOR = 8, SCOPE_ARROW = 16, SCOPE_SIMPLE_CATCH = 32, SCOPE_SUPER = 64, SCOPE_DIRECT_SUPER = 128, SCOPE_CLASS_STATIC_BLOCK = 256, SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;
    function functionFlags(async, generator) {
        return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0);
    }
    // Used in checkLVal* and declareName to determine the type of a binding
    var BIND_NONE = 0, BIND_VAR = 1, BIND_LEXICAL = 2, BIND_FUNCTION = 3, BIND_SIMPLE_CATCH = 4, BIND_OUTSIDE = 5; // Special case for function names as bound inside the function
    var Parser$1 = function Parser(options, input, startPos) {
        this.options = options = getOptions(options);
        this.sourceFile = options.sourceFile;
        this.keywords = wordsRegexp(keywords$1[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
        var reserved = "";
        if (options.allowReserved !== true) {
            reserved = reservedWords[options.ecmaVersion >= 6 ? 6 : options.ecmaVersion === 5 ? 5 : 3];
            if (options.sourceType === "module") reserved += " await";
        }
        this.reservedWords = wordsRegexp(reserved);
        var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
        this.reservedWordsStrict = wordsRegexp(reservedStrict);
        this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
        this.input = String(input);
        // Used to signal to callers of `readWord1` whether the word
        // contained any escape sequences. This is needed because words with
        // escape sequences must not be interpreted as keywords.
        this.containsEsc = false;
        // Set up token state
        // The current position of the tokenizer in the input.
        if (startPos) {
            this.pos = startPos;
            this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
            this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
        } else {
            this.pos = this.lineStart = 0;
            this.curLine = 1;
        }
        // Properties of the current token:
        // Its type
        this.type = types$1.eof;
        // For tokens that include more information than their type, the value
        this.value = null;
        // Its start and end offset
        this.start = this.end = this.pos;
        // And, if locations are used, the {line, column} object
        // corresponding to those offsets
        this.startLoc = this.endLoc = this.curPosition();
        // Position information for the previous token
        this.lastTokEndLoc = this.lastTokStartLoc = null;
        this.lastTokStart = this.lastTokEnd = this.pos;
        // The context stack is used to superficially track syntactic
        // context to predict whether a regular expression is allowed in a
        // given position.
        this.context = this.initialContext();
        this.exprAllowed = true;
        // Figure out if it's a module code.
        this.inModule = options.sourceType === "module";
        this.strict = this.inModule || this.strictDirective(this.pos);
        // Used to signify the start of a potential arrow function
        this.potentialArrowAt = -1;
        this.potentialArrowInForAwait = false;
        // Positions to delayed-check that yield/await does not exist in default parameters.
        this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
        // Labels in scope.
        this.labels = [];
        // Thus-far undefined exports.
        this.undefinedExports = Object.create(null);
        // If enabled, skip leading hashbang line.
        if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!") this.skipLineComment(2);
        // Scope tracking for duplicate variable names (see scope.js)
        this.scopeStack = [];
        this.enterScope(SCOPE_TOP);
        // For RegExp validation
        this.regexpState = null;
        // The stack of private names.
        // Each element has two properties: 'declared' and 'used'.
        // When it exited from the outermost class definition, all used private names must be declared.
        this.privateNameStack = [];
    };
    var prototypeAccessors = {
        inFunction: {
            configurable: true
        },
        inGenerator: {
            configurable: true
        },
        inAsync: {
            configurable: true
        },
        canAwait: {
            configurable: true
        },
        allowSuper: {
            configurable: true
        },
        allowDirectSuper: {
            configurable: true
        },
        treatFunctionsAsVar: {
            configurable: true
        },
        allowNewDotTarget: {
            configurable: true
        },
        inClassStaticBlock: {
            configurable: true
        }
    };
    Parser$1.prototype.parse = function parse() {
        var node = this.options.program || this.startNode();
        this.nextToken();
        return this.parseTopLevel(node);
    };
    prototypeAccessors.inFunction.get = function() {
        return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;
    };
    prototypeAccessors.inGenerator.get = function() {
        return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 && !this.currentVarScope().inClassFieldInit;
    };
    prototypeAccessors.inAsync.get = function() {
        return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 && !this.currentVarScope().inClassFieldInit;
    };
    prototypeAccessors.canAwait.get = function() {
        for(var i = this.scopeStack.length - 1; i >= 0; i--){
            var scope = this.scopeStack[i];
            if (scope.inClassFieldInit || scope.flags & SCOPE_CLASS_STATIC_BLOCK) return false;
            if (scope.flags & SCOPE_FUNCTION) return (scope.flags & SCOPE_ASYNC) > 0;
        }
        return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
    };
    prototypeAccessors.allowSuper.get = function() {
        var ref = this.currentThisScope();
        var flags = ref.flags;
        var inClassFieldInit = ref.inClassFieldInit;
        return (flags & SCOPE_SUPER) > 0 || inClassFieldInit || this.options.allowSuperOutsideMethod;
    };
    prototypeAccessors.allowDirectSuper.get = function() {
        return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;
    };
    prototypeAccessors.treatFunctionsAsVar.get = function() {
        return this.treatFunctionsAsVarInScope(this.currentScope());
    };
    prototypeAccessors.allowNewDotTarget.get = function() {
        var ref = this.currentThisScope();
        var flags = ref.flags;
        var inClassFieldInit = ref.inClassFieldInit;
        return (flags & (SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK)) > 0 || inClassFieldInit;
    };
    prototypeAccessors.inClassStaticBlock.get = function() {
        return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0;
    };
    Parser$1.extend = function extend() {
        var plugins = [], len = arguments.length;
        while(len--)plugins[len] = arguments[len];
        var cls = this;
        for(var i = 0; i < plugins.length; i++)cls = plugins[i](cls);
        return cls;
    };
    Parser$1.parse = function parse(input, options) {
        return new this(options, input).parse();
    };
    Parser$1.parseExpressionAt = function parseExpressionAt(input, pos, options) {
        var parser = new this(options, input, pos);
        parser.nextToken();
        return parser.parseExpression();
    };
    Parser$1.tokenizer = function tokenizer(input, options) {
        return new this(options, input);
    };
    Object.defineProperties(Parser$1.prototype, prototypeAccessors);
    var pp$9 = Parser$1.prototype;
    // ## Parser utilities
    var literal = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;
    pp$9.strictDirective = function(start) {
        if (this.options.ecmaVersion < 5) return false;
        for(;;){
            // Try to find string literal.
            skipWhiteSpace.lastIndex = start;
            start += skipWhiteSpace.exec(this.input)[0].length;
            var match = literal.exec(this.input.slice(start));
            if (!match) return false;
            if ((match[1] || match[2]) === "use strict") {
                skipWhiteSpace.lastIndex = start + match[0].length;
                var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
                var next = this.input.charAt(end);
                return next === ";" || next === "}" || lineBreak.test(spaceAfter[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end + 1) === "=");
            }
            start += match[0].length;
            // Skip semicolon, if any.
            skipWhiteSpace.lastIndex = start;
            start += skipWhiteSpace.exec(this.input)[0].length;
            if (this.input[start] === ";") start++;
        }
    };
    // Predicate that tests whether the next token is of the given
    // type, and if yes, consumes it as a side effect.
    pp$9.eat = function(type) {
        if (this.type === type) {
            this.next();
            return true;
        } else return false;
    };
    // Tests whether parsed token is a contextual keyword.
    pp$9.isContextual = function(name) {
        return this.type === types$1.name && this.value === name && !this.containsEsc;
    };
    // Consumes contextual keyword if possible.
    pp$9.eatContextual = function(name) {
        if (!this.isContextual(name)) return false;
        this.next();
        return true;
    };
    // Asserts that following token is given contextual keyword.
    pp$9.expectContextual = function(name) {
        if (!this.eatContextual(name)) this.unexpected();
    };
    // Test whether a semicolon can be inserted at the current position.
    pp$9.canInsertSemicolon = function() {
        return this.type === types$1.eof || this.type === types$1.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
    };
    pp$9.insertSemicolon = function() {
        if (this.canInsertSemicolon()) {
            if (this.options.onInsertedSemicolon) this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
            return true;
        }
    };
    // Consume a semicolon, or, failing that, see if we are allowed to
    // pretend that there is a semicolon at this position.
    pp$9.semicolon = function() {
        if (!this.eat(types$1.semi) && !this.insertSemicolon()) this.unexpected();
    };
    pp$9.afterTrailingComma = function(tokType, notNext) {
        if (this.type === tokType) {
            if (this.options.onTrailingComma) this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
            if (!notNext) this.next();
            return true;
        }
    };
    // Expect a token of a given type. If found, consume it, otherwise,
    // raise an unexpected token error.
    pp$9.expect = function(type) {
        this.eat(type) || this.unexpected();
    };
    // Raise an unexpected token error.
    pp$9.unexpected = function(pos) {
        this.raise(pos != null ? pos : this.start, "Unexpected token");
    };
    var DestructuringErrors = function DestructuringErrors() {
        this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
    };
    pp$9.checkPatternErrors = function(refDestructuringErrors, isAssign) {
        if (!refDestructuringErrors) return;
        if (refDestructuringErrors.trailingComma > -1) this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element");
        var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
        if (parens > -1) this.raiseRecoverable(parens, isAssign ? "Assigning to rvalue" : "Parenthesized pattern");
    };
    pp$9.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
        if (!refDestructuringErrors) return false;
        var shorthandAssign = refDestructuringErrors.shorthandAssign;
        var doubleProto = refDestructuringErrors.doubleProto;
        if (!andThrow) return shorthandAssign >= 0 || doubleProto >= 0;
        if (shorthandAssign >= 0) this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns");
        if (doubleProto >= 0) this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property");
    };
    pp$9.checkYieldAwaitInDefaultParams = function() {
        if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) this.raise(this.yieldPos, "Yield expression cannot be a default value");
        if (this.awaitPos) this.raise(this.awaitPos, "Await expression cannot be a default value");
    };
    pp$9.isSimpleAssignTarget = function(expr) {
        if (expr.type === "ParenthesizedExpression") return this.isSimpleAssignTarget(expr.expression);
        return expr.type === "Identifier" || expr.type === "MemberExpression";
    };
    var pp$8 = Parser$1.prototype;
    // ### Statement parsing
    // Parse a program. Initializes the parser, reads any number of
    // statements, and wraps them in a Program node.  Optionally takes a
    // `program` argument.  If present, the statements will be appended
    // to its body instead of creating a new node.
    pp$8.parseTopLevel = function(node) {
        var exports1 = Object.create(null);
        if (!node.body) node.body = [];
        while(this.type !== types$1.eof){
            var stmt = this.parseStatement(null, true, exports1);
            node.body.push(stmt);
        }
        if (this.inModule) for(var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1){
            var name = list[i];
            this.raiseRecoverable(this.undefinedExports[name].start, "Export '" + name + "' is not defined");
        }
        this.adaptDirectivePrologue(node.body);
        this.next();
        node.sourceType = this.options.sourceType;
        return this.finishNode(node, "Program");
    };
    var loopLabel = {
        kind: "loop"
    }, switchLabel = {
        kind: "switch"
    };
    pp$8.isLet = function(context) {
        if (this.options.ecmaVersion < 6 || !this.isContextual("let")) return false;
        skipWhiteSpace.lastIndex = this.pos;
        var skip = skipWhiteSpace.exec(this.input);
        var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
        // For ambiguous cases, determine if a LexicalDeclaration (or only a
        // Statement) is allowed here. If context is not empty then only a Statement
        // is allowed. However, `let [` is an explicit negative lookahead for
        // ExpressionStatement, so special-case it first.
        if (nextCh === 91 || nextCh === 92) return true;
         // '[', '/'
        if (context) return false;
        if (nextCh === 123 || nextCh > 0xd7ff && nextCh < 0xdc00) return true;
         // '{', astral
        if (isIdentifierStart(nextCh, true)) {
            var pos = next + 1;
            while(isIdentifierChar(nextCh = this.input.charCodeAt(pos), true))++pos;
            if (nextCh === 92 || nextCh > 0xd7ff && nextCh < 0xdc00) return true;
            var ident = this.input.slice(next, pos);
            if (!keywordRelationalOperator.test(ident)) return true;
        }
        return false;
    };
    // check 'async [no LineTerminator here] function'
    // - 'async /*foo*/ function' is OK.
    // - 'async /*\n*/ function' is invalid.
    pp$8.isAsyncFunction = function() {
        if (this.options.ecmaVersion < 8 || !this.isContextual("async")) return false;
        skipWhiteSpace.lastIndex = this.pos;
        var skip = skipWhiteSpace.exec(this.input);
        var next = this.pos + skip[0].length, after;
        return !lineBreak.test(this.input.slice(this.pos, next)) && this.input.slice(next, next + 8) === "function" && (next + 8 === this.input.length || !(isIdentifierChar(after = this.input.charCodeAt(next + 8)) || after > 0xd7ff && after < 0xdc00));
    };
    // Parse a single statement.
    //
    // If expecting a statement and finding a slash operator, parse a
    // regular expression literal. This is to handle cases like
    // `if (foo) /blah/.exec(foo)`, where looking at the previous token
    // does not help.
    pp$8.parseStatement = function(context, topLevel, exports1) {
        var starttype = this.type, node = this.startNode(), kind;
        if (this.isLet(context)) {
            starttype = types$1._var;
            kind = "let";
        }
        // Most types of statements are recognized by the keyword they
        // start with. Many are trivial to parse, some require a bit of
        // complexity.
        switch(starttype){
            case types$1._break:
            case types$1._continue:
                return this.parseBreakContinueStatement(node, starttype.keyword);
            case types$1._debugger:
                return this.parseDebuggerStatement(node);
            case types$1._do:
                return this.parseDoStatement(node);
            case types$1._for:
                return this.parseForStatement(node);
            case types$1._function:
                // Function as sole body of either an if statement or a labeled statement
                // works, but not when it is part of a labeled statement that is the sole
                // body of an if statement.
                if (context && (this.strict || context !== "if" && context !== "label") && this.options.ecmaVersion >= 6) this.unexpected();
                return this.parseFunctionStatement(node, false, !context);
            case types$1._class:
                if (context) this.unexpected();
                return this.parseClass(node, true);
            case types$1._if:
                return this.parseIfStatement(node);
            case types$1._return:
                return this.parseReturnStatement(node);
            case types$1._switch:
                return this.parseSwitchStatement(node);
            case types$1._throw:
                return this.parseThrowStatement(node);
            case types$1._try:
                return this.parseTryStatement(node);
            case types$1._const:
            case types$1._var:
                kind = kind || this.value;
                if (context && kind !== "var") this.unexpected();
                return this.parseVarStatement(node, kind);
            case types$1._while:
                return this.parseWhileStatement(node);
            case types$1._with:
                return this.parseWithStatement(node);
            case types$1.braceL:
                return this.parseBlock(true, node);
            case types$1.semi:
                return this.parseEmptyStatement(node);
            case types$1._export:
            case types$1._import:
                if (this.options.ecmaVersion > 10 && starttype === types$1._import) {
                    skipWhiteSpace.lastIndex = this.pos;
                    var skip = skipWhiteSpace.exec(this.input);
                    var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
                    if (nextCh === 40 || nextCh === 46) return this.parseExpressionStatement(node, this.parseExpression());
                }
                if (!this.options.allowImportExportEverywhere) {
                    if (!topLevel) this.raise(this.start, "'import' and 'export' may only appear at the top level");
                    if (!this.inModule) this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
                }
                return starttype === types$1._import ? this.parseImport(node) : this.parseExport(node, exports1);
            // If the statement does not start with a statement keyword or a
            // brace, it's an ExpressionStatement or LabeledStatement. We
            // simply start parsing an expression, and afterwards, if the
            // next token is a colon and the expression was a simple
            // Identifier node, we switch to interpreting it as a label.
            default:
                if (this.isAsyncFunction()) {
                    if (context) this.unexpected();
                    this.next();
                    return this.parseFunctionStatement(node, true, !context);
                }
                var maybeName = this.value, expr = this.parseExpression();
                if (starttype === types$1.name && expr.type === "Identifier" && this.eat(types$1.colon)) return this.parseLabeledStatement(node, maybeName, expr, context);
                else return this.parseExpressionStatement(node, expr);
        }
    };
    pp$8.parseBreakContinueStatement = function(node, keyword) {
        var isBreak = keyword === "break";
        this.next();
        if (this.eat(types$1.semi) || this.insertSemicolon()) node.label = null;
        else if (this.type !== types$1.name) this.unexpected();
        else {
            node.label = this.parseIdent();
            this.semicolon();
        }
        // Verify that there is an actual destination to break or
        // continue to.
        var i = 0;
        for(; i < this.labels.length; ++i){
            var lab = this.labels[i];
            if (node.label == null || lab.name === node.label.name) {
                if (lab.kind != null && (isBreak || lab.kind === "loop")) break;
                if (node.label && isBreak) break;
            }
        }
        if (i === this.labels.length) this.raise(node.start, "Unsyntactic " + keyword);
        return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
    };
    pp$8.parseDebuggerStatement = function(node) {
        this.next();
        this.semicolon();
        return this.finishNode(node, "DebuggerStatement");
    };
    pp$8.parseDoStatement = function(node) {
        this.next();
        this.labels.push(loopLabel);
        node.body = this.parseStatement("do");
        this.labels.pop();
        this.expect(types$1._while);
        node.test = this.parseParenExpression();
        if (this.options.ecmaVersion >= 6) this.eat(types$1.semi);
        else this.semicolon();
        return this.finishNode(node, "DoWhileStatement");
    };
    // Disambiguating between a `for` and a `for`/`in` or `for`/`of`
    // loop is non-trivial. Basically, we have to parse the init `var`
    // statement or expression, disallowing the `in` operator (see
    // the second parameter to `parseExpression`), and then check
    // whether the next token is `in` or `of`. When there is no init
    // part (semicolon immediately after the opening parenthesis), it
    // is a regular `for` loop.
    pp$8.parseForStatement = function(node) {
        this.next();
        var awaitAt = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
        this.labels.push(loopLabel);
        this.enterScope(0);
        this.expect(types$1.parenL);
        if (this.type === types$1.semi) {
            if (awaitAt > -1) this.unexpected(awaitAt);
            return this.parseFor(node, null);
        }
        var isLet = this.isLet();
        if (this.type === types$1._var || this.type === types$1._const || isLet) {
            var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
            this.next();
            this.parseVar(init$1, true, kind);
            this.finishNode(init$1, "VariableDeclaration");
            if ((this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && init$1.declarations.length === 1) {
                if (this.options.ecmaVersion >= 9) {
                    if (this.type === types$1._in) {
                        if (awaitAt > -1) this.unexpected(awaitAt);
                    } else node.await = awaitAt > -1;
                }
                return this.parseForIn(node, init$1);
            }
            if (awaitAt > -1) this.unexpected(awaitAt);
            return this.parseFor(node, init$1);
        }
        var startsWithLet = this.isContextual("let"), isForOf = false;
        var refDestructuringErrors = new DestructuringErrors;
        var init = this.parseExpression(awaitAt > -1 ? "await" : true, refDestructuringErrors);
        if (this.type === types$1._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
            if (this.options.ecmaVersion >= 9) {
                if (this.type === types$1._in) {
                    if (awaitAt > -1) this.unexpected(awaitAt);
                } else node.await = awaitAt > -1;
            }
            if (startsWithLet && isForOf) this.raise(init.start, "The left-hand side of a for-of loop may not start with 'let'.");
            this.toAssignable(init, false, refDestructuringErrors);
            this.checkLValPattern(init);
            return this.parseForIn(node, init);
        } else this.checkExpressionErrors(refDestructuringErrors, true);
        if (awaitAt > -1) this.unexpected(awaitAt);
        return this.parseFor(node, init);
    };
    pp$8.parseFunctionStatement = function(node, isAsync, declarationPosition) {
        this.next();
        return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync);
    };
    pp$8.parseIfStatement = function(node) {
        this.next();
        node.test = this.parseParenExpression();
        // allow function declarations in branches, but only in non-strict mode
        node.consequent = this.parseStatement("if");
        node.alternate = this.eat(types$1._else) ? this.parseStatement("if") : null;
        return this.finishNode(node, "IfStatement");
    };
    pp$8.parseReturnStatement = function(node) {
        if (!this.inFunction && !this.options.allowReturnOutsideFunction) this.raise(this.start, "'return' outside of function");
        this.next();
        // In `return` (and `break`/`continue`), the keywords with
        // optional arguments, we eagerly look for a semicolon or the
        // possibility to insert one.
        if (this.eat(types$1.semi) || this.insertSemicolon()) node.argument = null;
        else {
            node.argument = this.parseExpression();
            this.semicolon();
        }
        return this.finishNode(node, "ReturnStatement");
    };
    pp$8.parseSwitchStatement = function(node) {
        this.next();
        node.discriminant = this.parseParenExpression();
        node.cases = [];
        this.expect(types$1.braceL);
        this.labels.push(switchLabel);
        this.enterScope(0);
        // Statements under must be grouped (by label) in SwitchCase
        // nodes. `cur` is used to keep the node that we are currently
        // adding statements to.
        var cur;
        for(var sawDefault = false; this.type !== types$1.braceR;)if (this.type === types$1._case || this.type === types$1._default) {
            var isCase = this.type === types$1._case;
            if (cur) this.finishNode(cur, "SwitchCase");
            node.cases.push(cur = this.startNode());
            cur.consequent = [];
            this.next();
            if (isCase) cur.test = this.parseExpression();
            else {
                if (sawDefault) this.raiseRecoverable(this.lastTokStart, "Multiple default clauses");
                sawDefault = true;
                cur.test = null;
            }
            this.expect(types$1.colon);
        } else {
            if (!cur) this.unexpected();
            cur.consequent.push(this.parseStatement(null));
        }
        this.exitScope();
        if (cur) this.finishNode(cur, "SwitchCase");
        this.next(); // Closing brace
        this.labels.pop();
        return this.finishNode(node, "SwitchStatement");
    };
    pp$8.parseThrowStatement = function(node) {
        this.next();
        if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) this.raise(this.lastTokEnd, "Illegal newline after throw");
        node.argument = this.parseExpression();
        this.semicolon();
        return this.finishNode(node, "ThrowStatement");
    };
    // Reused empty array added for node fields that are always empty.
    var empty$1 = [];
    pp$8.parseCatchClauseParam = function() {
        var param = this.parseBindingAtom();
        var simple = param.type === "Identifier";
        this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
        this.checkLValPattern(param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
        this.expect(types$1.parenR);
        return param;
    };
    pp$8.parseTryStatement = function(node) {
        this.next();
        node.block = this.parseBlock();
        node.handler = null;
        if (this.type === types$1._catch) {
            var clause = this.startNode();
            this.next();
            if (this.eat(types$1.parenL)) clause.param = this.parseCatchClauseParam();
            else {
                if (this.options.ecmaVersion < 10) this.unexpected();
                clause.param = null;
                this.enterScope(0);
            }
            clause.body = this.parseBlock(false);
            this.exitScope();
            node.handler = this.finishNode(clause, "CatchClause");
        }
        node.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;
        if (!node.handler && !node.finalizer) this.raise(node.start, "Missing catch or finally clause");
        return this.finishNode(node, "TryStatement");
    };
    pp$8.parseVarStatement = function(node, kind, allowMissingInitializer) {
        this.next();
        this.parseVar(node, false, kind, allowMissingInitializer);
        this.semicolon();
        return this.finishNode(node, "VariableDeclaration");
    };
    pp$8.parseWhileStatement = function(node) {
        this.next();
        node.test = this.parseParenExpression();
        this.labels.push(loopLabel);
        node.body = this.parseStatement("while");
        this.labels.pop();
        return this.finishNode(node, "WhileStatement");
    };
    pp$8.parseWithStatement = function(node) {
        if (this.strict) this.raise(this.start, "'with' in strict mode");
        this.next();
        node.object = this.parseParenExpression();
        node.body = this.parseStatement("with");
        return this.finishNode(node, "WithStatement");
    };
    pp$8.parseEmptyStatement = function(node) {
        this.next();
        return this.finishNode(node, "EmptyStatement");
    };
    pp$8.parseLabeledStatement = function(node, maybeName, expr, context) {
        for(var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1){
            var label = list[i$1];
            if (label.name === maybeName) this.raise(expr.start, "Label '" + maybeName + "' is already declared");
        }
        var kind = this.type.isLoop ? "loop" : this.type === types$1._switch ? "switch" : null;
        for(var i = this.labels.length - 1; i >= 0; i--){
            var label$1 = this.labels[i];
            if (label$1.statementStart === node.start) {
                // Update information about previous labels on this node
                label$1.statementStart = this.start;
                label$1.kind = kind;
            } else break;
        }
        this.labels.push({
            name: maybeName,
            kind: kind,
            statementStart: this.start
        });
        node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
        this.labels.pop();
        node.label = expr;
        return this.finishNode(node, "LabeledStatement");
    };
    pp$8.parseExpressionStatement = function(node, expr) {
        node.expression = expr;
        this.semicolon();
        return this.finishNode(node, "ExpressionStatement");
    };
    // Parse a semicolon-enclosed block of statements, handling `"use
    // strict"` declarations when `allowStrict` is true (used for
    // function bodies).
    pp$8.parseBlock = function(createNewLexicalScope, node, exitStrict) {
        if (createNewLexicalScope === void 0) createNewLexicalScope = true;
        if (node === void 0) node = this.startNode();
        node.body = [];
        this.expect(types$1.braceL);
        if (createNewLexicalScope) this.enterScope(0);
        while(this.type !== types$1.braceR){
            var stmt = this.parseStatement(null);
            node.body.push(stmt);
        }
        if (exitStrict) this.strict = false;
        this.next();
        if (createNewLexicalScope) this.exitScope();
        return this.finishNode(node, "BlockStatement");
    };
    // Parse a regular `for` loop. The disambiguation code in
    // `parseStatement` will already have parsed the init statement or
    // expression.
    pp$8.parseFor = function(node, init) {
        node.init = init;
        this.expect(types$1.semi);
        node.test = this.type === types$1.semi ? null : this.parseExpression();
        this.expect(types$1.semi);
        node.update = this.type === types$1.parenR ? null : this.parseExpression();
        this.expect(types$1.parenR);
        node.body = this.parseStatement("for");
        this.exitScope();
        this.labels.pop();
        return this.finishNode(node, "ForStatement");
    };
    // Parse a `for`/`in` and `for`/`of` loop, which are almost
    // same from parser's perspective.
    pp$8.parseForIn = function(node, init) {
        var isForIn = this.type === types$1._in;
        this.next();
        if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || this.options.ecmaVersion < 8 || this.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) this.raise(init.start, (isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer");
        node.left = init;
        node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
        this.expect(types$1.parenR);
        node.body = this.parseStatement("for");
        this.exitScope();
        this.labels.pop();
        return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
    };
    // Parse a list of variable declarations.
    pp$8.parseVar = function(node, isFor, kind, allowMissingInitializer) {
        node.declarations = [];
        node.kind = kind;
        for(;;){
            var decl = this.startNode();
            this.parseVarId(decl, kind);
            if (this.eat(types$1.eq)) decl.init = this.parseMaybeAssign(isFor);
            else if (!allowMissingInitializer && kind === "const" && !(this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) this.unexpected();
            else if (!allowMissingInitializer && decl.id.type !== "Identifier" && !(isFor && (this.type === types$1._in || this.isContextual("of")))) this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
            else decl.init = null;
            node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
            if (!this.eat(types$1.comma)) break;
        }
        return node;
    };
    pp$8.parseVarId = function(decl, kind) {
        decl.id = this.parseBindingAtom();
        this.checkLValPattern(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
    };
    var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;
    // Parse a function declaration or literal (depending on the
    // `statement & FUNC_STATEMENT`).
    // Remove `allowExpressionBody` for 7.0.0, as it is only called with false
    pp$8.parseFunction = function(node, statement, allowExpressionBody, isAsync, forInit) {
        this.initFunction(node);
        if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
            if (this.type === types$1.star && statement & FUNC_HANGING_STATEMENT) this.unexpected();
            node.generator = this.eat(types$1.star);
        }
        if (this.options.ecmaVersion >= 8) node.async = !!isAsync;
        if (statement & FUNC_STATEMENT) {
            node.id = statement & FUNC_NULLABLE_ID && this.type !== types$1.name ? null : this.parseIdent();
            if (node.id && !(statement & FUNC_HANGING_STATEMENT)) this.checkLValSimple(node.id, this.strict || node.generator || node.async ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION);
        }
        var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        this.enterScope(functionFlags(node.async, node.generator));
        if (!(statement & FUNC_STATEMENT)) node.id = this.type === types$1.name ? this.parseIdent() : null;
        this.parseFunctionParams(node);
        this.parseFunctionBody(node, allowExpressionBody, false, forInit);
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.finishNode(node, statement & FUNC_STATEMENT ? "FunctionDeclaration" : "FunctionExpression");
    };
    pp$8.parseFunctionParams = function(node) {
        this.expect(types$1.parenL);
        node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
        this.checkYieldAwaitInDefaultParams();
    };
    // Parse a class declaration or literal (depending on the
    // `isStatement` parameter).
    pp$8.parseClass = function(node, isStatement) {
        this.next();
        // ecma-262 14.6 Class Definitions
        // A class definition is always strict mode code.
        var oldStrict = this.strict;
        this.strict = true;
        this.parseClassId(node, isStatement);
        this.parseClassSuper(node);
        var privateNameMap = this.enterClassBody();
        var classBody = this.startNode();
        var hadConstructor = false;
        classBody.body = [];
        this.expect(types$1.braceL);
        while(this.type !== types$1.braceR){
            var element = this.parseClassElement(node.superClass !== null);
            if (element) {
                classBody.body.push(element);
                if (element.type === "MethodDefinition" && element.kind === "constructor") {
                    if (hadConstructor) this.raiseRecoverable(element.start, "Duplicate constructor in the same class");
                    hadConstructor = true;
                } else if (element.key && element.key.type === "PrivateIdentifier" && isPrivateNameConflicted(privateNameMap, element)) this.raiseRecoverable(element.key.start, "Identifier '#" + element.key.name + "' has already been declared");
            }
        }
        this.strict = oldStrict;
        this.next();
        node.body = this.finishNode(classBody, "ClassBody");
        this.exitClassBody();
        return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
    };
    pp$8.parseClassElement = function(constructorAllowsSuper) {
        if (this.eat(types$1.semi)) return null;
        var ecmaVersion = this.options.ecmaVersion;
        var node = this.startNode();
        var keyName = "";
        var isGenerator = false;
        var isAsync = false;
        var kind = "method";
        var isStatic = false;
        if (this.eatContextual("static")) {
            // Parse static init block
            if (ecmaVersion >= 13 && this.eat(types$1.braceL)) {
                this.parseClassStaticBlock(node);
                return node;
            }
            if (this.isClassElementNameStart() || this.type === types$1.star) isStatic = true;
            else keyName = "static";
        }
        node.static = isStatic;
        if (!keyName && ecmaVersion >= 8 && this.eatContextual("async")) {
            if ((this.isClassElementNameStart() || this.type === types$1.star) && !this.canInsertSemicolon()) isAsync = true;
            else keyName = "async";
        }
        if (!keyName && (ecmaVersion >= 9 || !isAsync) && this.eat(types$1.star)) isGenerator = true;
        if (!keyName && !isAsync && !isGenerator) {
            var lastValue = this.value;
            if (this.eatContextual("get") || this.eatContextual("set")) {
                if (this.isClassElementNameStart()) kind = lastValue;
                else keyName = lastValue;
            }
        }
        // Parse element name
        if (keyName) {
            // 'async', 'get', 'set', or 'static' were not a keyword contextually.
            // The last token is any of those. Make it the element name.
            node.computed = false;
            node.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
            node.key.name = keyName;
            this.finishNode(node.key, "Identifier");
        } else this.parseClassElementName(node);
        // Parse element value
        if (ecmaVersion < 13 || this.type === types$1.parenL || kind !== "method" || isGenerator || isAsync) {
            var isConstructor = !node.static && checkKeyName(node, "constructor");
            var allowsDirectSuper = isConstructor && constructorAllowsSuper;
            // Couldn't move this check into the 'parseClassMethod' method for backward compatibility.
            if (isConstructor && kind !== "method") this.raise(node.key.start, "Constructor can't have get/set modifier");
            node.kind = isConstructor ? "constructor" : kind;
            this.parseClassMethod(node, isGenerator, isAsync, allowsDirectSuper);
        } else this.parseClassField(node);
        return node;
    };
    pp$8.isClassElementNameStart = function() {
        return this.type === types$1.name || this.type === types$1.privateId || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword;
    };
    pp$8.parseClassElementName = function(element) {
        if (this.type === types$1.privateId) {
            if (this.value === "constructor") this.raise(this.start, "Classes can't have an element named '#constructor'");
            element.computed = false;
            element.key = this.parsePrivateIdent();
        } else this.parsePropertyName(element);
    };
    pp$8.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
        // Check key and flags
        var key = method.key;
        if (method.kind === "constructor") {
            if (isGenerator) this.raise(key.start, "Constructor can't be a generator");
            if (isAsync) this.raise(key.start, "Constructor can't be an async method");
        } else if (method.static && checkKeyName(method, "prototype")) this.raise(key.start, "Classes may not have a static property named prototype");
        // Parse value
        var value = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
        // Check value
        if (method.kind === "get" && value.params.length !== 0) this.raiseRecoverable(value.start, "getter should have no params");
        if (method.kind === "set" && value.params.length !== 1) this.raiseRecoverable(value.start, "setter should have exactly one param");
        if (method.kind === "set" && value.params[0].type === "RestElement") this.raiseRecoverable(value.params[0].start, "Setter cannot use rest params");
        return this.finishNode(method, "MethodDefinition");
    };
    pp$8.parseClassField = function(field) {
        if (checkKeyName(field, "constructor")) this.raise(field.key.start, "Classes can't have a field named 'constructor'");
        else if (field.static && checkKeyName(field, "prototype")) this.raise(field.key.start, "Classes can't have a static field named 'prototype'");
        if (this.eat(types$1.eq)) {
            // To raise SyntaxError if 'arguments' exists in the initializer.
            var scope = this.currentThisScope();
            var inClassFieldInit = scope.inClassFieldInit;
            scope.inClassFieldInit = true;
            field.value = this.parseMaybeAssign();
            scope.inClassFieldInit = inClassFieldInit;
        } else field.value = null;
        this.semicolon();
        return this.finishNode(field, "PropertyDefinition");
    };
    pp$8.parseClassStaticBlock = function(node) {
        node.body = [];
        var oldLabels = this.labels;
        this.labels = [];
        this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);
        while(this.type !== types$1.braceR){
            var stmt = this.parseStatement(null);
            node.body.push(stmt);
        }
        this.next();
        this.exitScope();
        this.labels = oldLabels;
        return this.finishNode(node, "StaticBlock");
    };
    pp$8.parseClassId = function(node, isStatement) {
        if (this.type === types$1.name) {
            node.id = this.parseIdent();
            if (isStatement) this.checkLValSimple(node.id, BIND_LEXICAL, false);
        } else {
            if (isStatement === true) this.unexpected();
            node.id = null;
        }
    };
    pp$8.parseClassSuper = function(node) {
        node.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts(null, false) : null;
    };
    pp$8.enterClassBody = function() {
        var element = {
            declared: Object.create(null),
            used: []
        };
        this.privateNameStack.push(element);
        return element.declared;
    };
    pp$8.exitClassBody = function() {
        var ref = this.privateNameStack.pop();
        var declared = ref.declared;
        var used = ref.used;
        if (!this.options.checkPrivateFields) return;
        var len = this.privateNameStack.length;
        var parent = len === 0 ? null : this.privateNameStack[len - 1];
        for(var i = 0; i < used.length; ++i){
            var id = used[i];
            if (!hasOwn(declared, id.name)) {
                if (parent) parent.used.push(id);
                else this.raiseRecoverable(id.start, "Private field '#" + id.name + "' must be declared in an enclosing class");
            }
        }
    };
    function isPrivateNameConflicted(privateNameMap, element) {
        var name = element.key.name;
        var curr = privateNameMap[name];
        var next = "true";
        if (element.type === "MethodDefinition" && (element.kind === "get" || element.kind === "set")) next = (element.static ? "s" : "i") + element.kind;
        // `class { get #a(){}; static set #a(_){} }` is also conflict.
        if (curr === "iget" && next === "iset" || curr === "iset" && next === "iget" || curr === "sget" && next === "sset" || curr === "sset" && next === "sget") {
            privateNameMap[name] = "true";
            return false;
        } else if (!curr) {
            privateNameMap[name] = next;
            return false;
        } else return true;
    }
    function checkKeyName(node, name) {
        var computed = node.computed;
        var key = node.key;
        return !computed && (key.type === "Identifier" && key.name === name || key.type === "Literal" && key.value === name);
    }
    // Parses module export declaration.
    pp$8.parseExportAllDeclaration = function(node, exports1) {
        if (this.options.ecmaVersion >= 11) {
            if (this.eatContextual("as")) {
                node.exported = this.parseModuleExportName();
                this.checkExport(exports1, node.exported, this.lastTokStart);
            } else node.exported = null;
        }
        this.expectContextual("from");
        if (this.type !== types$1.string) this.unexpected();
        node.source = this.parseExprAtom();
        this.semicolon();
        return this.finishNode(node, "ExportAllDeclaration");
    };
    pp$8.parseExport = function(node, exports1) {
        this.next();
        // export * from '...'
        if (this.eat(types$1.star)) return this.parseExportAllDeclaration(node, exports1);
        if (this.eat(types$1._default)) {
            this.checkExport(exports1, "default", this.lastTokStart);
            node.declaration = this.parseExportDefaultDeclaration();
            return this.finishNode(node, "ExportDefaultDeclaration");
        }
        // export var|const|let|function|class ...
        if (this.shouldParseExportStatement()) {
            node.declaration = this.parseExportDeclaration(node);
            if (node.declaration.type === "VariableDeclaration") this.checkVariableExport(exports1, node.declaration.declarations);
            else this.checkExport(exports1, node.declaration.id, node.declaration.id.start);
            node.specifiers = [];
            node.source = null;
        } else {
            node.declaration = null;
            node.specifiers = this.parseExportSpecifiers(exports1);
            if (this.eatContextual("from")) {
                if (this.type !== types$1.string) this.unexpected();
                node.source = this.parseExprAtom();
            } else {
                for(var i = 0, list = node.specifiers; i < list.length; i += 1){
                    // check for keywords used as local names
                    var spec = list[i];
                    this.checkUnreserved(spec.local);
                    // check if export is defined
                    this.checkLocalExport(spec.local);
                    if (spec.local.type === "Literal") this.raise(spec.local.start, "A string literal cannot be used as an exported binding without `from`.");
                }
                node.source = null;
            }
            this.semicolon();
        }
        return this.finishNode(node, "ExportNamedDeclaration");
    };
    pp$8.parseExportDeclaration = function(node) {
        return this.parseStatement(null);
    };
    pp$8.parseExportDefaultDeclaration = function() {
        var isAsync;
        if (this.type === types$1._function || (isAsync = this.isAsyncFunction())) {
            var fNode = this.startNode();
            this.next();
            if (isAsync) this.next();
            return this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
        } else if (this.type === types$1._class) {
            var cNode = this.startNode();
            return this.parseClass(cNode, "nullableID");
        } else {
            var declaration = this.parseMaybeAssign();
            this.semicolon();
            return declaration;
        }
    };
    pp$8.checkExport = function(exports1, name, pos) {
        if (!exports1) return;
        if (typeof name !== "string") name = name.type === "Identifier" ? name.name : name.value;
        if (hasOwn(exports1, name)) this.raiseRecoverable(pos, "Duplicate export '" + name + "'");
        exports1[name] = true;
    };
    pp$8.checkPatternExport = function(exports1, pat) {
        var type = pat.type;
        if (type === "Identifier") this.checkExport(exports1, pat, pat.start);
        else if (type === "ObjectPattern") for(var i = 0, list = pat.properties; i < list.length; i += 1){
            var prop = list[i];
            this.checkPatternExport(exports1, prop);
        }
        else if (type === "ArrayPattern") for(var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1){
            var elt = list$1[i$1];
            if (elt) this.checkPatternExport(exports1, elt);
        }
        else if (type === "Property") this.checkPatternExport(exports1, pat.value);
        else if (type === "AssignmentPattern") this.checkPatternExport(exports1, pat.left);
        else if (type === "RestElement") this.checkPatternExport(exports1, pat.argument);
    };
    pp$8.checkVariableExport = function(exports1, decls) {
        if (!exports1) return;
        for(var i = 0, list = decls; i < list.length; i += 1){
            var decl = list[i];
            this.checkPatternExport(exports1, decl.id);
        }
    };
    pp$8.shouldParseExportStatement = function() {
        return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
    };
    // Parses a comma-separated list of module exports.
    pp$8.parseExportSpecifier = function(exports1) {
        var node = this.startNode();
        node.local = this.parseModuleExportName();
        node.exported = this.eatContextual("as") ? this.parseModuleExportName() : node.local;
        this.checkExport(exports1, node.exported, node.exported.start);
        return this.finishNode(node, "ExportSpecifier");
    };
    pp$8.parseExportSpecifiers = function(exports1) {
        var nodes = [], first = true;
        // export { x, y as z } [from '...']
        this.expect(types$1.braceL);
        while(!this.eat(types$1.braceR)){
            if (!first) {
                this.expect(types$1.comma);
                if (this.afterTrailingComma(types$1.braceR)) break;
            } else first = false;
            nodes.push(this.parseExportSpecifier(exports1));
        }
        return nodes;
    };
    // Parses import declaration.
    pp$8.parseImport = function(node) {
        this.next();
        // import '...'
        if (this.type === types$1.string) {
            node.specifiers = empty$1;
            node.source = this.parseExprAtom();
        } else {
            node.specifiers = this.parseImportSpecifiers();
            this.expectContextual("from");
            node.source = this.type === types$1.string ? this.parseExprAtom() : this.unexpected();
        }
        this.semicolon();
        return this.finishNode(node, "ImportDeclaration");
    };
    // Parses a comma-separated list of module imports.
    pp$8.parseImportSpecifier = function() {
        var node = this.startNode();
        node.imported = this.parseModuleExportName();
        if (this.eatContextual("as")) node.local = this.parseIdent();
        else {
            this.checkUnreserved(node.imported);
            node.local = node.imported;
        }
        this.checkLValSimple(node.local, BIND_LEXICAL);
        return this.finishNode(node, "ImportSpecifier");
    };
    pp$8.parseImportDefaultSpecifier = function() {
        // import defaultObj, { x, y as z } from '...'
        var node = this.startNode();
        node.local = this.parseIdent();
        this.checkLValSimple(node.local, BIND_LEXICAL);
        return this.finishNode(node, "ImportDefaultSpecifier");
    };
    pp$8.parseImportNamespaceSpecifier = function() {
        var node = this.startNode();
        this.next();
        this.expectContextual("as");
        node.local = this.parseIdent();
        this.checkLValSimple(node.local, BIND_LEXICAL);
        return this.finishNode(node, "ImportNamespaceSpecifier");
    };
    pp$8.parseImportSpecifiers = function() {
        var nodes = [], first = true;
        if (this.type === types$1.name) {
            nodes.push(this.parseImportDefaultSpecifier());
            if (!this.eat(types$1.comma)) return nodes;
        }
        if (this.type === types$1.star) {
            nodes.push(this.parseImportNamespaceSpecifier());
            return nodes;
        }
        this.expect(types$1.braceL);
        while(!this.eat(types$1.braceR)){
            if (!first) {
                this.expect(types$1.comma);
                if (this.afterTrailingComma(types$1.braceR)) break;
            } else first = false;
            nodes.push(this.parseImportSpecifier());
        }
        return nodes;
    };
    pp$8.parseModuleExportName = function() {
        if (this.options.ecmaVersion >= 13 && this.type === types$1.string) {
            var stringLiteral = this.parseLiteral(this.value);
            if (loneSurrogate.test(stringLiteral.value)) this.raise(stringLiteral.start, "An export name cannot include a lone surrogate.");
            return stringLiteral;
        }
        return this.parseIdent(true);
    };
    // Set `ExpressionStatement#directive` property for directive prologues.
    pp$8.adaptDirectivePrologue = function(statements) {
        for(var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i)statements[i].directive = statements[i].expression.raw.slice(1, -1);
    };
    pp$8.isDirectiveCandidate = function(statement) {
        return this.options.ecmaVersion >= 5 && statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && typeof statement.expression.value === "string" && // Reject parenthesized strings.
        (this.input[statement.start] === '"' || this.input[statement.start] === "'");
    };
    var pp$7 = Parser$1.prototype;
    // Convert existing expression atom to assignable pattern
    // if possible.
    pp$7.toAssignable = function(node, isBinding, refDestructuringErrors) {
        if (this.options.ecmaVersion >= 6 && node) switch(node.type){
            case "Identifier":
                if (this.inAsync && node.name === "await") this.raise(node.start, "Cannot use 'await' as identifier inside an async function");
                break;
            case "ObjectPattern":
            case "ArrayPattern":
            case "AssignmentPattern":
            case "RestElement":
                break;
            case "ObjectExpression":
                node.type = "ObjectPattern";
                if (refDestructuringErrors) this.checkPatternErrors(refDestructuringErrors, true);
                for(var i = 0, list = node.properties; i < list.length; i += 1){
                    var prop = list[i];
                    this.toAssignable(prop, isBinding);
                    // Early error:
                    //   AssignmentRestProperty[Yield, Await] :
                    //     `...` DestructuringAssignmentTarget[Yield, Await]
                    //
                    //   It is a Syntax Error if |DestructuringAssignmentTarget| is an |ArrayLiteral| or an |ObjectLiteral|.
                    if (prop.type === "RestElement" && (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")) this.raise(prop.argument.start, "Unexpected token");
                }
                break;
            case "Property":
                // AssignmentProperty has type === "Property"
                if (node.kind !== "init") this.raise(node.key.start, "Object pattern can't contain getter or setter");
                this.toAssignable(node.value, isBinding);
                break;
            case "ArrayExpression":
                node.type = "ArrayPattern";
                if (refDestructuringErrors) this.checkPatternErrors(refDestructuringErrors, true);
                this.toAssignableList(node.elements, isBinding);
                break;
            case "SpreadElement":
                node.type = "RestElement";
                this.toAssignable(node.argument, isBinding);
                if (node.argument.type === "AssignmentPattern") this.raise(node.argument.start, "Rest elements cannot have a default value");
                break;
            case "AssignmentExpression":
                if (node.operator !== "=") this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
                node.type = "AssignmentPattern";
                delete node.operator;
                this.toAssignable(node.left, isBinding);
                break;
            case "ParenthesizedExpression":
                this.toAssignable(node.expression, isBinding, refDestructuringErrors);
                break;
            case "ChainExpression":
                this.raiseRecoverable(node.start, "Optional chaining cannot appear in left-hand side");
                break;
            case "MemberExpression":
                if (!isBinding) break;
            default:
                this.raise(node.start, "Assigning to rvalue");
        }
        else if (refDestructuringErrors) this.checkPatternErrors(refDestructuringErrors, true);
        return node;
    };
    // Convert list of expression atoms to binding list.
    pp$7.toAssignableList = function(exprList, isBinding) {
        var end = exprList.length;
        for(var i = 0; i < end; i++){
            var elt = exprList[i];
            if (elt) this.toAssignable(elt, isBinding);
        }
        if (end) {
            var last = exprList[end - 1];
            if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier") this.unexpected(last.argument.start);
        }
        return exprList;
    };
    // Parses spread element.
    pp$7.parseSpread = function(refDestructuringErrors) {
        var node = this.startNode();
        this.next();
        node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
        return this.finishNode(node, "SpreadElement");
    };
    pp$7.parseRestBinding = function() {
        var node = this.startNode();
        this.next();
        // RestElement inside of a function parameter must be an identifier
        if (this.options.ecmaVersion === 6 && this.type !== types$1.name) this.unexpected();
        node.argument = this.parseBindingAtom();
        return this.finishNode(node, "RestElement");
    };
    // Parses lvalue (assignable) atom.
    pp$7.parseBindingAtom = function() {
        if (this.options.ecmaVersion >= 6) switch(this.type){
            case types$1.bracketL:
                var node = this.startNode();
                this.next();
                node.elements = this.parseBindingList(types$1.bracketR, true, true);
                return this.finishNode(node, "ArrayPattern");
            case types$1.braceL:
                return this.parseObj(true);
        }
        return this.parseIdent();
    };
    pp$7.parseBindingList = function(close, allowEmpty, allowTrailingComma, allowModifiers) {
        var elts = [], first = true;
        while(!this.eat(close)){
            if (first) first = false;
            else this.expect(types$1.comma);
            if (allowEmpty && this.type === types$1.comma) elts.push(null);
            else if (allowTrailingComma && this.afterTrailingComma(close)) break;
            else if (this.type === types$1.ellipsis) {
                var rest = this.parseRestBinding();
                this.parseBindingListItem(rest);
                elts.push(rest);
                if (this.type === types$1.comma) this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
                this.expect(close);
                break;
            } else elts.push(this.parseAssignableListItem(allowModifiers));
        }
        return elts;
    };
    pp$7.parseAssignableListItem = function(allowModifiers) {
        var elem = this.parseMaybeDefault(this.start, this.startLoc);
        this.parseBindingListItem(elem);
        return elem;
    };
    pp$7.parseBindingListItem = function(param) {
        return param;
    };
    // Parses assignment pattern around given atom if possible.
    pp$7.parseMaybeDefault = function(startPos, startLoc, left) {
        left = left || this.parseBindingAtom();
        if (this.options.ecmaVersion < 6 || !this.eat(types$1.eq)) return left;
        var node = this.startNodeAt(startPos, startLoc);
        node.left = left;
        node.right = this.parseMaybeAssign();
        return this.finishNode(node, "AssignmentPattern");
    };
    // The following three functions all verify that a node is an lvalue —
    // something that can be bound, or assigned to. In order to do so, they perform
    // a variety of checks:
    //
    // - Check that none of the bound/assigned-to identifiers are reserved words.
    // - Record name declarations for bindings in the appropriate scope.
    // - Check duplicate argument names, if checkClashes is set.
    //
    // If a complex binding pattern is encountered (e.g., object and array
    // destructuring), the entire pattern is recursively checked.
    //
    // There are three versions of checkLVal*() appropriate for different
    // circumstances:
    //
    // - checkLValSimple() shall be used if the syntactic construct supports
    //   nothing other than identifiers and member expressions. Parenthesized
    //   expressions are also correctly handled. This is generally appropriate for
    //   constructs for which the spec says
    //
    //   > It is a Syntax Error if AssignmentTargetType of [the production] is not
    //   > simple.
    //
    //   It is also appropriate for checking if an identifier is valid and not
    //   defined elsewhere, like import declarations or function/class identifiers.
    //
    //   Examples where this is used include:
    //     a += …;
    //     import a from '…';
    //   where a is the node to be checked.
    //
    // - checkLValPattern() shall be used if the syntactic construct supports
    //   anything checkLValSimple() supports, as well as object and array
    //   destructuring patterns. This is generally appropriate for constructs for
    //   which the spec says
    //
    //   > It is a Syntax Error if [the production] is neither an ObjectLiteral nor
    //   > an ArrayLiteral and AssignmentTargetType of [the production] is not
    //   > simple.
    //
    //   Examples where this is used include:
    //     (a = …);
    //     const a = …;
    //     try { … } catch (a) { … }
    //   where a is the node to be checked.
    //
    // - checkLValInnerPattern() shall be used if the syntactic construct supports
    //   anything checkLValPattern() supports, as well as default assignment
    //   patterns, rest elements, and other constructs that may appear within an
    //   object or array destructuring pattern.
    //
    //   As a special case, function parameters also use checkLValInnerPattern(),
    //   as they also support defaults and rest constructs.
    //
    // These functions deliberately support both assignment and binding constructs,
    // as the logic for both is exceedingly similar. If the node is the target of
    // an assignment, then bindingType should be set to BIND_NONE. Otherwise, it
    // should be set to the appropriate BIND_* constant, like BIND_VAR or
    // BIND_LEXICAL.
    //
    // If the function is called with a non-BIND_NONE bindingType, then
    // additionally a checkClashes object may be specified to allow checking for
    // duplicate argument names. checkClashes is ignored if the provided construct
    // is an assignment (i.e., bindingType is BIND_NONE).
    pp$7.checkLValSimple = function(expr, bindingType, checkClashes) {
        if (bindingType === void 0) bindingType = BIND_NONE;
        var isBind = bindingType !== BIND_NONE;
        switch(expr.type){
            case "Identifier":
                if (this.strict && this.reservedWordsStrictBind.test(expr.name)) this.raiseRecoverable(expr.start, (isBind ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
                if (isBind) {
                    if (bindingType === BIND_LEXICAL && expr.name === "let") this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name");
                    if (checkClashes) {
                        if (hasOwn(checkClashes, expr.name)) this.raiseRecoverable(expr.start, "Argument name clash");
                        checkClashes[expr.name] = true;
                    }
                    if (bindingType !== BIND_OUTSIDE) this.declareName(expr.name, bindingType, expr.start);
                }
                break;
            case "ChainExpression":
                this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
                break;
            case "MemberExpression":
                if (isBind) this.raiseRecoverable(expr.start, "Binding member expression");
                break;
            case "ParenthesizedExpression":
                if (isBind) this.raiseRecoverable(expr.start, "Binding parenthesized expression");
                return this.checkLValSimple(expr.expression, bindingType, checkClashes);
            default:
                this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
        }
    };
    pp$7.checkLValPattern = function(expr, bindingType, checkClashes) {
        if (bindingType === void 0) bindingType = BIND_NONE;
        switch(expr.type){
            case "ObjectPattern":
                for(var i = 0, list = expr.properties; i < list.length; i += 1){
                    var prop = list[i];
                    this.checkLValInnerPattern(prop, bindingType, checkClashes);
                }
                break;
            case "ArrayPattern":
                for(var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1){
                    var elem = list$1[i$1];
                    if (elem) this.checkLValInnerPattern(elem, bindingType, checkClashes);
                }
                break;
            default:
                this.checkLValSimple(expr, bindingType, checkClashes);
        }
    };
    pp$7.checkLValInnerPattern = function(expr, bindingType, checkClashes) {
        if (bindingType === void 0) bindingType = BIND_NONE;
        switch(expr.type){
            case "Property":
                // AssignmentProperty has type === "Property"
                this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
                break;
            case "AssignmentPattern":
                this.checkLValPattern(expr.left, bindingType, checkClashes);
                break;
            case "RestElement":
                this.checkLValPattern(expr.argument, bindingType, checkClashes);
                break;
            default:
                this.checkLValPattern(expr, bindingType, checkClashes);
        }
    };
    // The algorithm used to determine whether a regexp can appear at a
    // given point in the program is loosely based on sweet.js' approach.
    // See https://github.com/mozilla/sweet.js/wiki/design
    var TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {
        this.token = token;
        this.isExpr = !!isExpr;
        this.preserveSpace = !!preserveSpace;
        this.override = override;
        this.generator = !!generator;
    };
    var types = {
        b_stat: new TokContext("{", false),
        b_expr: new TokContext("{", true),
        b_tmpl: new TokContext("${", false),
        p_stat: new TokContext("(", false),
        p_expr: new TokContext("(", true),
        q_tmpl: new TokContext("`", true, true, function(p) {
            return p.tryReadTemplateToken();
        }),
        f_stat: new TokContext("function", false),
        f_expr: new TokContext("function", true),
        f_expr_gen: new TokContext("function", true, false, null, true),
        f_gen: new TokContext("function", false, false, null, true)
    };
    var pp$6 = Parser$1.prototype;
    pp$6.initialContext = function() {
        return [
            types.b_stat
        ];
    };
    pp$6.curContext = function() {
        return this.context[this.context.length - 1];
    };
    pp$6.braceIsBlock = function(prevType) {
        var parent = this.curContext();
        if (parent === types.f_expr || parent === types.f_stat) return true;
        if (prevType === types$1.colon && (parent === types.b_stat || parent === types.b_expr)) return !parent.isExpr;
        // The check for `tt.name && exprAllowed` detects whether we are
        // after a `yield` or `of` construct. See the `updateContext` for
        // `tt.name`.
        if (prevType === types$1._return || prevType === types$1.name && this.exprAllowed) return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
        if (prevType === types$1._else || prevType === types$1.semi || prevType === types$1.eof || prevType === types$1.parenR || prevType === types$1.arrow) return true;
        if (prevType === types$1.braceL) return parent === types.b_stat;
        if (prevType === types$1._var || prevType === types$1._const || prevType === types$1.name) return false;
        return !this.exprAllowed;
    };
    pp$6.inGeneratorContext = function() {
        for(var i = this.context.length - 1; i >= 1; i--){
            var context = this.context[i];
            if (context.token === "function") return context.generator;
        }
        return false;
    };
    pp$6.updateContext = function(prevType) {
        var update, type = this.type;
        if (type.keyword && prevType === types$1.dot) this.exprAllowed = false;
        else if (update = type.updateContext) update.call(this, prevType);
        else this.exprAllowed = type.beforeExpr;
    };
    // Used to handle edge cases when token context could not be inferred correctly during tokenization phase
    pp$6.overrideContext = function(tokenCtx) {
        if (this.curContext() !== tokenCtx) this.context[this.context.length - 1] = tokenCtx;
    };
    // Token-specific context update code
    types$1.parenR.updateContext = types$1.braceR.updateContext = function() {
        if (this.context.length === 1) {
            this.exprAllowed = true;
            return;
        }
        var out = this.context.pop();
        if (out === types.b_stat && this.curContext().token === "function") out = this.context.pop();
        this.exprAllowed = !out.isExpr;
    };
    types$1.braceL.updateContext = function(prevType) {
        this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);
        this.exprAllowed = true;
    };
    types$1.dollarBraceL.updateContext = function() {
        this.context.push(types.b_tmpl);
        this.exprAllowed = true;
    };
    types$1.parenL.updateContext = function(prevType) {
        var statementParens = prevType === types$1._if || prevType === types$1._for || prevType === types$1._with || prevType === types$1._while;
        this.context.push(statementParens ? types.p_stat : types.p_expr);
        this.exprAllowed = true;
    };
    types$1.incDec.updateContext = function() {
    // tokExprAllowed stays unchanged
    };
    types$1._function.updateContext = types$1._class.updateContext = function(prevType) {
        if (prevType.beforeExpr && prevType !== types$1._else && !(prevType === types$1.semi && this.curContext() !== types.p_stat) && !(prevType === types$1._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) && !((prevType === types$1.colon || prevType === types$1.braceL) && this.curContext() === types.b_stat)) this.context.push(types.f_expr);
        else this.context.push(types.f_stat);
        this.exprAllowed = false;
    };
    types$1.colon.updateContext = function() {
        if (this.curContext().token === "function") this.context.pop();
        this.exprAllowed = true;
    };
    types$1.backQuote.updateContext = function() {
        if (this.curContext() === types.q_tmpl) this.context.pop();
        else this.context.push(types.q_tmpl);
        this.exprAllowed = false;
    };
    types$1.star.updateContext = function(prevType) {
        if (prevType === types$1._function) {
            var index = this.context.length - 1;
            if (this.context[index] === types.f_expr) this.context[index] = types.f_expr_gen;
            else this.context[index] = types.f_gen;
        }
        this.exprAllowed = true;
    };
    types$1.name.updateContext = function(prevType) {
        var allowed = false;
        if (this.options.ecmaVersion >= 6 && prevType !== types$1.dot) {
            if (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) allowed = true;
        }
        this.exprAllowed = allowed;
    };
    // A recursive descent parser operates by defining functions for all
    // syntactic elements, and recursively calling those, each function
    // advancing the input stream and returning an AST node. Precedence
    // of constructs (for example, the fact that `!x[1]` means `!(x[1])`
    // instead of `(!x)[1]` is handled by the fact that the parser
    // function that parses unary prefix operators is called first, and
    // in turn calls the function that parses `[]` subscripts — that
    // way, it'll receive the node for `x[1]` already parsed, and wraps
    // *that* in the unary operator node.
    //
    // Acorn uses an [operator precedence parser][opp] to handle binary
    // operator precedence, because it is much more compact than using
    // the technique outlined above, which uses different, nesting
    // functions to specify precedence, for all of the ten binary
    // precedence levels that JavaScript defines.
    //
    // [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser
    var pp$5 = Parser$1.prototype;
    // Check if property name clashes with already added.
    // Object/class getters and setters are not allowed to clash —
    // either with each other or with an init property — and in
    // strict mode, init properties are also not allowed to be repeated.
    pp$5.checkPropClash = function(prop, propHash, refDestructuringErrors) {
        if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement") return;
        if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) return;
        var key = prop.key;
        var name;
        switch(key.type){
            case "Identifier":
                name = key.name;
                break;
            case "Literal":
                name = String(key.value);
                break;
            default:
                return;
        }
        var kind = prop.kind;
        if (this.options.ecmaVersion >= 6) {
            if (name === "__proto__" && kind === "init") {
                if (propHash.proto) {
                    if (refDestructuringErrors) {
                        if (refDestructuringErrors.doubleProto < 0) refDestructuringErrors.doubleProto = key.start;
                    } else this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
                }
                propHash.proto = true;
            }
            return;
        }
        name = "$" + name;
        var other = propHash[name];
        if (other) {
            var redefinition;
            if (kind === "init") redefinition = this.strict && other.init || other.get || other.set;
            else redefinition = other.init || other[kind];
            if (redefinition) this.raiseRecoverable(key.start, "Redefinition of property");
        } else other = propHash[name] = {
            init: false,
            get: false,
            set: false
        };
        other[kind] = true;
    };
    // ### Expression parsing
    // These nest, from the most general expression type at the top to
    // 'atomic', nondivisible expression types at the bottom. Most of
    // the functions will simply let the function(s) below them parse,
    // and, *if* the syntactic construct they handle is present, wrap
    // the AST node that the inner parser gave them in another node.
    // Parse a full expression. The optional arguments are used to
    // forbid the `in` operator (in for loops initalization expressions)
    // and provide reference for storing '=' operator inside shorthand
    // property assignment in contexts where both object expression
    // and object pattern might appear (so it's possible to raise
    // delayed syntax error at correct position).
    pp$5.parseExpression = function(forInit, refDestructuringErrors) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
        if (this.type === types$1.comma) {
            var node = this.startNodeAt(startPos, startLoc);
            node.expressions = [
                expr
            ];
            while(this.eat(types$1.comma))node.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors));
            return this.finishNode(node, "SequenceExpression");
        }
        return expr;
    };
    // Parse an assignment expression. This includes applications of
    // operators like `+=`.
    pp$5.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {
        if (this.isContextual("yield")) {
            if (this.inGenerator) return this.parseYield(forInit);
            else this.exprAllowed = false;
        }
        var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
        if (refDestructuringErrors) {
            oldParenAssign = refDestructuringErrors.parenthesizedAssign;
            oldTrailingComma = refDestructuringErrors.trailingComma;
            oldDoubleProto = refDestructuringErrors.doubleProto;
            refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
        } else {
            refDestructuringErrors = new DestructuringErrors;
            ownDestructuringErrors = true;
        }
        var startPos = this.start, startLoc = this.startLoc;
        if (this.type === types$1.parenL || this.type === types$1.name) {
            this.potentialArrowAt = this.start;
            this.potentialArrowInForAwait = forInit === "await";
        }
        var left = this.parseMaybeConditional(forInit, refDestructuringErrors);
        if (afterLeftParse) left = afterLeftParse.call(this, left, startPos, startLoc);
        if (this.type.isAssign) {
            var node = this.startNodeAt(startPos, startLoc);
            node.operator = this.value;
            if (this.type === types$1.eq) left = this.toAssignable(left, false, refDestructuringErrors);
            if (!ownDestructuringErrors) refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
            if (refDestructuringErrors.shorthandAssign >= left.start) refDestructuringErrors.shorthandAssign = -1;
             // reset because shorthand default was used correctly
            if (this.type === types$1.eq) this.checkLValPattern(left);
            else this.checkLValSimple(left);
            node.left = left;
            this.next();
            node.right = this.parseMaybeAssign(forInit);
            if (oldDoubleProto > -1) refDestructuringErrors.doubleProto = oldDoubleProto;
            return this.finishNode(node, "AssignmentExpression");
        } else if (ownDestructuringErrors) this.checkExpressionErrors(refDestructuringErrors, true);
        if (oldParenAssign > -1) refDestructuringErrors.parenthesizedAssign = oldParenAssign;
        if (oldTrailingComma > -1) refDestructuringErrors.trailingComma = oldTrailingComma;
        return left;
    };
    // Parse a ternary conditional (`?:`) operator.
    pp$5.parseMaybeConditional = function(forInit, refDestructuringErrors) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseExprOps(forInit, refDestructuringErrors);
        if (this.checkExpressionErrors(refDestructuringErrors)) return expr;
        if (this.eat(types$1.question)) {
            var node = this.startNodeAt(startPos, startLoc);
            node.test = expr;
            node.consequent = this.parseMaybeAssign();
            this.expect(types$1.colon);
            node.alternate = this.parseMaybeAssign(forInit);
            return this.finishNode(node, "ConditionalExpression");
        }
        return expr;
    };
    // Start the precedence parser.
    pp$5.parseExprOps = function(forInit, refDestructuringErrors) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);
        if (this.checkExpressionErrors(refDestructuringErrors)) return expr;
        return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit);
    };
    // Parse binary operators with the operator precedence parsing
    // algorithm. `left` is the left-hand side of the operator.
    // `minPrec` provides context that allows the function to stop and
    // defer further parser to one of its callers when it encounters an
    // operator that has a lower precedence than the set it is parsing.
    pp$5.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {
        var prec = this.type.binop;
        if (prec != null && (!forInit || this.type !== types$1._in)) {
            if (prec > minPrec) {
                var logical = this.type === types$1.logicalOR || this.type === types$1.logicalAND;
                var coalesce = this.type === types$1.coalesce;
                if (coalesce) // Handle the precedence of `tt.coalesce` as equal to the range of logical expressions.
                // In other words, `node.right` shouldn't contain logical expressions in order to check the mixed error.
                prec = types$1.logicalAND.binop;
                var op = this.value;
                this.next();
                var startPos = this.start, startLoc = this.startLoc;
                var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);
                var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
                if (logical && this.type === types$1.coalesce || coalesce && (this.type === types$1.logicalOR || this.type === types$1.logicalAND)) this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
                return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, forInit);
            }
        }
        return left;
    };
    pp$5.buildBinary = function(startPos, startLoc, left, right, op, logical) {
        if (right.type === "PrivateIdentifier") this.raise(right.start, "Private identifier can only be left side of binary expression");
        var node = this.startNodeAt(startPos, startLoc);
        node.left = left;
        node.operator = op;
        node.right = right;
        return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression");
    };
    // Parse unary operators, both prefix and postfix.
    pp$5.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {
        var startPos = this.start, startLoc = this.startLoc, expr;
        if (this.isContextual("await") && this.canAwait) {
            expr = this.parseAwait(forInit);
            sawUnary = true;
        } else if (this.type.prefix) {
            var node = this.startNode(), update = this.type === types$1.incDec;
            node.operator = this.value;
            node.prefix = true;
            this.next();
            node.argument = this.parseMaybeUnary(null, true, update, forInit);
            this.checkExpressionErrors(refDestructuringErrors, true);
            if (update) this.checkLValSimple(node.argument);
            else if (this.strict && node.operator === "delete" && node.argument.type === "Identifier") this.raiseRecoverable(node.start, "Deleting local variable in strict mode");
            else if (node.operator === "delete" && isPrivateFieldAccess(node.argument)) this.raiseRecoverable(node.start, "Private fields can not be deleted");
            else sawUnary = true;
            expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
        } else if (!sawUnary && this.type === types$1.privateId) {
            if ((forInit || this.privateNameStack.length === 0) && this.options.checkPrivateFields) this.unexpected();
            expr = this.parsePrivateIdent();
            // only could be private fields in 'in', such as #x in obj
            if (this.type !== types$1._in) this.unexpected();
        } else {
            expr = this.parseExprSubscripts(refDestructuringErrors, forInit);
            if (this.checkExpressionErrors(refDestructuringErrors)) return expr;
            while(this.type.postfix && !this.canInsertSemicolon()){
                var node$1 = this.startNodeAt(startPos, startLoc);
                node$1.operator = this.value;
                node$1.prefix = false;
                node$1.argument = expr;
                this.checkLValSimple(expr);
                this.next();
                expr = this.finishNode(node$1, "UpdateExpression");
            }
        }
        if (!incDec && this.eat(types$1.starstar)) {
            if (sawUnary) this.unexpected(this.lastTokStart);
            else return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), "**", false);
        } else return expr;
    };
    function isPrivateFieldAccess(node) {
        return node.type === "MemberExpression" && node.property.type === "PrivateIdentifier" || node.type === "ChainExpression" && isPrivateFieldAccess(node.expression);
    }
    // Parse call, dot, and `[]`-subscript expressions.
    pp$5.parseExprSubscripts = function(refDestructuringErrors, forInit) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseExprAtom(refDestructuringErrors, forInit);
        if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")") return expr;
        var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);
        if (refDestructuringErrors && result.type === "MemberExpression") {
            if (refDestructuringErrors.parenthesizedAssign >= result.start) refDestructuringErrors.parenthesizedAssign = -1;
            if (refDestructuringErrors.parenthesizedBind >= result.start) refDestructuringErrors.parenthesizedBind = -1;
            if (refDestructuringErrors.trailingComma >= result.start) refDestructuringErrors.trailingComma = -1;
        }
        return result;
    };
    pp$5.parseSubscripts = function(base, startPos, startLoc, noCalls, forInit) {
        var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" && this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && this.potentialArrowAt === base.start;
        var optionalChained = false;
        while(true){
            var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);
            if (element.optional) optionalChained = true;
            if (element === base || element.type === "ArrowFunctionExpression") {
                if (optionalChained) {
                    var chainNode = this.startNodeAt(startPos, startLoc);
                    chainNode.expression = element;
                    element = this.finishNode(chainNode, "ChainExpression");
                }
                return element;
            }
            base = element;
        }
    };
    pp$5.shouldParseAsyncArrow = function() {
        return !this.canInsertSemicolon() && this.eat(types$1.arrow);
    };
    pp$5.parseSubscriptAsyncArrow = function(startPos, startLoc, exprList, forInit) {
        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit);
    };
    pp$5.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
        var optionalSupported = this.options.ecmaVersion >= 11;
        var optional = optionalSupported && this.eat(types$1.questionDot);
        if (noCalls && optional) this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
        var computed = this.eat(types$1.bracketL);
        if (computed || optional && this.type !== types$1.parenL && this.type !== types$1.backQuote || this.eat(types$1.dot)) {
            var node = this.startNodeAt(startPos, startLoc);
            node.object = base;
            if (computed) {
                node.property = this.parseExpression();
                this.expect(types$1.bracketR);
            } else if (this.type === types$1.privateId && base.type !== "Super") node.property = this.parsePrivateIdent();
            else node.property = this.parseIdent(this.options.allowReserved !== "never");
            node.computed = !!computed;
            if (optionalSupported) node.optional = optional;
            base = this.finishNode(node, "MemberExpression");
        } else if (!noCalls && this.eat(types$1.parenL)) {
            var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
            this.yieldPos = 0;
            this.awaitPos = 0;
            this.awaitIdentPos = 0;
            var exprList = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
            if (maybeAsyncArrow && !optional && this.shouldParseAsyncArrow()) {
                this.checkPatternErrors(refDestructuringErrors, false);
                this.checkYieldAwaitInDefaultParams();
                if (this.awaitIdentPos > 0) this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function");
                this.yieldPos = oldYieldPos;
                this.awaitPos = oldAwaitPos;
                this.awaitIdentPos = oldAwaitIdentPos;
                return this.parseSubscriptAsyncArrow(startPos, startLoc, exprList, forInit);
            }
            this.checkExpressionErrors(refDestructuringErrors, true);
            this.yieldPos = oldYieldPos || this.yieldPos;
            this.awaitPos = oldAwaitPos || this.awaitPos;
            this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
            var node$1 = this.startNodeAt(startPos, startLoc);
            node$1.callee = base;
            node$1.arguments = exprList;
            if (optionalSupported) node$1.optional = optional;
            base = this.finishNode(node$1, "CallExpression");
        } else if (this.type === types$1.backQuote) {
            if (optional || optionalChained) this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
            var node$2 = this.startNodeAt(startPos, startLoc);
            node$2.tag = base;
            node$2.quasi = this.parseTemplate({
                isTagged: true
            });
            base = this.finishNode(node$2, "TaggedTemplateExpression");
        }
        return base;
    };
    // Parse an atomic expression — either a single token that is an
    // expression, an expression started by a keyword like `function` or
    // `new`, or an expression wrapped in punctuation like `()`, `[]`,
    // or `{}`.
    pp$5.parseExprAtom = function(refDestructuringErrors, forInit, forNew) {
        // If a division operator appears in an expression position, the
        // tokenizer got confused, and we force it to read a regexp instead.
        if (this.type === types$1.slash) this.readRegexp();
        var node, canBeArrow = this.potentialArrowAt === this.start;
        switch(this.type){
            case types$1._super:
                if (!this.allowSuper) this.raise(this.start, "'super' keyword outside a method");
                node = this.startNode();
                this.next();
                if (this.type === types$1.parenL && !this.allowDirectSuper) this.raise(node.start, "super() call outside constructor of a subclass");
                // The `super` keyword can appear at below:
                // SuperProperty:
                //     super [ Expression ]
                //     super . IdentifierName
                // SuperCall:
                //     super ( Arguments )
                if (this.type !== types$1.dot && this.type !== types$1.bracketL && this.type !== types$1.parenL) this.unexpected();
                return this.finishNode(node, "Super");
            case types$1._this:
                node = this.startNode();
                this.next();
                return this.finishNode(node, "ThisExpression");
            case types$1.name:
                var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
                var id = this.parseIdent(false);
                if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types$1._function)) {
                    this.overrideContext(types.f_expr);
                    return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit);
                }
                if (canBeArrow && !this.canInsertSemicolon()) {
                    if (this.eat(types$1.arrow)) return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [
                        id
                    ], false, forInit);
                    if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types$1.name && !containsEsc && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
                        id = this.parseIdent(false);
                        if (this.canInsertSemicolon() || !this.eat(types$1.arrow)) this.unexpected();
                        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [
                            id
                        ], true, forInit);
                    }
                }
                return id;
            case types$1.regexp:
                var value = this.value;
                node = this.parseLiteral(value.value);
                node.regex = {
                    pattern: value.pattern,
                    flags: value.flags
                };
                return node;
            case types$1.num:
            case types$1.string:
                return this.parseLiteral(this.value);
            case types$1._null:
            case types$1._true:
            case types$1._false:
                node = this.startNode();
                node.value = this.type === types$1._null ? null : this.type === types$1._true;
                node.raw = this.type.keyword;
                this.next();
                return this.finishNode(node, "Literal");
            case types$1.parenL:
                var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);
                if (refDestructuringErrors) {
                    if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) refDestructuringErrors.parenthesizedAssign = start;
                    if (refDestructuringErrors.parenthesizedBind < 0) refDestructuringErrors.parenthesizedBind = start;
                }
                return expr;
            case types$1.bracketL:
                node = this.startNode();
                this.next();
                node.elements = this.parseExprList(types$1.bracketR, true, true, refDestructuringErrors);
                return this.finishNode(node, "ArrayExpression");
            case types$1.braceL:
                this.overrideContext(types.b_expr);
                return this.parseObj(false, refDestructuringErrors);
            case types$1._function:
                node = this.startNode();
                this.next();
                return this.parseFunction(node, 0);
            case types$1._class:
                return this.parseClass(this.startNode(), false);
            case types$1._new:
                return this.parseNew();
            case types$1.backQuote:
                return this.parseTemplate();
            case types$1._import:
                if (this.options.ecmaVersion >= 11) return this.parseExprImport(forNew);
                else return this.unexpected();
            default:
                return this.parseExprAtomDefault();
        }
    };
    pp$5.parseExprAtomDefault = function() {
        this.unexpected();
    };
    pp$5.parseExprImport = function(forNew) {
        var node = this.startNode();
        // Consume `import` as an identifier for `import.meta`.
        // Because `this.parseIdent(true)` doesn't check escape sequences, it needs the check of `this.containsEsc`.
        if (this.containsEsc) this.raiseRecoverable(this.start, "Escape sequence in keyword import");
        this.next();
        if (this.type === types$1.parenL && !forNew) return this.parseDynamicImport(node);
        else if (this.type === types$1.dot) {
            var meta = this.startNodeAt(node.start, node.loc && node.loc.start);
            meta.name = "import";
            node.meta = this.finishNode(meta, "Identifier");
            return this.parseImportMeta(node);
        } else this.unexpected();
    };
    pp$5.parseDynamicImport = function(node) {
        this.next(); // skip `(`
        // Parse node.source.
        node.source = this.parseMaybeAssign();
        // Verify ending.
        if (!this.eat(types$1.parenR)) {
            var errorPos = this.start;
            if (this.eat(types$1.comma) && this.eat(types$1.parenR)) this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
            else this.unexpected(errorPos);
        }
        return this.finishNode(node, "ImportExpression");
    };
    pp$5.parseImportMeta = function(node) {
        this.next(); // skip `.`
        var containsEsc = this.containsEsc;
        node.property = this.parseIdent(true);
        if (node.property.name !== "meta") this.raiseRecoverable(node.property.start, "The only valid meta property for import is 'import.meta'");
        if (containsEsc) this.raiseRecoverable(node.start, "'import.meta' must not contain escaped characters");
        if (this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere) this.raiseRecoverable(node.start, "Cannot use 'import.meta' outside a module");
        return this.finishNode(node, "MetaProperty");
    };
    pp$5.parseLiteral = function(value) {
        var node = this.startNode();
        node.value = value;
        node.raw = this.input.slice(this.start, this.end);
        if (node.raw.charCodeAt(node.raw.length - 1) === 110) node.bigint = node.raw.slice(0, -1).replace(/_/g, "");
        this.next();
        return this.finishNode(node, "Literal");
    };
    pp$5.parseParenExpression = function() {
        this.expect(types$1.parenL);
        var val = this.parseExpression();
        this.expect(types$1.parenR);
        return val;
    };
    pp$5.shouldParseArrow = function(exprList) {
        return !this.canInsertSemicolon();
    };
    pp$5.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {
        var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
        if (this.options.ecmaVersion >= 6) {
            this.next();
            var innerStartPos = this.start, innerStartLoc = this.startLoc;
            var exprList = [], first = true, lastIsComma = false;
            var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
            this.yieldPos = 0;
            this.awaitPos = 0;
            // Do not save awaitIdentPos to allow checking awaits nested in parameters
            while(this.type !== types$1.parenR){
                first ? first = false : this.expect(types$1.comma);
                if (allowTrailingComma && this.afterTrailingComma(types$1.parenR, true)) {
                    lastIsComma = true;
                    break;
                } else if (this.type === types$1.ellipsis) {
                    spreadStart = this.start;
                    exprList.push(this.parseParenItem(this.parseRestBinding()));
                    if (this.type === types$1.comma) this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
                    break;
                } else exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
            }
            var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
            this.expect(types$1.parenR);
            if (canBeArrow && this.shouldParseArrow(exprList) && this.eat(types$1.arrow)) {
                this.checkPatternErrors(refDestructuringErrors, false);
                this.checkYieldAwaitInDefaultParams();
                this.yieldPos = oldYieldPos;
                this.awaitPos = oldAwaitPos;
                return this.parseParenArrowList(startPos, startLoc, exprList, forInit);
            }
            if (!exprList.length || lastIsComma) this.unexpected(this.lastTokStart);
            if (spreadStart) this.unexpected(spreadStart);
            this.checkExpressionErrors(refDestructuringErrors, true);
            this.yieldPos = oldYieldPos || this.yieldPos;
            this.awaitPos = oldAwaitPos || this.awaitPos;
            if (exprList.length > 1) {
                val = this.startNodeAt(innerStartPos, innerStartLoc);
                val.expressions = exprList;
                this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
            } else val = exprList[0];
        } else val = this.parseParenExpression();
        if (this.options.preserveParens) {
            var par = this.startNodeAt(startPos, startLoc);
            par.expression = val;
            return this.finishNode(par, "ParenthesizedExpression");
        } else return val;
    };
    pp$5.parseParenItem = function(item) {
        return item;
    };
    pp$5.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {
        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit);
    };
    // New's precedence is slightly tricky. It must allow its argument to
    // be a `[]` or dot subscript expression, but not a call — at least,
    // not without wrapping it in parentheses. Thus, it uses the noCalls
    // argument to parseSubscripts to prevent it from consuming the
    // argument list.
    var empty = [];
    pp$5.parseNew = function() {
        if (this.containsEsc) this.raiseRecoverable(this.start, "Escape sequence in keyword new");
        var node = this.startNode();
        this.next();
        if (this.options.ecmaVersion >= 6 && this.type === types$1.dot) {
            var meta = this.startNodeAt(node.start, node.loc && node.loc.start);
            meta.name = "new";
            node.meta = this.finishNode(meta, "Identifier");
            this.next();
            var containsEsc = this.containsEsc;
            node.property = this.parseIdent(true);
            if (node.property.name !== "target") this.raiseRecoverable(node.property.start, "The only valid meta property for new is 'new.target'");
            if (containsEsc) this.raiseRecoverable(node.start, "'new.target' must not contain escaped characters");
            if (!this.allowNewDotTarget) this.raiseRecoverable(node.start, "'new.target' can only be used in functions and class static block");
            return this.finishNode(node, "MetaProperty");
        }
        var startPos = this.start, startLoc = this.startLoc;
        node.callee = this.parseSubscripts(this.parseExprAtom(null, false, true), startPos, startLoc, true, false);
        if (this.eat(types$1.parenL)) node.arguments = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false);
        else node.arguments = empty;
        return this.finishNode(node, "NewExpression");
    };
    // Parse template expression.
    pp$5.parseTemplateElement = function(ref) {
        var isTagged = ref.isTagged;
        var elem = this.startNode();
        if (this.type === types$1.invalidTemplate) {
            if (!isTagged) this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
            elem.value = {
                raw: this.value,
                cooked: null
            };
        } else elem.value = {
            raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
            cooked: this.value
        };
        this.next();
        elem.tail = this.type === types$1.backQuote;
        return this.finishNode(elem, "TemplateElement");
    };
    pp$5.parseTemplate = function(ref) {
        if (ref === void 0) ref = {};
        var isTagged = ref.isTagged;
        if (isTagged === void 0) isTagged = false;
        var node = this.startNode();
        this.next();
        node.expressions = [];
        var curElt = this.parseTemplateElement({
            isTagged: isTagged
        });
        node.quasis = [
            curElt
        ];
        while(!curElt.tail){
            if (this.type === types$1.eof) this.raise(this.pos, "Unterminated template literal");
            this.expect(types$1.dollarBraceL);
            node.expressions.push(this.parseExpression());
            this.expect(types$1.braceR);
            node.quasis.push(curElt = this.parseTemplateElement({
                isTagged: isTagged
            }));
        }
        this.next();
        return this.finishNode(node, "TemplateLiteral");
    };
    pp$5.isAsyncProp = function(prop) {
        return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" && (this.type === types$1.name || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types$1.star) && !lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
    };
    // Parse an object literal or binding pattern.
    pp$5.parseObj = function(isPattern, refDestructuringErrors) {
        var node = this.startNode(), first = true, propHash = {};
        node.properties = [];
        this.next();
        while(!this.eat(types$1.braceR)){
            if (!first) {
                this.expect(types$1.comma);
                if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$1.braceR)) break;
            } else first = false;
            var prop = this.parseProperty(isPattern, refDestructuringErrors);
            if (!isPattern) this.checkPropClash(prop, propHash, refDestructuringErrors);
            node.properties.push(prop);
        }
        return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
    };
    pp$5.parseProperty = function(isPattern, refDestructuringErrors) {
        var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
        if (this.options.ecmaVersion >= 9 && this.eat(types$1.ellipsis)) {
            if (isPattern) {
                prop.argument = this.parseIdent(false);
                if (this.type === types$1.comma) this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
                return this.finishNode(prop, "RestElement");
            }
            // Parse argument.
            prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
            // To disallow trailing comma via `this.toAssignable()`.
            if (this.type === types$1.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) refDestructuringErrors.trailingComma = this.start;
            // Finish
            return this.finishNode(prop, "SpreadElement");
        }
        if (this.options.ecmaVersion >= 6) {
            prop.method = false;
            prop.shorthand = false;
            if (isPattern || refDestructuringErrors) {
                startPos = this.start;
                startLoc = this.startLoc;
            }
            if (!isPattern) isGenerator = this.eat(types$1.star);
        }
        var containsEsc = this.containsEsc;
        this.parsePropertyName(prop);
        if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
            isAsync = true;
            isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$1.star);
            this.parsePropertyName(prop);
        } else isAsync = false;
        this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
        return this.finishNode(prop, "Property");
    };
    pp$5.parseGetterSetter = function(prop) {
        prop.kind = prop.key.name;
        this.parsePropertyName(prop);
        prop.value = this.parseMethod(false);
        var paramCount = prop.kind === "get" ? 0 : 1;
        if (prop.value.params.length !== paramCount) {
            var start = prop.value.start;
            if (prop.kind === "get") this.raiseRecoverable(start, "getter should have no params");
            else this.raiseRecoverable(start, "setter should have exactly one param");
        } else if (prop.kind === "set" && prop.value.params[0].type === "RestElement") this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
    };
    pp$5.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
        if ((isGenerator || isAsync) && this.type === types$1.colon) this.unexpected();
        if (this.eat(types$1.colon)) {
            prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
            prop.kind = "init";
        } else if (this.options.ecmaVersion >= 6 && this.type === types$1.parenL) {
            if (isPattern) this.unexpected();
            prop.kind = "init";
            prop.method = true;
            prop.value = this.parseMethod(isGenerator, isAsync);
        } else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && this.type !== types$1.comma && this.type !== types$1.braceR && this.type !== types$1.eq) {
            if (isGenerator || isAsync) this.unexpected();
            this.parseGetterSetter(prop);
        } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
            if (isGenerator || isAsync) this.unexpected();
            this.checkUnreserved(prop.key);
            if (prop.key.name === "await" && !this.awaitIdentPos) this.awaitIdentPos = startPos;
            prop.kind = "init";
            if (isPattern) prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
            else if (this.type === types$1.eq && refDestructuringErrors) {
                if (refDestructuringErrors.shorthandAssign < 0) refDestructuringErrors.shorthandAssign = this.start;
                prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
            } else prop.value = this.copyNode(prop.key);
            prop.shorthand = true;
        } else this.unexpected();
    };
    pp$5.parsePropertyName = function(prop) {
        if (this.options.ecmaVersion >= 6) {
            if (this.eat(types$1.bracketL)) {
                prop.computed = true;
                prop.key = this.parseMaybeAssign();
                this.expect(types$1.bracketR);
                return prop.key;
            } else prop.computed = false;
        }
        return prop.key = this.type === types$1.num || this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
    };
    // Initialize empty function node.
    pp$5.initFunction = function(node) {
        node.id = null;
        if (this.options.ecmaVersion >= 6) node.generator = node.expression = false;
        if (this.options.ecmaVersion >= 8) node.async = false;
    };
    // Parse object or class method.
    pp$5.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
        var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.initFunction(node);
        if (this.options.ecmaVersion >= 6) node.generator = isGenerator;
        if (this.options.ecmaVersion >= 8) node.async = !!isAsync;
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
        this.expect(types$1.parenL);
        node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
        this.checkYieldAwaitInDefaultParams();
        this.parseFunctionBody(node, false, true, false);
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.finishNode(node, "FunctionExpression");
    };
    // Parse arrow function expression with given parameters.
    pp$5.parseArrowExpression = function(node, params, isAsync, forInit) {
        var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
        this.initFunction(node);
        if (this.options.ecmaVersion >= 8) node.async = !!isAsync;
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        node.params = this.toAssignableList(params, true);
        this.parseFunctionBody(node, true, false, forInit);
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.finishNode(node, "ArrowFunctionExpression");
    };
    // Parse function body and check parameters.
    pp$5.parseFunctionBody = function(node, isArrowFunction, isMethod, forInit) {
        var isExpression = isArrowFunction && this.type !== types$1.braceL;
        var oldStrict = this.strict, useStrict = false;
        if (isExpression) {
            node.body = this.parseMaybeAssign(forInit);
            node.expression = true;
            this.checkParams(node, false);
        } else {
            var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
            if (!oldStrict || nonSimple) {
                useStrict = this.strictDirective(this.end);
                // If this is a strict mode function, verify that argument names
                // are not repeated, and it does not try to bind the words `eval`
                // or `arguments`.
                if (useStrict && nonSimple) this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list");
            }
            // Start a new scope with regard to labels and the `inFunction`
            // flag (restore them to their old value afterwards).
            var oldLabels = this.labels;
            this.labels = [];
            if (useStrict) this.strict = true;
            // Add the params to varDeclaredNames to ensure that an error is thrown
            // if a let/const declaration in the function clashes with one of the params.
            this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));
            // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'
            if (this.strict && node.id) this.checkLValSimple(node.id, BIND_OUTSIDE);
            node.body = this.parseBlock(false, undefined, useStrict && !oldStrict);
            node.expression = false;
            this.adaptDirectivePrologue(node.body.body);
            this.labels = oldLabels;
        }
        this.exitScope();
    };
    pp$5.isSimpleParamList = function(params) {
        for(var i = 0, list = params; i < list.length; i += 1){
            var param = list[i];
            if (param.type !== "Identifier") return false;
        }
        return true;
    };
    // Checks function params for various disallowed patterns such as using "eval"
    // or "arguments" and duplicate parameters.
    pp$5.checkParams = function(node, allowDuplicates) {
        var nameHash = Object.create(null);
        for(var i = 0, list = node.params; i < list.length; i += 1){
            var param = list[i];
            this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);
        }
    };
    // Parses a comma-separated list of expressions, and returns them as
    // an array. `close` is the token type that ends the list, and
    // `allowEmpty` can be turned on to allow subsequent commas with
    // nothing in between them to be parsed as `null` (which is needed
    // for array literals).
    pp$5.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
        var elts = [], first = true;
        while(!this.eat(close)){
            if (!first) {
                this.expect(types$1.comma);
                if (allowTrailingComma && this.afterTrailingComma(close)) break;
            } else first = false;
            var elt = void 0;
            if (allowEmpty && this.type === types$1.comma) elt = null;
            else if (this.type === types$1.ellipsis) {
                elt = this.parseSpread(refDestructuringErrors);
                if (refDestructuringErrors && this.type === types$1.comma && refDestructuringErrors.trailingComma < 0) refDestructuringErrors.trailingComma = this.start;
            } else elt = this.parseMaybeAssign(false, refDestructuringErrors);
            elts.push(elt);
        }
        return elts;
    };
    pp$5.checkUnreserved = function(ref) {
        var start = ref.start;
        var end = ref.end;
        var name = ref.name;
        if (this.inGenerator && name === "yield") this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator");
        if (this.inAsync && name === "await") this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function");
        if (this.currentThisScope().inClassFieldInit && name === "arguments") this.raiseRecoverable(start, "Cannot use 'arguments' in class field initializer");
        if (this.inClassStaticBlock && (name === "arguments" || name === "await")) this.raise(start, "Cannot use " + name + " in class static initialization block");
        if (this.keywords.test(name)) this.raise(start, "Unexpected keyword '" + name + "'");
        if (this.options.ecmaVersion < 6 && this.input.slice(start, end).indexOf("\\") !== -1) return;
        var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
        if (re.test(name)) {
            if (!this.inAsync && name === "await") this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function");
            this.raiseRecoverable(start, "The keyword '" + name + "' is reserved");
        }
    };
    // Parse the next token as an identifier. If `liberal` is true (used
    // when parsing properties), it will also convert keywords into
    // identifiers.
    pp$5.parseIdent = function(liberal) {
        var node = this.parseIdentNode();
        this.next(!!liberal);
        this.finishNode(node, "Identifier");
        if (!liberal) {
            this.checkUnreserved(node);
            if (node.name === "await" && !this.awaitIdentPos) this.awaitIdentPos = node.start;
        }
        return node;
    };
    pp$5.parseIdentNode = function() {
        var node = this.startNode();
        if (this.type === types$1.name) node.name = this.value;
        else if (this.type.keyword) {
            node.name = this.type.keyword;
            // To fix https://github.com/acornjs/acorn/issues/575
            // `class` and `function` keywords push new context into this.context.
            // But there is no chance to pop the context if the keyword is consumed as an identifier such as a property name.
            // If the previous token is a dot, this does not apply because the context-managing code already ignored the keyword
            if ((node.name === "class" || node.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) this.context.pop();
            this.type = types$1.name;
        } else this.unexpected();
        return node;
    };
    pp$5.parsePrivateIdent = function() {
        var node = this.startNode();
        if (this.type === types$1.privateId) node.name = this.value;
        else this.unexpected();
        this.next();
        this.finishNode(node, "PrivateIdentifier");
        // For validating existence
        if (this.options.checkPrivateFields) {
            if (this.privateNameStack.length === 0) this.raise(node.start, "Private field '#" + node.name + "' must be declared in an enclosing class");
            else this.privateNameStack[this.privateNameStack.length - 1].used.push(node);
        }
        return node;
    };
    // Parses yield expression inside generator.
    pp$5.parseYield = function(forInit) {
        if (!this.yieldPos) this.yieldPos = this.start;
        var node = this.startNode();
        this.next();
        if (this.type === types$1.semi || this.canInsertSemicolon() || this.type !== types$1.star && !this.type.startsExpr) {
            node.delegate = false;
            node.argument = null;
        } else {
            node.delegate = this.eat(types$1.star);
            node.argument = this.parseMaybeAssign(forInit);
        }
        return this.finishNode(node, "YieldExpression");
    };
    pp$5.parseAwait = function(forInit) {
        if (!this.awaitPos) this.awaitPos = this.start;
        var node = this.startNode();
        this.next();
        node.argument = this.parseMaybeUnary(null, true, false, forInit);
        return this.finishNode(node, "AwaitExpression");
    };
    var pp$4 = Parser$1.prototype;
    // This function is used to raise exceptions on parse errors. It
    // takes an offset integer (into the current `input`) to indicate
    // the location of the error, attaches the position to the end
    // of the error message, and then raises a `SyntaxError` with that
    // message.
    pp$4.raise = function(pos, message) {
        var loc = getLineInfo(this.input, pos);
        message += " (" + loc.line + ":" + loc.column + ")";
        var err = new SyntaxError(message);
        err.pos = pos;
        err.loc = loc;
        err.raisedAt = this.pos;
        throw err;
    };
    pp$4.raiseRecoverable = pp$4.raise;
    pp$4.curPosition = function() {
        if (this.options.locations) return new Position(this.curLine, this.pos - this.lineStart);
    };
    var pp$3 = Parser$1.prototype;
    var Scope$1 = function Scope(flags) {
        this.flags = flags;
        // A list of var-declared names in the current lexical scope
        this.var = [];
        // A list of lexically-declared names in the current lexical scope
        this.lexical = [];
        // A list of lexically-declared FunctionDeclaration names in the current lexical scope
        this.functions = [];
        // A switch to disallow the identifier reference 'arguments'
        this.inClassFieldInit = false;
    };
    // The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.
    pp$3.enterScope = function(flags) {
        this.scopeStack.push(new Scope$1(flags));
    };
    pp$3.exitScope = function() {
        this.scopeStack.pop();
    };
    // The spec says:
    // > At the top level of a function, or script, function declarations are
    // > treated like var declarations rather than like lexical declarations.
    pp$3.treatFunctionsAsVarInScope = function(scope) {
        return scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_TOP;
    };
    pp$3.declareName = function(name, bindingType, pos) {
        var redeclared = false;
        if (bindingType === BIND_LEXICAL) {
            var scope = this.currentScope();
            redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
            scope.lexical.push(name);
            if (this.inModule && scope.flags & SCOPE_TOP) delete this.undefinedExports[name];
        } else if (bindingType === BIND_SIMPLE_CATCH) {
            var scope$1 = this.currentScope();
            scope$1.lexical.push(name);
        } else if (bindingType === BIND_FUNCTION) {
            var scope$2 = this.currentScope();
            if (this.treatFunctionsAsVar) redeclared = scope$2.lexical.indexOf(name) > -1;
            else redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1;
            scope$2.functions.push(name);
        } else for(var i = this.scopeStack.length - 1; i >= 0; --i){
            var scope$3 = this.scopeStack[i];
            if (scope$3.lexical.indexOf(name) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH && scope$3.lexical[0] === name) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
                redeclared = true;
                break;
            }
            scope$3.var.push(name);
            if (this.inModule && scope$3.flags & SCOPE_TOP) delete this.undefinedExports[name];
            if (scope$3.flags & SCOPE_VAR) break;
        }
        if (redeclared) this.raiseRecoverable(pos, "Identifier '" + name + "' has already been declared");
    };
    pp$3.checkLocalExport = function(id) {
        // scope.functions must be empty as Module code is always strict.
        if (this.scopeStack[0].lexical.indexOf(id.name) === -1 && this.scopeStack[0].var.indexOf(id.name) === -1) this.undefinedExports[id.name] = id;
    };
    pp$3.currentScope = function() {
        return this.scopeStack[this.scopeStack.length - 1];
    };
    pp$3.currentVarScope = function() {
        for(var i = this.scopeStack.length - 1;; i--){
            var scope = this.scopeStack[i];
            if (scope.flags & SCOPE_VAR) return scope;
        }
    };
    // Could be useful for `this`, `new.target`, `super()`, `super.property`, and `super[property]`.
    pp$3.currentThisScope = function() {
        for(var i = this.scopeStack.length - 1;; i--){
            var scope = this.scopeStack[i];
            if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) return scope;
        }
    };
    var Node$1 = function Node(parser, pos, loc) {
        this.type = "";
        this.start = pos;
        this.end = 0;
        if (parser.options.locations) this.loc = new SourceLocation(parser, loc);
        if (parser.options.directSourceFile) this.sourceFile = parser.options.directSourceFile;
        if (parser.options.ranges) this.range = [
            pos,
            0
        ];
    };
    // Start an AST node, attaching a start offset.
    var pp$2 = Parser$1.prototype;
    pp$2.startNode = function() {
        return new Node$1(this, this.start, this.startLoc);
    };
    pp$2.startNodeAt = function(pos, loc) {
        return new Node$1(this, pos, loc);
    };
    // Finish an AST node, adding `type` and `end` properties.
    function finishNodeAt(node, type, pos, loc) {
        node.type = type;
        node.end = pos;
        if (this.options.locations) node.loc.end = loc;
        if (this.options.ranges) node.range[1] = pos;
        return node;
    }
    pp$2.finishNode = function(node, type) {
        return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc);
    };
    // Finish node at given position
    pp$2.finishNodeAt = function(node, type, pos, loc) {
        return finishNodeAt.call(this, node, type, pos, loc);
    };
    pp$2.copyNode = function(node) {
        var newNode = new Node$1(this, node.start, this.startLoc);
        for(var prop in node)newNode[prop] = node[prop];
        return newNode;
    };
    // This file contains Unicode properties extracted from the ECMAScript specification.
    // The lists are extracted like so:
    // $$('#table-binary-unicode-properties > figure > table > tbody > tr > td:nth-child(1) code').map(el => el.innerText)
    // #table-binary-unicode-properties
    var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
    var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
    var ecma11BinaryProperties = ecma10BinaryProperties;
    var ecma12BinaryProperties = ecma11BinaryProperties + " EBase EComp EMod EPres ExtPict";
    var ecma13BinaryProperties = ecma12BinaryProperties;
    var ecma14BinaryProperties = ecma13BinaryProperties;
    var unicodeBinaryProperties = {
        9: ecma9BinaryProperties,
        10: ecma10BinaryProperties,
        11: ecma11BinaryProperties,
        12: ecma12BinaryProperties,
        13: ecma13BinaryProperties,
        14: ecma14BinaryProperties
    };
    // #table-binary-unicode-properties-of-strings
    var ecma14BinaryPropertiesOfStrings = "Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji";
    var unicodeBinaryPropertiesOfStrings = {
        9: "",
        10: "",
        11: "",
        12: "",
        13: "",
        14: ecma14BinaryPropertiesOfStrings
    };
    // #table-unicode-general-category-values
    var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";
    // #table-unicode-script-values
    var ecma9ScriptValues = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
    var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
    var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
    var ecma12ScriptValues = ecma11ScriptValues + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
    var ecma13ScriptValues = ecma12ScriptValues + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith";
    var ecma14ScriptValues = ecma13ScriptValues + " Hrkt Katakana_Or_Hiragana Kawi Nag_Mundari Nagm Unknown Zzzz";
    var unicodeScriptValues = {
        9: ecma9ScriptValues,
        10: ecma10ScriptValues,
        11: ecma11ScriptValues,
        12: ecma12ScriptValues,
        13: ecma13ScriptValues,
        14: ecma14ScriptValues
    };
    var data = {};
    function buildUnicodeData(ecmaVersion) {
        var d = data[ecmaVersion] = {
            binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + " " + unicodeGeneralCategoryValues),
            binaryOfStrings: wordsRegexp(unicodeBinaryPropertiesOfStrings[ecmaVersion]),
            nonBinary: {
                General_Category: wordsRegexp(unicodeGeneralCategoryValues),
                Script: wordsRegexp(unicodeScriptValues[ecmaVersion])
            }
        };
        d.nonBinary.Script_Extensions = d.nonBinary.Script;
        d.nonBinary.gc = d.nonBinary.General_Category;
        d.nonBinary.sc = d.nonBinary.Script;
        d.nonBinary.scx = d.nonBinary.Script_Extensions;
    }
    for(var i$2 = 0, list$1 = [
        9,
        10,
        11,
        12,
        13,
        14
    ]; i$2 < list$1.length; i$2 += 1){
        var ecmaVersion = list$1[i$2];
        buildUnicodeData(ecmaVersion);
    }
    var pp$1 = Parser$1.prototype;
    var RegExpValidationState = function RegExpValidationState(parser) {
        this.parser = parser;
        this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "") + (parser.options.ecmaVersion >= 13 ? "d" : "") + (parser.options.ecmaVersion >= 15 ? "v" : "");
        this.unicodeProperties = data[parser.options.ecmaVersion >= 14 ? 14 : parser.options.ecmaVersion];
        this.source = "";
        this.flags = "";
        this.start = 0;
        this.switchU = false;
        this.switchV = false;
        this.switchN = false;
        this.pos = 0;
        this.lastIntValue = 0;
        this.lastStringValue = "";
        this.lastAssertionIsQuantifiable = false;
        this.numCapturingParens = 0;
        this.maxBackReference = 0;
        this.groupNames = [];
        this.backReferenceNames = [];
    };
    RegExpValidationState.prototype.reset = function reset(start, pattern, flags) {
        var unicodeSets = flags.indexOf("v") !== -1;
        var unicode = flags.indexOf("u") !== -1;
        this.start = start | 0;
        this.source = pattern + "";
        this.flags = flags;
        if (unicodeSets && this.parser.options.ecmaVersion >= 15) {
            this.switchU = true;
            this.switchV = true;
            this.switchN = true;
        } else {
            this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
            this.switchV = false;
            this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
        }
    };
    RegExpValidationState.prototype.raise = function raise(message) {
        this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + message);
    };
    // If u flag is given, this returns the code point at the index (it combines a surrogate pair).
    // Otherwise, this returns the code unit of the index (can be a part of a surrogate pair).
    RegExpValidationState.prototype.at = function at(i, forceU) {
        if (forceU === void 0) forceU = false;
        var s = this.source;
        var l = s.length;
        if (i >= l) return -1;
        var c = s.charCodeAt(i);
        if (!(forceU || this.switchU) || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) return c;
        var next = s.charCodeAt(i + 1);
        return next >= 0xDC00 && next <= 0xDFFF ? (c << 10) + next - 0x35FDC00 : c;
    };
    RegExpValidationState.prototype.nextIndex = function nextIndex(i, forceU) {
        if (forceU === void 0) forceU = false;
        var s = this.source;
        var l = s.length;
        if (i >= l) return l;
        var c = s.charCodeAt(i), next;
        if (!(forceU || this.switchU) || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l || (next = s.charCodeAt(i + 1)) < 0xDC00 || next > 0xDFFF) return i + 1;
        return i + 2;
    };
    RegExpValidationState.prototype.current = function current(forceU) {
        if (forceU === void 0) forceU = false;
        return this.at(this.pos, forceU);
    };
    RegExpValidationState.prototype.lookahead = function lookahead(forceU) {
        if (forceU === void 0) forceU = false;
        return this.at(this.nextIndex(this.pos, forceU), forceU);
    };
    RegExpValidationState.prototype.advance = function advance(forceU) {
        if (forceU === void 0) forceU = false;
        this.pos = this.nextIndex(this.pos, forceU);
    };
    RegExpValidationState.prototype.eat = function eat(ch, forceU) {
        if (forceU === void 0) forceU = false;
        if (this.current(forceU) === ch) {
            this.advance(forceU);
            return true;
        }
        return false;
    };
    RegExpValidationState.prototype.eatChars = function eatChars(chs, forceU) {
        if (forceU === void 0) forceU = false;
        var pos = this.pos;
        for(var i = 0, list = chs; i < list.length; i += 1){
            var ch = list[i];
            var current = this.at(pos, forceU);
            if (current === -1 || current !== ch) return false;
            pos = this.nextIndex(pos, forceU);
        }
        this.pos = pos;
        return true;
    };
    /**
 * Validate the flags part of a given RegExpLiteral.
 *
 * @param {RegExpValidationState} state The state to validate RegExp.
 * @returns {void}
 */ pp$1.validateRegExpFlags = function(state) {
        var validFlags = state.validFlags;
        var flags = state.flags;
        var u = false;
        var v = false;
        for(var i = 0; i < flags.length; i++){
            var flag = flags.charAt(i);
            if (validFlags.indexOf(flag) === -1) this.raise(state.start, "Invalid regular expression flag");
            if (flags.indexOf(flag, i + 1) > -1) this.raise(state.start, "Duplicate regular expression flag");
            if (flag === "u") u = true;
            if (flag === "v") v = true;
        }
        if (this.options.ecmaVersion >= 15 && u && v) this.raise(state.start, "Invalid regular expression flag");
    };
    /**
 * Validate the pattern part of a given RegExpLiteral.
 *
 * @param {RegExpValidationState} state The state to validate RegExp.
 * @returns {void}
 */ pp$1.validateRegExpPattern = function(state) {
        this.regexp_pattern(state);
        // The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of
        // parsing contains a |GroupName|, reparse with the goal symbol
        // |Pattern[~U, +N]| and use this result instead. Throw a *SyntaxError*
        // exception if _P_ did not conform to the grammar, if any elements of _P_
        // were not matched by the parse, or if any Early Error conditions exist.
        if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {
            state.switchN = true;
            this.regexp_pattern(state);
        }
    };
    // https://www.ecma-international.org/ecma-262/8.0/#prod-Pattern
    pp$1.regexp_pattern = function(state) {
        state.pos = 0;
        state.lastIntValue = 0;
        state.lastStringValue = "";
        state.lastAssertionIsQuantifiable = false;
        state.numCapturingParens = 0;
        state.maxBackReference = 0;
        state.groupNames.length = 0;
        state.backReferenceNames.length = 0;
        this.regexp_disjunction(state);
        if (state.pos !== state.source.length) {
            // Make the same messages as V8.
            if (state.eat(0x29 /* ) */ )) state.raise("Unmatched ')'");
            if (state.eat(0x5D /* ] */ ) || state.eat(0x7D /* } */ )) state.raise("Lone quantifier brackets");
        }
        if (state.maxBackReference > state.numCapturingParens) state.raise("Invalid escape");
        for(var i = 0, list = state.backReferenceNames; i < list.length; i += 1){
            var name = list[i];
            if (state.groupNames.indexOf(name) === -1) state.raise("Invalid named capture referenced");
        }
    };
    // https://www.ecma-international.org/ecma-262/8.0/#prod-Disjunction
    pp$1.regexp_disjunction = function(state) {
        this.regexp_alternative(state);
        while(state.eat(0x7C /* | */ ))this.regexp_alternative(state);
        // Make the same message as V8.
        if (this.regexp_eatQuantifier(state, true)) state.raise("Nothing to repeat");
        if (state.eat(0x7B /* { */ )) state.raise("Lone quantifier brackets");
    };
    // https://www.ecma-international.org/ecma-262/8.0/#prod-Alternative
    pp$1.regexp_alternative = function(state) {
        while(state.pos < state.source.length && this.regexp_eatTerm(state));
    };
    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Term
    pp$1.regexp_eatTerm = function(state) {
        if (this.regexp_eatAssertion(state)) {
            // Handle `QuantifiableAssertion Quantifier` alternative.
            // `state.lastAssertionIsQuantifiable` is true if the last eaten Assertion
            // is a QuantifiableAssertion.
            if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) // Make the same message as V8.
            {
                if (state.switchU) state.raise("Invalid quantifier");
            }
            return true;
        }
        if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
            this.regexp_eatQuantifier(state);
            return true;
        }
        return false;
    };
    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Assertion
    pp$1.regexp_eatAssertion = function(state) {
        var start = state.pos;
        state.lastAssertionIsQuantifiable = false;
        // ^, $
        if (state.eat(0x5E /* ^ */ ) || state.eat(0x24 /* $ */ )) return true;
        // \b \B
        if (state.eat(0x5C /* \ */ )) {
            if (state.eat(0x42 /* B */ ) || state.eat(0x62 /* b */ )) return true;
            state.pos = start;
        }
        // Lookahead / Lookbehind
        if (state.eat(0x28 /* ( */ ) && state.eat(0x3F /* ? */ )) {
            var lookbehind = false;
            if (this.options.ecmaVersion >= 9) lookbehind = state.eat(0x3C /* < */ );
            if (state.eat(0x3D /* = */ ) || state.eat(0x21 /* ! */ )) {
                this.regexp_disjunction(state);
                if (!state.eat(0x29 /* ) */ )) state.raise("Unterminated group");
                state.lastAssertionIsQuantifiable = !lookbehind;
                return true;
            }
        }
        state.pos = start;
        return false;
    };
    // https://www.ecma-international.org/ecma-262/8.0/#prod-Quantifier
    pp$1.regexp_eatQuantifier = function(state, noError) {
        if (noError === void 0) noError = false;
        if (this.regexp_eatQuantifierPrefix(state, noError)) {
            state.eat(0x3F /* ? */ );
            return true;
        }
        return false;
    };
    // https://www.ecma-international.org/ecma-262/8.0/#prod-QuantifierPrefix
    pp$1.regexp_eatQuantifierPrefix = function(state, noError) {
        return state.eat(0x2A /* * */ ) || state.eat(0x2B /* + */ ) || state.eat(0x3F /* ? */ ) || this.regexp_eatBracedQuantifier(state, noError);
    };
    pp$1.regexp_eatBracedQuantifier = function(state, noError) {
        var start = state.pos;
        if (state.eat(0x7B /* { */ )) {
            var min = 0, max = -1;
            if (this.regexp_eatDecimalDigits(state)) {
                min = state.lastIntValue;
                if (state.eat(0x2C /* , */ ) && this.regexp_eatDecimalDigits(state)) max = state.lastIntValue;
                if (state.eat(0x7D /* } */ )) {
                    // SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-term
                    if (max !== -1 && max < min && !noError) state.raise("numbers out of order in {} quantifier");
                    return true;
                }
            }
            if (state.switchU && !noError) state.raise("Incomplete quantifier");
            state.pos = start;
        }
        return false;
    };
    // https://www.ecma-international.org/ecma-262/8.0/#prod-Atom
    pp$1.regexp_eatAtom = function(state) {
        return this.regexp_eatPatternCharacters(state) || state.eat(0x2E /* . */ ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);
    };
    pp$1.regexp_eatReverseSolidusAtomEscape = function(state) {
        var start = state.pos;
        if (state.eat(0x5C /* \ */ )) {
            if (this.regexp_eatAtomEscape(state)) return true;
            state.pos = start;
        }
        return false;
    };
    pp$1.regexp_eatUncapturingGroup = function(state) {
        var start = state.pos;
        if (state.eat(0x28 /* ( */ )) {
            if (state.eat(0x3F /* ? */ ) && state.eat(0x3A /* : */ )) {
                this.regexp_disjunction(state);
                if (state.eat(0x29 /* ) */ )) return true;
                state.raise("Unterminated group");
            }
            state.pos = start;
        }
        return false;
    };
    pp$1.regexp_eatCapturingGroup = function(state) {
        if (state.eat(0x28 /* ( */ )) {
            if (this.options.ecmaVersion >= 9) this.regexp_groupSpecifier(state);
            else if (state.current() === 0x3F /* ? */ ) state.raise("Invalid group");
            this.regexp_disjunction(state);
            if (state.eat(0x29 /* ) */ )) {
                state.numCapturingParens += 1;
                return true;
            }
            state.raise("Unterminated group");
        }
        return false;
    };
    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedAtom
    pp$1.regexp_eatExtendedAtom = function(state) {
        return state.eat(0x2E /* . */ ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);
    };
    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-InvalidBracedQuantifier
    pp$1.regexp_eatInvalidBracedQuantifier = function(state) {
        if (this.regexp_eatBracedQuantifier(state, true)) state.raise("Nothing to repeat");
        return false;
    };
    // https://www.ecma-international.org/ecma-262/8.0/#prod-SyntaxCharacter
    pp$1.regexp_eatSyntaxCharacter = function(state) {
        var ch = state.current();
        if (isSyntaxCharacter(ch)) {
            state.lastIntValue = ch;
            state.advance();
            return true;
        }
        return false;
    };
    function isSyntaxCharacter(ch) {
        return ch === 0x24 /* $ */  || ch >= 0x28 /* ( */  && ch <= 0x2B /* + */  || ch === 0x2E /* . */  || ch === 0x3F /* ? */  || ch >= 0x5B /* [ */  && ch <= 0x5E /* ^ */  || ch >= 0x7B /* { */  && ch <= 0x7D /* } */ ;
    }
    // https://www.ecma-international.org/ecma-262/8.0/#prod-PatternCharacter
    // But eat eager.
    pp$1.regexp_eatPatternCharacters = function(state) {
        var start = state.pos;
        var ch = 0;
        while((ch = state.current()) !== -1 && !isSyntaxCharacter(ch))state.advance();
        return state.pos !== start;
    };
    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedPatternCharacter
    pp$1.regexp_eatExtendedPatternCharacter = function(state) {
        var ch = state.current();
        if (ch !== -1 && ch !== 0x24 /* $ */  && !(ch >= 0x28 /* ( */  && ch <= 0x2B /* + */ ) && ch !== 0x2E /* . */  && ch !== 0x3F /* ? */  && ch !== 0x5B /* [ */  && ch !== 0x5E /* ^ */  && ch !== 0x7C /* | */ ) {
            state.advance();
            return true;
        }
        return false;
    };
    // GroupSpecifier ::
    //   [empty]
    //   `?` GroupName
    pp$1.regexp_groupSpecifier = function(state) {
        if (state.eat(0x3F /* ? */ )) {
            if (this.regexp_eatGroupName(state)) {
                if (state.groupNames.indexOf(state.lastStringValue) !== -1) state.raise("Duplicate capture group name");
                state.groupNames.push(state.lastStringValue);
                return;
            }
            state.raise("Invalid group");
        }
    };
    // GroupName ::
    //   `<` RegExpIdentifierName `>`
    // Note: this updates `state.lastStringValue` property with the eaten name.
    pp$1.regexp_eatGroupName = function(state) {
        state.lastStringValue = "";
        if (state.eat(0x3C /* < */ )) {
            if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E /* > */ )) return true;
            state.raise("Invalid capture group name");
        }
        return false;
    };
    // RegExpIdentifierName ::
    //   RegExpIdentifierStart
    //   RegExpIdentifierName RegExpIdentifierPart
    // Note: this updates `state.lastStringValue` property with the eaten name.
    pp$1.regexp_eatRegExpIdentifierName = function(state) {
        state.lastStringValue = "";
        if (this.regexp_eatRegExpIdentifierStart(state)) {
            state.lastStringValue += codePointToString(state.lastIntValue);
            while(this.regexp_eatRegExpIdentifierPart(state))state.lastStringValue += codePointToString(state.lastIntValue);
            return true;
        }
        return false;
    };
    // RegExpIdentifierStart ::
    //   UnicodeIDStart
    //   `$`
    //   `_`
    //   `\` RegExpUnicodeEscapeSequence[+U]
    pp$1.regexp_eatRegExpIdentifierStart = function(state) {
        var start = state.pos;
        var forceU = this.options.ecmaVersion >= 11;
        var ch = state.current(forceU);
        state.advance(forceU);
        if (ch === 0x5C /* \ */  && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) ch = state.lastIntValue;
        if (isRegExpIdentifierStart(ch)) {
            state.lastIntValue = ch;
            return true;
        }
        state.pos = start;
        return false;
    };
    function isRegExpIdentifierStart(ch) {
        return isIdentifierStart(ch, true) || ch === 0x24 /* $ */  || ch === 0x5F /* _ */ ;
    }
    // RegExpIdentifierPart ::
    //   UnicodeIDContinue
    //   `$`
    //   `_`
    //   `\` RegExpUnicodeEscapeSequence[+U]
    //   <ZWNJ>
    //   <ZWJ>
    pp$1.regexp_eatRegExpIdentifierPart = function(state) {
        var start = state.pos;
        var forceU = this.options.ecmaVersion >= 11;
        var ch = state.current(forceU);
        state.advance(forceU);
        if (ch === 0x5C /* \ */  && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) ch = state.lastIntValue;
        if (isRegExpIdentifierPart(ch)) {
            state.lastIntValue = ch;
            return true;
        }
        state.pos = start;
        return false;
    };
    function isRegExpIdentifierPart(ch) {
        return isIdentifierChar(ch, true) || ch === 0x24 /* $ */  || ch === 0x5F /* _ */  || ch === 0x200C /* <ZWNJ> */  || ch === 0x200D /* <ZWJ> */ ;
    }
    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape
    pp$1.regexp_eatAtomEscape = function(state) {
        if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) return true;
        if (state.switchU) {
            // Make the same message as V8.
            if (state.current() === 0x63 /* c */ ) state.raise("Invalid unicode escape");
            state.raise("Invalid escape");
        }
        return false;
    };
    pp$1.regexp_eatBackReference = function(state) {
        var start = state.pos;
        if (this.regexp_eatDecimalEscape(state)) {
            var n = state.lastIntValue;
            if (state.switchU) {
                // For SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-atomescape
                if (n > state.maxBackReference) state.maxBackReference = n;
                return true;
            }
            if (n <= state.numCapturingParens) return true;
            state.pos = start;
        }
        return false;
    };
    pp$1.regexp_eatKGroupName = function(state) {
        if (state.eat(0x6B /* k */ )) {
            if (this.regexp_eatGroupName(state)) {
                state.backReferenceNames.push(state.lastStringValue);
                return true;
            }
            state.raise("Invalid named reference");
        }
        return false;
    };
    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape
    pp$1.regexp_eatCharacterEscape = function(state) {
        return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state, false) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);
    };
    pp$1.regexp_eatCControlLetter = function(state) {
        var start = state.pos;
        if (state.eat(0x63 /* c */ )) {
            if (this.regexp_eatControlLetter(state)) return true;
            state.pos = start;
        }
        return false;
    };
    pp$1.regexp_eatZero = function(state) {
        if (state.current() === 0x30 /* 0 */  && !isDecimalDigit(state.lookahead())) {
            state.lastIntValue = 0;
            state.advance();
            return true;
        }
        return false;
    };
    // https://www.ecma-international.org/ecma-262/8.0/#prod-ControlEscape
    pp$1.regexp_eatControlEscape = function(state) {
        var ch = state.current();
        if (ch === 0x74 /* t */ ) {
            state.lastIntValue = 0x09; /* \t */ 
            state.advance();
            return true;
        }
        if (ch === 0x6E /* n */ ) {
            state.lastIntValue = 0x0A; /* \n */ 
            state.advance();
            return true;
        }
        if (ch === 0x76 /* v */ ) {
            state.lastIntValue = 0x0B; /* \v */ 
            state.advance();
            return true;
        }
        if (ch === 0x66 /* f */ ) {
            state.lastIntValue = 0x0C; /* \f */ 
            state.advance();
            return true;
        }
        if (ch === 0x72 /* r */ ) {
            state.lastIntValue = 0x0D; /* \r */ 
            state.advance();
            return true;
        }
        return false;
    };
    // https://www.ecma-international.org/ecma-262/8.0/#prod-ControlLetter
    pp$1.regexp_eatControlLetter = function(state) {
        var ch = state.current();
        if (isControlLetter(ch)) {
            state.lastIntValue = ch % 0x20;
            state.advance();
            return true;
        }
        return false;
    };
    function isControlLetter(ch) {
        return ch >= 0x41 /* A */  && ch <= 0x5A /* Z */  || ch >= 0x61 /* a */  && ch <= 0x7A /* z */ ;
    }
    // https://www.ecma-international.org/ecma-262/8.0/#prod-RegExpUnicodeEscapeSequence
    pp$1.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
        if (forceU === void 0) forceU = false;
        var start = state.pos;
        var switchU = forceU || state.switchU;
        if (state.eat(0x75 /* u */ )) {
            if (this.regexp_eatFixedHexDigits(state, 4)) {
                var lead = state.lastIntValue;
                if (switchU && lead >= 0xD800 && lead <= 0xDBFF) {
                    var leadSurrogateEnd = state.pos;
                    if (state.eat(0x5C /* \ */ ) && state.eat(0x75 /* u */ ) && this.regexp_eatFixedHexDigits(state, 4)) {
                        var trail = state.lastIntValue;
                        if (trail >= 0xDC00 && trail <= 0xDFFF) {
                            state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
                            return true;
                        }
                    }
                    state.pos = leadSurrogateEnd;
                    state.lastIntValue = lead;
                }
                return true;
            }
            if (switchU && state.eat(0x7B /* { */ ) && this.regexp_eatHexDigits(state) && state.eat(0x7D /* } */ ) && isValidUnicode(state.lastIntValue)) return true;
            if (switchU) state.raise("Invalid unicode escape");
            state.pos = start;
        }
        return false;
    };
    function isValidUnicode(ch) {
        return ch >= 0 && ch <= 0x10FFFF;
    }
    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-IdentityEscape
    pp$1.regexp_eatIdentityEscape = function(state) {
        if (state.switchU) {
            if (this.regexp_eatSyntaxCharacter(state)) return true;
            if (state.eat(0x2F /* / */ )) {
                state.lastIntValue = 0x2F; /* / */ 
                return true;
            }
            return false;
        }
        var ch = state.current();
        if (ch !== 0x63 /* c */  && (!state.switchN || ch !== 0x6B /* k */ )) {
            state.lastIntValue = ch;
            state.advance();
            return true;
        }
        return false;
    };
    // https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalEscape
    pp$1.regexp_eatDecimalEscape = function(state) {
        state.lastIntValue = 0;
        var ch = state.current();
        if (ch >= 0x31 /* 1 */  && ch <= 0x39 /* 9 */ ) {
            do {
                state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */ );
                state.advance();
            }while ((ch = state.current()) >= 0x30 /* 0 */  && ch <= 0x39 /* 9 */ );
            return true;
        }
        return false;
    };
    // Return values used by character set parsing methods, needed to
    // forbid negation of sets that can match strings.
    var CharSetNone = 0; // Nothing parsed
    var CharSetOk = 1; // Construct parsed, cannot contain strings
    var CharSetString = 2; // Construct parsed, can contain strings
    // https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClassEscape
    pp$1.regexp_eatCharacterClassEscape = function(state) {
        var ch = state.current();
        if (isCharacterClassEscape(ch)) {
            state.lastIntValue = -1;
            state.advance();
            return CharSetOk;
        }
        var negate = false;
        if (state.switchU && this.options.ecmaVersion >= 9 && ((negate = ch === 0x50 /* P */ ) || ch === 0x70 /* p */ )) {
            state.lastIntValue = -1;
            state.advance();
            var result;
            if (state.eat(0x7B /* { */ ) && (result = this.regexp_eatUnicodePropertyValueExpression(state)) && state.eat(0x7D /* } */ )) {
                if (negate && result === CharSetString) state.raise("Invalid property name");
                return result;
            }
            state.raise("Invalid property name");
        }
        return CharSetNone;
    };
    function isCharacterClassEscape(ch) {
        return ch === 0x64 /* d */  || ch === 0x44 /* D */  || ch === 0x73 /* s */  || ch === 0x53 /* S */  || ch === 0x77 /* w */  || ch === 0x57 /* W */ ;
    }
    // UnicodePropertyValueExpression ::
    //   UnicodePropertyName `=` UnicodePropertyValue
    //   LoneUnicodePropertyNameOrValue
    pp$1.regexp_eatUnicodePropertyValueExpression = function(state) {
        var start = state.pos;
        // UnicodePropertyName `=` UnicodePropertyValue
        if (this.regexp_eatUnicodePropertyName(state) && state.eat(0x3D /* = */ )) {
            var name = state.lastStringValue;
            if (this.regexp_eatUnicodePropertyValue(state)) {
                var value = state.lastStringValue;
                this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
                return CharSetOk;
            }
        }
        state.pos = start;
        // LoneUnicodePropertyNameOrValue
        if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
            var nameOrValue = state.lastStringValue;
            return this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
        }
        return CharSetNone;
    };
    pp$1.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {
        if (!hasOwn(state.unicodeProperties.nonBinary, name)) state.raise("Invalid property name");
        if (!state.unicodeProperties.nonBinary[name].test(value)) state.raise("Invalid property value");
    };
    pp$1.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
        if (state.unicodeProperties.binary.test(nameOrValue)) return CharSetOk;
        if (state.switchV && state.unicodeProperties.binaryOfStrings.test(nameOrValue)) return CharSetString;
        state.raise("Invalid property name");
    };
    // UnicodePropertyName ::
    //   UnicodePropertyNameCharacters
    pp$1.regexp_eatUnicodePropertyName = function(state) {
        var ch = 0;
        state.lastStringValue = "";
        while(isUnicodePropertyNameCharacter(ch = state.current())){
            state.lastStringValue += codePointToString(ch);
            state.advance();
        }
        return state.lastStringValue !== "";
    };
    function isUnicodePropertyNameCharacter(ch) {
        return isControlLetter(ch) || ch === 0x5F /* _ */ ;
    }
    // UnicodePropertyValue ::
    //   UnicodePropertyValueCharacters
    pp$1.regexp_eatUnicodePropertyValue = function(state) {
        var ch = 0;
        state.lastStringValue = "";
        while(isUnicodePropertyValueCharacter(ch = state.current())){
            state.lastStringValue += codePointToString(ch);
            state.advance();
        }
        return state.lastStringValue !== "";
    };
    function isUnicodePropertyValueCharacter(ch) {
        return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch);
    }
    // LoneUnicodePropertyNameOrValue ::
    //   UnicodePropertyValueCharacters
    pp$1.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
        return this.regexp_eatUnicodePropertyValue(state);
    };
    // https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClass
    pp$1.regexp_eatCharacterClass = function(state) {
        if (state.eat(0x5B /* [ */ )) {
            var negate = state.eat(0x5E /* ^ */ );
            var result = this.regexp_classContents(state);
            if (!state.eat(0x5D /* ] */ )) state.raise("Unterminated character class");
            if (negate && result === CharSetString) state.raise("Negated character class may contain strings");
            return true;
        }
        return false;
    };
    // https://tc39.es/ecma262/#prod-ClassContents
    // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassRanges
    pp$1.regexp_classContents = function(state) {
        if (state.current() === 0x5D /* ] */ ) return CharSetOk;
        if (state.switchV) return this.regexp_classSetExpression(state);
        this.regexp_nonEmptyClassRanges(state);
        return CharSetOk;
    };
    // https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRanges
    // https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRangesNoDash
    pp$1.regexp_nonEmptyClassRanges = function(state) {
        while(this.regexp_eatClassAtom(state)){
            var left = state.lastIntValue;
            if (state.eat(0x2D /* - */ ) && this.regexp_eatClassAtom(state)) {
                var right = state.lastIntValue;
                if (state.switchU && (left === -1 || right === -1)) state.raise("Invalid character class");
                if (left !== -1 && right !== -1 && left > right) state.raise("Range out of order in character class");
            }
        }
    };
    // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtom
    // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtomNoDash
    pp$1.regexp_eatClassAtom = function(state) {
        var start = state.pos;
        if (state.eat(0x5C /* \ */ )) {
            if (this.regexp_eatClassEscape(state)) return true;
            if (state.switchU) {
                // Make the same message as V8.
                var ch$1 = state.current();
                if (ch$1 === 0x63 /* c */  || isOctalDigit(ch$1)) state.raise("Invalid class escape");
                state.raise("Invalid escape");
            }
            state.pos = start;
        }
        var ch = state.current();
        if (ch !== 0x5D /* ] */ ) {
            state.lastIntValue = ch;
            state.advance();
            return true;
        }
        return false;
    };
    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassEscape
    pp$1.regexp_eatClassEscape = function(state) {
        var start = state.pos;
        if (state.eat(0x62 /* b */ )) {
            state.lastIntValue = 0x08; /* <BS> */ 
            return true;
        }
        if (state.switchU && state.eat(0x2D /* - */ )) {
            state.lastIntValue = 0x2D; /* - */ 
            return true;
        }
        if (!state.switchU && state.eat(0x63 /* c */ )) {
            if (this.regexp_eatClassControlLetter(state)) return true;
            state.pos = start;
        }
        return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);
    };
    // https://tc39.es/ecma262/#prod-ClassSetExpression
    // https://tc39.es/ecma262/#prod-ClassUnion
    // https://tc39.es/ecma262/#prod-ClassIntersection
    // https://tc39.es/ecma262/#prod-ClassSubtraction
    pp$1.regexp_classSetExpression = function(state) {
        var result = CharSetOk, subResult;
        if (this.regexp_eatClassSetRange(state)) ;
        else if (subResult = this.regexp_eatClassSetOperand(state)) {
            if (subResult === CharSetString) result = CharSetString;
            // https://tc39.es/ecma262/#prod-ClassIntersection
            var start = state.pos;
            while(state.eatChars([
                0x26,
                0x26
            ])){
                if (state.current() !== 0x26 /* & */  && (subResult = this.regexp_eatClassSetOperand(state))) {
                    if (subResult !== CharSetString) result = CharSetOk;
                    continue;
                }
                state.raise("Invalid character in character class");
            }
            if (start !== state.pos) return result;
            // https://tc39.es/ecma262/#prod-ClassSubtraction
            while(state.eatChars([
                0x2D,
                0x2D
            ])){
                if (this.regexp_eatClassSetOperand(state)) continue;
                state.raise("Invalid character in character class");
            }
            if (start !== state.pos) return result;
        } else state.raise("Invalid character in character class");
        // https://tc39.es/ecma262/#prod-ClassUnion
        for(;;){
            if (this.regexp_eatClassSetRange(state)) continue;
            subResult = this.regexp_eatClassSetOperand(state);
            if (!subResult) return result;
            if (subResult === CharSetString) result = CharSetString;
        }
    };
    // https://tc39.es/ecma262/#prod-ClassSetRange
    pp$1.regexp_eatClassSetRange = function(state) {
        var start = state.pos;
        if (this.regexp_eatClassSetCharacter(state)) {
            var left = state.lastIntValue;
            if (state.eat(0x2D /* - */ ) && this.regexp_eatClassSetCharacter(state)) {
                var right = state.lastIntValue;
                if (left !== -1 && right !== -1 && left > right) state.raise("Range out of order in character class");
                return true;
            }
            state.pos = start;
        }
        return false;
    };
    // https://tc39.es/ecma262/#prod-ClassSetOperand
    pp$1.regexp_eatClassSetOperand = function(state) {
        if (this.regexp_eatClassSetCharacter(state)) return CharSetOk;
        return this.regexp_eatClassStringDisjunction(state) || this.regexp_eatNestedClass(state);
    };
    // https://tc39.es/ecma262/#prod-NestedClass
    pp$1.regexp_eatNestedClass = function(state) {
        var start = state.pos;
        if (state.eat(0x5B /* [ */ )) {
            var negate = state.eat(0x5E /* ^ */ );
            var result = this.regexp_classContents(state);
            if (state.eat(0x5D /* ] */ )) {
                if (negate && result === CharSetString) state.raise("Negated character class may contain strings");
                return result;
            }
            state.pos = start;
        }
        if (state.eat(0x5C /* \ */ )) {
            var result$1 = this.regexp_eatCharacterClassEscape(state);
            if (result$1) return result$1;
            state.pos = start;
        }
        return null;
    };
    // https://tc39.es/ecma262/#prod-ClassStringDisjunction
    pp$1.regexp_eatClassStringDisjunction = function(state) {
        var start = state.pos;
        if (state.eatChars([
            0x5C,
            0x71
        ])) {
            if (state.eat(0x7B /* { */ )) {
                var result = this.regexp_classStringDisjunctionContents(state);
                if (state.eat(0x7D /* } */ )) return result;
            } else // Make the same message as V8.
            state.raise("Invalid escape");
            state.pos = start;
        }
        return null;
    };
    // https://tc39.es/ecma262/#prod-ClassStringDisjunctionContents
    pp$1.regexp_classStringDisjunctionContents = function(state) {
        var result = this.regexp_classString(state);
        while(state.eat(0x7C /* | */ ))if (this.regexp_classString(state) === CharSetString) result = CharSetString;
        return result;
    };
    // https://tc39.es/ecma262/#prod-ClassString
    // https://tc39.es/ecma262/#prod-NonEmptyClassString
    pp$1.regexp_classString = function(state) {
        var count = 0;
        while(this.regexp_eatClassSetCharacter(state))count++;
        return count === 1 ? CharSetOk : CharSetString;
    };
    // https://tc39.es/ecma262/#prod-ClassSetCharacter
    pp$1.regexp_eatClassSetCharacter = function(state) {
        var start = state.pos;
        if (state.eat(0x5C /* \ */ )) {
            if (this.regexp_eatCharacterEscape(state) || this.regexp_eatClassSetReservedPunctuator(state)) return true;
            if (state.eat(0x62 /* b */ )) {
                state.lastIntValue = 0x08; /* <BS> */ 
                return true;
            }
            state.pos = start;
            return false;
        }
        var ch = state.current();
        if (ch < 0 || ch === state.lookahead() && isClassSetReservedDoublePunctuatorCharacter(ch)) return false;
        if (isClassSetSyntaxCharacter(ch)) return false;
        state.advance();
        state.lastIntValue = ch;
        return true;
    };
    // https://tc39.es/ecma262/#prod-ClassSetReservedDoublePunctuator
    function isClassSetReservedDoublePunctuatorCharacter(ch) {
        return ch === 0x21 /* ! */  || ch >= 0x23 /* # */  && ch <= 0x26 /* & */  || ch >= 0x2A /* * */  && ch <= 0x2C /* , */  || ch === 0x2E /* . */  || ch >= 0x3A /* : */  && ch <= 0x40 /* @ */  || ch === 0x5E /* ^ */  || ch === 0x60 /* ` */  || ch === 0x7E /* ~ */ ;
    }
    // https://tc39.es/ecma262/#prod-ClassSetSyntaxCharacter
    function isClassSetSyntaxCharacter(ch) {
        return ch === 0x28 /* ( */  || ch === 0x29 /* ) */  || ch === 0x2D /* - */  || ch === 0x2F /* / */  || ch >= 0x5B /* [ */  && ch <= 0x5D /* ] */  || ch >= 0x7B /* { */  && ch <= 0x7D /* } */ ;
    }
    // https://tc39.es/ecma262/#prod-ClassSetReservedPunctuator
    pp$1.regexp_eatClassSetReservedPunctuator = function(state) {
        var ch = state.current();
        if (isClassSetReservedPunctuator(ch)) {
            state.lastIntValue = ch;
            state.advance();
            return true;
        }
        return false;
    };
    // https://tc39.es/ecma262/#prod-ClassSetReservedPunctuator
    function isClassSetReservedPunctuator(ch) {
        return ch === 0x21 /* ! */  || ch === 0x23 /* # */  || ch === 0x25 /* % */  || ch === 0x26 /* & */  || ch === 0x2C /* , */  || ch === 0x2D /* - */  || ch >= 0x3A /* : */  && ch <= 0x3E /* > */  || ch === 0x40 /* @ */  || ch === 0x60 /* ` */  || ch === 0x7E /* ~ */ ;
    }
    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassControlLetter
    pp$1.regexp_eatClassControlLetter = function(state) {
        var ch = state.current();
        if (isDecimalDigit(ch) || ch === 0x5F /* _ */ ) {
            state.lastIntValue = ch % 0x20;
            state.advance();
            return true;
        }
        return false;
    };
    // https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence
    pp$1.regexp_eatHexEscapeSequence = function(state) {
        var start = state.pos;
        if (state.eat(0x78 /* x */ )) {
            if (this.regexp_eatFixedHexDigits(state, 2)) return true;
            if (state.switchU) state.raise("Invalid escape");
            state.pos = start;
        }
        return false;
    };
    // https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalDigits
    pp$1.regexp_eatDecimalDigits = function(state) {
        var start = state.pos;
        var ch = 0;
        state.lastIntValue = 0;
        while(isDecimalDigit(ch = state.current())){
            state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */ );
            state.advance();
        }
        return state.pos !== start;
    };
    function isDecimalDigit(ch) {
        return ch >= 0x30 /* 0 */  && ch <= 0x39 /* 9 */ ;
    }
    // https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigits
    pp$1.regexp_eatHexDigits = function(state) {
        var start = state.pos;
        var ch = 0;
        state.lastIntValue = 0;
        while(isHexDigit(ch = state.current())){
            state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
            state.advance();
        }
        return state.pos !== start;
    };
    function isHexDigit(ch) {
        return ch >= 0x30 /* 0 */  && ch <= 0x39 /* 9 */  || ch >= 0x41 /* A */  && ch <= 0x46 /* F */  || ch >= 0x61 /* a */  && ch <= 0x66 /* f */ ;
    }
    function hexToInt(ch) {
        if (ch >= 0x41 /* A */  && ch <= 0x46 /* F */ ) return 10 + (ch - 0x41 /* A */ );
        if (ch >= 0x61 /* a */  && ch <= 0x66 /* f */ ) return 10 + (ch - 0x61 /* a */ );
        return ch - 0x30 /* 0 */ ;
    }
    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-LegacyOctalEscapeSequence
    // Allows only 0-377(octal) i.e. 0-255(decimal).
    pp$1.regexp_eatLegacyOctalEscapeSequence = function(state) {
        if (this.regexp_eatOctalDigit(state)) {
            var n1 = state.lastIntValue;
            if (this.regexp_eatOctalDigit(state)) {
                var n2 = state.lastIntValue;
                if (n1 <= 3 && this.regexp_eatOctalDigit(state)) state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
                else state.lastIntValue = n1 * 8 + n2;
            } else state.lastIntValue = n1;
            return true;
        }
        return false;
    };
    // https://www.ecma-international.org/ecma-262/8.0/#prod-OctalDigit
    pp$1.regexp_eatOctalDigit = function(state) {
        var ch = state.current();
        if (isOctalDigit(ch)) {
            state.lastIntValue = ch - 0x30; /* 0 */ 
            state.advance();
            return true;
        }
        state.lastIntValue = 0;
        return false;
    };
    function isOctalDigit(ch) {
        return ch >= 0x30 /* 0 */  && ch <= 0x37 /* 7 */ ;
    }
    // https://www.ecma-international.org/ecma-262/8.0/#prod-Hex4Digits
    // https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigit
    // And HexDigit HexDigit in https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence
    pp$1.regexp_eatFixedHexDigits = function(state, length) {
        var start = state.pos;
        state.lastIntValue = 0;
        for(var i = 0; i < length; ++i){
            var ch = state.current();
            if (!isHexDigit(ch)) {
                state.pos = start;
                return false;
            }
            state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
            state.advance();
        }
        return true;
    };
    // Object type used to represent tokens. Note that normally, tokens
    // simply exist as properties on the parser object. This is only
    // used for the onToken callback and the external tokenizer.
    var Token = function Token(p) {
        this.type = p.type;
        this.value = p.value;
        this.start = p.start;
        this.end = p.end;
        if (p.options.locations) this.loc = new SourceLocation(p, p.startLoc, p.endLoc);
        if (p.options.ranges) this.range = [
            p.start,
            p.end
        ];
    };
    // ## Tokenizer
    var pp$a = Parser$1.prototype;
    // Move to the next token
    pp$a.next = function(ignoreEscapeSequenceInKeyword) {
        if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc) this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword);
        if (this.options.onToken) this.options.onToken(new Token(this));
        this.lastTokEnd = this.end;
        this.lastTokStart = this.start;
        this.lastTokEndLoc = this.endLoc;
        this.lastTokStartLoc = this.startLoc;
        this.nextToken();
    };
    pp$a.getToken = function() {
        this.next();
        return new Token(this);
    };
    // If we're in an ES6 environment, make parsers iterable
    if (typeof Symbol !== "undefined") pp$a[Symbol.iterator] = function() {
        var this$1$1 = this;
        return {
            next: function() {
                var token = this$1$1.getToken();
                return {
                    done: token.type === types$1.eof,
                    value: token
                };
            }
        };
    };
    // Toggle strict mode. Re-reads the next number or string to please
    // pedantic tests (`"use strict"; 010;` should fail).
    // Read a single token, updating the parser object's token-related
    // properties.
    pp$a.nextToken = function() {
        var curContext = this.curContext();
        if (!curContext || !curContext.preserveSpace) this.skipSpace();
        this.start = this.pos;
        if (this.options.locations) this.startLoc = this.curPosition();
        if (this.pos >= this.input.length) return this.finishToken(types$1.eof);
        if (curContext.override) return curContext.override(this);
        else this.readToken(this.fullCharCodeAtPos());
    };
    pp$a.readToken = function(code) {
        // Identifier or keyword. '\uXXXX' sequences are allowed in
        // identifiers, so '\' also dispatches to that.
        if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\' */ ) return this.readWord();
        return this.getTokenFromCode(code);
    };
    pp$a.fullCharCodeAtPos = function() {
        var code = this.input.charCodeAt(this.pos);
        if (code <= 0xd7ff || code >= 0xdc00) return code;
        var next = this.input.charCodeAt(this.pos + 1);
        return next <= 0xdbff || next >= 0xe000 ? code : (code << 10) + next - 0x35fdc00;
    };
    pp$a.skipBlockComment = function() {
        var startLoc = this.options.onComment && this.curPosition();
        var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
        if (end === -1) this.raise(this.pos - 2, "Unterminated comment");
        this.pos = end + 2;
        if (this.options.locations) for(var nextBreak = void 0, pos = start; (nextBreak = nextLineBreak(this.input, pos, this.pos)) > -1;){
            ++this.curLine;
            pos = this.lineStart = nextBreak;
        }
        if (this.options.onComment) this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos, startLoc, this.curPosition());
    };
    pp$a.skipLineComment = function(startSkip) {
        var start = this.pos;
        var startLoc = this.options.onComment && this.curPosition();
        var ch = this.input.charCodeAt(this.pos += startSkip);
        while(this.pos < this.input.length && !isNewLine(ch))ch = this.input.charCodeAt(++this.pos);
        if (this.options.onComment) this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos, startLoc, this.curPosition());
    };
    // Called at the start of the parse and after every token. Skips
    // whitespace and comments, and.
    pp$a.skipSpace = function() {
        loop: while(this.pos < this.input.length){
            var ch = this.input.charCodeAt(this.pos);
            switch(ch){
                case 32:
                case 160:
                    ++this.pos;
                    break;
                case 13:
                    if (this.input.charCodeAt(this.pos + 1) === 10) ++this.pos;
                case 10:
                case 8232:
                case 8233:
                    ++this.pos;
                    if (this.options.locations) {
                        ++this.curLine;
                        this.lineStart = this.pos;
                    }
                    break;
                case 47:
                    switch(this.input.charCodeAt(this.pos + 1)){
                        case 42:
                            this.skipBlockComment();
                            break;
                        case 47:
                            this.skipLineComment(2);
                            break;
                        default:
                            break loop;
                    }
                    break;
                default:
                    if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) ++this.pos;
                    else break loop;
            }
        }
    };
    // Called at the end of every token. Sets `end`, `val`, and
    // maintains `context` and `exprAllowed`, and skips the space after
    // the token, so that the next one's `start` will point at the
    // right position.
    pp$a.finishToken = function(type, val) {
        this.end = this.pos;
        if (this.options.locations) this.endLoc = this.curPosition();
        var prevType = this.type;
        this.type = type;
        this.value = val;
        this.updateContext(prevType);
    };
    // ### Token reading
    // This is the function that is called to fetch the next token. It
    // is somewhat obscure, because it works in character codes rather
    // than characters, and because operator parsing has been inlined
    // into it.
    //
    // All in the name of speed.
    //
    pp$a.readToken_dot = function() {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next >= 48 && next <= 57) return this.readNumber(true);
        var next2 = this.input.charCodeAt(this.pos + 2);
        if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
            this.pos += 3;
            return this.finishToken(types$1.ellipsis);
        } else {
            ++this.pos;
            return this.finishToken(types$1.dot);
        }
    };
    pp$a.readToken_slash = function() {
        var next = this.input.charCodeAt(this.pos + 1);
        if (this.exprAllowed) {
            ++this.pos;
            return this.readRegexp();
        }
        if (next === 61) return this.finishOp(types$1.assign, 2);
        return this.finishOp(types$1.slash, 1);
    };
    pp$a.readToken_mult_modulo_exp = function(code) {
        var next = this.input.charCodeAt(this.pos + 1);
        var size = 1;
        var tokentype = code === 42 ? types$1.star : types$1.modulo;
        // exponentiation operator ** and **=
        if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
            ++size;
            tokentype = types$1.starstar;
            next = this.input.charCodeAt(this.pos + 2);
        }
        if (next === 61) return this.finishOp(types$1.assign, size + 1);
        return this.finishOp(tokentype, size);
    };
    pp$a.readToken_pipe_amp = function(code) {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === code) {
            if (this.options.ecmaVersion >= 12) {
                var next2 = this.input.charCodeAt(this.pos + 2);
                if (next2 === 61) return this.finishOp(types$1.assign, 3);
            }
            return this.finishOp(code === 124 ? types$1.logicalOR : types$1.logicalAND, 2);
        }
        if (next === 61) return this.finishOp(types$1.assign, 2);
        return this.finishOp(code === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1);
    };
    pp$a.readToken_caret = function() {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === 61) return this.finishOp(types$1.assign, 2);
        return this.finishOp(types$1.bitwiseXOR, 1);
    };
    pp$a.readToken_plus_min = function(code) {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === code) {
            if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
                // A `-->` line comment
                this.skipLineComment(3);
                this.skipSpace();
                return this.nextToken();
            }
            return this.finishOp(types$1.incDec, 2);
        }
        if (next === 61) return this.finishOp(types$1.assign, 2);
        return this.finishOp(types$1.plusMin, 1);
    };
    pp$a.readToken_lt_gt = function(code) {
        var next = this.input.charCodeAt(this.pos + 1);
        var size = 1;
        if (next === code) {
            size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
            if (this.input.charCodeAt(this.pos + size) === 61) return this.finishOp(types$1.assign, size + 1);
            return this.finishOp(types$1.bitShift, size);
        }
        if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {
            // `<!--`, an XML-style comment that should be interpreted as a line comment
            this.skipLineComment(4);
            this.skipSpace();
            return this.nextToken();
        }
        if (next === 61) size = 2;
        return this.finishOp(types$1.relational, size);
    };
    pp$a.readToken_eq_excl = function(code) {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === 61) return this.finishOp(types$1.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
        if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {
            this.pos += 2;
            return this.finishToken(types$1.arrow);
        }
        return this.finishOp(code === 61 ? types$1.eq : types$1.prefix, 1);
    };
    pp$a.readToken_question = function() {
        var ecmaVersion = this.options.ecmaVersion;
        if (ecmaVersion >= 11) {
            var next = this.input.charCodeAt(this.pos + 1);
            if (next === 46) {
                var next2 = this.input.charCodeAt(this.pos + 2);
                if (next2 < 48 || next2 > 57) return this.finishOp(types$1.questionDot, 2);
            }
            if (next === 63) {
                if (ecmaVersion >= 12) {
                    var next2$1 = this.input.charCodeAt(this.pos + 2);
                    if (next2$1 === 61) return this.finishOp(types$1.assign, 3);
                }
                return this.finishOp(types$1.coalesce, 2);
            }
        }
        return this.finishOp(types$1.question, 1);
    };
    pp$a.readToken_numberSign = function() {
        var ecmaVersion = this.options.ecmaVersion;
        var code = 35; // '#'
        if (ecmaVersion >= 13) {
            ++this.pos;
            code = this.fullCharCodeAtPos();
            if (isIdentifierStart(code, true) || code === 92 /* '\' */ ) return this.finishToken(types$1.privateId, this.readWord1());
        }
        this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
    };
    pp$a.getTokenFromCode = function(code) {
        switch(code){
            // The interpretation of a dot depends on whether it is followed
            // by a digit or another two dots.
            case 46:
                return this.readToken_dot();
            // Punctuation tokens.
            case 40:
                ++this.pos;
                return this.finishToken(types$1.parenL);
            case 41:
                ++this.pos;
                return this.finishToken(types$1.parenR);
            case 59:
                ++this.pos;
                return this.finishToken(types$1.semi);
            case 44:
                ++this.pos;
                return this.finishToken(types$1.comma);
            case 91:
                ++this.pos;
                return this.finishToken(types$1.bracketL);
            case 93:
                ++this.pos;
                return this.finishToken(types$1.bracketR);
            case 123:
                ++this.pos;
                return this.finishToken(types$1.braceL);
            case 125:
                ++this.pos;
                return this.finishToken(types$1.braceR);
            case 58:
                ++this.pos;
                return this.finishToken(types$1.colon);
            case 96:
                if (this.options.ecmaVersion < 6) break;
                ++this.pos;
                return this.finishToken(types$1.backQuote);
            case 48:
                var next = this.input.charCodeAt(this.pos + 1);
                if (next === 120 || next === 88) return this.readRadixNumber(16);
                 // '0x', '0X' - hex number
                if (this.options.ecmaVersion >= 6) {
                    if (next === 111 || next === 79) return this.readRadixNumber(8);
                     // '0o', '0O' - octal number
                    if (next === 98 || next === 66) return this.readRadixNumber(2);
                     // '0b', '0B' - binary number
                }
            // Anything else beginning with a digit is an integer, octal
            // number, or float.
            case 49:
            case 50:
            case 51:
            case 52:
            case 53:
            case 54:
            case 55:
            case 56:
            case 57:
                return this.readNumber(false);
            // Quotes produce strings.
            case 34:
            case 39:
                return this.readString(code);
            // Operators are parsed inline in tiny state machines. '=' (61) is
            // often referred to. `finishOp` simply skips the amount of
            // characters it is given as second argument, and returns a token
            // of the type given by its first argument.
            case 47:
                return this.readToken_slash();
            case 37:
            case 42:
                return this.readToken_mult_modulo_exp(code);
            case 124:
            case 38:
                return this.readToken_pipe_amp(code);
            case 94:
                return this.readToken_caret();
            case 43:
            case 45:
                return this.readToken_plus_min(code);
            case 60:
            case 62:
                return this.readToken_lt_gt(code);
            case 61:
            case 33:
                return this.readToken_eq_excl(code);
            case 63:
                return this.readToken_question();
            case 126:
                return this.finishOp(types$1.prefix, 1);
            case 35:
                return this.readToken_numberSign();
        }
        this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
    };
    pp$a.finishOp = function(type, size) {
        var str = this.input.slice(this.pos, this.pos + size);
        this.pos += size;
        return this.finishToken(type, str);
    };
    pp$a.readRegexp = function() {
        var escaped, inClass, start = this.pos;
        for(;;){
            if (this.pos >= this.input.length) this.raise(start, "Unterminated regular expression");
            var ch = this.input.charAt(this.pos);
            if (lineBreak.test(ch)) this.raise(start, "Unterminated regular expression");
            if (!escaped) {
                if (ch === "[") inClass = true;
                else if (ch === "]" && inClass) inClass = false;
                else if (ch === "/" && !inClass) break;
                escaped = ch === "\\";
            } else escaped = false;
            ++this.pos;
        }
        var pattern = this.input.slice(start, this.pos);
        ++this.pos;
        var flagsStart = this.pos;
        var flags = this.readWord1();
        if (this.containsEsc) this.unexpected(flagsStart);
        // Validate pattern
        var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
        state.reset(start, pattern, flags);
        this.validateRegExpFlags(state);
        this.validateRegExpPattern(state);
        // Create Literal#value property value.
        var value = null;
        try {
            value = new RegExp(pattern, flags);
        } catch (e) {
        // ESTree requires null if it failed to instantiate RegExp object.
        // https://github.com/estree/estree/blob/a27003adf4fd7bfad44de9cef372a2eacd527b1c/es5.md#regexpliteral
        }
        return this.finishToken(types$1.regexp, {
            pattern: pattern,
            flags: flags,
            value: value
        });
    };
    // Read an integer in the given radix. Return null if zero digits
    // were read, the integer value otherwise. When `len` is given, this
    // will return `null` unless the integer has exactly `len` digits.
    pp$a.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
        // `len` is used for character escape sequences. In that case, disallow separators.
        var allowSeparators = this.options.ecmaVersion >= 12 && len === undefined;
        // `maybeLegacyOctalNumericLiteral` is true if it doesn't have prefix (0x,0o,0b)
        // and isn't fraction part nor exponent part. In that case, if the first digit
        // is zero then disallow separators.
        var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;
        var start = this.pos, total = 0, lastCode = 0;
        for(var i = 0, e = len == null ? Infinity : len; i < e; ++i, ++this.pos){
            var code = this.input.charCodeAt(this.pos), val = void 0;
            if (allowSeparators && code === 95) {
                if (isLegacyOctalNumericLiteral) this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals");
                if (lastCode === 95) this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore");
                if (i === 0) this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits");
                lastCode = code;
                continue;
            }
            if (code >= 97) val = code - 97 + 10;
            else if (code >= 65) val = code - 65 + 10;
            else if (code >= 48 && code <= 57) val = code - 48;
            else val = Infinity;
            if (val >= radix) break;
            lastCode = code;
            total = total * radix + val;
        }
        if (allowSeparators && lastCode === 95) this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits");
        if (this.pos === start || len != null && this.pos - start !== len) return null;
        return total;
    };
    function stringToNumber(str, isLegacyOctalNumericLiteral) {
        if (isLegacyOctalNumericLiteral) return parseInt(str, 8);
        // `parseFloat(value)` stops parsing at the first numeric separator then returns a wrong value.
        return parseFloat(str.replace(/_/g, ""));
    }
    function stringToBigInt(str) {
        if (typeof BigInt !== "function") return null;
        // `BigInt(value)` throws syntax error if the string contains numeric separators.
        return BigInt(str.replace(/_/g, ""));
    }
    pp$a.readRadixNumber = function(radix) {
        var start = this.pos;
        this.pos += 2; // 0x
        var val = this.readInt(radix);
        if (val == null) this.raise(this.start + 2, "Expected number in radix " + radix);
        if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
            val = stringToBigInt(this.input.slice(start, this.pos));
            ++this.pos;
        } else if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, "Identifier directly after number");
        return this.finishToken(types$1.num, val);
    };
    // Read an integer, octal integer, or floating-point number.
    pp$a.readNumber = function(startsWithDot) {
        var start = this.pos;
        if (!startsWithDot && this.readInt(10, undefined, true) === null) this.raise(start, "Invalid number");
        var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
        if (octal && this.strict) this.raise(start, "Invalid number");
        var next = this.input.charCodeAt(this.pos);
        if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
            var val$1 = stringToBigInt(this.input.slice(start, this.pos));
            ++this.pos;
            if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, "Identifier directly after number");
            return this.finishToken(types$1.num, val$1);
        }
        if (octal && /[89]/.test(this.input.slice(start, this.pos))) octal = false;
        if (next === 46 && !octal) {
            ++this.pos;
            this.readInt(10);
            next = this.input.charCodeAt(this.pos);
        }
        if ((next === 69 || next === 101) && !octal) {
            next = this.input.charCodeAt(++this.pos);
            if (next === 43 || next === 45) ++this.pos;
             // '+-'
            if (this.readInt(10) === null) this.raise(start, "Invalid number");
        }
        if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, "Identifier directly after number");
        var val = stringToNumber(this.input.slice(start, this.pos), octal);
        return this.finishToken(types$1.num, val);
    };
    // Read a string value, interpreting backslash-escapes.
    pp$a.readCodePoint = function() {
        var ch = this.input.charCodeAt(this.pos), code;
        if (ch === 123) {
            if (this.options.ecmaVersion < 6) this.unexpected();
            var codePos = ++this.pos;
            code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
            ++this.pos;
            if (code > 0x10FFFF) this.invalidStringToken(codePos, "Code point out of bounds");
        } else code = this.readHexChar(4);
        return code;
    };
    pp$a.readString = function(quote) {
        var out = "", chunkStart = ++this.pos;
        for(;;){
            if (this.pos >= this.input.length) this.raise(this.start, "Unterminated string constant");
            var ch = this.input.charCodeAt(this.pos);
            if (ch === quote) break;
            if (ch === 92) {
                out += this.input.slice(chunkStart, this.pos);
                out += this.readEscapedChar(false);
                chunkStart = this.pos;
            } else if (ch === 0x2028 || ch === 0x2029) {
                if (this.options.ecmaVersion < 10) this.raise(this.start, "Unterminated string constant");
                ++this.pos;
                if (this.options.locations) {
                    this.curLine++;
                    this.lineStart = this.pos;
                }
            } else {
                if (isNewLine(ch)) this.raise(this.start, "Unterminated string constant");
                ++this.pos;
            }
        }
        out += this.input.slice(chunkStart, this.pos++);
        return this.finishToken(types$1.string, out);
    };
    // Reads template string tokens.
    var INVALID_TEMPLATE_ESCAPE_ERROR = {};
    pp$a.tryReadTemplateToken = function() {
        this.inTemplateElement = true;
        try {
            this.readTmplToken();
        } catch (err) {
            if (err === INVALID_TEMPLATE_ESCAPE_ERROR) this.readInvalidTemplateToken();
            else throw err;
        }
        this.inTemplateElement = false;
    };
    pp$a.invalidStringToken = function(position, message) {
        if (this.inTemplateElement && this.options.ecmaVersion >= 9) throw INVALID_TEMPLATE_ESCAPE_ERROR;
        else this.raise(position, message);
    };
    pp$a.readTmplToken = function() {
        var out = "", chunkStart = this.pos;
        for(;;){
            if (this.pos >= this.input.length) this.raise(this.start, "Unterminated template");
            var ch = this.input.charCodeAt(this.pos);
            if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
                if (this.pos === this.start && (this.type === types$1.template || this.type === types$1.invalidTemplate)) {
                    if (ch === 36) {
                        this.pos += 2;
                        return this.finishToken(types$1.dollarBraceL);
                    } else {
                        ++this.pos;
                        return this.finishToken(types$1.backQuote);
                    }
                }
                out += this.input.slice(chunkStart, this.pos);
                return this.finishToken(types$1.template, out);
            }
            if (ch === 92) {
                out += this.input.slice(chunkStart, this.pos);
                out += this.readEscapedChar(true);
                chunkStart = this.pos;
            } else if (isNewLine(ch)) {
                out += this.input.slice(chunkStart, this.pos);
                ++this.pos;
                switch(ch){
                    case 13:
                        if (this.input.charCodeAt(this.pos) === 10) ++this.pos;
                    case 10:
                        out += "\n";
                        break;
                    default:
                        out += String.fromCharCode(ch);
                        break;
                }
                if (this.options.locations) {
                    ++this.curLine;
                    this.lineStart = this.pos;
                }
                chunkStart = this.pos;
            } else ++this.pos;
        }
    };
    // Reads a template token to search for the end, without validating any escape sequences
    pp$a.readInvalidTemplateToken = function() {
        for(; this.pos < this.input.length; this.pos++)switch(this.input[this.pos]){
            case "\\":
                ++this.pos;
                break;
            case "$":
                if (this.input[this.pos + 1] !== "{") break;
            // falls through
            case "`":
                return this.finishToken(types$1.invalidTemplate, this.input.slice(this.start, this.pos));
        }
        this.raise(this.start, "Unterminated template");
    };
    // Used to read escaped characters
    pp$a.readEscapedChar = function(inTemplate) {
        var ch = this.input.charCodeAt(++this.pos);
        ++this.pos;
        switch(ch){
            case 110:
                return "\n" // 'n' -> '\n'
                ;
            case 114:
                return "\r" // 'r' -> '\r'
                ;
            case 120:
                return String.fromCharCode(this.readHexChar(2)) // 'x'
                ;
            case 117:
                return codePointToString(this.readCodePoint()) // 'u'
                ;
            case 116:
                return "	" // 't' -> '\t'
                ;
            case 98:
                return "\b" // 'b' -> '\b'
                ;
            case 118:
                return "\v" // 'v' -> '\u000b'
                ;
            case 102:
                return "\f" // 'f' -> '\f'
                ;
            case 13:
                if (this.input.charCodeAt(this.pos) === 10) ++this.pos;
                 // '\r\n'
            case 10:
                if (this.options.locations) {
                    this.lineStart = this.pos;
                    ++this.curLine;
                }
                return "";
            case 56:
            case 57:
                if (this.strict) this.invalidStringToken(this.pos - 1, "Invalid escape sequence");
                if (inTemplate) {
                    var codePos = this.pos - 1;
                    this.invalidStringToken(codePos, "Invalid escape sequence in template string");
                }
            default:
                if (ch >= 48 && ch <= 55) {
                    var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
                    var octal = parseInt(octalStr, 8);
                    if (octal > 255) {
                        octalStr = octalStr.slice(0, -1);
                        octal = parseInt(octalStr, 8);
                    }
                    this.pos += octalStr.length - 1;
                    ch = this.input.charCodeAt(this.pos);
                    if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) this.invalidStringToken(this.pos - 1 - octalStr.length, inTemplate ? "Octal literal in template string" : "Octal literal in strict mode");
                    return String.fromCharCode(octal);
                }
                if (isNewLine(ch)) // Unicode new line characters after \ get removed from output in both
                // template literals and strings
                return "";
                return String.fromCharCode(ch);
        }
    };
    // Used to read character escape sequences ('\x', '\u', '\U').
    pp$a.readHexChar = function(len) {
        var codePos = this.pos;
        var n = this.readInt(16, len);
        if (n === null) this.invalidStringToken(codePos, "Bad character escape sequence");
        return n;
    };
    // Read an identifier, and return it as a string. Sets `this.containsEsc`
    // to whether the word contained a '\u' escape.
    //
    // Incrementally adds only escaped chars, adding other chunks as-is
    // as a micro-optimization.
    pp$a.readWord1 = function() {
        this.containsEsc = false;
        var word = "", first = true, chunkStart = this.pos;
        var astral = this.options.ecmaVersion >= 6;
        while(this.pos < this.input.length){
            var ch = this.fullCharCodeAtPos();
            if (isIdentifierChar(ch, astral)) this.pos += ch <= 0xffff ? 1 : 2;
            else if (ch === 92) {
                this.containsEsc = true;
                word += this.input.slice(chunkStart, this.pos);
                var escStart = this.pos;
                if (this.input.charCodeAt(++this.pos) !== 117) this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX");
                ++this.pos;
                var esc = this.readCodePoint();
                if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral)) this.invalidStringToken(escStart, "Invalid Unicode escape");
                word += codePointToString(esc);
                chunkStart = this.pos;
            } else break;
            first = false;
        }
        return word + this.input.slice(chunkStart, this.pos);
    };
    // Read an identifier or keyword token. Will check for reserved
    // words when necessary.
    pp$a.readWord = function() {
        var word = this.readWord1();
        var type = types$1.name;
        if (this.keywords.test(word)) type = keywords[word];
        return this.finishToken(type, word);
    };
    // Acorn is a tiny, fast JavaScript parser written in JavaScript.
    //
    // Acorn was written by Marijn Haverbeke, Ingvar Stepanyan, and
    // various contributors and released under an MIT license.
    //
    // Git repositories for Acorn are available at
    //
    //     http://marijnhaverbeke.nl/git/acorn
    //     https://github.com/acornjs/acorn.git
    //
    // Please use the [github bug tracker][ghbt] to report issues.
    //
    // [ghbt]: https://github.com/acornjs/acorn/issues
    //
    // [walk]: util/walk.js
    var version = "8.11.3";
    Parser$1.acorn = {
        Parser: Parser$1,
        version: version,
        defaultOptions: defaultOptions,
        Position: Position,
        SourceLocation: SourceLocation,
        getLineInfo: getLineInfo,
        Node: Node$1,
        TokenType: TokenType,
        tokTypes: types$1,
        keywordTypes: keywords,
        TokContext: TokContext,
        tokContexts: types,
        isIdentifierChar: isIdentifierChar,
        isIdentifierStart: isIdentifierStart,
        Token: Token,
        isNewLine: isNewLine,
        lineBreak: lineBreak,
        lineBreakG: lineBreakG,
        nonASCIIwhitespace: nonASCIIwhitespace
    };
    // The main exported interface (under `self.acorn` when in the
    // browser) is a `parse` function that takes a code string and returns
    // an abstract syntax tree as specified by the [ESTree spec][estree].
    //
    // [estree]: https://github.com/estree/estree
    function parse$b(input, options) {
        return Parser$1.parse(input, options);
    }
    // This function tries to parse a single expression at a given
    // offset in a string. Useful for parsing mixed-language formats
    // that embed JavaScript expressions.
    function parseExpressionAt$1(input, pos, options) {
        return Parser$1.parseExpressionAt(input, pos, options);
    }
    /**
 * @template T
 * @overload
 * @param {T[][]} nodes
 * @param {T[]} [target]
 * @returns {T[]}
 */ /**
 * @template T
 * @overload
 * @param {T[]} nodes
 * @param {T[]} [target]
 * @returns {T[]}
 */ /**
 * @param {any[]} nodes
 * @param {any[]} [target]
 * @returns {any[]}
 */ function flatten$1(nodes, target = []) {
        for(let i = 0; i < nodes.length; i += 1){
            const node = nodes[i];
            if (Array.isArray(node)) flatten$1(node, target);
            else target.push(node);
        }
        return target;
    }
    const regex_whitespace = /\s/;
    const regex_whitespaces = /\s+/;
    const regex_starts_with_whitespace = /^\s/;
    const regex_starts_with_whitespaces = /^[ \t\r\n]*/;
    const regex_ends_with_whitespace = /\s$/;
    const regex_ends_with_whitespaces = /[ \t\r\n]*$/;
    const regex_only_whitespaces = /^[ \t\n\r\f]+$/;
    const regex_whitespace_characters = /\s/g;
    const regex_non_whitespace_character = /\S/;
    const regex_starts_with_newline = /^\r?\n/;
    const regex_not_newline_characters = /[^\n]/g;
    const regex_double_quotes = /"/g;
    const regex_backslashes = /\\/g;
    const regex_starts_with_underscore = /^_/;
    const regex_ends_with_underscore = /_$/;
    const regex_dimensions = /^(?:offset|client)(?:Width|Height)$/;
    const regex_content_rect = /^(?:contentRect)$/;
    const regex_content_box_size = /^(?:contentBoxSize)$/;
    const regex_border_box_size = /^(?:borderBoxSize)$/;
    const regex_device_pixel_content_box_size = /^(?:devicePixelContentBoxSize)$/;
    const regex_box_size = /^(?:contentRect|contentBoxSize|borderBoxSize|devicePixelContentBoxSize)$/;
    const regex_svelte_ignore = /^\s*svelte-ignore\s+([\s\S]+)\s*$/m;
    /**
 * @param {string} text
 * @returns {string[]}
 */ function extract_svelte_ignore(text) {
        const match = regex_svelte_ignore.exec(text);
        return match ? match[1].split(regex_whitespace).map((x)=>x.trim()).filter(Boolean) : [];
    }
    /**
 * @param {import('estree').Node} node
 * @returns {string[]}
 */ function extract_svelte_ignore_from_comments(node) {
        return flatten$1((node.leadingComments || []).map((comment)=>extract_svelte_ignore(comment.value)));
    }
    /**
 * @param {number} position
 * @param {import('../interfaces.js').TemplateNode[]} template_nodes
 * @returns {string[]}
 */ function extract_ignores_above_position(position, template_nodes) {
        const previous_node_idx = template_nodes.findIndex((child)=>child.end === position);
        if (previous_node_idx === -1) return [];
        for(let i = previous_node_idx; i >= 0; i--){
            const node = template_nodes[i];
            if (node.type !== "Comment" && node.type !== "Text") return [];
            if (node.type === "Comment") {
                if (node.ignores.length) return node.ignores;
            }
        }
        return [];
    }
    /**
 * @param {import('../compile/nodes/interfaces.js').INode} node
 * @returns {string[]}
 */ function extract_ignores_above_node(node) {
        /**
	 * This utilizes the fact that node has a prev and a next attribute
	 * which means that it can find svelte-ignores along
	 * the nodes on the same level as itself who share the same parent.
	 */ let cur_node = node.prev;
        while(cur_node){
            if (cur_node.type !== "Comment" && cur_node.type !== "Text") return [];
            if (cur_node.type === "Comment" && cur_node.ignores.length) return cur_node.ignores;
            cur_node = cur_node.prev;
        }
        return [];
    }
    /**
 * @param {string} name
 * @param {string[]} names
 */ function fuzzymatch(name, names) {
        const set = new FuzzySet(names);
        const matches = set.get(name);
        return matches && matches[0] && matches[0][0] > 0.7 ? matches[0][1] : null;
    }
    // adapted from https://github.com/Glench/fuzzyset.js/blob/master/lib/fuzzyset.js
    // BSD Licensed
    const GRAM_SIZE_LOWER = 2;
    const GRAM_SIZE_UPPER = 3;
    // return an edit distance from 0 to 1
    /**
 * @param {string} str1
 * @param {string} str2
 */ function _distance(str1, str2) {
        if (str1 === null && str2 === null) throw "Trying to compare two null values";
        if (str1 === null || str2 === null) return 0;
        str1 = String(str1);
        str2 = String(str2);
        const distance = levenshtein(str1, str2);
        return 1 - distance / Math.max(str1.length, str2.length);
    }
    // helper functions
    /**
 * @param {string} str1
 * @param {string} str2
 */ function levenshtein(str1, str2) {
        /**
	 * @type {number[]}
	 */ const current = [];
        let prev;
        let value;
        for(let i = 0; i <= str2.length; i++)for(let j = 0; j <= str1.length; j++){
            if (i && j) {
                if (str1.charAt(j - 1) === str2.charAt(i - 1)) value = prev;
                else value = Math.min(current[j], current[j - 1], prev) + 1;
            } else value = i + j;
            prev = current[j];
            current[j] = value;
        }
        return current.pop();
    }
    const non_word_regex = /[^\w, ]+/;
    /**
 * @param {string} value
 * @param {any} gram_size
 */ function iterate_grams(value, gram_size = 2) {
        const simplified = "-" + value.toLowerCase().replace(non_word_regex, "") + "-";
        const len_diff = gram_size - simplified.length;
        const results = [];
        if (len_diff > 0) for(let i = 0; i < len_diff; ++i)value += "-";
        for(let i = 0; i < simplified.length - gram_size + 1; ++i)results.push(simplified.slice(i, i + gram_size));
        return results;
    }
    /**
 * @param {string} value
 * @param {any} gram_size
 */ function gram_counter(value, gram_size = 2) {
        // return an object where key=gram, value=number of occurrences
        const result = {};
        const grams = iterate_grams(value, gram_size);
        let i = 0;
        for(i; i < grams.length; ++i)if (grams[i] in result) result[grams[i]] += 1;
        else result[grams[i]] = 1;
        return result;
    }
    /**
 * @param {any} a
 * @param {any} b
 */ function sort_descending(a, b) {
        return b[0] - a[0];
    }
    class FuzzySet {
        exact_set = {};
        match_dict = {};
        items = {};
        /**
	 * @param {string[]} arr
	 */ constructor(arr){
            // initialization
            for(let i = GRAM_SIZE_LOWER; i < GRAM_SIZE_UPPER + 1; ++i)this.items[i] = [];
            // add all the items to the set
            for(let i = 0; i < arr.length; ++i)this.add(arr[i]);
        }
        /**
	 * @param {string} value
	 */ add(value) {
            const normalized_value = value.toLowerCase();
            if (normalized_value in this.exact_set) return false;
            let i = GRAM_SIZE_LOWER;
            for(i; i < GRAM_SIZE_UPPER + 1; ++i)this._add(value, i);
        }
        /**
	 * @param {string} value
	 * @param {number} gram_size
	 */ _add(value, gram_size) {
            const normalized_value = value.toLowerCase();
            const items = this.items[gram_size] || [];
            const index = items.length;
            items.push(0);
            const gram_counts = gram_counter(normalized_value, gram_size);
            let sum_of_square_gram_counts = 0;
            let gram;
            let gram_count;
            for(gram in gram_counts){
                gram_count = gram_counts[gram];
                sum_of_square_gram_counts += Math.pow(gram_count, 2);
                if (gram in this.match_dict) this.match_dict[gram].push([
                    index,
                    gram_count
                ]);
                else this.match_dict[gram] = [
                    [
                        index,
                        gram_count
                    ]
                ];
            }
            const vector_normal = Math.sqrt(sum_of_square_gram_counts);
            items[index] = [
                vector_normal,
                normalized_value
            ];
            this.items[gram_size] = items;
            this.exact_set[normalized_value] = value;
        }
        /**
	 * @param {string} value
	 */ get(value) {
            const normalized_value = value.toLowerCase();
            const result = this.exact_set[normalized_value];
            if (result) return [
                [
                    1,
                    result
                ]
            ];
            let results = [];
            // start with high gram size and if there are no results, go to lower gram sizes
            for(let gram_size = GRAM_SIZE_UPPER; gram_size >= GRAM_SIZE_LOWER; --gram_size){
                results = this.__get(value, gram_size);
                if (results) return results;
            }
            return null;
        }
        /**
	 * @param {string} value
	 * @param {number} gram_size
	 */ __get(value, gram_size) {
            const normalized_value = value.toLowerCase();
            const matches = {};
            const gram_counts = gram_counter(normalized_value, gram_size);
            const items = this.items[gram_size];
            let sum_of_square_gram_counts = 0;
            let gram;
            let gram_count;
            let i;
            let index;
            let other_gram_count;
            for(gram in gram_counts){
                gram_count = gram_counts[gram];
                sum_of_square_gram_counts += Math.pow(gram_count, 2);
                if (gram in this.match_dict) for(i = 0; i < this.match_dict[gram].length; ++i){
                    index = this.match_dict[gram][i][0];
                    other_gram_count = this.match_dict[gram][i][1];
                    if (index in matches) matches[index] += gram_count * other_gram_count;
                    else matches[index] = gram_count * other_gram_count;
                }
            }
            const vector_normal = Math.sqrt(sum_of_square_gram_counts);
            let results = [];
            let match_score;
            // build a results list of [score, str]
            for(const match_index in matches){
                match_score = matches[match_index];
                results.push([
                    match_score / (vector_normal * items[match_index][0]),
                    items[match_index][1]
                ]);
            }
            results.sort(sort_descending);
            let new_results = [];
            const end_index = Math.min(50, results.length);
            // truncate somewhat arbitrarily to 50
            for(let i = 0; i < end_index; ++i)new_results.push([
                _distance(results[i][1], normalized_value),
                results[i][1]
            ]);
            results = new_results;
            results.sort(sort_descending);
            new_results = [];
            for(let i = 0; i < results.length; ++i)if (results[i][0] == results[0][0]) new_results.push([
                results[i][0],
                this.exact_set[results[i][1]]
            ]);
            return new_results;
        }
    }
    /** regex of all html void element names */ const void_element_names = /^(?:area|base|br|col|command|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/;
    /** regex of all html element names. svg and math are omitted because they belong to the svg elements namespace */ const html_element_names = /^(?:a|abbr|address|area|article|aside|audio|b|base|bdi|bdo|blockquote|body|br|button|canvas|caption|cite|code|col|colgroup|data|datalist|dd|del|details|dfn|dialog|div|dl|dt|em|embed|fieldset|figcaption|figure|footer|form|h1|h2|h3|h4|h5|h6|head|header|hr|html|i|iframe|img|input|ins|kbd|label|legend|li|link|main|map|mark|meta|meter|nav|noscript|object|ol|optgroup|option|output|p|param|picture|pre|progress|q|rp|rt|ruby|s|samp|script|section|select|small|source|span|strong|style|sub|summary|sup|table|tbody|td|template|textarea|tfoot|th|thead|time|title|tr|track|u|ul|var|video|wbr)$/;
    /** regex of all svg element names */ const svg$1 = /^(?:altGlyph|altGlyphDef|altGlyphItem|animate|animateColor|animateMotion|animateTransform|circle|clipPath|color-profile|cursor|defs|desc|discard|ellipse|feBlend|feColorMatrix|feComponentTransfer|feComposite|feConvolveMatrix|feDiffuseLighting|feDisplacementMap|feDistantLight|feDropShadow|feFlood|feFuncA|feFuncB|feFuncG|feFuncR|feGaussianBlur|feImage|feMerge|feMergeNode|feMorphology|feOffset|fePointLight|feSpecularLighting|feSpotLight|feTile|feTurbulence|filter|font|font-face|font-face-format|font-face-name|font-face-src|font-face-uri|foreignObject|g|glyph|glyphRef|hatch|hatchpath|hkern|image|line|linearGradient|marker|mask|mesh|meshgradient|meshpatch|meshrow|metadata|missing-glyph|mpath|path|pattern|polygon|polyline|radialGradient|rect|set|solidcolor|stop|svg|switch|symbol|text|textPath|tref|tspan|unknown|use|view|vkern)$/;
    /**
 * @param {string} name
 * @returns {boolean}
 */ function is_void(name) {
        return void_element_names.test(name) || name.toLowerCase() === "!doctype";
    }
    /**
 * @param {string} name
 * @returns {boolean}
 */ function is_html(name) {
        return html_element_names.test(name);
    }
    /**
 * @param {string} name
 * @returns {boolean}
 */ function is_svg(name) {
        return svg$1.test(name);
    }
    /**
 * @param {string[]} items
 * @param {string} [conjunction]
 */ function list(items, conjunction = "or") {
        if (items.length === 1) return items[0];
        return `${items.slice(0, -1).join(", ")} ${conjunction} ${items[items.length - 1]}`;
    }
    // All parser errors should be listed and accessed from here
    /**
 * @internal
 */ var parser_errors = {
        /**
	 * @param {string} message
	 */ css_syntax_error: (message)=>({
                code: "css-syntax-error",
                message: message
            }),
        duplicate_attribute: {
            code: "duplicate-attribute",
            message: "Attributes need to be unique"
        },
        /**
	 * @param {string} slug
	 * @param {string} name
	 */ duplicate_element: (slug, name)=>({
                code: `duplicate-${slug}`,
                message: `A component can only have one <${name}> tag`
            }),
        duplicate_style: {
            code: "duplicate-style",
            message: "You can only have one top-level <style> tag per component"
        },
        empty_attribute_shorthand: {
            code: "empty-attribute-shorthand",
            message: "Attribute shorthand cannot be empty"
        },
        /**
	 * @param {string} type
	 */ empty_directive_name: (type)=>({
                code: "empty-directive-name",
                message: `${type} name cannot be empty`
            }),
        empty_global_selector: {
            code: "css-syntax-error",
            message: ":global() must contain a selector"
        },
        expected_block_type: {
            code: "expected-block-type",
            message: "Expected if, each or await"
        },
        expected_name: {
            code: "expected-name",
            message: "Expected name"
        },
        /** @param {string} block */ invalid_catch_placement_unclosed_block: (block)=>({
                code: "invalid-catch-placement",
                message: `Expected to close ${block} before seeing {:catch} block`
            }),
        invalid_catch_placement_without_await: {
            code: "invalid-catch-placement",
            message: "Cannot have an {:catch} block outside an {#await ...} block"
        },
        invalid_component_definition: {
            code: "invalid-component-definition",
            message: "invalid component definition"
        },
        /**
	 * @param {string} name
	 */ invalid_closing_tag_unopened: (name)=>({
                code: "invalid-closing-tag",
                message: `</${name}> attempted to close an element that was not open`
            }),
        /**
	 * @param {string} name
	 * @param {string} reason
	 */ invalid_closing_tag_autoclosed: (name, reason)=>({
                code: "invalid-closing-tag",
                message: `</${name}> attempted to close <${name}> that was already automatically closed by <${reason}>`
            }),
        invalid_debug_args: {
            code: "invalid-debug-args",
            message: "{@debug ...} arguments must be identifiers, not arbitrary expressions"
        },
        invalid_declaration: {
            code: "invalid-declaration",
            message: "Declaration cannot be empty"
        },
        invalid_directive_value: {
            code: "invalid-directive-value",
            message: "Directive value must be a JavaScript expression enclosed in curly braces"
        },
        invalid_elseif: {
            code: "invalid-elseif",
            message: "'elseif' should be 'else if'"
        },
        invalid_elseif_placement_outside_if: {
            code: "invalid-elseif-placement",
            message: "Cannot have an {:else if ...} block outside an {#if ...} block"
        },
        /**
	 * @param {string} block
	 */ invalid_elseif_placement_unclosed_block: (block)=>({
                code: "invalid-elseif-placement",
                message: `Expected to close ${block} before seeing {:else if ...} block`
            }),
        invalid_else_placement_outside_if: {
            code: "invalid-else-placement",
            message: "Cannot have an {:else} block outside an {#if ...} or {#each ...} block"
        },
        /**
	 * @param {string} block
	 */ invalid_else_placement_unclosed_block: (block)=>({
                code: "invalid-else-placement",
                message: `Expected to close ${block} before seeing {:else} block`
            }),
        /**
	 * @param {string} slug
	 * @param {string} name
	 */ invalid_element_content: (slug, name)=>({
                code: `invalid-${slug}-content`,
                message: `<${name}> cannot have children`
            }),
        invalid_element_definition: {
            code: "invalid-element-definition",
            message: "Invalid element definition"
        },
        /**
	 * @param {string} slug
	 * @param {string} name
	 */ invalid_element_placement: (slug, name)=>({
                code: `invalid-${slug}-placement`,
                message: `<${name}> tags cannot be inside elements or blocks`
            }),
        /**
	 * @param {string} location
	 * @param {string} name
	 */ invalid_logic_block_placement: (location, name)=>({
                code: "invalid-logic-block-placement",
                message: `{#${name}} logic block cannot be ${location}`
            }),
        /**
	 * @param {string} location
	 * @param {string} name
	 */ invalid_tag_placement: (location, name)=>({
                code: "invalid-tag-placement",
                message: `{@${name}} tag cannot be ${location}`
            }),
        /**
	 * @param {string} name
	 */ invalid_ref_directive: (name)=>({
                code: "invalid-ref-directive",
                message: `The ref directive is no longer supported \u{2014} use \`bind:this={${name}}\` instead`
            }),
        invalid_ref_selector: {
            code: "invalid-ref-selector",
            message: "ref selectors are no longer supported"
        },
        invalid_self_placement: {
            code: "invalid-self-placement",
            message: "<svelte:self> components can only exist inside {#if} blocks, {#each} blocks, or slots passed to components"
        },
        invalid_script_instance: {
            code: "invalid-script",
            message: "A component can only have one instance-level <script> element"
        },
        invalid_script_module: {
            code: "invalid-script",
            message: 'A component can only have one <script context="module"> element'
        },
        invalid_script_context_attribute: {
            code: "invalid-script",
            message: "context attribute must be static"
        },
        invalid_script_context_value: {
            code: "invalid-script",
            message: 'If the context attribute is supplied, its value must be "module"'
        },
        invalid_tag_name: {
            code: "invalid-tag-name",
            message: "Expected valid tag name"
        },
        /**
	 * @param {string[]} tags
	 * @param {string} match
	 */ invalid_tag_name_svelte_element: (tags, match)=>({
                code: "invalid-tag-name",
                message: `Valid <svelte:...> tag names are ${list(tags)}${match ? " (did you mean " + match + "?)" : ""}`
            }),
        /** @param {string} block */ invalid_then_placement_unclosed_block: (block)=>({
                code: "invalid-then-placement",
                message: `Expected to close ${block} before seeing {:then} block`
            }),
        invalid_then_placement_without_await: {
            code: "invalid-then-placement",
            message: "Cannot have an {:then} block outside an {#await ...} block"
        },
        /**
	 * @param {string} name
	 */ invalid_void_content: (name)=>({
                code: "invalid-void-content",
                message: `<${name}> is a void element and cannot have children, or a closing tag`
            }),
        missing_component_definition: {
            code: "missing-component-definition",
            message: "<svelte:component> must have a 'this' attribute"
        },
        missing_attribute_value: {
            code: "missing-attribute-value",
            message: "Expected value for the attribute"
        },
        missing_element_definition: {
            code: "missing-element-definition",
            message: "<svelte:element> must have a 'this' attribute"
        },
        unclosed_script: {
            code: "unclosed-script",
            message: "<script> must have a closing tag"
        },
        unclosed_style: {
            code: "unclosed-style",
            message: "<style> must have a closing tag"
        },
        unclosed_comment: {
            code: "unclosed-comment",
            message: "comment was left open, expected -->"
        },
        /**
	 * @param {string} token
	 */ unclosed_attribute_value: (token)=>({
                code: "unclosed-attribute-value",
                message: `Expected to close the attribute value with ${token}`
            }),
        unexpected_block_close: {
            code: "unexpected-block-close",
            message: "Unexpected block closing tag"
        },
        unexpected_eof: {
            code: "unexpected-eof",
            message: "Unexpected end of input"
        },
        /**
	 * @param {string} token
	 */ unexpected_eof_token: (token)=>({
                code: "unexpected-eof",
                message: `Unexpected ${token}`
            }),
        /**
	 * @param {string} token
	 */ unexpected_token: (token)=>({
                code: "unexpected-token",
                message: `Expected ${token}`
            }),
        unexpected_token_destructure: {
            code: "unexpected-token",
            message: "Expected identifier or destructure pattern"
        }
    };
    /**
 * @typedef { import('estree').Node} Node
 * @typedef {{
 *   skip: () => void;
 *   remove: () => void;
 *   replace: (node: Node) => void;
 * }} WalkerContext
 */ class WalkerBase {
        constructor(){
            /** @type {boolean} */ this.should_skip = false;
            /** @type {boolean} */ this.should_remove = false;
            /** @type {Node | null} */ this.replacement = null;
            /** @type {WalkerContext} */ this.context = {
                skip: ()=>this.should_skip = true,
                remove: ()=>this.should_remove = true,
                replace: (node)=>this.replacement = node
            };
        }
        /**
	 * @template {Node} Parent
	 * @param {Parent | null | undefined} parent
	 * @param {keyof Parent | null | undefined} prop
	 * @param {number | null | undefined} index
	 * @param {Node} node
	 */ replace(parent, prop, index, node) {
            if (parent && prop) {
                if (index != null) /** @type {Array<Node>} */ parent[prop][index] = node;
                else /** @type {Node} */ parent[prop] = node;
            }
        }
        /**
	 * @template {Node} Parent
	 * @param {Parent | null | undefined} parent
	 * @param {keyof Parent | null | undefined} prop
	 * @param {number | null | undefined} index
	 */ remove(parent, prop, index) {
            if (parent && prop) {
                if (index !== null && index !== undefined) /** @type {Array<Node>} */ parent[prop].splice(index, 1);
                else delete parent[prop];
            }
        }
    }
    /**
 * @typedef { import('estree').Node} Node
 * @typedef { import('./walker.js').WalkerContext} WalkerContext
 * @typedef {(
 *    this: WalkerContext,
 *    node: Node,
 *    parent: Node | null,
 *    key: string | number | symbol | null | undefined,
 *    index: number | null | undefined
 * ) => void} SyncHandler
 */ class SyncWalker extends WalkerBase {
        /**
	 *
	 * @param {SyncHandler} [enter]
	 * @param {SyncHandler} [leave]
	 */ constructor(enter, leave){
            super();
            /** @type {boolean} */ this.should_skip = false;
            /** @type {boolean} */ this.should_remove = false;
            /** @type {Node | null} */ this.replacement = null;
            /** @type {WalkerContext} */ this.context = {
                skip: ()=>this.should_skip = true,
                remove: ()=>this.should_remove = true,
                replace: (node)=>this.replacement = node
            };
            /** @type {SyncHandler | undefined} */ this.enter = enter;
            /** @type {SyncHandler | undefined} */ this.leave = leave;
        }
        /**
	 * @template {Node} Parent
	 * @param {Node} node
	 * @param {Parent | null} parent
	 * @param {keyof Parent} [prop]
	 * @param {number | null} [index]
	 * @returns {Node | null}
	 */ visit(node, parent, prop, index) {
            if (node) {
                if (this.enter) {
                    const _should_skip = this.should_skip;
                    const _should_remove = this.should_remove;
                    const _replacement = this.replacement;
                    this.should_skip = false;
                    this.should_remove = false;
                    this.replacement = null;
                    this.enter.call(this.context, node, parent, prop, index);
                    if (this.replacement) {
                        node = this.replacement;
                        this.replace(parent, prop, index, node);
                    }
                    if (this.should_remove) this.remove(parent, prop, index);
                    const skipped = this.should_skip;
                    const removed = this.should_remove;
                    this.should_skip = _should_skip;
                    this.should_remove = _should_remove;
                    this.replacement = _replacement;
                    if (skipped) return node;
                    if (removed) return null;
                }
                /** @type {keyof Node} */ let key;
                for(key in node){
                    /** @type {unknown} */ const value = node[key];
                    if (value && typeof value === "object") {
                        if (Array.isArray(value)) {
                            const nodes = /** @type {Array<unknown>} */ value;
                            for(let i = 0; i < nodes.length; i += 1){
                                const item = nodes[i];
                                if (isNode(item)) {
                                    if (!this.visit(item, node, key, i)) // removed
                                    i--;
                                }
                            }
                        } else if (isNode(value)) this.visit(value, node, key, null);
                    }
                }
                if (this.leave) {
                    const _replacement = this.replacement;
                    const _should_remove = this.should_remove;
                    this.replacement = null;
                    this.should_remove = false;
                    this.leave.call(this.context, node, parent, prop, index);
                    if (this.replacement) {
                        node = this.replacement;
                        this.replace(parent, prop, index, node);
                    }
                    if (this.should_remove) this.remove(parent, prop, index);
                    const removed = this.should_remove;
                    this.replacement = _replacement;
                    this.should_remove = _should_remove;
                    if (removed) return null;
                }
            }
            return node;
        }
    }
    /**
 * Ducktype a node.
 *
 * @param {unknown} value
 * @returns {value is Node}
 */ function isNode(value) {
        return value !== null && typeof value === "object" && "type" in value && typeof value.type === "string";
    }
    /**
 * @typedef {import('estree').Node} Node
 * @typedef {import('./sync.js').SyncHandler} SyncHandler
 * @typedef {import('./async.js').AsyncHandler} AsyncHandler
 */ /**
 * @param {Node} ast
 * @param {{
 *   enter?: SyncHandler
 *   leave?: SyncHandler
 * }} walker
 * @returns {Node | null}
 */ function walk(ast, { enter: enter, leave: leave }) {
        const instance = new SyncWalker(enter, leave);
        return instance.visit(ast, null);
    }
    // generate an ID that is, to all intents and purposes, unique
    const id = Math.round(Math.random() * 1e20).toString(36);
    const re$1 = new RegExp(`_${id}_(?:(\\d+)|(AT)|(HASH))_(\\w+)?`, "g");
    /** @typedef {import('estree').Comment} Comment */ /** @typedef {import('estree').Node} Node */ /**
 * @typedef {Node & {
 *   start: number;
 *   end: number;
 *   has_trailing_newline?: boolean
 * }} NodeWithLocation
 */ /**
 * @typedef {Comment & {
 *   start: number;
 *   end: number;
 *   has_trailing_newline?: boolean
 * }} CommentWithLocation
 */ /**
 * @param {CommentWithLocation[]} comments
 * @param {string} raw
 */ const get_comment_handlers = (comments, raw)=>({
            // pass to acorn options
            /**
	 * @param {boolean} block
	 * @param {string} value
	 * @param {number} start
	 * @param {number} end
	 */ onComment: (block, value, start, end)=>{
                if (block && /\n/.test(value)) {
                    let a = start;
                    while(a > 0 && raw[a - 1] !== "\n")a -= 1;
                    let b = a;
                    while(/[ \t]/.test(raw[b]))b += 1;
                    const indentation = raw.slice(a, b);
                    value = value.replace(new RegExp(`^${indentation}`, "gm"), "");
                }
                comments.push({
                    type: block ? "Block" : "Line",
                    value: value,
                    start: start,
                    end: end
                });
            },
            // pass to estree-walker options
            /** @param {NodeWithLocation} node */ enter (node) {
                let comment;
                while(comments[0] && comments[0].start < node.start){
                    comment = comments.shift();
                    comment.value = comment.value.replace(re$1, (match, id, at, hash, value)=>{
                        if (hash) return `#${value}`;
                        if (at) return `@${value}`;
                        return match;
                    });
                    const next = comments[0] || node;
                    comment.has_trailing_newline = comment.type === "Line" || /\n/.test(raw.slice(comment.end, next.start));
                    (node.leadingComments || (node.leadingComments = [])).push(comment);
                }
            },
            /** @param {NodeWithLocation} node */ leave (node) {
                if (comments[0]) {
                    const slice = raw.slice(node.end, comments[0].start);
                    if (/^[,) \t]*$/.test(slice)) node.trailingComments = [
                        comments.shift()
                    ];
                }
            }
        });
    /** @typedef { import('estree').Node} Node */ /** @typedef {Node | {
 *   type: 'PropertyDefinition';
 *   computed: boolean;
 *   value: Node
 * }} NodeWithPropertyDefinition */ /**
 *
 * @param {NodeWithPropertyDefinition} node
 * @param {NodeWithPropertyDefinition} parent
 * @returns {boolean}
 */ function is_reference(node, parent) {
        if (node.type === "MemberExpression") return !node.computed && is_reference(node.object, node);
        if (node.type === "Identifier") {
            if (!parent) return true;
            switch(parent.type){
                // disregard `bar` in `foo.bar`
                case "MemberExpression":
                    return parent.computed || node === parent.object;
                // disregard the `foo` in `class {foo(){}}` but keep it in `class {[foo](){}}`
                case "MethodDefinition":
                    return parent.computed;
                // disregard the `foo` in `class {foo=bar}` but keep it in `class {[foo]=bar}` and `class {bar=foo}`
                case "PropertyDefinition":
                    return parent.computed || node === parent.value;
                // disregard the `bar` in `{ bar: foo }`, but keep it in `{ [bar]: foo }`
                case "Property":
                    return parent.computed || node === parent.value;
                // disregard the `bar` in `export { foo as bar }` or
                // the foo in `import { foo as bar }`
                case "ExportSpecifier":
                case "ImportSpecifier":
                    return node === parent.local;
                // disregard the `foo` in `foo: while (...) { ... break foo; ... continue foo;}`
                case "LabeledStatement":
                case "BreakStatement":
                case "ContinueStatement":
                    return false;
                default:
                    return true;
            }
        }
        return false;
    }
    /** @param {import('estree').Node} expression */ function analyze(expression) {
        /** @typedef {import('estree').Node} Node */ /** @type {WeakMap<Node, Scope>} */ const map = new WeakMap();
        /** @type {Map<string, Node>} */ const globals = new Map();
        const scope = new Scope(null, false);
        /** @type {[Scope, import('estree').Identifier][]} */ const references = [];
        /** @type {Scope} */ let current_scope = scope;
        walk(expression, {
            enter (node, parent) {
                switch(node.type){
                    case "Identifier":
                        if (parent && is_reference(node, parent)) references.push([
                            current_scope,
                            node
                        ]);
                        break;
                    case "ImportDeclaration":
                        node.specifiers.forEach((specifier)=>{
                            current_scope.declarations.set(specifier.local.name, specifier);
                        });
                        break;
                    case "FunctionExpression":
                    case "FunctionDeclaration":
                    case "ArrowFunctionExpression":
                        if (node.type === "FunctionDeclaration") {
                            if (node.id) current_scope.declarations.set(node.id.name, node);
                            map.set(node, current_scope = new Scope(current_scope, false));
                        } else {
                            map.set(node, current_scope = new Scope(current_scope, false));
                            if (node.type === "FunctionExpression" && node.id) current_scope.declarations.set(node.id.name, node);
                        }
                        node.params.forEach((param)=>{
                            extract_names(param).forEach((name)=>{
                                current_scope.declarations.set(name, node);
                            });
                        });
                        break;
                    case "ForStatement":
                    case "ForInStatement":
                    case "ForOfStatement":
                        map.set(node, current_scope = new Scope(current_scope, true));
                        break;
                    case "BlockStatement":
                        map.set(node, current_scope = new Scope(current_scope, true));
                        break;
                    case "ClassDeclaration":
                    case "VariableDeclaration":
                        current_scope.add_declaration(node);
                        break;
                    case "CatchClause":
                        map.set(node, current_scope = new Scope(current_scope, true));
                        if (node.param) extract_names(node.param).forEach((name)=>{
                            if (node.param) current_scope.declarations.set(name, node.param);
                        });
                        break;
                }
            },
            leave (node) {
                if (map.has(node) && current_scope !== null && current_scope.parent) current_scope = current_scope.parent;
            }
        });
        for(let i = references.length - 1; i >= 0; --i){
            const [scope, reference] = references[i];
            if (!scope.references.has(reference.name)) add_reference(scope, reference.name);
            if (!scope.find_owner(reference.name)) globals.set(reference.name, reference);
        }
        return {
            map: map,
            scope: scope,
            globals: globals
        };
    }
    /**
 * @param {Scope} scope
 * @param {string} name
 */ function add_reference(scope, name) {
        scope.references.add(name);
        if (scope.parent) add_reference(scope.parent, name);
    }
    class Scope {
        /**
	 * @param {Scope | null} parent 
	 * @param {boolean} block 
	 */ constructor(parent, block){
            /** @type {Scope | null} */ this.parent = parent;
            /** @type {boolean} */ this.block = block;
            /** @type {Map<string, import('estree').Node>} */ this.declarations = new Map();
            /** @type {Set<string>} */ this.initialised_declarations = new Set();
            /** @type {Set<string>} */ this.references = new Set();
        }
        /**
	 * @param {import('estree').VariableDeclaration | import('estree').ClassDeclaration} node
	 */ add_declaration(node) {
            if (node.type === "VariableDeclaration") {
                if (node.kind === "var" && this.block && this.parent) this.parent.add_declaration(node);
                else {
                    /** @param {import('estree').VariableDeclarator} declarator */ const handle_declarator = (declarator)=>{
                        extract_names(declarator.id).forEach((name)=>{
                            this.declarations.set(name, node);
                            if (declarator.init) this.initialised_declarations.add(name);
                        });
                    };
                    node.declarations.forEach(handle_declarator);
                }
            } else if (node.id) this.declarations.set(node.id.name, node);
        }
        /**
	 * @param {string} name
	 * @returns {Scope | null}
	 */ find_owner(name) {
            if (this.declarations.has(name)) return this;
            return this.parent && this.parent.find_owner(name);
        }
        /**
	 * @param {string} name
	 * @returns {boolean}
	 */ has(name) {
            return this.declarations.has(name) || !!this.parent && this.parent.has(name);
        }
    }
    /**
 * @param {import('estree').Node} param
 * @returns {string[]}
 */ function extract_names(param) {
        return extract_identifiers(param).map((node)=>node.name);
    }
    /**
 * @param {import('estree').Node} param
 * @param {import('estree').Identifier[]} nodes
 * @returns {import('estree').Identifier[]}
 */ function extract_identifiers(param, nodes = []) {
        switch(param.type){
            case "Identifier":
                nodes.push(param);
                break;
            case "MemberExpression":
                let object = param;
                while(object.type === "MemberExpression")object = /** @type {any} */ object.object;
                nodes.push(/** @type {any} */ object);
                break;
            case "ObjectPattern":
                /** @param {import('estree').Property | import('estree').RestElement} prop */ const handle_prop = (prop)=>{
                    if (prop.type === "RestElement") extract_identifiers(prop.argument, nodes);
                    else extract_identifiers(prop.value, nodes);
                };
                param.properties.forEach(handle_prop);
                break;
            case "ArrayPattern":
                /** @param {import('estree').Node} element */ const handle_element = (element)=>{
                    if (element) extract_identifiers(element, nodes);
                };
                param.elements.forEach((element)=>{
                    if (element) handle_element(element);
                });
                break;
            case "RestElement":
                extract_identifiers(param.argument, nodes);
                break;
            case "AssignmentPattern":
                extract_identifiers(param.left, nodes);
                break;
        }
        return nodes;
    }
    /**
 * Does `array.push` for all `items`. Needed because `array.push(...items)` throws
 * "Maximum call stack size exceeded" when `items` is too big of an array.
 *
 * @param {any[]} array
 * @param {any[]} items
 */ function push_array$1(array, items) {
        for(let i = 0; i < items.length; i++)array.push(items[i]);
    }
    // heavily based on https://github.com/davidbonnet/astring
    // released under MIT license https://github.com/davidbonnet/astring/blob/master/LICENSE
    /** @typedef {import('estree').ArrowFunctionExpression} ArrowFunctionExpression */ /** @typedef {import('estree').BinaryExpression} BinaryExpression */ /** @typedef {import('estree').CallExpression} CallExpression */ /** @typedef {import('estree').Comment} Comment */ /** @typedef {import('estree').ExportSpecifier} ExportSpecifier */ /** @typedef {import('estree').Expression} Expression */ /** @typedef {import('estree').FunctionDeclaration} FunctionDeclaration */ /** @typedef {import('estree').ImportDeclaration} ImportDeclaration */ /** @typedef {import('estree').ImportSpecifier} ImportSpecifier */ /** @typedef {import('estree').Literal} Literal */ /** @typedef {import('estree').LogicalExpression} LogicalExpression */ /** @typedef {import('estree').NewExpression} NewExpression */ /** @typedef {import('estree').Node} Node */ /** @typedef {import('estree').ObjectExpression} ObjectExpression */ /** @typedef {import('estree').Pattern} Pattern */ /** @typedef {import('estree').Property} Property */ /** @typedef {import('estree').PropertyDefinition} PropertyDefinition */ /** @typedef {import('estree').SequenceExpression} SequenceExpression */ /** @typedef {import('estree').SimpleCallExpression} SimpleCallExpression */ /** @typedef {import('estree').SwitchStatement} SwitchStatement */ /** @typedef {import('estree').VariableDeclaration} VariableDeclaration */ /** @typedef {import('estree').StaticBlock} StaticBlock */ /** @typedef {import('estree').PrivateIdentifier} PrivateIdenifier*/ /**
 * @typedef {{
 *   content: string;
 *   loc?: {
 *     start: { line: number; column: number; };
 *     end: { line: number; column: number; };
 *   };
 *   has_newline: boolean;
 * }} Chunk
 */ /**
 * @typedef {(node: any, state: State) => Chunk[]} Handler
 */ /**
 * @typedef {{
 *   indent: string;
 *   scope: any; // TODO import from periscopic
 *   scope_map: WeakMap<Node, any>;
 *   getName: (name: string) => string;
 *   deconflicted: WeakMap<Node, Map<string, string>>;
 *   comments: Comment[];
 * }} State
 */ /**
 * @param {Node} node
 * @param {State} state
 * @returns {Chunk[]}
 */ function handle(node, state) {
        const handler = handlers$1[node.type];
        if (!handler) throw new Error(`Not implemented ${node.type}`);
        const result = handler(node, state);
        if (node.leadingComments) result.unshift(c(node.leadingComments.map((comment)=>comment.type === "Block" ? `/*${comment.value}*/${/** @type {any} */ comment.has_trailing_newline ? `\n${state.indent}` : ` `}` : `//${comment.value}${/** @type {any} */ comment.has_trailing_newline ? `\n${state.indent}` : ` `}`).join(``)));
        if (node.trailingComments) state.comments.push(node.trailingComments[0]); // there is only ever one
        return result;
    }
    /**
 * @param {string} content
 * @param {Node} [node]
 * @returns {Chunk}
 */ function c(content, node) {
        return {
            content: content,
            loc: node && node.loc,
            has_newline: /\n/.test(content)
        };
    }
    const OPERATOR_PRECEDENCE = {
        "||": 2,
        "&&": 3,
        "??": 4,
        "|": 5,
        "^": 6,
        "&": 7,
        "==": 8,
        "!=": 8,
        "===": 8,
        "!==": 8,
        "<": 9,
        ">": 9,
        "<=": 9,
        ">=": 9,
        in: 9,
        instanceof: 9,
        "<<": 10,
        ">>": 10,
        ">>>": 10,
        "+": 11,
        "-": 11,
        "*": 12,
        "%": 12,
        "/": 12,
        "**": 13
    };
    /** @type {Record<string, number>} */ const EXPRESSIONS_PRECEDENCE = {
        ArrayExpression: 20,
        TaggedTemplateExpression: 20,
        ThisExpression: 20,
        Identifier: 20,
        Literal: 18,
        TemplateLiteral: 20,
        Super: 20,
        SequenceExpression: 20,
        MemberExpression: 19,
        CallExpression: 19,
        NewExpression: 19,
        AwaitExpression: 17,
        ClassExpression: 17,
        FunctionExpression: 17,
        ObjectExpression: 17,
        UpdateExpression: 16,
        UnaryExpression: 15,
        BinaryExpression: 14,
        LogicalExpression: 13,
        ConditionalExpression: 4,
        ArrowFunctionExpression: 3,
        AssignmentExpression: 3,
        YieldExpression: 2,
        RestElement: 1
    };
    /**
 *
 * @param {Expression} node
 * @param {BinaryExpression | LogicalExpression} parent
 * @param {boolean} is_right
 * @returns
 */ function needs_parens(node, parent, is_right) {
        // special case where logical expressions and coalesce expressions cannot be mixed,
        // either of them need to be wrapped with parentheses
        if (node.type === "LogicalExpression" && parent.type === "LogicalExpression" && (parent.operator === "??" && node.operator !== "??" || parent.operator !== "??" && node.operator === "??")) return true;
        const precedence = EXPRESSIONS_PRECEDENCE[node.type];
        const parent_precedence = EXPRESSIONS_PRECEDENCE[parent.type];
        if (precedence !== parent_precedence) // Different node types
        return !is_right && precedence === 15 && parent_precedence === 14 && parent.operator === "**" || precedence < parent_precedence;
        if (precedence !== 13 && precedence !== 14) // Not a `LogicalExpression` or `BinaryExpression`
        return false;
        if (/** @type {BinaryExpression} */ node.operator === "**" && parent.operator === "**") // Exponentiation operator has right-to-left associativity
        return !is_right;
        if (is_right) // Parenthesis are used if both operators have the same precedence
        return OPERATOR_PRECEDENCE[/** @type {BinaryExpression} */ node.operator] <= OPERATOR_PRECEDENCE[parent.operator];
        return OPERATOR_PRECEDENCE[/** @type {BinaryExpression} */ node.operator] < OPERATOR_PRECEDENCE[parent.operator];
    }
    /** @param {Node} node */ function has_call_expression(node) {
        while(node){
            if (node.type[0] === "CallExpression") return true;
            else if (node.type === "MemberExpression") node = node.object;
            else return false;
        }
    }
    /** @param {Chunk[]} chunks */ const has_newline = (chunks)=>{
        for(let i = 0; i < chunks.length; i += 1){
            if (chunks[i].has_newline) return true;
        }
        return false;
    };
    /** @param {Chunk[]} chunks */ const get_length = (chunks)=>{
        let total = 0;
        for(let i = 0; i < chunks.length; i += 1)total += chunks[i].content.length;
        return total;
    };
    /**
 * @param {number} a
 * @param {number} b
 */ const sum = (a, b)=>a + b;
    /**
 * @param {Chunk[][]} nodes
 * @param {Chunk} separator
 * @returns {Chunk[]}
 */ const join$1 = (nodes, separator)=>{
        if (nodes.length === 0) return [];
        const joined = [
            ...nodes[0]
        ];
        for(let i = 1; i < nodes.length; i += 1){
            joined.push(separator);
            push_array$1(joined, nodes[i]);
        }
        return joined;
    };
    /**
 * @param {(node: any, state: State) => Chunk[]} fn
 */ const scoped = (fn)=>{
        /**
	 * @param {any} node
	 * @param {State} state
	 */ const scoped_fn = (node, state)=>{
            return fn(node, {
                ...state,
                scope: state.scope_map.get(node)
            });
        };
        return scoped_fn;
    };
    /**
 * @param {string} name
 * @param {Set<string>} names
 */ const deconflict = (name, names)=>{
        const original = name;
        let i = 1;
        while(names.has(name))name = `${original}$${i++}`;
        return name;
    };
    /**
 * @param {Node[]} nodes
 * @param {State} state
 */ const handle_body = (nodes, state)=>{
        const chunks = [];
        const body = nodes.map((statement)=>{
            const chunks = handle(statement, {
                ...state,
                indent: state.indent
            });
            let add_newline = false;
            while(state.comments.length){
                const comment = state.comments.shift();
                const prefix = add_newline ? `\n${state.indent}` : ` `;
                chunks.push(c(comment.type === "Block" ? `${prefix}/*${comment.value}*/` : `${prefix}//${comment.value}`));
                add_newline = comment.type === "Line";
            }
            return chunks;
        });
        let needed_padding = false;
        for(let i = 0; i < body.length; i += 1){
            const needs_padding = has_newline(body[i]);
            if (i > 0) chunks.push(c(needs_padding || needed_padding ? `\n\n${state.indent}` : `\n${state.indent}`));
            push_array$1(chunks, body[i]);
            needed_padding = needs_padding;
        }
        return chunks;
    };
    /**
 * @param {VariableDeclaration} node
 * @param {State} state
 */ const handle_var_declaration = (node, state)=>{
        const chunks = [
            c(`${node.kind} `)
        ];
        const declarators = node.declarations.map((d)=>handle(d, {
                ...state,
                indent: state.indent + (node.declarations.length === 1 ? "" : "	")
            }));
        const multiple_lines = declarators.some(has_newline) || declarators.map(get_length).reduce(sum, 0) + (state.indent.length + declarators.length - 1) * 2 > 80;
        const separator = c(multiple_lines ? `,\n${state.indent}\t` : ", ");
        push_array$1(chunks, join$1(declarators, separator));
        return chunks;
    };
    /** @type {Record<string, Handler>} */ const handlers$1 = {
        Program (node, state) {
            return handle_body(node.body, state);
        },
        BlockStatement: scoped((node, state)=>{
            return [
                c(`{\n${state.indent}\t`),
                ...handle_body(node.body, {
                    ...state,
                    indent: state.indent + "	"
                }),
                c(`\n${state.indent}}`)
            ];
        }),
        EmptyStatement (node, state) {
            return [
                c(";")
            ];
        },
        ParenthesizedExpression (node, state) {
            return handle(node.expression, state);
        },
        ExpressionStatement (node, state) {
            if (node.expression.type === "AssignmentExpression" && node.expression.left.type === "ObjectPattern") // is an AssignmentExpression to an ObjectPattern
            return [
                c("("),
                ...handle(node.expression, state),
                c(");")
            ];
            return [
                ...handle(node.expression, state),
                c(";")
            ];
        },
        IfStatement (node, state) {
            const chunks = [
                c("if ("),
                ...handle(node.test, state),
                c(") "),
                ...handle(node.consequent, state)
            ];
            if (node.alternate) {
                chunks.push(c(" else "));
                push_array$1(chunks, handle(node.alternate, state));
            }
            return chunks;
        },
        LabeledStatement (node, state) {
            return [
                ...handle(node.label, state),
                c(": "),
                ...handle(node.body, state)
            ];
        },
        BreakStatement (node, state) {
            return node.label ? [
                c("break "),
                ...handle(node.label, state),
                c(";")
            ] : [
                c("break;")
            ];
        },
        ContinueStatement (node, state) {
            return node.label ? [
                c("continue "),
                ...handle(node.label, state),
                c(";")
            ] : [
                c("continue;")
            ];
        },
        WithStatement (node, state) {
            return [
                c("with ("),
                ...handle(node.object, state),
                c(") "),
                ...handle(node.body, state)
            ];
        },
        SwitchStatement (/** @type {SwitchStatement} */ node, state) {
            const chunks = [
                c("switch ("),
                ...handle(node.discriminant, state),
                c(") {")
            ];
            node.cases.forEach((block)=>{
                if (block.test) {
                    chunks.push(c(`\n${state.indent}\tcase `));
                    push_array$1(chunks, handle(block.test, {
                        ...state,
                        indent: `${state.indent}\t`
                    }));
                    chunks.push(c(":"));
                } else chunks.push(c(`\n${state.indent}\tdefault:`));
                block.consequent.forEach((statement)=>{
                    chunks.push(c(`\n${state.indent}\t\t`));
                    push_array$1(chunks, handle(statement, {
                        ...state,
                        indent: `${state.indent}\t\t`
                    }));
                });
            });
            chunks.push(c(`\n${state.indent}}`));
            return chunks;
        },
        ReturnStatement (node, state) {
            if (node.argument) {
                const contains_comment = node.argument.leadingComments && node.argument.leadingComments.some((/** @type import('../utils/comments.js').CommentWithLocation */ comment)=>comment.has_trailing_newline);
                return [
                    c(contains_comment ? "return (" : "return "),
                    ...handle(node.argument, state),
                    c(contains_comment ? ");" : ";")
                ];
            } else return [
                c("return;")
            ];
        },
        ThrowStatement (node, state) {
            return [
                c("throw "),
                ...handle(node.argument, state),
                c(";")
            ];
        },
        TryStatement (node, state) {
            const chunks = [
                c("try "),
                ...handle(node.block, state)
            ];
            if (node.handler) {
                if (node.handler.param) {
                    chunks.push(c(" catch("));
                    push_array$1(chunks, handle(node.handler.param, state));
                    chunks.push(c(") "));
                } else chunks.push(c(" catch "));
                push_array$1(chunks, handle(node.handler.body, state));
            }
            if (node.finalizer) {
                chunks.push(c(" finally "));
                push_array$1(chunks, handle(node.finalizer, state));
            }
            return chunks;
        },
        WhileStatement (node, state) {
            return [
                c("while ("),
                ...handle(node.test, state),
                c(") "),
                ...handle(node.body, state)
            ];
        },
        DoWhileStatement (node, state) {
            return [
                c("do "),
                ...handle(node.body, state),
                c(" while ("),
                ...handle(node.test, state),
                c(");")
            ];
        },
        ForStatement: scoped((node, state)=>{
            const chunks = [
                c("for (")
            ];
            if (node.init) {
                if (node.init.type === "VariableDeclaration") push_array$1(chunks, handle_var_declaration(node.init, state));
                else push_array$1(chunks, handle(node.init, state));
            }
            chunks.push(c("; "));
            if (node.test) push_array$1(chunks, handle(node.test, state));
            chunks.push(c("; "));
            if (node.update) push_array$1(chunks, handle(node.update, state));
            chunks.push(c(") "));
            push_array$1(chunks, handle(node.body, state));
            return chunks;
        }),
        ForInStatement: scoped((node, state)=>{
            const chunks = [
                c(`for ${node.await ? "await " : ""}(`)
            ];
            if (node.left.type === "VariableDeclaration") push_array$1(chunks, handle_var_declaration(node.left, state));
            else push_array$1(chunks, handle(node.left, state));
            chunks.push(c(node.type === "ForInStatement" ? ` in ` : ` of `));
            push_array$1(chunks, handle(node.right, state));
            chunks.push(c(") "));
            push_array$1(chunks, handle(node.body, state));
            return chunks;
        }),
        DebuggerStatement (node, state) {
            return [
                c("debugger", node),
                c(";")
            ];
        },
        FunctionDeclaration: scoped((/** @type {FunctionDeclaration} */ node, state)=>{
            const chunks = [];
            if (node.async) chunks.push(c("async "));
            chunks.push(c(node.generator ? "function* " : "function "));
            if (node.id) push_array$1(chunks, handle(node.id, state));
            chunks.push(c("("));
            const params = node.params.map((p)=>handle(p, {
                    ...state,
                    indent: state.indent + "	"
                }));
            const multiple_lines = params.some(has_newline) || params.map(get_length).reduce(sum, 0) + (state.indent.length + params.length - 1) * 2 > 80;
            const separator = c(multiple_lines ? `,\n${state.indent}` : ", ");
            if (multiple_lines) {
                chunks.push(c(`\n${state.indent}\t`));
                push_array$1(chunks, join$1(params, separator));
                chunks.push(c(`\n${state.indent}`));
            } else push_array$1(chunks, join$1(params, separator));
            chunks.push(c(") "));
            push_array$1(chunks, handle(node.body, state));
            return chunks;
        }),
        VariableDeclaration (node, state) {
            return handle_var_declaration(node, state).concat(c(";"));
        },
        VariableDeclarator (node, state) {
            if (node.init) return [
                ...handle(node.id, state),
                c(" = "),
                ...handle(node.init, state)
            ];
            else return handle(node.id, state);
        },
        ClassDeclaration (node, state) {
            const chunks = [
                c("class ")
            ];
            if (node.id) {
                push_array$1(chunks, handle(node.id, state));
                chunks.push(c(" "));
            }
            if (node.superClass) {
                chunks.push(c("extends "));
                push_array$1(chunks, handle(node.superClass, state));
                chunks.push(c(" "));
            }
            push_array$1(chunks, handle(node.body, state));
            return chunks;
        },
        ImportDeclaration (/** @type {ImportDeclaration} */ node, state) {
            const chunks = [
                c("import ")
            ];
            const { length: length } = node.specifiers;
            const source = handle(node.source, state);
            if (length > 0) {
                let i = 0;
                while(i < length){
                    if (i > 0) chunks.push(c(", "));
                    const specifier = node.specifiers[i];
                    if (specifier.type === "ImportDefaultSpecifier") {
                        chunks.push(c(specifier.local.name, specifier));
                        i += 1;
                    } else if (specifier.type === "ImportNamespaceSpecifier") {
                        chunks.push(c("* as " + specifier.local.name, specifier));
                        i += 1;
                    } else break;
                }
                if (i < length) {
                    // we have named specifiers
                    const specifiers = node.specifiers.slice(i).map((/** @type {ImportSpecifier} */ specifier)=>{
                        const name = handle(specifier.imported, state)[0];
                        const as = handle(specifier.local, state)[0];
                        if (name.content === as.content) return [
                            as
                        ];
                        return [
                            name,
                            c(" as "),
                            as
                        ];
                    });
                    const width = get_length(chunks) + specifiers.map(get_length).reduce(sum, 0) + 2 * specifiers.length + 6 + get_length(source);
                    if (width > 80) {
                        chunks.push(c(`{\n\t`));
                        push_array$1(chunks, join$1(specifiers, c(",\n	")));
                        chunks.push(c("\n}"));
                    } else {
                        chunks.push(c(`{ `));
                        push_array$1(chunks, join$1(specifiers, c(", ")));
                        chunks.push(c(" }"));
                    }
                }
                chunks.push(c(" from "));
            }
            push_array$1(chunks, source);
            chunks.push(c(";"));
            return chunks;
        },
        ImportExpression (node, state) {
            return [
                c("import("),
                ...handle(node.source, state),
                c(")")
            ];
        },
        ExportDefaultDeclaration (node, state) {
            const chunks = [
                c(`export default `),
                ...handle(node.declaration, state)
            ];
            if (node.declaration.type !== "FunctionDeclaration") chunks.push(c(";"));
            return chunks;
        },
        ExportNamedDeclaration (node, state) {
            const chunks = [
                c("export ")
            ];
            if (node.declaration) push_array$1(chunks, handle(node.declaration, state));
            else {
                const specifiers = node.specifiers.map((/** @type {ExportSpecifier} */ specifier)=>{
                    const name = handle(specifier.local, state)[0];
                    const as = handle(specifier.exported, state)[0];
                    if (name.content === as.content) return [
                        name
                    ];
                    return [
                        name,
                        c(" as "),
                        as
                    ];
                });
                const width = 7 + specifiers.map(get_length).reduce(sum, 0) + 2 * specifiers.length;
                if (width > 80) {
                    chunks.push(c("{\n	"));
                    push_array$1(chunks, join$1(specifiers, c(",\n	")));
                    chunks.push(c("\n}"));
                } else {
                    chunks.push(c("{ "));
                    push_array$1(chunks, join$1(specifiers, c(", ")));
                    chunks.push(c(" }"));
                }
                if (node.source) {
                    chunks.push(c(" from "));
                    push_array$1(chunks, handle(node.source, state));
                }
            }
            chunks.push(c(";"));
            return chunks;
        },
        ExportAllDeclaration (node, state) {
            return [
                c(`export * from `),
                ...handle(node.source, state),
                c(`;`)
            ];
        },
        MethodDefinition (node, state) {
            const chunks = [];
            if (node.static) chunks.push(c("static "));
            if (node.kind === "get" || node.kind === "set") // Getter or setter
            chunks.push(c(node.kind + " "));
            if (node.value.async) chunks.push(c("async "));
            if (node.value.generator) chunks.push(c("*"));
            if (node.computed) {
                chunks.push(c("["));
                push_array$1(chunks, handle(node.key, state));
                chunks.push(c("]"));
            } else push_array$1(chunks, handle(node.key, state));
            chunks.push(c("("));
            const { params: params } = node.value;
            for(let i = 0; i < params.length; i += 1){
                push_array$1(chunks, handle(params[i], state));
                if (i < params.length - 1) chunks.push(c(", "));
            }
            chunks.push(c(") "));
            push_array$1(chunks, handle(node.value.body, state));
            return chunks;
        },
        ArrowFunctionExpression: scoped((/** @type {ArrowFunctionExpression} */ node, state)=>{
            const chunks = [];
            if (node.async) chunks.push(c("async "));
            if (node.params.length === 1 && node.params[0].type === "Identifier") push_array$1(chunks, handle(node.params[0], state));
            else {
                const params = node.params.map((param)=>handle(param, {
                        ...state,
                        indent: state.indent + "	"
                    }));
                chunks.push(c("("));
                push_array$1(chunks, join$1(params, c(", ")));
                chunks.push(c(")"));
            }
            chunks.push(c(" => "));
            if (node.body.type === "ObjectExpression" || node.body.type === "AssignmentExpression" && node.body.left.type === "ObjectPattern") {
                chunks.push(c("("));
                push_array$1(chunks, handle(node.body, state));
                chunks.push(c(")"));
            } else push_array$1(chunks, handle(node.body, state));
            return chunks;
        }),
        ThisExpression (node, state) {
            return [
                c("this", node)
            ];
        },
        Super (node, state) {
            return [
                c("super", node)
            ];
        },
        RestElement (node, state) {
            return [
                c("..."),
                ...handle(node.argument, state)
            ];
        },
        YieldExpression (node, state) {
            if (node.argument) return [
                c(node.delegate ? `yield* ` : `yield `),
                ...handle(node.argument, state)
            ];
            return [
                c(node.delegate ? `yield*` : `yield`)
            ];
        },
        AwaitExpression (node, state) {
            if (node.argument) {
                const precedence = EXPRESSIONS_PRECEDENCE[node.argument.type];
                if (precedence && precedence < EXPRESSIONS_PRECEDENCE.AwaitExpression) return [
                    c("await ("),
                    ...handle(node.argument, state),
                    c(")")
                ];
                else return [
                    c("await "),
                    ...handle(node.argument, state)
                ];
            }
            return [
                c("await")
            ];
        },
        TemplateLiteral (node, state) {
            const chunks = [
                c("`")
            ];
            const { quasis: quasis, expressions: expressions } = node;
            for(let i = 0; i < expressions.length; i++){
                chunks.push(c(quasis[i].value.raw), c("${"));
                push_array$1(chunks, handle(expressions[i], state));
                chunks.push(c("}"));
            }
            chunks.push(c(quasis[quasis.length - 1].value.raw), c("`"));
            return chunks;
        },
        TaggedTemplateExpression (node, state) {
            return handle(node.tag, state).concat(handle(node.quasi, state));
        },
        ArrayExpression (node, state) {
            const chunks = [
                c("[")
            ];
            /** @type {Chunk[][]} */ const elements = [];
            /** @type {Chunk[]} */ let sparse_commas = [];
            for(let i = 0; i < node.elements.length; i += 1){
                // can't use map/forEach because of sparse arrays
                const element = node.elements[i];
                if (element) {
                    elements.push([
                        ...sparse_commas,
                        ...handle(element, {
                            ...state,
                            indent: state.indent + "	"
                        })
                    ]);
                    sparse_commas = [];
                } else sparse_commas.push(c(","));
            }
            const multiple_lines = elements.some(has_newline) || elements.map(get_length).reduce(sum, 0) + (state.indent.length + elements.length - 1) * 2 > 80;
            if (multiple_lines) {
                chunks.push(c(`\n${state.indent}\t`));
                push_array$1(chunks, join$1(elements, c(`,\n${state.indent}\t`)));
                chunks.push(c(`\n${state.indent}`));
                push_array$1(chunks, sparse_commas);
            } else {
                push_array$1(chunks, join$1(elements, c(", ")));
                push_array$1(chunks, sparse_commas);
            }
            chunks.push(c("]"));
            return chunks;
        },
        ObjectExpression (/** @type {ObjectExpression} */ node, state) {
            if (node.properties.length === 0) return [
                c("{}")
            ];
            let has_inline_comment = false;
            /** @type {Chunk[]} */ const chunks = [];
            const separator = c(", ");
            node.properties.forEach((p, i)=>{
                push_array$1(chunks, handle(p, {
                    ...state,
                    indent: state.indent + "	"
                }));
                if (state.comments.length) {
                    // TODO generalise this, so it works with ArrayExpressions and other things.
                    // At present, stuff will just get appended to the closest statement/declaration
                    chunks.push(c(", "));
                    while(state.comments.length){
                        const comment = state.comments.shift();
                        chunks.push(c(comment.type === "Block" ? `/*${comment.value}*/\n${state.indent}\t` : `//${comment.value}\n${state.indent}\t`));
                        if (comment.type === "Line") has_inline_comment = true;
                    }
                } else if (i < node.properties.length - 1) chunks.push(separator);
            });
            const multiple_lines = has_inline_comment || has_newline(chunks) || get_length(chunks) > 40;
            if (multiple_lines) separator.content = `,\n${state.indent}\t`;
            return [
                c(multiple_lines ? `{\n${state.indent}\t` : `{ `),
                ...chunks,
                c(multiple_lines ? `\n${state.indent}}` : ` }`)
            ];
        },
        Property (node, state) {
            const value = handle(node.value, state);
            if (node.key === node.value) return value;
            // special case
            if (!node.computed && node.value.type === "AssignmentPattern" && node.value.left.type === "Identifier" && node.value.left.name === node.key.name) return value;
            if (!node.computed && node.value.type === "Identifier" && (node.key.type === "Identifier" && node.key.name === value[0].content || node.key.type === "Literal" && node.key.value === value[0].content)) return value;
            const key = handle(node.key, state);
            if (node.value.type === "FunctionExpression" && !node.value.id) {
                state = {
                    ...state,
                    scope: state.scope_map.get(node.value)
                };
                const chunks = node.kind !== "init" ? [
                    c(`${node.kind} `)
                ] : [];
                if (node.value.async) chunks.push(c("async "));
                if (node.value.generator) chunks.push(c("*"));
                push_array$1(chunks, node.computed ? [
                    c("["),
                    ...key,
                    c("]")
                ] : key);
                chunks.push(c("("));
                push_array$1(chunks, join$1(node.value.params.map((/** @type {Pattern} */ param)=>handle(param, state)), c(", ")));
                chunks.push(c(") "));
                push_array$1(chunks, handle(node.value.body, state));
                return chunks;
            }
            if (node.computed) return [
                c("["),
                ...key,
                c("]: "),
                ...value
            ];
            return [
                ...key,
                c(": "),
                ...value
            ];
        },
        ObjectPattern (node, state) {
            const chunks = [
                c("{ ")
            ];
            for(let i = 0; i < node.properties.length; i += 1){
                push_array$1(chunks, handle(node.properties[i], state));
                if (i < node.properties.length - 1) chunks.push(c(", "));
            }
            chunks.push(c(" }"));
            return chunks;
        },
        SequenceExpression (/** @type {SequenceExpression} */ node, state) {
            const expressions = node.expressions.map((e)=>handle(e, state));
            return [
                c("("),
                ...join$1(expressions, c(", ")),
                c(")")
            ];
        },
        UnaryExpression (node, state) {
            const chunks = [
                c(node.operator)
            ];
            if (node.operator.length > 1) chunks.push(c(" "));
            if (EXPRESSIONS_PRECEDENCE[node.argument.type] < EXPRESSIONS_PRECEDENCE.UnaryExpression) {
                chunks.push(c("("));
                push_array$1(chunks, handle(node.argument, state));
                chunks.push(c(")"));
            } else push_array$1(chunks, handle(node.argument, state));
            return chunks;
        },
        UpdateExpression (node, state) {
            return node.prefix ? [
                c(node.operator),
                ...handle(node.argument, state)
            ] : [
                ...handle(node.argument, state),
                c(node.operator)
            ];
        },
        AssignmentExpression (node, state) {
            return [
                ...handle(node.left, state),
                c(` ${node.operator || "="} `),
                ...handle(node.right, state)
            ];
        },
        BinaryExpression (node, state) {
            /**
		 * @type any[]
		 */ const chunks = [];
            // TODO
            // const is_in = node.operator === 'in';
            // if (is_in) {
            // 	// Avoids confusion in `for` loops initializers
            // 	chunks.push(c('('));
            // }
            if (needs_parens(node.left, node, false)) {
                chunks.push(c("("));
                push_array$1(chunks, handle(node.left, state));
                chunks.push(c(")"));
            } else push_array$1(chunks, handle(node.left, state));
            chunks.push(c(` ${node.operator} `));
            if (needs_parens(node.right, node, true)) {
                chunks.push(c("("));
                push_array$1(chunks, handle(node.right, state));
                chunks.push(c(")"));
            } else push_array$1(chunks, handle(node.right, state));
            return chunks;
        },
        ConditionalExpression (node, state) {
            /**
		 * @type any[]
		 */ const chunks = [];
            if (EXPRESSIONS_PRECEDENCE[node.test.type] > EXPRESSIONS_PRECEDENCE.ConditionalExpression) push_array$1(chunks, handle(node.test, state));
            else {
                chunks.push(c("("));
                push_array$1(chunks, handle(node.test, state));
                chunks.push(c(")"));
            }
            const child_state = {
                ...state,
                indent: state.indent + "	"
            };
            const consequent = handle(node.consequent, child_state);
            const alternate = handle(node.alternate, child_state);
            const multiple_lines = has_newline(consequent) || has_newline(alternate) || get_length(chunks) + get_length(consequent) + get_length(alternate) > 50;
            if (multiple_lines) {
                chunks.push(c(`\n${state.indent}? `));
                push_array$1(chunks, consequent);
                chunks.push(c(`\n${state.indent}: `));
                push_array$1(chunks, alternate);
            } else {
                chunks.push(c(` ? `));
                push_array$1(chunks, consequent);
                chunks.push(c(` : `));
                push_array$1(chunks, alternate);
            }
            return chunks;
        },
        NewExpression (/** @type {NewExpression} */ node, state) {
            const chunks = [
                c("new ")
            ];
            if (EXPRESSIONS_PRECEDENCE[node.callee.type] < EXPRESSIONS_PRECEDENCE.CallExpression || has_call_expression(node.callee)) {
                chunks.push(c("("));
                push_array$1(chunks, handle(node.callee, state));
                chunks.push(c(")"));
            } else push_array$1(chunks, handle(node.callee, state));
            // TODO this is copied from CallExpression — DRY it out
            const args = node.arguments.map((arg)=>handle(arg, {
                    ...state,
                    indent: state.indent + "	"
                }));
            const separator = args.some(has_newline) // TODO or length exceeds 80
             ? c(",\n" + state.indent) : c(", ");
            chunks.push(c("("));
            push_array$1(chunks, join$1(args, separator));
            chunks.push(c(")"));
            return chunks;
        },
        ChainExpression (node, state) {
            return handle(node.expression, state);
        },
        CallExpression (/** @type {CallExpression} */ node, state) {
            /**
		 * @type any[]
		 */ const chunks = [];
            if (EXPRESSIONS_PRECEDENCE[node.callee.type] < EXPRESSIONS_PRECEDENCE.CallExpression) {
                chunks.push(c("("));
                push_array$1(chunks, handle(node.callee, state));
                chunks.push(c(")"));
            } else push_array$1(chunks, handle(node.callee, state));
            if (/** @type {SimpleCallExpression} */ node.optional) chunks.push(c("?."));
            let has_inline_comment = false;
            let arg_chunks = [];
            outer: for (const arg of node.arguments){
                const chunks = [];
                while(state.comments.length){
                    const comment = state.comments.shift();
                    if (comment.type === "Line") {
                        has_inline_comment = true;
                        break outer;
                    }
                    chunks.push(c(comment.type === "Block" ? `/*${comment.value}*/ ` : `//${comment.value}`));
                }
                push_array$1(chunks, handle(arg, state));
                arg_chunks.push(chunks);
            }
            const multiple_lines = has_inline_comment || arg_chunks.slice(0, -1).some(has_newline); // TODO or length exceeds 80
            if (multiple_lines) {
                // need to handle args again. TODO find alternative approach?
                const args = node.arguments.map((arg, i)=>{
                    const chunks = handle(arg, {
                        ...state,
                        indent: `${state.indent}\t`
                    });
                    if (i < node.arguments.length - 1) chunks.push(c(","));
                    while(state.comments.length){
                        const comment = state.comments.shift();
                        chunks.push(c(comment.type === "Block" ? ` /*${comment.value}*/ ` : ` //${comment.value}`));
                    }
                    return chunks;
                });
                chunks.push(c(`(\n${state.indent}\t`));
                push_array$1(chunks, join$1(args, c(`\n${state.indent}\t`)));
                chunks.push(c(`\n${state.indent})`));
            } else {
                chunks.push(c("("));
                push_array$1(chunks, join$1(arg_chunks, c(", ")));
                chunks.push(c(")"));
            }
            return chunks;
        },
        MemberExpression (node, state) {
            /**
		 * @type any[]
		 */ const chunks = [];
            if (EXPRESSIONS_PRECEDENCE[node.object.type] < EXPRESSIONS_PRECEDENCE.MemberExpression) {
                chunks.push(c("("));
                push_array$1(chunks, handle(node.object, state));
                chunks.push(c(")"));
            } else push_array$1(chunks, handle(node.object, state));
            if (node.computed) {
                if (node.optional) chunks.push(c("?."));
                chunks.push(c("["));
                push_array$1(chunks, handle(node.property, state));
                chunks.push(c("]"));
            } else {
                chunks.push(c(node.optional ? "?." : "."));
                push_array$1(chunks, handle(node.property, state));
            }
            return chunks;
        },
        MetaProperty (node, state) {
            return [
                ...handle(node.meta, state),
                c("."),
                ...handle(node.property, state)
            ];
        },
        Identifier (node, state) {
            let name = node.name;
            if (name[0] === "@") name = state.getName(name.slice(1));
            else if (node.name[0] === "#") {
                const owner = state.scope.find_owner(node.name);
                if (!owner) throw new Error(`Could not find owner for node`);
                if (!state.deconflicted.has(owner)) state.deconflicted.set(owner, new Map());
                const deconflict_map = state.deconflicted.get(owner);
                if (!deconflict_map.has(node.name)) deconflict_map.set(node.name, deconflict(node.name.slice(1), owner.references));
                name = deconflict_map.get(node.name);
            }
            return [
                c(name, node)
            ];
        },
        Literal (/** @type {Literal} */ node, state) {
            if (typeof node.value === "string") return [
                // TODO do we need to handle weird unicode characters somehow?
                // str.replace(/\\u(\d{4})/g, (m, n) => String.fromCharCode(+n))
                c((node.raw || JSON.stringify(node.value)).replace(re$1, (_m, _i, at, hash, name)=>{
                    if (at) return "@" + name;
                    if (hash) return "#" + name;
                    throw new Error(`this shouldn't happen`);
                }), node)
            ];
            return [
                c(node.raw || String(node.value), node)
            ];
        },
        PropertyDefinition (/** @type {PropertyDefinition} */ node, state) {
            const chunks = [];
            if (node.static) chunks.push(c("static "));
            if (node.computed) chunks.push(c("["), ...handle(node.key, state), c("]"));
            else chunks.push(...handle(node.key, state));
            if (node.value) {
                chunks.push(c(" = "));
                chunks.push(...handle(node.value, state));
            }
            chunks.push(c(";"));
            return chunks;
        },
        StaticBlock (/** @type {StaticBlock} */ node, state) {
            const chunks = [
                c("static ")
            ];
            push_array$1(chunks, handlers$1.BlockStatement(node, state));
            return chunks;
        },
        PrivateIdentifier (/** @type {PrivateIdenifier} */ node, state) {
            const chunks = [
                c("#")
            ];
            push_array$1(chunks, [
                c(node.name, node)
            ]);
            return chunks;
        }
    };
    handlers$1.ForOfStatement = handlers$1.ForInStatement;
    handlers$1.FunctionExpression = handlers$1.FunctionDeclaration;
    handlers$1.ClassExpression = handlers$1.ClassDeclaration;
    handlers$1.ClassBody = handlers$1.BlockStatement;
    handlers$1.SpreadElement = handlers$1.RestElement;
    handlers$1.ArrayPattern = handlers$1.ArrayExpression;
    handlers$1.LogicalExpression = handlers$1.BinaryExpression;
    handlers$1.AssignmentPattern = handlers$1.AssignmentExpression;
    const comma = ",".charCodeAt(0);
    const semicolon = ";".charCodeAt(0);
    const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    const intToChar = new Uint8Array(64); // 64 possible chars.
    const charToInt = new Uint8Array(128); // z is 122 in ASCII
    for(let i = 0; i < chars.length; i++){
        const c = chars.charCodeAt(i);
        intToChar[i] = c;
        charToInt[c] = i;
    }
    // Provide a fallback for older environments.
    const td = typeof TextDecoder !== "undefined" ? /* #__PURE__ */ new TextDecoder() : typeof Buffer !== "undefined" ? {
        decode (buf) {
            const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);
            return out.toString();
        }
    } : {
        decode (buf) {
            let out = "";
            for(let i = 0; i < buf.length; i++)out += String.fromCharCode(buf[i]);
            return out;
        }
    };
    function decode(mappings) {
        const state = new Int32Array(5);
        const decoded = [];
        let index = 0;
        do {
            const semi = indexOf(mappings, index);
            const line = [];
            let sorted = true;
            let lastCol = 0;
            state[0] = 0;
            for(let i = index; i < semi; i++){
                let seg;
                i = decodeInteger(mappings, i, state, 0); // genColumn
                const col = state[0];
                if (col < lastCol) sorted = false;
                lastCol = col;
                if (hasMoreVlq(mappings, i, semi)) {
                    i = decodeInteger(mappings, i, state, 1); // sourcesIndex
                    i = decodeInteger(mappings, i, state, 2); // sourceLine
                    i = decodeInteger(mappings, i, state, 3); // sourceColumn
                    if (hasMoreVlq(mappings, i, semi)) {
                        i = decodeInteger(mappings, i, state, 4); // namesIndex
                        seg = [
                            col,
                            state[1],
                            state[2],
                            state[3],
                            state[4]
                        ];
                    } else seg = [
                        col,
                        state[1],
                        state[2],
                        state[3]
                    ];
                } else seg = [
                    col
                ];
                line.push(seg);
            }
            if (!sorted) sort(line);
            decoded.push(line);
            index = semi + 1;
        }while (index <= mappings.length);
        return decoded;
    }
    function indexOf(mappings, index) {
        const idx = mappings.indexOf(";", index);
        return idx === -1 ? mappings.length : idx;
    }
    function decodeInteger(mappings, pos, state, j) {
        let value = 0;
        let shift = 0;
        let integer = 0;
        do {
            const c = mappings.charCodeAt(pos++);
            integer = charToInt[c];
            value |= (integer & 31) << shift;
            shift += 5;
        }while (integer & 32);
        const shouldNegate = value & 1;
        value >>>= 1;
        if (shouldNegate) value = -2147483648 | -value;
        state[j] += value;
        return pos;
    }
    function hasMoreVlq(mappings, i, length) {
        if (i >= length) return false;
        return mappings.charCodeAt(i) !== comma;
    }
    function sort(line) {
        line.sort(sortComparator$1);
    }
    function sortComparator$1(a, b) {
        return a[0] - b[0];
    }
    function encode(decoded) {
        const state = new Int32Array(5);
        const bufLength = 16384;
        const subLength = bufLength - 36;
        const buf = new Uint8Array(bufLength);
        const sub = buf.subarray(0, subLength);
        let pos = 0;
        let out = "";
        for(let i = 0; i < decoded.length; i++){
            const line = decoded[i];
            if (i > 0) {
                if (pos === bufLength) {
                    out += td.decode(buf);
                    pos = 0;
                }
                buf[pos++] = semicolon;
            }
            if (line.length === 0) continue;
            state[0] = 0;
            for(let j = 0; j < line.length; j++){
                const segment = line[j];
                // We can push up to 5 ints, each int can take at most 7 chars, and we
                // may push a comma.
                if (pos > subLength) {
                    out += td.decode(sub);
                    buf.copyWithin(0, subLength, pos);
                    pos -= subLength;
                }
                if (j > 0) buf[pos++] = comma;
                pos = encodeInteger(buf, pos, state, segment, 0); // genColumn
                if (segment.length === 1) continue;
                pos = encodeInteger(buf, pos, state, segment, 1); // sourcesIndex
                pos = encodeInteger(buf, pos, state, segment, 2); // sourceLine
                pos = encodeInteger(buf, pos, state, segment, 3); // sourceColumn
                if (segment.length === 4) continue;
                pos = encodeInteger(buf, pos, state, segment, 4); // namesIndex
            }
        }
        return out + td.decode(buf.subarray(0, pos));
    }
    function encodeInteger(buf, pos, state, segment, j) {
        const next = segment[j];
        let num = next - state[j];
        state[j] = next;
        num = num < 0 ? -num << 1 | 1 : num << 1;
        do {
            let clamped = num & 31;
            num >>>= 5;
            if (num > 0) clamped |= 32;
            buf[pos++] = intToChar[clamped];
        }while (num > 0);
        return pos;
    }
    /** @type {(str?: string) => string} str */ let btoa$1 = ()=>{
        throw new Error("Unsupported environment: `window.btoa` or `Buffer` should be supported.");
    };
    if (typeof window !== "undefined" && typeof window.btoa === "function") btoa$1 = (str)=>window.btoa(unescape(encodeURIComponent(str)));
    else if (typeof Buffer === "function") btoa$1 = (str)=>Buffer.from(str, "utf-8").toString("base64");
    /** @typedef {import('estree').Node} Node */ /**
 * @typedef {{
 *   file?: string;
 *   sourceMapSource?: string;
 *   sourceMapContent?: string;
 *   sourceMapEncodeMappings?: boolean; // default true
 *   getName?: (name: string) => string;
 * }} PrintOptions
 */ /**
 * @param {Node} node
 * @param {PrintOptions} opts
 * @returns {{ code: string, map: any }} // TODO
 */ function print(node, opts = {}) {
        if (Array.isArray(node)) return print({
            type: "Program",
            body: node,
            sourceType: "module"
        }, opts);
        const { getName: getName = /** @param {string} x */ (x)=>{
            throw new Error(`Unhandled sigil @${x}`);
        } } = opts;
        let { map: scope_map, scope: scope } = analyze(node);
        const deconflicted = new WeakMap();
        const chunks = handle(node, {
            indent: "",
            getName: getName,
            scope: scope,
            scope_map: scope_map,
            deconflicted: deconflicted,
            comments: []
        });
        /** @typedef {[number, number, number, number]} Segment */ let code = "";
        let current_column = 0;
        /** @type {Segment[][]} */ let mappings = [];
        /** @type {Segment[]} */ let current_line = [];
        for(let i = 0; i < chunks.length; i += 1){
            const chunk = chunks[i];
            code += chunk.content;
            if (chunk.loc) current_line.push([
                current_column,
                0,
                chunk.loc.start.line - 1,
                chunk.loc.start.column
            ]);
            for(let i = 0; i < chunk.content.length; i += 1)if (chunk.content[i] === "\n") {
                mappings.push(current_line);
                current_line = [];
                current_column = 0;
            } else current_column += 1;
            if (chunk.loc) current_line.push([
                current_column,
                0,
                chunk.loc.end.line - 1,
                chunk.loc.end.column
            ]);
        }
        mappings.push(current_line);
        const map = {
            version: 3,
            /** @type {string[]} */ names: [],
            sources: [
                opts.sourceMapSource || null
            ],
            sourcesContent: [
                opts.sourceMapContent || null
            ],
            mappings: opts.sourceMapEncodeMappings == undefined || opts.sourceMapEncodeMappings ? encode(mappings) : mappings
        };
        Object.defineProperties(map, {
            toString: {
                enumerable: false,
                value: function toString() {
                    return JSON.stringify(this);
                }
            },
            toUrl: {
                enumerable: false,
                value: function toUrl() {
                    return "data:application/json;charset=utf-8;base64," + btoa$1(this.toString());
                }
            }
        });
        return {
            code: code,
            map: map
        };
    }
    /** @typedef {import('estree').Expression} Expression */ /** @typedef {import('estree').Node} Node */ /** @typedef {import('estree').ObjectExpression} ObjectExpression */ /** @typedef {import('estree').Property} Property */ /** @typedef {import('estree').SpreadElement} SpreadElement */ /** @typedef {import('./utils/comments').CommentWithLocation} CommentWithLocation */ /** @type {Record<string, string>} */ const sigils = {
        "@": "AT",
        "#": "HASH"
    };
    /** @param {TemplateStringsArray} strings */ const join = (strings)=>{
        let str = strings[0];
        for(let i = 1; i < strings.length; i += 1)str += `_${id}_${i - 1}_${strings[i]}`;
        return str.replace(/([@#])(\w+)/g, (_m, sigil, name)=>`_${id}_${sigils[sigil]}_${name}`);
    };
    /**
 * @param {any[]} array
 * @param {any[]} target
 */ const flatten_body = (array, target)=>{
        for(let i = 0; i < array.length; i += 1){
            const statement = array[i];
            if (Array.isArray(statement)) {
                flatten_body(statement, target);
                continue;
            }
            if (statement.type === "ExpressionStatement") {
                if (statement.expression === EMPTY) continue;
                if (Array.isArray(statement.expression)) {
                    // TODO this is hacktacular
                    let node = statement.expression[0];
                    while(Array.isArray(node))node = node[0];
                    if (node) node.leadingComments = statement.leadingComments;
                    flatten_body(statement.expression, target);
                    continue;
                }
                if (/(Expression|Literal)$/.test(statement.expression.type)) {
                    target.push(statement);
                    continue;
                }
                if (statement.leadingComments) statement.expression.leadingComments = statement.leadingComments;
                if (statement.trailingComments) statement.expression.trailingComments = statement.trailingComments;
                target.push(statement.expression);
                continue;
            }
            target.push(statement);
        }
        return target;
    };
    /**
 * @param {any[]} array
 * @param {any[]} target
 */ const flatten_properties = (array, target)=>{
        for(let i = 0; i < array.length; i += 1){
            const property = array[i];
            if (property.value === EMPTY) continue;
            if (property.key === property.value && Array.isArray(property.key)) {
                flatten_properties(property.key, target);
                continue;
            }
            target.push(property);
        }
        return target;
    };
    /**
 * @param {any[]} nodes
 * @param {any[]} target
 */ const flatten = (nodes, target)=>{
        for(let i = 0; i < nodes.length; i += 1){
            const node = nodes[i];
            if (node === EMPTY) continue;
            if (Array.isArray(node)) {
                flatten(node, target);
                continue;
            }
            target.push(node);
        }
        return target;
    };
    const EMPTY = {
        type: "Empty"
    };
    /**
 *
 * @param {CommentWithLocation[]} comments
 * @param {string} raw
 * @returns {any}
 */ const acorn_opts = (comments, raw)=>{
        const { onComment: onComment } = get_comment_handlers(comments, raw);
        return {
            ecmaVersion: 2022,
            sourceType: "module",
            allowAwaitOutsideFunction: true,
            allowImportExportEverywhere: true,
            allowReturnOutsideFunction: true,
            onComment: onComment
        };
    };
    /**
 * @param {string} raw
 * @param {Node} node
 * @param {any[]} values
 * @param {CommentWithLocation[]} comments
 */ const inject = (raw, node, values, comments)=>{
        comments.forEach((comment)=>{
            comment.value = comment.value.replace(re$1, (m, i)=>+i in values ? values[+i] : m);
        });
        const { enter: enter, leave: leave } = get_comment_handlers(comments, raw);
        return walk(node, {
            enter: enter,
            /** @param {any} node */ leave (node) {
                if (node.type === "Identifier") {
                    re$1.lastIndex = 0;
                    const match = re$1.exec(node.name);
                    if (match) {
                        if (match[1]) {
                            if (+match[1] in values) {
                                let value = values[+match[1]];
                                if (typeof value === "string") value = {
                                    type: "Identifier",
                                    name: value,
                                    leadingComments: node.leadingComments,
                                    trailingComments: node.trailingComments
                                };
                                else if (typeof value === "number") value = {
                                    type: "Literal",
                                    value: value,
                                    leadingComments: node.leadingComments,
                                    trailingComments: node.trailingComments
                                };
                                this.replace(value || EMPTY);
                            }
                        } else node.name = `${match[2] ? `@` : `#`}${match[4]}`;
                    }
                }
                if (node.type === "Literal") {
                    if (typeof node.value === "string") {
                        re$1.lastIndex = 0;
                        const new_value = /** @type {string} */ node.value.replace(re$1, (m, i)=>+i in values ? values[+i] : m);
                        const has_changed = new_value !== node.value;
                        node.value = new_value;
                        if (has_changed && node.raw) // preserve the quotes
                        node.raw = `${node.raw[0]}${JSON.stringify(node.value).slice(1, -1)}${node.raw[node.raw.length - 1]}`;
                    }
                }
                if (node.type === "TemplateElement") {
                    re$1.lastIndex = 0;
                    node.value.raw = /** @type {string} */ node.value.raw.replace(re$1, (m, i)=>+i in values ? values[+i] : m);
                }
                if (node.type === "Program" || node.type === "BlockStatement") node.body = flatten_body(node.body, []);
                if (node.type === "ObjectExpression" || node.type === "ObjectPattern") node.properties = flatten_properties(node.properties, []);
                if (node.type === "ArrayExpression" || node.type === "ArrayPattern") node.elements = flatten(node.elements, []);
                if (node.type === "FunctionExpression" || node.type === "FunctionDeclaration" || node.type === "ArrowFunctionExpression") node.params = flatten(node.params, []);
                if (node.type === "CallExpression" || node.type === "NewExpression") node.arguments = flatten(node.arguments, []);
                if (node.type === "ImportDeclaration" || node.type === "ExportNamedDeclaration") node.specifiers = flatten(node.specifiers, []);
                if (node.type === "ForStatement") {
                    node.init = node.init === EMPTY ? null : node.init;
                    node.test = node.test === EMPTY ? null : node.test;
                    node.update = node.update === EMPTY ? null : node.update;
                }
                leave(node);
            }
        });
    };
    /**
 *
 * @param {TemplateStringsArray} strings
 * @param  {any[]} values
 * @returns {Node[]}
 */ function b$1(strings, ...values) {
        const str = join(strings);
        /** @type {CommentWithLocation[]} */ const comments = [];
        try {
            let ast = /** @type {any} */ parse$b(str, acorn_opts(comments, str));
            ast = inject(str, ast, values, comments);
            return ast.body;
        } catch (err) {
            handle_error(str, err);
        }
    }
    /**
 *
 * @param {TemplateStringsArray} strings
 * @param  {any[]} values
 * @returns {Expression & { start: Number, end: number }}
 */ function x$1(strings, ...values) {
        const str = join(strings);
        /** @type {CommentWithLocation[]} */ const comments = [];
        try {
            let expression = /** @type {Expression & { start: Number, end: number }} */ parseExpressionAt$1(str, 0, acorn_opts(comments, str));
            const match = /\S+/.exec(str.slice(expression.end));
            if (match) throw new Error(`Unexpected token '${match[0]}'`);
            expression = /** @type {Expression & { start: Number, end: number }} */ inject(str, expression, values, comments);
            return expression;
        } catch (err) {
            handle_error(str, err);
        }
    }
    /**
 *
 * @param {TemplateStringsArray} strings
 * @param  {any[]} values
 * @returns {(Property | SpreadElement) & { start: Number, end: number }}
 */ function p(strings, ...values) {
        const str = `{${join(strings)}}`;
        /** @type {CommentWithLocation[]} */ const comments = [];
        try {
            let expression = /** @type {any} */ parseExpressionAt$1(str, 0, acorn_opts(comments, str));
            expression = inject(str, expression, values, comments);
            return expression.properties[0];
        } catch (err) {
            handle_error(str, err);
        }
    }
    /**
 * @param {string} str
 * @param {Error} err
 */ function handle_error(str, err) {
        // TODO location/code frame
        re$1.lastIndex = 0;
        str = str.replace(re$1, (m, i, at, hash, name)=>{
            if (at) return `@${name}`;
            if (hash) return `#${name}`;
            return "${...}";
        });
        console.log(`failed to parse:\n${str}`);
        throw err;
    }
    /**
 * @param {string} source
 * @param {any} opts
 */ const parse$a = (source, opts)=>{
        /** @type {CommentWithLocation[]} */ const comments = [];
        const { onComment: onComment, enter: enter, leave: leave } = get_comment_handlers(comments, source);
        const ast = /** @type {any} */ parse$b(source, {
            onComment: onComment,
            ...opts
        });
        walk(ast, {
            enter: enter,
            leave: leave
        });
        return ast;
    };
    /**
 * @param {string} source
 * @param {number} index
 * @param {any} opts
 */ const parseExpressionAt = (source, index, opts)=>{
        /** @type {CommentWithLocation[]} */ const comments = [];
        const { onComment: onComment, enter: enter, leave: leave } = get_comment_handlers(comments, source);
        const ast = /** @type {any} */ parseExpressionAt$1(source, index, {
            onComment: onComment,
            ...opts
        });
        walk(ast, {
            enter: enter,
            leave: leave
        });
        return ast;
    };
    /**
 * @param {string} source
 */ const parse$9 = (source)=>parse$a(source, {
            sourceType: "module",
            ecmaVersion: 13,
            locations: true
        });
    /**
 * @param {string} source
 * @param {number} index
 */ const parse_expression_at = (source, index)=>parseExpressionAt(source, index, {
            sourceType: "module",
            ecmaVersion: 13,
            locations: true
        });
    /**
 * @param {import('../index.js').Parser} parser
 * @returns {import('estree').Node | undefined}
 */ function read_expression(parser) {
        try {
            const node = parse_expression_at(parser.template, parser.index);
            let num_parens = 0;
            for(let i = parser.index; i < node.start; i += 1)if (parser.template[i] === "(") num_parens += 1;
            let index = node.end;
            while(num_parens > 0){
                const char = parser.template[index];
                if (char === ")") num_parens -= 1;
                else if (!regex_whitespace.test(char)) parser.error(parser_errors.unexpected_token(")"), index);
                index += 1;
            }
            parser.index = index;
            return node;
        } catch (err) {
            parser.acorn_error(err);
        }
    }
    const regex_closing_script_tag = /<\/script\s*>/;
    const regex_starts_with_closing_script_tag = /^<\/script\s*>/;
    /**
 * @param {import('../index.js').Parser} parser
 * @param {any[]} attributes
 * @param {number} start
 * @returns {string}
 */ function get_context(parser, attributes, start) {
        const context = attributes.find((attribute)=>attribute.name === "context");
        if (!context) return "default";
        if (context.value.length !== 1 || context.value[0].type !== "Text") parser.error(parser_errors.invalid_script_context_attribute, start);
        const value = context.value[0].data;
        if (value !== "module") parser.error(parser_errors.invalid_script_context_value, context.start);
        return value;
    }
    /**
 * @param {import('../index.js').Parser} parser
 * @param {number} start
 * @param {import('estree').Node[]} attributes
 * @returns {import('../../interfaces.js').Script}
 */ function read_script(parser, start, attributes) {
        const script_start = parser.index;
        const data = parser.read_until(regex_closing_script_tag, parser_errors.unclosed_script);
        if (parser.index >= parser.template.length) parser.error(parser_errors.unclosed_script);
        const source = parser.template.slice(0, script_start).replace(regex_not_newline_characters, " ") + data;
        parser.read(regex_starts_with_closing_script_tag);
        /**
	 * @type {import('estree').Program}
	 */ let ast;
        try {
            ast = parse$9(source);
        } catch (err) {
            parser.acorn_error(err);
        }
        // TODO is this necessary?
        /** @type {any} */ ast.start = script_start;
        return {
            type: "Script",
            start: start,
            end: parser.index,
            context: get_context(parser, attributes, start),
            content: ast
        };
    }
    var rs = Object.create;
    var tr = Object.defineProperty;
    var ns = Object.getOwnPropertyDescriptor;
    var os = Object.getOwnPropertyNames;
    var is = Object.getPrototypeOf, as = Object.prototype.hasOwnProperty;
    var Oe = (e, t)=>()=>(t || e((t = {
                exports: {}
            }).exports, t), t.exports), b = (e, t)=>{
        for(var r in t)tr(e, r, {
            get: t[r],
            enumerable: !0
        });
    }, ss = (e, t, r, n)=>{
        if (t && typeof t == "object" || typeof t == "function") for (let o of os(t))!as.call(e, o) && o !== r && tr(e, o, {
            get: ()=>t[o],
            enumerable: !(n = ns(t, o)) || n.enumerable
        });
        return e;
    };
    var ls = (e, t, r)=>(r = e != null ? rs(is(e)) : {}, ss(t || !e || !e.__esModule ? tr(r, "default", {
            value: e,
            enumerable: !0
        }) : r, e));
    var Jo = Oe((ur)=>{
        var Zo = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
        ur.encode = function(e) {
            if (0 <= e && e < Zo.length) return Zo[e];
            throw new TypeError("Must be between 0 and 63: " + e);
        };
        ur.decode = function(e) {
            var t = 65, r = 90, n = 97, o = 122, i = 48, s = 57, u = 43, c = 47, a = 26, l = 52;
            return t <= e && e <= r ? e - t : n <= e && e <= o ? e - n + a : i <= e && e <= s ? e - i + l : e == u ? 62 : e == c ? 63 : -1;
        };
    });
    var oi = Oe((hr)=>{
        var ei = Jo(), pr = 5, ti = 1 << pr, ri = ti - 1, ni = ti;
        function ks(e) {
            return e < 0 ? (-e << 1) + 1 : (e << 1) + 0;
        }
        function ws(e) {
            var t = (e & 1) === 1, r = e >> 1;
            return t ? -r : r;
        }
        hr.encode = function(t) {
            var r = "", n, o = ks(t);
            do n = o & ri, o >>>= pr, o > 0 && (n |= ni), r += ei.encode(n);
            while (o > 0);
            return r;
        };
        hr.decode = function(t, r, n) {
            var o = t.length, i = 0, s = 0, u, c;
            do {
                if (r >= o) throw new Error("Expected more digits in base 64 VLQ value.");
                if (c = ei.decode(t.charCodeAt(r++)), c === -1) throw new Error("Invalid base64 digit: " + t.charAt(r - 1));
                u = !!(c & ni), c &= ri, i = i + (c << s), s += pr;
            }while (u);
            n.value = ws(i), n.rest = r;
        };
    });
    var Et = Oe((K)=>{
        function vs(e, t, r) {
            if (t in e) return e[t];
            if (arguments.length === 3) return r;
            throw new Error('"' + t + '" is a required argument.');
        }
        K.getArg = vs;
        var ii = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/, Ss = /^data:.+\,.+$/;
        function nt(e) {
            var t = e.match(ii);
            return t ? {
                scheme: t[1],
                auth: t[2],
                host: t[3],
                port: t[4],
                path: t[5]
            } : null;
        }
        K.urlParse = nt;
        function qe(e) {
            var t = "";
            return e.scheme && (t += e.scheme + ":"), t += "//", e.auth && (t += e.auth + "@"), e.host && (t += e.host), e.port && (t += ":" + e.port), e.path && (t += e.path), t;
        }
        K.urlGenerate = qe;
        var Cs = 32;
        function As(e) {
            var t = [];
            return function(r) {
                for(var n = 0; n < t.length; n++)if (t[n].input === r) {
                    var o = t[0];
                    return t[0] = t[n], t[n] = o, t[0].result;
                }
                var i = e(r);
                return t.unshift({
                    input: r,
                    result: i
                }), t.length > Cs && t.pop(), i;
            };
        }
        var mr = As(function(t) {
            var r = t, n = nt(t);
            if (n) {
                if (!n.path) return t;
                r = n.path;
            }
            for(var o = K.isAbsolute(r), i = [], s = 0, u = 0;;)if (s = u, u = r.indexOf("/", s), u === -1) {
                i.push(r.slice(s));
                break;
            } else for(i.push(r.slice(s, u)); u < r.length && r[u] === "/";)u++;
            for(var c, a = 0, u = i.length - 1; u >= 0; u--)c = i[u], c === "." ? i.splice(u, 1) : c === ".." ? a++ : a > 0 && (c === "" ? (i.splice(u + 1, a), a = 0) : (i.splice(u, 2), a--));
            return r = i.join("/"), r === "" && (r = o ? "/" : "."), n ? (n.path = r, qe(n)) : r;
        });
        K.normalize = mr;
        function ai(e, t) {
            e === "" && (e = "."), t === "" && (t = ".");
            var r = nt(t), n = nt(e);
            if (n && (e = n.path || "/"), r && !r.scheme) return n && (r.scheme = n.scheme), qe(r);
            if (r || t.match(Ss)) return t;
            if (n && !n.host && !n.path) return n.host = t, qe(n);
            var o = t.charAt(0) === "/" ? t : mr(e.replace(/\/+$/, "") + "/" + t);
            return n ? (n.path = o, qe(n)) : o;
        }
        K.join = ai;
        K.isAbsolute = function(e) {
            return e.charAt(0) === "/" || ii.test(e);
        };
        function Ts(e, t) {
            e === "" && (e = "."), e = e.replace(/\/$/, "");
            for(var r = 0; t.indexOf(e + "/") !== 0;){
                var n = e.lastIndexOf("/");
                if (n < 0 || (e = e.slice(0, n), e.match(/^([^\/]+:\/)?\/*$/))) return t;
                ++r;
            }
            return Array(r + 1).join("../") + t.substr(e.length + 1);
        }
        K.relative = Ts;
        var si = function() {
            var e = Object.create(null);
            return !("__proto__" in e);
        }();
        function li(e) {
            return e;
        }
        function Es(e) {
            return ci(e) ? "$" + e : e;
        }
        K.toSetString = si ? li : Es;
        function Ls(e) {
            return ci(e) ? e.slice(1) : e;
        }
        K.fromSetString = si ? li : Ls;
        function ci(e) {
            if (!e) return !1;
            var t = e.length;
            if (t < 9 || e.charCodeAt(t - 1) !== 95 || e.charCodeAt(t - 2) !== 95 || e.charCodeAt(t - 3) !== 111 || e.charCodeAt(t - 4) !== 116 || e.charCodeAt(t - 5) !== 111 || e.charCodeAt(t - 6) !== 114 || e.charCodeAt(t - 7) !== 112 || e.charCodeAt(t - 8) !== 95 || e.charCodeAt(t - 9) !== 95) return !1;
            for(var r = t - 10; r >= 0; r--)if (e.charCodeAt(r) !== 36) return !1;
            return !0;
        }
        function Ps(e, t, r) {
            var n = be(e.source, t.source);
            return n !== 0 || (n = e.originalLine - t.originalLine, n !== 0) || (n = e.originalColumn - t.originalColumn, n !== 0 || r) || (n = e.generatedColumn - t.generatedColumn, n !== 0) || (n = e.generatedLine - t.generatedLine, n !== 0) ? n : be(e.name, t.name);
        }
        K.compareByOriginalPositions = Ps;
        function Is(e, t, r) {
            var n;
            return n = e.originalLine - t.originalLine, n !== 0 || (n = e.originalColumn - t.originalColumn, n !== 0 || r) || (n = e.generatedColumn - t.generatedColumn, n !== 0) || (n = e.generatedLine - t.generatedLine, n !== 0) ? n : be(e.name, t.name);
        }
        K.compareByOriginalPositionsNoSource = Is;
        function Ds(e, t, r) {
            var n = e.generatedLine - t.generatedLine;
            return n !== 0 || (n = e.generatedColumn - t.generatedColumn, n !== 0 || r) || (n = be(e.source, t.source), n !== 0) || (n = e.originalLine - t.originalLine, n !== 0) || (n = e.originalColumn - t.originalColumn, n !== 0) ? n : be(e.name, t.name);
        }
        K.compareByGeneratedPositionsDeflated = Ds;
        function Os(e, t, r) {
            var n = e.generatedColumn - t.generatedColumn;
            return n !== 0 || r || (n = be(e.source, t.source), n !== 0) || (n = e.originalLine - t.originalLine, n !== 0) || (n = e.originalColumn - t.originalColumn, n !== 0) ? n : be(e.name, t.name);
        }
        K.compareByGeneratedPositionsDeflatedNoLine = Os;
        function be(e, t) {
            return e === t ? 0 : e === null ? 1 : t === null ? -1 : e > t ? 1 : -1;
        }
        function Ns(e, t) {
            var r = e.generatedLine - t.generatedLine;
            return r !== 0 || (r = e.generatedColumn - t.generatedColumn, r !== 0) || (r = be(e.source, t.source), r !== 0) || (r = e.originalLine - t.originalLine, r !== 0) || (r = e.originalColumn - t.originalColumn, r !== 0) ? r : be(e.name, t.name);
        }
        K.compareByGeneratedPositionsInflated = Ns;
        function zs(e) {
            return JSON.parse(e.replace(/^\)]}'[^\n]*\n/, ""));
        }
        K.parseSourceMapInput = zs;
        function Ms(e, t, r) {
            if (t = t || "", e && (e[e.length - 1] !== "/" && t[0] !== "/" && (e += "/"), t = e + t), r) {
                var n = nt(r);
                if (!n) throw new Error("sourceMapURL could not be parsed");
                if (n.path) {
                    var o = n.path.lastIndexOf("/");
                    o >= 0 && (n.path = n.path.substring(0, o + 1));
                }
                t = ai(qe(n), t);
            }
            return mr(t);
        }
        K.computeSourceURL = Ms;
    });
    var pi = Oe((ui)=>{
        var fr = Et(), dr = Object.prototype.hasOwnProperty, Le = typeof Map < "u";
        function xe() {
            this._array = [], this._set = Le ? new Map : Object.create(null);
        }
        xe.fromArray = function(t, r) {
            for(var n = new xe, o = 0, i = t.length; o < i; o++)n.add(t[o], r);
            return n;
        };
        xe.prototype.size = function() {
            return Le ? this._set.size : Object.getOwnPropertyNames(this._set).length;
        };
        xe.prototype.add = function(t, r) {
            var n = Le ? t : fr.toSetString(t), o = Le ? this.has(t) : dr.call(this._set, n), i = this._array.length;
            (!o || r) && this._array.push(t), o || (Le ? this._set.set(t, i) : this._set[n] = i);
        };
        xe.prototype.has = function(t) {
            if (Le) return this._set.has(t);
            var r = fr.toSetString(t);
            return dr.call(this._set, r);
        };
        xe.prototype.indexOf = function(t) {
            if (Le) {
                var r = this._set.get(t);
                if (r >= 0) return r;
            } else {
                var n = fr.toSetString(t);
                if (dr.call(this._set, n)) return this._set[n];
            }
            throw new Error('"' + t + '" is not in the set.');
        };
        xe.prototype.at = function(t) {
            if (t >= 0 && t < this._array.length) return this._array[t];
            throw new Error("No element indexed by " + t);
        };
        xe.prototype.toArray = function() {
            return this._array.slice();
        };
        ui.ArraySet = xe;
    });
    var fi = Oe((mi)=>{
        var hi = Et();
        function Rs(e, t) {
            var r = e.generatedLine, n = t.generatedLine, o = e.generatedColumn, i = t.generatedColumn;
            return n > r || n == r && i >= o || hi.compareByGeneratedPositionsInflated(e, t) <= 0;
        }
        function Lt() {
            this._array = [], this._sorted = !0, this._last = {
                generatedLine: -1,
                generatedColumn: 0
            };
        }
        Lt.prototype.unsortedForEach = function(t, r) {
            this._array.forEach(t, r);
        };
        Lt.prototype.add = function(t) {
            Rs(this._last, t) ? (this._last = t, this._array.push(t)) : (this._sorted = !1, this._array.push(t));
        };
        Lt.prototype.toArray = function() {
            return this._sorted || (this._array.sort(hi.compareByGeneratedPositionsInflated), this._sorted = !0), this._array;
        };
        mi.MappingList = Lt;
    });
    var gi = Oe((di)=>{
        var ot = oi(), j = Et(), Pt = pi().ArraySet, Fs = fi().MappingList;
        function oe(e) {
            e || (e = {}), this._file = j.getArg(e, "file", null), this._sourceRoot = j.getArg(e, "sourceRoot", null), this._skipValidation = j.getArg(e, "skipValidation", !1), this._sources = new Pt, this._names = new Pt, this._mappings = new Fs, this._sourcesContents = null;
        }
        oe.prototype._version = 3;
        oe.fromSourceMap = function(t) {
            var r = t.sourceRoot, n = new oe({
                file: t.file,
                sourceRoot: r
            });
            return t.eachMapping(function(o) {
                var i = {
                    generated: {
                        line: o.generatedLine,
                        column: o.generatedColumn
                    }
                };
                o.source != null && (i.source = o.source, r != null && (i.source = j.relative(r, i.source)), i.original = {
                    line: o.originalLine,
                    column: o.originalColumn
                }, o.name != null && (i.name = o.name)), n.addMapping(i);
            }), t.sources.forEach(function(o) {
                var i = o;
                r !== null && (i = j.relative(r, o)), n._sources.has(i) || n._sources.add(i);
                var s = t.sourceContentFor(o);
                s != null && n.setSourceContent(o, s);
            }), n;
        };
        oe.prototype.addMapping = function(t) {
            var r = j.getArg(t, "generated"), n = j.getArg(t, "original", null), o = j.getArg(t, "source", null), i = j.getArg(t, "name", null);
            this._skipValidation || this._validateMapping(r, n, o, i), o != null && (o = String(o), this._sources.has(o) || this._sources.add(o)), i != null && (i = String(i), this._names.has(i) || this._names.add(i)), this._mappings.add({
                generatedLine: r.line,
                generatedColumn: r.column,
                originalLine: n != null && n.line,
                originalColumn: n != null && n.column,
                source: o,
                name: i
            });
        };
        oe.prototype.setSourceContent = function(t, r) {
            var n = t;
            this._sourceRoot != null && (n = j.relative(this._sourceRoot, n)), r != null ? (this._sourcesContents || (this._sourcesContents = Object.create(null)), this._sourcesContents[j.toSetString(n)] = r) : this._sourcesContents && (delete this._sourcesContents[j.toSetString(n)], Object.keys(this._sourcesContents).length === 0 && (this._sourcesContents = null));
        };
        oe.prototype.applySourceMap = function(t, r, n) {
            var o = r;
            if (r == null) {
                if (t.file == null) throw new Error(`SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`);
                o = t.file;
            }
            var i = this._sourceRoot;
            i != null && (o = j.relative(i, o));
            var s = new Pt, u = new Pt;
            this._mappings.unsortedForEach(function(c) {
                if (c.source === o && c.originalLine != null) {
                    var a = t.originalPositionFor({
                        line: c.originalLine,
                        column: c.originalColumn
                    });
                    a.source != null && (c.source = a.source, n != null && (c.source = j.join(n, c.source)), i != null && (c.source = j.relative(i, c.source)), c.originalLine = a.line, c.originalColumn = a.column, a.name != null && (c.name = a.name));
                }
                var l = c.source;
                l != null && !s.has(l) && s.add(l);
                var p = c.name;
                p != null && !u.has(p) && u.add(p);
            }, this), this._sources = s, this._names = u, t.sources.forEach(function(c) {
                var a = t.sourceContentFor(c);
                a != null && (n != null && (c = j.join(n, c)), i != null && (c = j.relative(i, c)), this.setSourceContent(c, a));
            }, this);
        };
        oe.prototype._validateMapping = function(t, r, n, o) {
            if (r && typeof r.line != "number" && typeof r.column != "number") throw new Error("original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.");
            if (!(t && "line" in t && "column" in t && t.line > 0 && t.column >= 0 && !r && !n && !o)) {
                if (t && "line" in t && "column" in t && r && "line" in r && "column" in r && t.line > 0 && t.column >= 0 && r.line > 0 && r.column >= 0 && n) return;
                throw new Error("Invalid mapping: " + JSON.stringify({
                    generated: t,
                    source: n,
                    original: r,
                    name: o
                }));
            }
        };
        oe.prototype._serializeMappings = function() {
            for(var t = 0, r = 1, n = 0, o = 0, i = 0, s = 0, u = "", c, a, l, p, m = this._mappings.toArray(), f = 0, P = m.length; f < P; f++){
                if (a = m[f], c = "", a.generatedLine !== r) for(t = 0; a.generatedLine !== r;)c += ";", r++;
                else if (f > 0) {
                    if (!j.compareByGeneratedPositionsInflated(a, m[f - 1])) continue;
                    c += ",";
                }
                c += ot.encode(a.generatedColumn - t), t = a.generatedColumn, a.source != null && (p = this._sources.indexOf(a.source), c += ot.encode(p - s), s = p, c += ot.encode(a.originalLine - 1 - o), o = a.originalLine - 1, c += ot.encode(a.originalColumn - n), n = a.originalColumn, a.name != null && (l = this._names.indexOf(a.name), c += ot.encode(l - i), i = l)), u += c;
            }
            return u;
        };
        oe.prototype._generateSourcesContent = function(t, r) {
            return t.map(function(n) {
                if (!this._sourcesContents) return null;
                r != null && (n = j.relative(r, n));
                var o = j.toSetString(n);
                return Object.prototype.hasOwnProperty.call(this._sourcesContents, o) ? this._sourcesContents[o] : null;
            }, this);
        };
        oe.prototype.toJSON = function() {
            var t = {
                version: this._version,
                sources: this._sources.toArray(),
                names: this._names.toArray(),
                mappings: this._serializeMappings()
            };
            return this._file != null && (t.file = this._file), this._sourceRoot != null && (t.sourceRoot = this._sourceRoot), this._sourcesContents && (t.sourcesContent = this._generateSourcesContent(t.sources, t.sourceRoot)), t;
        };
        oe.prototype.toString = function() {
            return JSON.stringify(this.toJSON());
        };
        di.SourceMapGenerator = oe;
    });
    var $e = {};
    b($e, {
        AtKeyword: ()=>I,
        BadString: ()=>Ae,
        BadUrl: ()=>Y,
        CDC: ()=>U,
        CDO: ()=>ue,
        Colon: ()=>O,
        Comma: ()=>G,
        Comment: ()=>E,
        Delim: ()=>g,
        Dimension: ()=>y,
        EOF: ()=>Xe,
        Function: ()=>x,
        Hash: ()=>v,
        Ident: ()=>h,
        LeftCurlyBracket: ()=>M,
        LeftParenthesis: ()=>T,
        LeftSquareBracket: ()=>q,
        Number: ()=>d,
        Percentage: ()=>A,
        RightCurlyBracket: ()=>H,
        RightParenthesis: ()=>w,
        RightSquareBracket: ()=>V,
        Semicolon: ()=>_,
        String: ()=>W,
        Url: ()=>F,
        WhiteSpace: ()=>k$2
    });
    var Xe = 0, h = 1, x = 2, I = 3, v = 4, W = 5, Ae = 6, F = 7, Y = 8, g = 9, d = 10, A = 11, y = 12, k$2 = 13, ue = 14, U = 15, O = 16, _ = 17, G = 18, q = 19, V = 20, T = 21, w = 22, M = 23, H = 24, E = 25;
    function B(e) {
        return e >= 48 && e <= 57;
    }
    function ee(e) {
        return B(e) || e >= 65 && e <= 70 || e >= 97 && e <= 102;
    }
    function yt(e) {
        return e >= 65 && e <= 90;
    }
    function cs(e) {
        return e >= 97 && e <= 122;
    }
    function us(e) {
        return yt(e) || cs(e);
    }
    function ps(e) {
        return e >= 128;
    }
    function xt(e) {
        return us(e) || ps(e) || e === 95;
    }
    function Ne(e) {
        return xt(e) || B(e) || e === 45;
    }
    function hs(e) {
        return e >= 0 && e <= 8 || e === 11 || e >= 14 && e <= 31 || e === 127;
    }
    function Ze(e) {
        return e === 10 || e === 13 || e === 12;
    }
    function pe(e) {
        return Ze(e) || e === 32 || e === 9;
    }
    function $(e, t) {
        return !(e !== 92 || Ze(t) || t === 0);
    }
    function ze(e, t, r) {
        return e === 45 ? xt(t) || t === 45 || $(t, r) : xt(e) ? !0 : e === 92 ? $(e, t) : !1;
    }
    function kt(e, t, r) {
        return e === 43 || e === 45 ? B(t) ? 2 : t === 46 && B(r) ? 3 : 0 : e === 46 ? B(t) ? 2 : 0 : B(e) ? 1 : 0;
    }
    function wt(e) {
        return e === 65279 || e === 65534 ? 1 : 0;
    }
    var rr = new Array(128), ms = 128, Je = 130, nr = 131, vt = 132, or = 133;
    for(let e = 0; e < rr.length; e++)rr[e] = pe(e) && Je || B(e) && nr || xt(e) && vt || hs(e) && or || e || ms;
    function St(e) {
        return e < 128 ? rr[e] : vt;
    }
    function Me(e, t) {
        return t < e.length ? e.charCodeAt(t) : 0;
    }
    function Ct(e, t, r) {
        return r === 13 && Me(e, t + 1) === 10 ? 2 : 1;
    }
    function de(e, t, r) {
        let n = e.charCodeAt(t);
        return yt(n) && (n = n | 32), n === r;
    }
    function ge(e, t, r, n) {
        if (r - t !== n.length || t < 0 || r > e.length) return !1;
        for(let o = t; o < r; o++){
            let i = n.charCodeAt(o - t), s = e.charCodeAt(o);
            if (yt(s) && (s = s | 32), s !== i) return !1;
        }
        return !0;
    }
    function qo(e, t) {
        for(; t >= 0 && pe(e.charCodeAt(t)); t--);
        return t + 1;
    }
    function et(e, t) {
        for(; t < e.length && pe(e.charCodeAt(t)); t++);
        return t;
    }
    function ir(e, t) {
        for(; t < e.length && B(e.charCodeAt(t)); t++);
        return t;
    }
    function se(e, t) {
        if (t += 2, ee(Me(e, t - 1))) {
            for(let n = Math.min(e.length, t + 5); t < n && ee(Me(e, t)); t++);
            let r = Me(e, t);
            pe(r) && (t += Ct(e, t, r));
        }
        return t;
    }
    function tt(e, t) {
        for(; t < e.length; t++){
            let r = e.charCodeAt(t);
            if (!Ne(r)) {
                if ($(r, Me(e, t + 1))) {
                    t = se(e, t) - 1;
                    continue;
                }
                break;
            }
        }
        return t;
    }
    function Te(e, t) {
        let r = e.charCodeAt(t);
        if ((r === 43 || r === 45) && (r = e.charCodeAt(t += 1)), B(r) && (t = ir(e, t + 1), r = e.charCodeAt(t)), r === 46 && B(e.charCodeAt(t + 1)) && (t += 2, t = ir(e, t)), de(e, t, 101)) {
            let n = 0;
            r = e.charCodeAt(t + 1), (r === 45 || r === 43) && (n = 1, r = e.charCodeAt(t + 2)), B(r) && (t = ir(e, t + 1 + n + 1));
        }
        return t;
    }
    function At(e, t) {
        for(; t < e.length; t++){
            let r = e.charCodeAt(t);
            if (r === 41) {
                t++;
                break;
            }
            $(r, Me(e, t + 1)) && (t = se(e, t));
        }
        return t;
    }
    function Re(e) {
        if (e.length === 1 && !ee(e.charCodeAt(0))) return e[0];
        let t = parseInt(e, 16);
        return (t === 0 || t >= 55296 && t <= 57343 || t > 1114111) && (t = 65533), String.fromCodePoint(t);
    }
    var Fe = [
        "EOF-token",
        "ident-token",
        "function-token",
        "at-keyword-token",
        "hash-token",
        "string-token",
        "bad-string-token",
        "url-token",
        "bad-url-token",
        "delim-token",
        "number-token",
        "percentage-token",
        "dimension-token",
        "whitespace-token",
        "CDO-token",
        "CDC-token",
        "colon-token",
        "semicolon-token",
        "comma-token",
        "[-token",
        "]-token",
        "(-token",
        ")-token",
        "{-token",
        "}-token"
    ];
    function Be(e = null, t) {
        return e === null || e.length < t ? new Uint32Array(Math.max(t + 1024, 16384)) : e;
    }
    var Uo = 10, fs = 12, jo = 13;
    function Wo(e) {
        let t = e.source, r = t.length, n = t.length > 0 ? wt(t.charCodeAt(0)) : 0, o = Be(e.lines, r), i = Be(e.columns, r), s = e.startLine, u = e.startColumn;
        for(let c = n; c < r; c++){
            let a = t.charCodeAt(c);
            o[c] = s, i[c] = u++, (a === Uo || a === jo || a === fs) && (a === jo && c + 1 < r && t.charCodeAt(c + 1) === Uo && (c++, o[c] = s, i[c] = u), s++, u = 1);
        }
        o[r] = s, i[r] = u, e.lines = o, e.columns = i, e.computed = !0;
    }
    var Tt = class {
        constructor(){
            this.lines = null, this.columns = null, this.computed = !1;
        }
        setSource(t, r = 0, n = 1, o = 1) {
            this.source = t, this.startOffset = r, this.startLine = n, this.startColumn = o, this.computed = !1;
        }
        getLocation(t, r) {
            return this.computed || Wo(this), {
                source: r,
                offset: this.startOffset + t,
                line: this.lines[t],
                column: this.columns[t]
            };
        }
        getLocationRange(t, r, n) {
            return this.computed || Wo(this), {
                source: n,
                start: {
                    offset: this.startOffset + t,
                    line: this.lines[t],
                    column: this.columns[t]
                },
                end: {
                    offset: this.startOffset + r,
                    line: this.lines[r],
                    column: this.columns[r]
                }
            };
        }
    };
    var ne = 16777215, we = 24, ds = new Map([
        [
            2,
            22
        ],
        [
            21,
            22
        ],
        [
            19,
            20
        ],
        [
            23,
            24
        ]
    ]), rt = class {
        constructor(t, r){
            this.setSource(t, r);
        }
        reset() {
            this.eof = !1, this.tokenIndex = -1, this.tokenType = 0, this.tokenStart = this.firstCharOffset, this.tokenEnd = this.firstCharOffset;
        }
        setSource(t = "", r = ()=>{}) {
            t = String(t || "");
            let n = t.length, o = Be(this.offsetAndType, t.length + 1), i = Be(this.balance, t.length + 1), s = 0, u = 0, c = 0, a = -1;
            for(this.offsetAndType = null, this.balance = null, r(t, (l, p, m)=>{
                switch(l){
                    default:
                        i[s] = n;
                        break;
                    case u:
                        {
                            let f = c & ne;
                            for(c = i[f], u = c >> we, i[s] = f, i[f++] = s; f < s; f++)i[f] === n && (i[f] = s);
                            break;
                        }
                    case 21:
                    case 2:
                    case 19:
                    case 23:
                        i[s] = c, u = ds.get(l), c = u << we | s;
                        break;
                }
                o[s++] = l << we | m, a === -1 && (a = p);
            }), o[s] = 0 << we | n, i[s] = n, i[n] = n; c !== 0;){
                let l = c & ne;
                c = i[l], i[l] = n;
            }
            this.source = t, this.firstCharOffset = a === -1 ? 0 : a, this.tokenCount = s, this.offsetAndType = o, this.balance = i, this.reset(), this.next();
        }
        lookupType(t) {
            return t += this.tokenIndex, t < this.tokenCount ? this.offsetAndType[t] >> we : 0;
        }
        lookupOffset(t) {
            return t += this.tokenIndex, t < this.tokenCount ? this.offsetAndType[t - 1] & ne : this.source.length;
        }
        lookupValue(t, r) {
            return t += this.tokenIndex, t < this.tokenCount ? ge(this.source, this.offsetAndType[t - 1] & ne, this.offsetAndType[t] & ne, r) : !1;
        }
        getTokenStart(t) {
            return t === this.tokenIndex ? this.tokenStart : t > 0 ? t < this.tokenCount ? this.offsetAndType[t - 1] & ne : this.offsetAndType[this.tokenCount] & ne : this.firstCharOffset;
        }
        substrToCursor(t) {
            return this.source.substring(t, this.tokenStart);
        }
        isBalanceEdge(t) {
            return this.balance[this.tokenIndex] < t;
        }
        isDelim(t, r) {
            return r ? this.lookupType(r) === 9 && this.source.charCodeAt(this.lookupOffset(r)) === t : this.tokenType === 9 && this.source.charCodeAt(this.tokenStart) === t;
        }
        skip(t) {
            let r = this.tokenIndex + t;
            r < this.tokenCount ? (this.tokenIndex = r, this.tokenStart = this.offsetAndType[r - 1] & ne, r = this.offsetAndType[r], this.tokenType = r >> we, this.tokenEnd = r & ne) : (this.tokenIndex = this.tokenCount, this.next());
        }
        next() {
            let t = this.tokenIndex + 1;
            t < this.tokenCount ? (this.tokenIndex = t, this.tokenStart = this.tokenEnd, t = this.offsetAndType[t], this.tokenType = t >> we, this.tokenEnd = t & ne) : (this.eof = !0, this.tokenIndex = this.tokenCount, this.tokenType = 0, this.tokenStart = this.tokenEnd = this.source.length);
        }
        skipSC() {
            for(; this.tokenType === 13 || this.tokenType === 25;)this.next();
        }
        skipUntilBalanced(t, r) {
            let n = t, o, i;
            e: for(; n < this.tokenCount; n++){
                if (o = this.balance[n], o < t) break e;
                switch(i = n > 0 ? this.offsetAndType[n - 1] & ne : this.firstCharOffset, r(this.source.charCodeAt(i))){
                    case 1:
                        break e;
                    case 2:
                        n++;
                        break e;
                    default:
                        this.balance[o] === n && (n = o);
                }
            }
            this.skip(n - this.tokenIndex);
        }
        forEachToken(t) {
            for(let r = 0, n = this.firstCharOffset; r < this.tokenCount; r++){
                let o = n, i = this.offsetAndType[r], s = i & ne, u = i >> we;
                n = s, t(u, o, s, r);
            }
        }
        dump() {
            let t = new Array(this.tokenCount);
            return this.forEachToken((r, n, o, i)=>{
                t[i] = {
                    idx: i,
                    type: Fe[r],
                    chunk: this.source.substring(n, o),
                    balance: this.balance[i]
                };
            }), t;
        }
    };
    function ve(e, t) {
        function r(p) {
            return p < u ? e.charCodeAt(p) : 0;
        }
        function n() {
            if (a = Te(e, a), ze(r(a), r(a + 1), r(a + 2))) {
                l = 12, a = tt(e, a);
                return;
            }
            if (r(a) === 37) {
                l = 11, a++;
                return;
            }
            l = 10;
        }
        function o() {
            let p = a;
            if (a = tt(e, a), ge(e, p, a, "url") && r(a) === 40) {
                if (a = et(e, a + 1), r(a) === 34 || r(a) === 39) {
                    l = 2, a = p + 4;
                    return;
                }
                s();
                return;
            }
            if (r(a) === 40) {
                l = 2, a++;
                return;
            }
            l = 1;
        }
        function i(p) {
            for(p || (p = r(a++)), l = 5; a < e.length; a++){
                let m = e.charCodeAt(a);
                switch(St(m)){
                    case p:
                        a++;
                        return;
                    case Je:
                        if (Ze(m)) {
                            a += Ct(e, a, m), l = 6;
                            return;
                        }
                        break;
                    case 92:
                        if (a === e.length - 1) break;
                        let f = r(a + 1);
                        Ze(f) ? a += Ct(e, a + 1, f) : $(m, f) && (a = se(e, a) - 1);
                        break;
                }
            }
        }
        function s() {
            for(l = 7, a = et(e, a); a < e.length; a++){
                let p = e.charCodeAt(a);
                switch(St(p)){
                    case 41:
                        a++;
                        return;
                    case Je:
                        if (a = et(e, a), r(a) === 41 || a >= e.length) {
                            a < e.length && a++;
                            return;
                        }
                        a = At(e, a), l = 8;
                        return;
                    case 34:
                    case 39:
                    case 40:
                    case or:
                        a = At(e, a), l = 8;
                        return;
                    case 92:
                        if ($(p, r(a + 1))) {
                            a = se(e, a) - 1;
                            break;
                        }
                        a = At(e, a), l = 8;
                        return;
                }
            }
        }
        e = String(e || "");
        let u = e.length, c = wt(r(0)), a = c, l;
        for(; a < u;){
            let p = e.charCodeAt(a);
            switch(St(p)){
                case Je:
                    l = 13, a = et(e, a + 1);
                    break;
                case 34:
                    i();
                    break;
                case 35:
                    Ne(r(a + 1)) || $(r(a + 1), r(a + 2)) ? (l = 4, a = tt(e, a + 1)) : (l = 9, a++);
                    break;
                case 39:
                    i();
                    break;
                case 40:
                    l = 21, a++;
                    break;
                case 41:
                    l = 22, a++;
                    break;
                case 43:
                    kt(p, r(a + 1), r(a + 2)) ? n() : (l = 9, a++);
                    break;
                case 44:
                    l = 18, a++;
                    break;
                case 45:
                    kt(p, r(a + 1), r(a + 2)) ? n() : r(a + 1) === 45 && r(a + 2) === 62 ? (l = 15, a = a + 3) : ze(p, r(a + 1), r(a + 2)) ? o() : (l = 9, a++);
                    break;
                case 46:
                    kt(p, r(a + 1), r(a + 2)) ? n() : (l = 9, a++);
                    break;
                case 47:
                    r(a + 1) === 42 ? (l = 25, a = e.indexOf("*/", a + 2), a = a === -1 ? e.length : a + 2) : (l = 9, a++);
                    break;
                case 58:
                    l = 16, a++;
                    break;
                case 59:
                    l = 17, a++;
                    break;
                case 60:
                    r(a + 1) === 33 && r(a + 2) === 45 && r(a + 3) === 45 ? (l = 14, a = a + 4) : (l = 9, a++);
                    break;
                case 64:
                    ze(r(a + 1), r(a + 2), r(a + 3)) ? (l = 3, a = tt(e, a + 1)) : (l = 9, a++);
                    break;
                case 91:
                    l = 19, a++;
                    break;
                case 92:
                    $(p, r(a + 1)) ? o() : (l = 9, a++);
                    break;
                case 93:
                    l = 20, a++;
                    break;
                case 123:
                    l = 23, a++;
                    break;
                case 125:
                    l = 24, a++;
                    break;
                case nr:
                    n();
                    break;
                case vt:
                    o();
                    break;
                default:
                    l = 9, a++;
            }
            t(l, c, c = a);
        }
    }
    var _e = null, D = class {
        static createItem(t) {
            return {
                prev: null,
                next: null,
                data: t
            };
        }
        constructor(){
            this.head = null, this.tail = null, this.cursor = null;
        }
        createItem(t) {
            return D.createItem(t);
        }
        allocateCursor(t, r) {
            let n;
            return _e !== null ? (n = _e, _e = _e.cursor, n.prev = t, n.next = r, n.cursor = this.cursor) : n = {
                prev: t,
                next: r,
                cursor: this.cursor
            }, this.cursor = n, n;
        }
        releaseCursor() {
            let { cursor: t } = this;
            this.cursor = t.cursor, t.prev = null, t.next = null, t.cursor = _e, _e = t;
        }
        updateCursors(t, r, n, o) {
            let { cursor: i } = this;
            for(; i !== null;)i.prev === t && (i.prev = r), i.next === n && (i.next = o), i = i.cursor;
        }
        *[Symbol.iterator]() {
            for(let t = this.head; t !== null; t = t.next)yield t.data;
        }
        get size() {
            let t = 0;
            for(let r = this.head; r !== null; r = r.next)t++;
            return t;
        }
        get isEmpty() {
            return this.head === null;
        }
        get first() {
            return this.head && this.head.data;
        }
        get last() {
            return this.tail && this.tail.data;
        }
        fromArray(t) {
            let r = null;
            this.head = null;
            for (let n of t){
                let o = D.createItem(n);
                r !== null ? r.next = o : this.head = o, o.prev = r, r = o;
            }
            return this.tail = r, this;
        }
        toArray() {
            return [
                ...this
            ];
        }
        toJSON() {
            return [
                ...this
            ];
        }
        forEach(t, r = this) {
            let n = this.allocateCursor(null, this.head);
            for(; n.next !== null;){
                let o = n.next;
                n.next = o.next, t.call(r, o.data, o, this);
            }
            this.releaseCursor();
        }
        forEachRight(t, r = this) {
            let n = this.allocateCursor(this.tail, null);
            for(; n.prev !== null;){
                let o = n.prev;
                n.prev = o.prev, t.call(r, o.data, o, this);
            }
            this.releaseCursor();
        }
        reduce(t, r, n = this) {
            let o = this.allocateCursor(null, this.head), i = r, s;
            for(; o.next !== null;)s = o.next, o.next = s.next, i = t.call(n, i, s.data, s, this);
            return this.releaseCursor(), i;
        }
        reduceRight(t, r, n = this) {
            let o = this.allocateCursor(this.tail, null), i = r, s;
            for(; o.prev !== null;)s = o.prev, o.prev = s.prev, i = t.call(n, i, s.data, s, this);
            return this.releaseCursor(), i;
        }
        some(t, r = this) {
            for(let n = this.head; n !== null; n = n.next)if (t.call(r, n.data, n, this)) return !0;
            return !1;
        }
        map(t, r = this) {
            let n = new D;
            for(let o = this.head; o !== null; o = o.next)n.appendData(t.call(r, o.data, o, this));
            return n;
        }
        filter(t, r = this) {
            let n = new D;
            for(let o = this.head; o !== null; o = o.next)t.call(r, o.data, o, this) && n.appendData(o.data);
            return n;
        }
        nextUntil(t, r, n = this) {
            if (t === null) return;
            let o = this.allocateCursor(null, t);
            for(; o.next !== null;){
                let i = o.next;
                if (o.next = i.next, r.call(n, i.data, i, this)) break;
            }
            this.releaseCursor();
        }
        prevUntil(t, r, n = this) {
            if (t === null) return;
            let o = this.allocateCursor(t, null);
            for(; o.prev !== null;){
                let i = o.prev;
                if (o.prev = i.prev, r.call(n, i.data, i, this)) break;
            }
            this.releaseCursor();
        }
        clear() {
            this.head = null, this.tail = null;
        }
        copy() {
            let t = new D;
            for (let r of this)t.appendData(r);
            return t;
        }
        prepend(t) {
            return this.updateCursors(null, t, this.head, t), this.head !== null ? (this.head.prev = t, t.next = this.head) : this.tail = t, this.head = t, this;
        }
        prependData(t) {
            return this.prepend(D.createItem(t));
        }
        append(t) {
            return this.insert(t);
        }
        appendData(t) {
            return this.insert(D.createItem(t));
        }
        insert(t, r = null) {
            if (r !== null) {
                if (this.updateCursors(r.prev, t, r, t), r.prev === null) {
                    if (this.head !== r) throw new Error("before doesn't belong to list");
                    this.head = t, r.prev = t, t.next = r, this.updateCursors(null, t);
                } else r.prev.next = t, t.prev = r.prev, r.prev = t, t.next = r;
            } else this.updateCursors(this.tail, t, null, t), this.tail !== null ? (this.tail.next = t, t.prev = this.tail) : this.head = t, this.tail = t;
            return this;
        }
        insertData(t, r) {
            return this.insert(D.createItem(t), r);
        }
        remove(t) {
            if (this.updateCursors(t, t.prev, t, t.next), t.prev !== null) t.prev.next = t.next;
            else {
                if (this.head !== t) throw new Error("item doesn't belong to list");
                this.head = t.next;
            }
            if (t.next !== null) t.next.prev = t.prev;
            else {
                if (this.tail !== t) throw new Error("item doesn't belong to list");
                this.tail = t.prev;
            }
            return t.prev = null, t.next = null, t;
        }
        push(t) {
            this.insert(D.createItem(t));
        }
        pop() {
            return this.tail !== null ? this.remove(this.tail) : null;
        }
        unshift(t) {
            this.prepend(D.createItem(t));
        }
        shift() {
            return this.head !== null ? this.remove(this.head) : null;
        }
        prependList(t) {
            return this.insertList(t, this.head);
        }
        appendList(t) {
            return this.insertList(t);
        }
        insertList(t, r) {
            return t.head === null ? this : (r != null ? (this.updateCursors(r.prev, t.tail, r, t.head), r.prev !== null ? (r.prev.next = t.head, t.head.prev = r.prev) : this.head = t.head, r.prev = t.tail, t.tail.next = r) : (this.updateCursors(this.tail, t.tail, null, t.head), this.tail !== null ? (this.tail.next = t.head, t.head.prev = this.tail) : this.head = t.head, this.tail = t.tail), t.head = null, t.tail = null, this);
        }
        replace(t, r) {
            "head" in r ? this.insertList(r, t) : this.insert(r, t), this.remove(t);
        }
    };
    function Ee(e, t) {
        let r = Object.create(SyntaxError.prototype), n = new Error;
        return Object.assign(r, {
            name: e,
            message: t,
            get stack () {
                return (n.stack || "").replace(/^(.+\n){1,3}/, `${e}: ${t}
`);
            }
        });
    }
    var ar = 100, Ho = 60, Yo = "    ";
    function Go({ source: e, line: t, column: r }, n) {
        function o(l, p) {
            return i.slice(l, p).map((m, f)=>String(l + f + 1).padStart(c) + " |" + m).join(`
`);
        }
        let i = e.split(/\r\n?|\n|\f/), s = Math.max(1, t - n) - 1, u = Math.min(t + n, i.length + 1), c = Math.max(4, String(u).length) + 1, a = 0;
        r += (Yo.length - 1) * (i[t - 1].substr(0, r - 1).match(/\t/g) || []).length, r > ar && (a = r - Ho + 3, r = Ho - 2);
        for(let l = s; l <= u; l++)l >= 0 && l < i.length && (i[l] = i[l].replace(/\t/g, Yo), i[l] = (a > 0 && i[l].length > a ? "\u2026" : "") + i[l].substr(a, ar - 2) + (i[l].length > a + ar - 1 ? "\u2026" : ""));
        return [
            o(s, t),
            new Array(r + c + 2).join("-") + "^",
            o(t, u)
        ].filter(Boolean).join(`
`);
    }
    function sr(e, t, r, n, o) {
        return Object.assign(Ee("SyntaxError", e), {
            source: t,
            offset: r,
            line: n,
            column: o,
            sourceFragment (s) {
                return Go({
                    source: t,
                    line: n,
                    column: o
                }, isNaN(s) ? 0 : s);
            },
            get formattedMessage () {
                return `Parse error: ${e}
` + Go({
                    source: t,
                    line: n,
                    column: o
                }, 2);
            }
        });
    }
    function Vo(e) {
        let t = this.createList(), r = !1, n = {
            recognizer: e
        };
        for(; !this.eof;){
            switch(this.tokenType){
                case 25:
                    this.next();
                    continue;
                case 13:
                    r = !0, this.next();
                    continue;
            }
            let o = e.getNode.call(this, n);
            if (o === void 0) break;
            r && (e.onWhiteSpace && e.onWhiteSpace.call(this, o, t, n), r = !1), t.push(o);
        }
        return r && e.onWhiteSpace && e.onWhiteSpace.call(this, null, t, n), t;
    }
    var Ko = ()=>{}, gs = 33, bs = 35, lr = 59, Qo = 123, Xo = 0;
    function xs(e) {
        return function() {
            return this[e]();
        };
    }
    function cr(e) {
        let t = Object.create(null);
        for(let r in e){
            let n = e[r], o = n.parse || n;
            o && (t[r] = o);
        }
        return t;
    }
    function ys(e) {
        let t = {
            context: Object.create(null),
            scope: Object.assign(Object.create(null), e.scope),
            atrule: cr(e.atrule),
            pseudo: cr(e.pseudo),
            node: cr(e.node)
        };
        for(let r in e.parseContext)switch(typeof e.parseContext[r]){
            case "function":
                t.context[r] = e.parseContext[r];
                break;
            case "string":
                t.context[r] = xs(e.parseContext[r]);
                break;
        }
        return {
            config: t,
            ...t,
            ...t.node
        };
    }
    function $o(e) {
        let t = "", r = "<unknown>", n = !1, o = Ko, i = !1, s = new Tt, u = Object.assign(new rt, ys(e || {}), {
            parseAtrulePrelude: !0,
            parseRulePrelude: !0,
            parseValue: !0,
            parseCustomProperty: !1,
            readSequence: Vo,
            consumeUntilBalanceEnd: ()=>0,
            consumeUntilLeftCurlyBracket (a) {
                return a === Qo ? 1 : 0;
            },
            consumeUntilLeftCurlyBracketOrSemicolon (a) {
                return a === Qo || a === lr ? 1 : 0;
            },
            consumeUntilExclamationMarkOrSemicolon (a) {
                return a === gs || a === lr ? 1 : 0;
            },
            consumeUntilSemicolonIncluded (a) {
                return a === lr ? 2 : 0;
            },
            createList () {
                return new D;
            },
            createSingleNodeList (a) {
                return new D().appendData(a);
            },
            getFirstListNode (a) {
                return a && a.first;
            },
            getLastListNode (a) {
                return a && a.last;
            },
            parseWithFallback (a, l) {
                let p = this.tokenIndex;
                try {
                    return a.call(this);
                } catch (m) {
                    if (i) throw m;
                    let f = l.call(this, p);
                    return i = !0, o(m, f), i = !1, f;
                }
            },
            lookupNonWSType (a) {
                let l;
                do if (l = this.lookupType(a++), l !== 13) return l;
                while (l !== Xo);
                return Xo;
            },
            charCodeAt (a) {
                return a >= 0 && a < t.length ? t.charCodeAt(a) : 0;
            },
            substring (a, l) {
                return t.substring(a, l);
            },
            substrToCursor (a) {
                return this.source.substring(a, this.tokenStart);
            },
            cmpChar (a, l) {
                return de(t, a, l);
            },
            cmpStr (a, l, p) {
                return ge(t, a, l, p);
            },
            consume (a) {
                let l = this.tokenStart;
                return this.eat(a), this.substrToCursor(l);
            },
            consumeFunctionName () {
                let a = t.substring(this.tokenStart, this.tokenEnd - 1);
                return this.eat(2), a;
            },
            consumeNumber (a) {
                let l = t.substring(this.tokenStart, Te(t, this.tokenStart));
                return this.eat(a), l;
            },
            eat (a) {
                if (this.tokenType !== a) {
                    let l = Fe[a].slice(0, -6).replace(/-/g, " ").replace(/^./, (f)=>f.toUpperCase()), p = `${/[[\](){}]/.test(l) ? `"${l}"` : l} is expected`, m = this.tokenStart;
                    switch(a){
                        case 1:
                            this.tokenType === 2 || this.tokenType === 7 ? (m = this.tokenEnd - 1, p = "Identifier is expected but function found") : p = "Identifier is expected";
                            break;
                        case 4:
                            this.isDelim(bs) && (this.next(), m++, p = "Name is expected");
                            break;
                        case 11:
                            this.tokenType === 10 && (m = this.tokenEnd, p = "Percent sign is expected");
                            break;
                    }
                    this.error(p, m);
                }
                this.next();
            },
            eatIdent (a) {
                (this.tokenType !== 1 || this.lookupValue(0, a) === !1) && this.error(`Identifier "${a}" is expected`), this.next();
            },
            eatDelim (a) {
                this.isDelim(a) || this.error(`Delim "${String.fromCharCode(a)}" is expected`), this.next();
            },
            getLocation (a, l) {
                return n ? s.getLocationRange(a, l, r) : null;
            },
            getLocationFromList (a) {
                if (n) {
                    let l = this.getFirstListNode(a), p = this.getLastListNode(a);
                    return s.getLocationRange(l !== null ? l.loc.start.offset - s.startOffset : this.tokenStart, p !== null ? p.loc.end.offset - s.startOffset : this.tokenStart, r);
                }
                return null;
            },
            error (a, l) {
                let p = typeof l < "u" && l < t.length ? s.getLocation(l) : this.eof ? s.getLocation(qo(t, t.length - 1)) : s.getLocation(this.tokenStart);
                throw new sr(a || "Unexpected input", t, p.offset, p.line, p.column);
            }
        });
        return Object.assign(function(a, l) {
            t = a, l = l || {}, u.setSource(t, ve), s.setSource(t, l.offset, l.line, l.column), r = l.filename || "<unknown>", n = Boolean(l.positions), o = typeof l.onParseError == "function" ? l.onParseError : Ko, i = !1, u.parseAtrulePrelude = "parseAtrulePrelude" in l ? Boolean(l.parseAtrulePrelude) : !0, u.parseRulePrelude = "parseRulePrelude" in l ? Boolean(l.parseRulePrelude) : !0, u.parseValue = "parseValue" in l ? Boolean(l.parseValue) : !0, u.parseCustomProperty = "parseCustomProperty" in l ? Boolean(l.parseCustomProperty) : !1;
            let { context: p = "default", onComment: m } = l;
            if (!(p in u.context)) throw new Error("Unknown context `" + p + "`");
            typeof m == "function" && u.forEachToken((P, te, X)=>{
                if (P === 25) {
                    let S = u.getLocation(te, X), R = ge(t, X - 2, X, "*/") ? t.slice(te + 2, X - 2) : t.slice(te + 2, X);
                    m(R, S);
                }
            });
            let f = u.context[p].call(u, l);
            return u.eof || u.error(), f;
        }, {
            SyntaxError: sr,
            config: u.config
        });
    }
    var xi = ls(gi(), 1), bi = new Set([
        "Atrule",
        "Selector",
        "Declaration"
    ]);
    function yi(e) {
        let t = new xi.SourceMapGenerator, r = {
            line: 1,
            column: 0
        }, n = {
            line: 0,
            column: 0
        }, o = {
            line: 1,
            column: 0
        }, i = {
            generated: o
        }, s = 1, u = 0, c = !1, a = e.node;
        e.node = function(m) {
            if (m.loc && m.loc.start && bi.has(m.type)) {
                let f = m.loc.start.line, P = m.loc.start.column - 1;
                (n.line !== f || n.column !== P) && (n.line = f, n.column = P, r.line = s, r.column = u, c && (c = !1, (r.line !== o.line || r.column !== o.column) && t.addMapping(i)), c = !0, t.addMapping({
                    source: m.loc.source,
                    original: n,
                    generated: r
                }));
            }
            a.call(this, m), c && bi.has(m.type) && (o.line = s, o.column = u);
        };
        let l = e.emit;
        e.emit = function(m, f, P) {
            for(let te = 0; te < m.length; te++)m.charCodeAt(te) === 10 ? (s++, u = 0) : u++;
            l(m, f, P);
        };
        let p = e.result;
        return e.result = function() {
            return c && t.addMapping(i), {
                css: p(),
                map: t
            };
        }, e;
    }
    var It = {};
    b(It, {
        safe: ()=>br,
        spec: ()=>Us
    });
    var Bs = 43, _s = 45, gr = (e, t)=>{
        if (e === 9 && (e = t), typeof e == "string") {
            let r = e.charCodeAt(0);
            return r > 127 ? 32768 : r << 8;
        }
        return e;
    }, ki = [
        [
            1,
            1
        ],
        [
            1,
            2
        ],
        [
            1,
            7
        ],
        [
            1,
            8
        ],
        [
            1,
            "-"
        ],
        [
            1,
            10
        ],
        [
            1,
            11
        ],
        [
            1,
            12
        ],
        [
            1,
            15
        ],
        [
            1,
            21
        ],
        [
            3,
            1
        ],
        [
            3,
            2
        ],
        [
            3,
            7
        ],
        [
            3,
            8
        ],
        [
            3,
            "-"
        ],
        [
            3,
            10
        ],
        [
            3,
            11
        ],
        [
            3,
            12
        ],
        [
            3,
            15
        ],
        [
            4,
            1
        ],
        [
            4,
            2
        ],
        [
            4,
            7
        ],
        [
            4,
            8
        ],
        [
            4,
            "-"
        ],
        [
            4,
            10
        ],
        [
            4,
            11
        ],
        [
            4,
            12
        ],
        [
            4,
            15
        ],
        [
            12,
            1
        ],
        [
            12,
            2
        ],
        [
            12,
            7
        ],
        [
            12,
            8
        ],
        [
            12,
            "-"
        ],
        [
            12,
            10
        ],
        [
            12,
            11
        ],
        [
            12,
            12
        ],
        [
            12,
            15
        ],
        [
            "#",
            1
        ],
        [
            "#",
            2
        ],
        [
            "#",
            7
        ],
        [
            "#",
            8
        ],
        [
            "#",
            "-"
        ],
        [
            "#",
            10
        ],
        [
            "#",
            11
        ],
        [
            "#",
            12
        ],
        [
            "#",
            15
        ],
        [
            "-",
            1
        ],
        [
            "-",
            2
        ],
        [
            "-",
            7
        ],
        [
            "-",
            8
        ],
        [
            "-",
            "-"
        ],
        [
            "-",
            10
        ],
        [
            "-",
            11
        ],
        [
            "-",
            12
        ],
        [
            "-",
            15
        ],
        [
            10,
            1
        ],
        [
            10,
            2
        ],
        [
            10,
            7
        ],
        [
            10,
            8
        ],
        [
            10,
            10
        ],
        [
            10,
            11
        ],
        [
            10,
            12
        ],
        [
            10,
            "%"
        ],
        [
            10,
            15
        ],
        [
            "@",
            1
        ],
        [
            "@",
            2
        ],
        [
            "@",
            7
        ],
        [
            "@",
            8
        ],
        [
            "@",
            "-"
        ],
        [
            "@",
            15
        ],
        [
            ".",
            10
        ],
        [
            ".",
            11
        ],
        [
            ".",
            12
        ],
        [
            "+",
            10
        ],
        [
            "+",
            11
        ],
        [
            "+",
            12
        ],
        [
            "/",
            "*"
        ]
    ], qs = ki.concat([
        [
            1,
            4
        ],
        [
            12,
            4
        ],
        [
            4,
            4
        ],
        [
            3,
            21
        ],
        [
            3,
            5
        ],
        [
            3,
            16
        ],
        [
            11,
            11
        ],
        [
            11,
            12
        ],
        [
            11,
            2
        ],
        [
            11,
            "-"
        ],
        [
            22,
            1
        ],
        [
            22,
            2
        ],
        [
            22,
            11
        ],
        [
            22,
            12
        ],
        [
            22,
            4
        ],
        [
            22,
            "-"
        ]
    ]);
    function wi(e) {
        let t = new Set(e.map(([r, n])=>gr(r) << 16 | gr(n)));
        return function(r, n, o) {
            let i = gr(n, o), s = o.charCodeAt(0);
            return (s === _s && n !== 1 && n !== 2 && n !== 15 || s === Bs ? t.has(r << 16 | s << 8) : t.has(r << 16 | i)) && this.emit(" ", 13, !0), i;
        };
    }
    var Us = wi(ki), br = wi(qs);
    var js = 92;
    function Ws(e, t) {
        if (typeof t == "function") {
            let r = null;
            e.children.forEach((n)=>{
                r !== null && t.call(this, r), this.node(n), r = n;
            });
            return;
        }
        e.children.forEach(this.node, this);
    }
    function Hs(e) {
        ve(e, (t, r, n)=>{
            this.token(t, e.slice(r, n));
        });
    }
    function vi(e) {
        let t = new Map;
        for(let r in e.node){
            let n = e.node[r];
            typeof (n.generate || n) == "function" && t.set(r, n.generate || n);
        }
        return function(r, n) {
            let o = "", i = 0, s = {
                node (c) {
                    if (t.has(c.type)) t.get(c.type).call(u, c);
                    else throw new Error("Unknown node type: " + c.type);
                },
                tokenBefore: br,
                token (c, a) {
                    i = this.tokenBefore(i, c, a), this.emit(a, c, !1), c === 9 && a.charCodeAt(0) === js && this.emit(`
`, 13, !0);
                },
                emit (c) {
                    o += c;
                },
                result () {
                    return o;
                }
            };
            n && (typeof n.decorator == "function" && (s = n.decorator(s)), n.sourceMap && (s = yi(s)), n.mode in It && (s.tokenBefore = It[n.mode]));
            let u = {
                node: (c)=>s.node(c),
                children: Ws,
                token: (c, a)=>s.token(c, a),
                tokenize: Hs
            };
            return s.node(r), s.result();
        };
    }
    function Si(e) {
        return {
            fromPlainObject (t) {
                return e(t, {
                    enter (r) {
                        r.children && !(r.children instanceof D) && (r.children = new D().fromArray(r.children));
                    }
                }), t;
            },
            toPlainObject (t) {
                return e(t, {
                    leave (r) {
                        r.children && r.children instanceof D && (r.children = r.children.toArray());
                    }
                }), t;
            }
        };
    }
    var { hasOwnProperty: xr } = Object.prototype, it = function() {};
    function Ci(e) {
        return typeof e == "function" ? e : it;
    }
    function Ai(e, t) {
        return function(r, n, o) {
            r.type === t && e.call(this, r, n, o);
        };
    }
    function Ys(e, t) {
        let r = t.structure, n = [];
        for(let o in r){
            if (xr.call(r, o) === !1) continue;
            let i = r[o], s = {
                name: o,
                type: !1,
                nullable: !1
            };
            Array.isArray(i) || (i = [
                i
            ]);
            for (let u of i)u === null ? s.nullable = !0 : typeof u == "string" ? s.type = "node" : Array.isArray(u) && (s.type = "list");
            s.type && n.push(s);
        }
        return n.length ? {
            context: t.walkContext,
            fields: n
        } : null;
    }
    function Gs(e) {
        let t = {};
        for(let r in e.node)if (xr.call(e.node, r)) {
            let n = e.node[r];
            if (!n.structure) throw new Error("Missed `structure` field in `" + r + "` node type definition");
            t[r] = Ys(r, n);
        }
        return t;
    }
    function Ti(e, t) {
        let r = e.fields.slice(), n = e.context, o = typeof n == "string";
        return t && r.reverse(), function(i, s, u, c) {
            let a;
            o && (a = s[n], s[n] = i);
            for (let l of r){
                let p = i[l.name];
                if (!l.nullable || p) {
                    if (l.type === "list") {
                        if (t ? p.reduceRight(c, !1) : p.reduce(c, !1)) return !0;
                    } else if (u(p)) return !0;
                }
            }
            o && (s[n] = a);
        };
    }
    function Ei({ StyleSheet: e, Atrule: t, Rule: r, Block: n, DeclarationList: o }) {
        return {
            Atrule: {
                StyleSheet: e,
                Atrule: t,
                Rule: r,
                Block: n
            },
            Rule: {
                StyleSheet: e,
                Atrule: t,
                Rule: r,
                Block: n
            },
            Declaration: {
                StyleSheet: e,
                Atrule: t,
                Rule: r,
                Block: n,
                DeclarationList: o
            }
        };
    }
    function Li(e) {
        let t = Gs(e), r = {}, n = {}, o = Symbol("break-walk"), i = Symbol("skip-node");
        for(let a in t)xr.call(t, a) && t[a] !== null && (r[a] = Ti(t[a], !1), n[a] = Ti(t[a], !0));
        let s = Ei(r), u = Ei(n), c = function(a, l) {
            function p(S, R, ke) {
                let z = m.call(X, S, R, ke);
                return z === o ? !0 : z === i ? !1 : !!(P.hasOwnProperty(S.type) && P[S.type](S, X, p, te) || f.call(X, S, R, ke) === o);
            }
            let m = it, f = it, P = r, te = (S, R, ke, z)=>S || p(R, ke, z), X = {
                break: o,
                skip: i,
                root: a,
                stylesheet: null,
                atrule: null,
                atrulePrelude: null,
                rule: null,
                selector: null,
                block: null,
                declaration: null,
                function: null
            };
            if (typeof l == "function") m = l;
            else if (l && (m = Ci(l.enter), f = Ci(l.leave), l.reverse && (P = n), l.visit)) {
                if (s.hasOwnProperty(l.visit)) P = l.reverse ? u[l.visit] : s[l.visit];
                else if (!t.hasOwnProperty(l.visit)) throw new Error("Bad value `" + l.visit + "` for `visit` option (should be: " + Object.keys(t).sort().join(", ") + ")");
                m = Ai(m, l.visit), f = Ai(f, l.visit);
            }
            if (m === it && f === it) throw new Error("Neither `enter` nor `leave` walker handler is set or both aren't a function");
            p(a);
        };
        return c.break = o, c.skip = i, c.find = function(a, l) {
            let p = null;
            return c(a, function(m, f, P) {
                if (l.call(this, m, f, P)) return p = m, o;
            }), p;
        }, c.findLast = function(a, l) {
            let p = null;
            return c(a, {
                reverse: !0,
                enter (m, f, P) {
                    if (l.call(this, m, f, P)) return p = m, o;
                }
            }), p;
        }, c.findAll = function(a, l) {
            let p = [];
            return c(a, function(m, f, P) {
                l.call(this, m, f, P) && p.push(m);
            }), p;
        }, c;
    }
    function Vs(e) {
        return e;
    }
    function Ks(e) {
        let { min: t, max: r, comma: n } = e;
        return t === 0 && r === 0 ? n ? "#?" : "*" : t === 0 && r === 1 ? "?" : t === 1 && r === 0 ? n ? "#" : "+" : t === 1 && r === 1 ? "" : (n ? "#" : "") + (t === r ? "{" + t + "}" : "{" + t + "," + (r !== 0 ? r : "") + "}");
    }
    function Qs(e) {
        switch(e.type){
            case "Range":
                return " [" + (e.min === null ? "-\u221E" : e.min) + "," + (e.max === null ? "\u221E" : e.max) + "]";
            default:
                throw new Error("Unknown node type `" + e.type + "`");
        }
    }
    function Xs(e, t, r, n) {
        let o = e.combinator === " " || n ? e.combinator : " " + e.combinator + " ", i = e.terms.map((s)=>yr(s, t, r, n)).join(o);
        return e.explicit || r ? (n || i[0] === "," ? "[" : "[ ") + i + (n ? "]" : " ]") : i;
    }
    function yr(e, t, r, n) {
        let o;
        switch(e.type){
            case "Group":
                o = Xs(e, t, r, n) + (e.disallowEmpty ? "!" : "");
                break;
            case "Multiplier":
                return yr(e.term, t, r, n) + t(Ks(e), e);
            case "Type":
                o = "<" + e.name + (e.opts ? t(Qs(e.opts), e.opts) : "") + ">";
                break;
            case "Property":
                o = "<'" + e.name + "'>";
                break;
            case "Keyword":
                o = e.name;
                break;
            case "AtKeyword":
                o = "@" + e.name;
                break;
            case "Function":
                o = e.name + "(";
                break;
            case "String":
            case "Token":
                o = e.value;
                break;
            case "Comma":
                o = ",";
                break;
            default:
                throw new Error("Unknown node type `" + e.type + "`");
        }
        return t(o, e);
    }
    function Pe(e, t) {
        let r = Vs, n = !1, o = !1;
        return typeof t == "function" ? r = t : t && (n = Boolean(t.forceBraces), o = Boolean(t.compact), typeof t.decorate == "function" && (r = t.decorate)), yr(e, r, n, o);
    }
    var Pi = {
        offset: 0,
        line: 1,
        column: 1
    };
    function $s(e, t) {
        let r = e.tokens, n = e.longestMatch, o = n < r.length && r[n].node || null, i = o !== t ? o : null, s = 0, u = 0, c = 0, a = "", l, p;
        for(let m = 0; m < r.length; m++){
            let f = r[m].value;
            m === n && (u = f.length, s = a.length), i !== null && r[m].node === i && (m <= n ? c++ : c = 0), a += f;
        }
        return n === r.length || c > 1 ? (l = Dt(i || t, "end") || at(Pi, a), p = at(l)) : (l = Dt(i, "start") || at(Dt(t, "start") || Pi, a.slice(0, s)), p = Dt(i, "end") || at(l, a.substr(s, u))), {
            css: a,
            mismatchOffset: s,
            mismatchLength: u,
            start: l,
            end: p
        };
    }
    function Dt(e, t) {
        let r = e && e.loc && e.loc[t];
        return r ? "line" in r ? at(r) : r : null;
    }
    function at({ offset: e, line: t, column: r }, n) {
        let o = {
            offset: e,
            line: t,
            column: r
        };
        if (n) {
            let i = n.split(/\n|\r\n?|\f/);
            o.offset += n.length, o.line += i.length - 1, o.column = i.length === 1 ? o.column + n.length : i.pop().length + 1;
        }
        return o;
    }
    var Ue = function(e, t) {
        let r = Ee("SyntaxReferenceError", e + (t ? " `" + t + "`" : ""));
        return r.reference = t, r;
    }, Ii = function(e, t, r, n) {
        let o = Ee("SyntaxMatchError", e), { css: i, mismatchOffset: s, mismatchLength: u, start: c, end: a } = $s(n, r);
        return o.rawMessage = e, o.syntax = t ? Pe(t) : "<generic>", o.css = i, o.mismatchOffset = s, o.mismatchLength = u, o.message = e + `
  syntax: ` + o.syntax + `
   value: ` + (i || "<empty string>") + `
  --------` + new Array(o.mismatchOffset + 1).join("-") + "^", Object.assign(o, c), o.loc = {
            source: r && r.loc && r.loc.source || "<unknown>",
            start: c,
            end: a
        }, o;
    };
    var Ot = new Map, je = new Map, Nt = 45, zt = Zs, kr = Js;
    function Mt(e, t) {
        return t = t || 0, e.length - t >= 2 && e.charCodeAt(t) === Nt && e.charCodeAt(t + 1) === Nt;
    }
    function wr(e, t) {
        if (t = t || 0, e.length - t >= 3 && e.charCodeAt(t) === Nt && e.charCodeAt(t + 1) !== Nt) {
            let r = e.indexOf("-", t + 2);
            if (r !== -1) return e.substring(t, r + 1);
        }
        return "";
    }
    function Zs(e) {
        if (Ot.has(e)) return Ot.get(e);
        let t = e.toLowerCase(), r = Ot.get(t);
        if (r === void 0) {
            let n = Mt(t, 0), o = n ? "" : wr(t, 0);
            r = Object.freeze({
                basename: t.substr(o.length),
                name: t,
                prefix: o,
                vendor: o,
                custom: n
            });
        }
        return Ot.set(e, r), r;
    }
    function Js(e) {
        if (je.has(e)) return je.get(e);
        let t = e, r = e[0];
        r === "/" ? r = e[1] === "/" ? "//" : "/" : r !== "_" && r !== "*" && r !== "$" && r !== "#" && r !== "+" && r !== "&" && (r = "");
        let n = Mt(t, r.length);
        if (!n && (t = t.toLowerCase(), je.has(t))) {
            let u = je.get(t);
            return je.set(e, u), u;
        }
        let o = n ? "" : wr(t, r.length), i = t.substr(0, r.length + o.length), s = Object.freeze({
            basename: t.substr(i.length),
            name: t.substr(r.length),
            hack: r,
            vendor: o,
            prefix: i,
            custom: n
        });
        return je.set(e, s), s;
    }
    var Rt = [
        "initial",
        "inherit",
        "unset",
        "revert",
        "revert-layer"
    ];
    var lt = 43, he = 45, vr = 110, We = !0, tl = !1;
    function Cr(e, t) {
        return e !== null && e.type === 9 && e.value.charCodeAt(0) === t;
    }
    function st(e, t, r) {
        for(; e !== null && (e.type === 13 || e.type === 25);)e = r(++t);
        return t;
    }
    function Se(e, t, r, n) {
        if (!e) return 0;
        let o = e.value.charCodeAt(t);
        if (o === lt || o === he) {
            if (r) return 0;
            t++;
        }
        for(; t < e.value.length; t++)if (!B(e.value.charCodeAt(t))) return 0;
        return n + 1;
    }
    function Sr(e, t, r) {
        let n = !1, o = st(e, t, r);
        if (e = r(o), e === null) return t;
        if (e.type !== 10) {
            if (Cr(e, lt) || Cr(e, he)) {
                if (n = !0, o = st(r(++o), o, r), e = r(o), e === null || e.type !== 10) return 0;
            } else return t;
        }
        if (!n) {
            let i = e.value.charCodeAt(0);
            if (i !== lt && i !== he) return 0;
        }
        return Se(e, n ? 0 : 1, n, o);
    }
    function Ar(e, t) {
        let r = 0;
        if (!e) return 0;
        if (e.type === 10) return Se(e, 0, tl, r);
        if (e.type === 1 && e.value.charCodeAt(0) === he) {
            if (!de(e.value, 1, vr)) return 0;
            switch(e.value.length){
                case 2:
                    return Sr(t(++r), r, t);
                case 3:
                    return e.value.charCodeAt(2) !== he ? 0 : (r = st(t(++r), r, t), e = t(r), Se(e, 0, We, r));
                default:
                    return e.value.charCodeAt(2) !== he ? 0 : Se(e, 3, We, r);
            }
        } else if (e.type === 1 || Cr(e, lt) && t(r + 1).type === 1) {
            if (e.type !== 1 && (e = t(++r)), e === null || !de(e.value, 0, vr)) return 0;
            switch(e.value.length){
                case 1:
                    return Sr(t(++r), r, t);
                case 2:
                    return e.value.charCodeAt(1) !== he ? 0 : (r = st(t(++r), r, t), e = t(r), Se(e, 0, We, r));
                default:
                    return e.value.charCodeAt(1) !== he ? 0 : Se(e, 2, We, r);
            }
        } else if (e.type === 12) {
            let n = e.value.charCodeAt(0), o = n === lt || n === he ? 1 : 0, i = o;
            for(; i < e.value.length && B(e.value.charCodeAt(i)); i++);
            return i === o || !de(e.value, i, vr) ? 0 : i + 1 === e.value.length ? Sr(t(++r), r, t) : e.value.charCodeAt(i + 1) !== he ? 0 : i + 2 === e.value.length ? (r = st(t(++r), r, t), e = t(r), Se(e, 0, We, r)) : Se(e, i + 2, We, r);
        }
        return 0;
    }
    var rl = 43, Di = 45, Oi = 63, nl = 117;
    function Tr(e, t) {
        return e !== null && e.type === 9 && e.value.charCodeAt(0) === t;
    }
    function ol(e, t) {
        return e.value.charCodeAt(0) === t;
    }
    function ct(e, t, r) {
        let n = 0;
        for(let o = t; o < e.value.length; o++){
            let i = e.value.charCodeAt(o);
            if (i === Di && r && n !== 0) return ct(e, t + n + 1, !1), 6;
            if (!ee(i) || ++n > 6) return 0;
        }
        return n;
    }
    function Ft(e, t, r) {
        if (!e) return 0;
        for(; Tr(r(t), Oi);){
            if (++e > 6) return 0;
            t++;
        }
        return t;
    }
    function Er(e, t) {
        let r = 0;
        if (e === null || e.type !== 1 || !de(e.value, 0, nl) || (e = t(++r), e === null)) return 0;
        if (Tr(e, rl)) return e = t(++r), e === null ? 0 : e.type === 1 ? Ft(ct(e, 0, !0), ++r, t) : Tr(e, Oi) ? Ft(1, ++r, t) : 0;
        if (e.type === 10) {
            let n = ct(e, 1, !0);
            return n === 0 ? 0 : (e = t(++r), e === null ? r : e.type === 12 || e.type === 10 ? !ol(e, Di) || !ct(e, 1, !1) ? 0 : r + 1 : Ft(n, r, t));
        }
        return e.type === 12 ? Ft(ct(e, 1, !0), ++r, t) : 0;
    }
    var il = [
        "calc(",
        "-moz-calc(",
        "-webkit-calc("
    ], Lr = new Map([
        [
            2,
            22
        ],
        [
            21,
            22
        ],
        [
            19,
            20
        ],
        [
            23,
            24
        ]
    ]);
    function le(e, t) {
        return t < e.length ? e.charCodeAt(t) : 0;
    }
    function Ni(e, t) {
        return ge(e, 0, e.length, t);
    }
    function zi(e, t) {
        for(let r = 0; r < t.length; r++)if (Ni(e, t[r])) return !0;
        return !1;
    }
    function Mi(e, t) {
        return t !== e.length - 2 ? !1 : le(e, t) === 92 && B(le(e, t + 1));
    }
    function Bt(e, t, r) {
        if (e && e.type === "Range") {
            let n = Number(r !== void 0 && r !== t.length ? t.substr(0, r) : t);
            if (isNaN(n) || e.min !== null && n < e.min && typeof e.min != "string" || e.max !== null && n > e.max && typeof e.max != "string") return !0;
        }
        return !1;
    }
    function al(e, t) {
        let r = 0, n = [], o = 0;
        e: do {
            switch(e.type){
                case 24:
                case 22:
                case 20:
                    if (e.type !== r) break e;
                    if (r = n.pop(), n.length === 0) {
                        o++;
                        break e;
                    }
                    break;
                case 2:
                case 21:
                case 19:
                case 23:
                    n.push(r), r = Lr.get(e.type);
                    break;
            }
            o++;
        }while (e = t(o));
        return o;
    }
    function ie(e) {
        return function(t, r, n) {
            return t === null ? 0 : t.type === 2 && zi(t.value, il) ? al(t, r) : e(t, r, n);
        };
    }
    function N(e) {
        return function(t) {
            return t === null || t.type !== e ? 0 : 1;
        };
    }
    function sl(e) {
        if (e === null || e.type !== 1) return 0;
        let t = e.value.toLowerCase();
        return zi(t, Rt) || Ni(t, "default") ? 0 : 1;
    }
    function ll(e) {
        return e === null || e.type !== 1 || le(e.value, 0) !== 45 || le(e.value, 1) !== 45 ? 0 : 1;
    }
    function cl(e) {
        if (e === null || e.type !== 4) return 0;
        let t = e.value.length;
        if (t !== 4 && t !== 5 && t !== 7 && t !== 9) return 0;
        for(let r = 1; r < t; r++)if (!ee(le(e.value, r))) return 0;
        return 1;
    }
    function ul(e) {
        return e === null || e.type !== 4 || !ze(le(e.value, 1), le(e.value, 2), le(e.value, 3)) ? 0 : 1;
    }
    function pl(e, t) {
        if (!e) return 0;
        let r = 0, n = [], o = 0;
        e: do {
            switch(e.type){
                case 6:
                case 8:
                    break e;
                case 24:
                case 22:
                case 20:
                    if (e.type !== r) break e;
                    r = n.pop();
                    break;
                case 17:
                    if (r === 0) break e;
                    break;
                case 9:
                    if (r === 0 && e.value === "!") break e;
                    break;
                case 2:
                case 21:
                case 19:
                case 23:
                    n.push(r), r = Lr.get(e.type);
                    break;
            }
            o++;
        }while (e = t(o));
        return o;
    }
    function hl(e, t) {
        if (!e) return 0;
        let r = 0, n = [], o = 0;
        e: do {
            switch(e.type){
                case 6:
                case 8:
                    break e;
                case 24:
                case 22:
                case 20:
                    if (e.type !== r) break e;
                    r = n.pop();
                    break;
                case 2:
                case 21:
                case 19:
                case 23:
                    n.push(r), r = Lr.get(e.type);
                    break;
            }
            o++;
        }while (e = t(o));
        return o;
    }
    function ye(e) {
        return e && (e = new Set(e)), function(t, r, n) {
            if (t === null || t.type !== 12) return 0;
            let o = Te(t.value, 0);
            if (e !== null) {
                let i = t.value.indexOf("\\", o), s = i === -1 || !Mi(t.value, i) ? t.value.substr(o) : t.value.substring(o, i);
                if (e.has(s.toLowerCase()) === !1) return 0;
            }
            return Bt(n, t.value, o) ? 0 : 1;
        };
    }
    function ml(e, t, r) {
        return e === null || e.type !== 11 || Bt(r, e.value, e.value.length - 1) ? 0 : 1;
    }
    function Ri(e) {
        return typeof e != "function" && (e = function() {
            return 0;
        }), function(t, r, n) {
            return t !== null && t.type === 10 && Number(t.value) === 0 ? 1 : e(t, r, n);
        };
    }
    function fl(e, t, r) {
        if (e === null) return 0;
        let n = Te(e.value, 0);
        return !(n === e.value.length) && !Mi(e.value, n) || Bt(r, e.value, n) ? 0 : 1;
    }
    function dl(e, t, r) {
        if (e === null || e.type !== 10) return 0;
        let n = le(e.value, 0) === 43 || le(e.value, 0) === 45 ? 1 : 0;
        for(; n < e.value.length; n++)if (!B(le(e.value, n))) return 0;
        return Bt(r, e.value, n) ? 0 : 1;
    }
    var gl = {
        "ident-token": N(1),
        "function-token": N(2),
        "at-keyword-token": N(3),
        "hash-token": N(4),
        "string-token": N(5),
        "bad-string-token": N(6),
        "url-token": N(7),
        "bad-url-token": N(8),
        "delim-token": N(9),
        "number-token": N(10),
        "percentage-token": N(11),
        "dimension-token": N(12),
        "whitespace-token": N(13),
        "CDO-token": N(14),
        "CDC-token": N(15),
        "colon-token": N(16),
        "semicolon-token": N(17),
        "comma-token": N(18),
        "[-token": N(19),
        "]-token": N(20),
        "(-token": N(21),
        ")-token": N(22),
        "{-token": N(23),
        "}-token": N(24)
    }, bl = {
        string: N(5),
        ident: N(1),
        percentage: ie(ml),
        zero: Ri(),
        number: ie(fl),
        integer: ie(dl),
        "custom-ident": sl,
        "custom-property-name": ll,
        "hex-color": cl,
        "id-selector": ul,
        "an-plus-b": Ar,
        urange: Er,
        "declaration-value": pl,
        "any-value": hl
    };
    function xl(e) {
        let { angle: t, decibel: r, frequency: n, flex: o, length: i, resolution: s, semitones: u, time: c } = e || {};
        return {
            dimension: ie(ye(null)),
            angle: ie(ye(t)),
            decibel: ie(ye(r)),
            frequency: ie(ye(n)),
            flex: ie(ye(o)),
            length: ie(Ri(ye(i))),
            resolution: ie(ye(s)),
            semitones: ie(ye(u)),
            time: ie(ye(c))
        };
    }
    function Fi(e) {
        return {
            ...gl,
            ...bl,
            ...xl(e)
        };
    }
    var _t = {};
    b(_t, {
        angle: ()=>kl,
        decibel: ()=>Al,
        flex: ()=>Cl,
        frequency: ()=>vl,
        length: ()=>yl,
        resolution: ()=>Sl,
        semitones: ()=>Tl,
        time: ()=>wl
    });
    var yl = [
        "cm",
        "mm",
        "q",
        "in",
        "pt",
        "pc",
        "px",
        "em",
        "rem",
        "ex",
        "rex",
        "cap",
        "rcap",
        "ch",
        "rch",
        "ic",
        "ric",
        "lh",
        "rlh",
        "vw",
        "svw",
        "lvw",
        "dvw",
        "vh",
        "svh",
        "lvh",
        "dvh",
        "vi",
        "svi",
        "lvi",
        "dvi",
        "vb",
        "svb",
        "lvb",
        "dvb",
        "vmin",
        "svmin",
        "lvmin",
        "dvmin",
        "vmax",
        "svmax",
        "lvmax",
        "dvmax",
        "cqw",
        "cqh",
        "cqi",
        "cqb",
        "cqmin",
        "cqmax"
    ], kl = [
        "deg",
        "grad",
        "rad",
        "turn"
    ], wl = [
        "s",
        "ms"
    ], vl = [
        "hz",
        "khz"
    ], Sl = [
        "dpi",
        "dpcm",
        "dppx",
        "x"
    ], Cl = [
        "fr"
    ], Al = [
        "db"
    ], Tl = [
        "st"
    ];
    var $i = {};
    b($i, {
        SyntaxError: ()=>qt,
        generate: ()=>Pe,
        parse: ()=>Ge,
        walk: ()=>Vt
    });
    function qt(e, t, r) {
        return Object.assign(Ee("SyntaxError", e), {
            input: t,
            offset: r,
            rawMessage: e,
            message: e + `
  ` + t + `
--` + new Array((r || t.length) + 1).join("-") + "^"
        });
    }
    var El = 9, Ll = 10, Pl = 12, Il = 13, Dl = 32, Ut = class {
        constructor(t){
            this.str = t, this.pos = 0;
        }
        charCodeAt(t) {
            return t < this.str.length ? this.str.charCodeAt(t) : 0;
        }
        charCode() {
            return this.charCodeAt(this.pos);
        }
        nextCharCode() {
            return this.charCodeAt(this.pos + 1);
        }
        nextNonWsCode(t) {
            return this.charCodeAt(this.findWsEnd(t));
        }
        findWsEnd(t) {
            for(; t < this.str.length; t++){
                let r = this.str.charCodeAt(t);
                if (r !== Il && r !== Ll && r !== Pl && r !== Dl && r !== El) break;
            }
            return t;
        }
        substringToPos(t) {
            return this.str.substring(this.pos, this.pos = t);
        }
        eat(t) {
            this.charCode() !== t && this.error("Expect `" + String.fromCharCode(t) + "`"), this.pos++;
        }
        peek() {
            return this.pos < this.str.length ? this.str.charAt(this.pos++) : "";
        }
        error(t) {
            throw new qt(t, this.str, this.pos);
        }
    };
    var Ol = 9, Nl = 10, zl = 12, Ml = 13, Rl = 32, Yi = 33, Dr = 35, Bi = 38, jt = 39, Gi = 40, Fl = 41, Vi = 42, Or = 43, Nr = 44, _i = 45, zr = 60, Ki = 62, Ir = 63, Bl = 64, Gt = 91, Mr = 93, Wt = 123, qi = 124, Ui = 125, ji = 8734, ut = new Uint8Array(128).map((e, t)=>/[a-zA-Z0-9\-]/.test(String.fromCharCode(t)) ? 1 : 0), Wi = {
        " ": 1,
        "&&": 2,
        "||": 3,
        "|": 4
    };
    function Ht(e) {
        return e.substringToPos(e.findWsEnd(e.pos));
    }
    function He(e) {
        let t = e.pos;
        for(; t < e.str.length; t++){
            let r = e.str.charCodeAt(t);
            if (r >= 128 || ut[r] === 0) break;
        }
        return e.pos === t && e.error("Expect a keyword"), e.substringToPos(t);
    }
    function Yt(e) {
        let t = e.pos;
        for(; t < e.str.length; t++){
            let r = e.str.charCodeAt(t);
            if (r < 48 || r > 57) break;
        }
        return e.pos === t && e.error("Expect a number"), e.substringToPos(t);
    }
    function _l(e) {
        let t = e.str.indexOf("'", e.pos + 1);
        return t === -1 && (e.pos = e.str.length, e.error("Expect an apostrophe")), e.substringToPos(t + 1);
    }
    function Hi(e) {
        let t = null, r = null;
        return e.eat(Wt), t = Yt(e), e.charCode() === Nr ? (e.pos++, e.charCode() !== Ui && (r = Yt(e))) : r = t, e.eat(Ui), {
            min: Number(t),
            max: r ? Number(r) : 0
        };
    }
    function ql(e) {
        let t = null, r = !1;
        switch(e.charCode()){
            case Vi:
                e.pos++, t = {
                    min: 0,
                    max: 0
                };
                break;
            case Or:
                e.pos++, t = {
                    min: 1,
                    max: 0
                };
                break;
            case Ir:
                e.pos++, t = {
                    min: 0,
                    max: 1
                };
                break;
            case Dr:
                e.pos++, r = !0, e.charCode() === Wt ? t = Hi(e) : e.charCode() === Ir ? (e.pos++, t = {
                    min: 0,
                    max: 0
                }) : t = {
                    min: 1,
                    max: 0
                };
                break;
            case Wt:
                t = Hi(e);
                break;
            default:
                return null;
        }
        return {
            type: "Multiplier",
            comma: r,
            min: t.min,
            max: t.max,
            term: null
        };
    }
    function Ye(e, t) {
        let r = ql(e);
        return r !== null ? (r.term = t, e.charCode() === Dr && e.charCodeAt(e.pos - 1) === Or ? Ye(e, r) : r) : t;
    }
    function Pr(e) {
        let t = e.peek();
        return t === "" ? null : {
            type: "Token",
            value: t
        };
    }
    function Ul(e) {
        let t;
        return e.eat(zr), e.eat(jt), t = He(e), e.eat(jt), e.eat(Ki), Ye(e, {
            type: "Property",
            name: t
        });
    }
    function jl(e) {
        let t = null, r = null, n = 1;
        return e.eat(Gt), e.charCode() === _i && (e.peek(), n = -1), n == -1 && e.charCode() === ji ? e.peek() : (t = n * Number(Yt(e)), ut[e.charCode()] !== 0 && (t += He(e))), Ht(e), e.eat(Nr), Ht(e), e.charCode() === ji ? e.peek() : (n = 1, e.charCode() === _i && (e.peek(), n = -1), r = n * Number(Yt(e)), ut[e.charCode()] !== 0 && (r += He(e))), e.eat(Mr), {
            type: "Range",
            min: t,
            max: r
        };
    }
    function Wl(e) {
        let t, r = null;
        return e.eat(zr), t = He(e), e.charCode() === Gi && e.nextCharCode() === Fl && (e.pos += 2, t += "()"), e.charCodeAt(e.findWsEnd(e.pos)) === Gt && (Ht(e), r = jl(e)), e.eat(Ki), Ye(e, {
            type: "Type",
            name: t,
            opts: r
        });
    }
    function Hl(e) {
        let t = He(e);
        return e.charCode() === Gi ? (e.pos++, {
            type: "Function",
            name: t
        }) : Ye(e, {
            type: "Keyword",
            name: t
        });
    }
    function Yl(e, t) {
        function r(o, i) {
            return {
                type: "Group",
                terms: o,
                combinator: i,
                disallowEmpty: !1,
                explicit: !1
            };
        }
        let n;
        for(t = Object.keys(t).sort((o, i)=>Wi[o] - Wi[i]); t.length > 0;){
            n = t.shift();
            let o = 0, i = 0;
            for(; o < e.length; o++){
                let s = e[o];
                s.type === "Combinator" && (s.value === n ? (i === -1 && (i = o - 1), e.splice(o, 1), o--) : (i !== -1 && o - i > 1 && (e.splice(i, o - i, r(e.slice(i, o), n)), o = i + 1), i = -1));
            }
            i !== -1 && t.length && e.splice(i, o - i, r(e.slice(i, o), n));
        }
        return n;
    }
    function Qi(e) {
        let t = [], r = {}, n, o = null, i = e.pos;
        for(; n = Vl(e);)n.type !== "Spaces" && (n.type === "Combinator" ? ((o === null || o.type === "Combinator") && (e.pos = i, e.error("Unexpected combinator")), r[n.value] = !0) : o !== null && o.type !== "Combinator" && (r[" "] = !0, t.push({
            type: "Combinator",
            value: " "
        })), t.push(n), o = n, i = e.pos);
        return o !== null && o.type === "Combinator" && (e.pos -= i, e.error("Unexpected combinator")), {
            type: "Group",
            terms: t,
            combinator: Yl(t, r) || " ",
            disallowEmpty: !1,
            explicit: !1
        };
    }
    function Gl(e) {
        let t;
        return e.eat(Gt), t = Qi(e), e.eat(Mr), t.explicit = !0, e.charCode() === Yi && (e.pos++, t.disallowEmpty = !0), t;
    }
    function Vl(e) {
        let t = e.charCode();
        if (t < 128 && ut[t] === 1) return Hl(e);
        switch(t){
            case Mr:
                break;
            case Gt:
                return Ye(e, Gl(e));
            case zr:
                return e.nextCharCode() === jt ? Ul(e) : Wl(e);
            case qi:
                return {
                    type: "Combinator",
                    value: e.substringToPos(e.pos + (e.nextCharCode() === qi ? 2 : 1))
                };
            case Bi:
                return e.pos++, e.eat(Bi), {
                    type: "Combinator",
                    value: "&&"
                };
            case Nr:
                return e.pos++, {
                    type: "Comma"
                };
            case jt:
                return Ye(e, {
                    type: "String",
                    value: _l(e)
                });
            case Rl:
            case Ol:
            case Nl:
            case Ml:
            case zl:
                return {
                    type: "Spaces",
                    value: Ht(e)
                };
            case Bl:
                return t = e.nextCharCode(), t < 128 && ut[t] === 1 ? (e.pos++, {
                    type: "AtKeyword",
                    name: He(e)
                }) : Pr(e);
            case Vi:
            case Or:
            case Ir:
            case Dr:
            case Yi:
                break;
            case Wt:
                if (t = e.nextCharCode(), t < 48 || t > 57) return Pr(e);
                break;
            default:
                return Pr(e);
        }
    }
    function Ge(e) {
        let t = new Ut(e), r = Qi(t);
        return t.pos !== e.length && t.error("Unexpected input"), r.terms.length === 1 && r.terms[0].type === "Group" ? r.terms[0] : r;
    }
    var pt = function() {};
    function Xi(e) {
        return typeof e == "function" ? e : pt;
    }
    function Vt(e, t, r) {
        function n(s) {
            switch(o.call(r, s), s.type){
                case "Group":
                    s.terms.forEach(n);
                    break;
                case "Multiplier":
                    n(s.term);
                    break;
                case "Type":
                case "Property":
                case "Keyword":
                case "AtKeyword":
                case "Function":
                case "String":
                case "Token":
                case "Comma":
                    break;
                default:
                    throw new Error("Unknown type: " + s.type);
            }
            i.call(r, s);
        }
        let o = pt, i = pt;
        if (typeof t == "function" ? o = t : t && (o = Xi(t.enter), i = Xi(t.leave)), o === pt && i === pt) throw new Error("Neither `enter` nor `leave` walker handler is set or both aren't a function");
        n(e);
    }
    var Kl = {
        decorator (e) {
            let t = [], r = null;
            return {
                ...e,
                node (n) {
                    let o = r;
                    r = n, e.node.call(this, n), r = o;
                },
                emit (n, o, i) {
                    t.push({
                        type: o,
                        value: n,
                        node: i ? null : r
                    });
                },
                result () {
                    return t;
                }
            };
        }
    };
    function Ql(e) {
        let t = [];
        return ve(e, (r, n, o)=>t.push({
                type: r,
                value: e.slice(n, o),
                node: null
            })), t;
    }
    function Zi(e, t) {
        return typeof e == "string" ? Ql(e) : t.generate(e, Kl);
    }
    var C = {
        type: "Match"
    }, L = {
        type: "Mismatch"
    }, Kt = {
        type: "DisallowEmpty"
    }, Xl = 40, $l = 41;
    function Z(e, t, r) {
        return t === C && r === L || e === C && t === C && r === C ? e : (e.type === "If" && e.else === L && t === C && (t = e.then, e = e.match), {
            type: "If",
            match: e,
            then: t,
            else: r
        });
    }
    function ea(e) {
        return e.length > 2 && e.charCodeAt(e.length - 2) === Xl && e.charCodeAt(e.length - 1) === $l;
    }
    function Ji(e) {
        return e.type === "Keyword" || e.type === "AtKeyword" || e.type === "Function" || e.type === "Type" && ea(e.name);
    }
    function Rr(e, t, r) {
        switch(e){
            case " ":
                {
                    let n = C;
                    for(let o = t.length - 1; o >= 0; o--){
                        let i = t[o];
                        n = Z(i, n, L);
                    }
                    return n;
                }
            case "|":
                {
                    let n = L, o = null;
                    for(let i = t.length - 1; i >= 0; i--){
                        let s = t[i];
                        if (Ji(s) && (o === null && i > 0 && Ji(t[i - 1]) && (o = Object.create(null), n = Z({
                            type: "Enum",
                            map: o
                        }, C, n)), o !== null)) {
                            let u = (ea(s.name) ? s.name.slice(0, -1) : s.name).toLowerCase();
                            if (!(u in o)) {
                                o[u] = s;
                                continue;
                            }
                        }
                        o = null, n = Z(s, C, n);
                    }
                    return n;
                }
            case "&&":
                {
                    if (t.length > 5) return {
                        type: "MatchOnce",
                        terms: t,
                        all: !0
                    };
                    let n = L;
                    for(let o = t.length - 1; o >= 0; o--){
                        let i = t[o], s;
                        t.length > 1 ? s = Rr(e, t.filter(function(u) {
                            return u !== i;
                        }), !1) : s = C, n = Z(i, s, n);
                    }
                    return n;
                }
            case "||":
                {
                    if (t.length > 5) return {
                        type: "MatchOnce",
                        terms: t,
                        all: !1
                    };
                    let n = r ? C : L;
                    for(let o = t.length - 1; o >= 0; o--){
                        let i = t[o], s;
                        t.length > 1 ? s = Rr(e, t.filter(function(u) {
                            return u !== i;
                        }), !0) : s = C, n = Z(i, s, n);
                    }
                    return n;
                }
        }
    }
    function Zl(e) {
        let t = C, r = Fr(e.term);
        if (e.max === 0) r = Z(r, Kt, L), t = Z(r, null, L), t.then = Z(C, C, t), e.comma && (t.then.else = Z({
            type: "Comma",
            syntax: e
        }, t, L));
        else for(let n = e.min || 1; n <= e.max; n++)e.comma && t !== C && (t = Z({
            type: "Comma",
            syntax: e
        }, t, L)), t = Z(r, Z(C, C, t), L);
        if (e.min === 0) t = Z(C, C, t);
        else for(let n = 0; n < e.min - 1; n++)e.comma && t !== C && (t = Z({
            type: "Comma",
            syntax: e
        }, t, L)), t = Z(r, t, L);
        return t;
    }
    function Fr(e) {
        if (typeof e == "function") return {
            type: "Generic",
            fn: e
        };
        switch(e.type){
            case "Group":
                {
                    let t = Rr(e.combinator, e.terms.map(Fr), !1);
                    return e.disallowEmpty && (t = Z(t, Kt, L)), t;
                }
            case "Multiplier":
                return Zl(e);
            case "Type":
            case "Property":
                return {
                    type: e.type,
                    name: e.name,
                    syntax: e
                };
            case "Keyword":
                return {
                    type: e.type,
                    name: e.name.toLowerCase(),
                    syntax: e
                };
            case "AtKeyword":
                return {
                    type: e.type,
                    name: "@" + e.name.toLowerCase(),
                    syntax: e
                };
            case "Function":
                return {
                    type: e.type,
                    name: e.name.toLowerCase() + "(",
                    syntax: e
                };
            case "String":
                return e.value.length === 3 ? {
                    type: "Token",
                    value: e.value.charAt(1),
                    syntax: e
                } : {
                    type: e.type,
                    value: e.value.substr(1, e.value.length - 2).replace(/\\'/g, "'"),
                    syntax: e
                };
            case "Token":
                return {
                    type: e.type,
                    value: e.value,
                    syntax: e
                };
            case "Comma":
                return {
                    type: e.type,
                    syntax: e
                };
            default:
                throw new Error("Unknown node type:", e.type);
        }
    }
    function Qt(e, t) {
        return typeof e == "string" && (e = Ge(e)), {
            type: "MatchGraph",
            match: Fr(e),
            syntax: t || null,
            source: e
        };
    }
    var { hasOwnProperty: ta } = Object.prototype, Jl = 0, ec = 1, _r = 2, aa = 3, ra = "Match", tc = "Mismatch", rc = "Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)", na = 15e3;
    function oc(e) {
        let t = null, r = null, n = e;
        for(; n !== null;)r = n.prev, n.prev = t, t = n, n = r;
        return t;
    }
    function Br(e, t) {
        if (e.length !== t.length) return !1;
        for(let r = 0; r < e.length; r++){
            let n = t.charCodeAt(r), o = e.charCodeAt(r);
            if (o >= 65 && o <= 90 && (o = o | 32), o !== n) return !1;
        }
        return !0;
    }
    function ic(e) {
        return e.type !== 9 ? !1 : e.value !== "?";
    }
    function oa(e) {
        return e === null ? !0 : e.type === 18 || e.type === 2 || e.type === 21 || e.type === 19 || e.type === 23 || ic(e);
    }
    function ia(e) {
        return e === null ? !0 : e.type === 22 || e.type === 20 || e.type === 24 || e.type === 9 && e.value === "/";
    }
    function ac(e, t, r) {
        function n() {
            do R++, S = R < e.length ? e[R] : null;
            while (S !== null && (S.type === 13 || S.type === 25));
        }
        function o(ae) {
            let fe = R + ae;
            return fe < e.length ? e[fe] : null;
        }
        function i(ae, fe) {
            return {
                nextState: ae,
                matchStack: z,
                syntaxStack: p,
                thenStack: m,
                tokenIndex: R,
                prev: fe
            };
        }
        function s(ae) {
            m = {
                nextState: ae,
                matchStack: z,
                syntaxStack: p,
                prev: m
            };
        }
        function u(ae) {
            f = i(ae, f);
        }
        function c() {
            z = {
                type: ec,
                syntax: t.syntax,
                token: S,
                prev: z
            }, n(), P = null, R > ke && (ke = R);
        }
        function a() {
            p = {
                syntax: t.syntax,
                opts: t.syntax.opts || p !== null && p.opts || null,
                prev: p
            }, z = {
                type: _r,
                syntax: t.syntax,
                token: z.token,
                prev: z
            };
        }
        function l() {
            z.type === _r ? z = z.prev : z = {
                type: aa,
                syntax: p.syntax,
                token: z.token,
                prev: z
            }, p = p.prev;
        }
        let p = null, m = null, f = null, P = null, te = 0, X = null, S = null, R = -1, ke = 0, z = {
            type: Jl,
            syntax: null,
            token: null,
            prev: null
        };
        for(n(); X === null && ++te < na;)switch(t.type){
            case "Match":
                if (m === null) {
                    if (S !== null && (R !== e.length - 1 || S.value !== "\\0" && S.value !== "\\9")) {
                        t = L;
                        break;
                    }
                    X = ra;
                    break;
                }
                if (t = m.nextState, t === Kt) {
                    if (m.matchStack === z) {
                        t = L;
                        break;
                    } else t = C;
                }
                for(; m.syntaxStack !== p;)l();
                m = m.prev;
                break;
            case "Mismatch":
                if (P !== null && P !== !1) (f === null || R > f.tokenIndex) && (f = P, P = !1);
                else if (f === null) {
                    X = tc;
                    break;
                }
                t = f.nextState, m = f.thenStack, p = f.syntaxStack, z = f.matchStack, R = f.tokenIndex, S = R < e.length ? e[R] : null, f = f.prev;
                break;
            case "MatchGraph":
                t = t.match;
                break;
            case "If":
                t.else !== L && u(t.else), t.then !== C && s(t.then), t = t.match;
                break;
            case "MatchOnce":
                t = {
                    type: "MatchOnceBuffer",
                    syntax: t,
                    index: 0,
                    mask: 0
                };
                break;
            case "MatchOnceBuffer":
                {
                    let Q = t.syntax.terms;
                    if (t.index === Q.length) {
                        if (t.mask === 0 || t.syntax.all) {
                            t = L;
                            break;
                        }
                        t = C;
                        break;
                    }
                    if (t.mask === (1 << Q.length) - 1) {
                        t = C;
                        break;
                    }
                    for(; t.index < Q.length; t.index++){
                        let J = 1 << t.index;
                        if ((t.mask & J) === 0) {
                            u(t), s({
                                type: "AddMatchOnce",
                                syntax: t.syntax,
                                mask: t.mask | J
                            }), t = Q[t.index++];
                            break;
                        }
                    }
                    break;
                }
            case "AddMatchOnce":
                t = {
                    type: "MatchOnceBuffer",
                    syntax: t.syntax,
                    index: 0,
                    mask: t.mask
                };
                break;
            case "Enum":
                if (S !== null) {
                    let Q = S.value.toLowerCase();
                    if (Q.indexOf("\\") !== -1 && (Q = Q.replace(/\\[09].*$/, "")), ta.call(t.map, Q)) {
                        t = t.map[Q];
                        break;
                    }
                }
                t = L;
                break;
            case "Generic":
                {
                    let Q = p !== null ? p.opts : null, J = R + Math.floor(t.fn(S, o, Q));
                    if (!isNaN(J) && J > R) {
                        for(; R < J;)c();
                        t = C;
                    } else t = L;
                    break;
                }
            case "Type":
            case "Property":
                {
                    let Q = t.type === "Type" ? "types" : "properties", J = ta.call(r, Q) ? r[Q][t.name] : null;
                    if (!J || !J.match) throw new Error("Bad syntax reference: " + (t.type === "Type" ? "<" + t.name + ">" : "<'" + t.name + "'>"));
                    if (P !== !1 && S !== null && t.type === "Type" && (t.name === "custom-ident" && S.type === 1 || t.name === "length" && S.value === "0")) {
                        P === null && (P = i(t, f)), t = L;
                        break;
                    }
                    a(), t = J.match;
                    break;
                }
            case "Keyword":
                {
                    let Q = t.name;
                    if (S !== null) {
                        let J = S.value;
                        if (J.indexOf("\\") !== -1 && (J = J.replace(/\\[09].*$/, "")), Br(J, Q)) {
                            c(), t = C;
                            break;
                        }
                    }
                    t = L;
                    break;
                }
            case "AtKeyword":
            case "Function":
                if (S !== null && Br(S.value, t.name)) {
                    c(), t = C;
                    break;
                }
                t = L;
                break;
            case "Token":
                if (S !== null && S.value === t.value) {
                    c(), t = C;
                    break;
                }
                t = L;
                break;
            case "Comma":
                S !== null && S.type === 18 ? oa(z.token) ? t = L : (c(), t = ia(S) ? L : C) : t = oa(z.token) || ia(S) ? C : L;
                break;
            case "String":
                let ae = "", fe = R;
                for(; fe < e.length && ae.length < t.value.length; fe++)ae += e[fe].value;
                if (Br(ae, t.value)) {
                    for(; R < fe;)c();
                    t = C;
                } else t = L;
                break;
            default:
                throw new Error("Unknown node type: " + t.type);
        }
        switch(X){
            case null:
                console.warn("[csstree-match] BREAK after " + na + " iterations"), X = rc, z = null;
                break;
            case ra:
                for(; p !== null;)l();
                break;
            default:
                z = null;
        }
        return {
            tokens: e,
            reason: X,
            iterations: te,
            match: z,
            longestMatch: ke
        };
    }
    function qr(e, t, r) {
        let n = ac(e, t, r || {});
        if (n.match === null) return n;
        let o = n.match, i = n.match = {
            syntax: t.syntax || null,
            match: []
        }, s = [
            i
        ];
        for(o = oc(o).prev; o !== null;){
            switch(o.type){
                case _r:
                    i.match.push(i = {
                        syntax: o.syntax,
                        match: []
                    }), s.push(i);
                    break;
                case aa:
                    s.pop(), i = s[s.length - 1];
                    break;
                default:
                    i.match.push({
                        syntax: o.syntax || null,
                        token: o.token.value,
                        node: o.token.node
                    });
            }
            o = o.prev;
        }
        return n;
    }
    var jr = {};
    b(jr, {
        getTrace: ()=>sa,
        isKeyword: ()=>cc,
        isProperty: ()=>lc,
        isType: ()=>sc
    });
    function sa(e) {
        function t(o) {
            return o === null ? !1 : o.type === "Type" || o.type === "Property" || o.type === "Keyword";
        }
        function r(o) {
            if (Array.isArray(o.match)) {
                for(let i = 0; i < o.match.length; i++)if (r(o.match[i])) return t(o.syntax) && n.unshift(o.syntax), !0;
            } else if (o.node === e) return n = t(o.syntax) ? [
                o.syntax
            ] : [], !0;
            return !1;
        }
        let n = null;
        return this.matched !== null && r(this.matched), n;
    }
    function sc(e, t) {
        return Ur(this, e, (r)=>r.type === "Type" && r.name === t);
    }
    function lc(e, t) {
        return Ur(this, e, (r)=>r.type === "Property" && r.name === t);
    }
    function cc(e) {
        return Ur(this, e, (t)=>t.type === "Keyword");
    }
    function Ur(e, t, r) {
        let n = sa.call(e, t);
        return n === null ? !1 : n.some(r);
    }
    function la(e) {
        return "node" in e ? e.node : la(e.match[0]);
    }
    function ca(e) {
        return "node" in e ? e.node : ca(e.match[e.match.length - 1]);
    }
    function Wr(e, t, r, n, o) {
        function i(u) {
            if (u.syntax !== null && u.syntax.type === n && u.syntax.name === o) {
                let c = la(u), a = ca(u);
                e.syntax.walk(t, function(l, p, m) {
                    if (l === c) {
                        let f = new D;
                        do {
                            if (f.appendData(p.data), p.data === a) break;
                            p = p.next;
                        }while (p !== null);
                        s.push({
                            parent: m,
                            nodes: f
                        });
                    }
                });
            }
            Array.isArray(u.match) && u.match.forEach(i);
        }
        let s = [];
        return r.matched !== null && i(r.matched), s;
    }
    var { hasOwnProperty: ht } = Object.prototype;
    function Hr(e) {
        return typeof e == "number" && isFinite(e) && Math.floor(e) === e && e >= 0;
    }
    function ua(e) {
        return Boolean(e) && Hr(e.offset) && Hr(e.line) && Hr(e.column);
    }
    function uc(e, t) {
        return function(n, o) {
            if (!n || n.constructor !== Object) return o(n, "Type of node should be an Object");
            for(let i in n){
                let s = !0;
                if (ht.call(n, i) !== !1) {
                    if (i === "type") n.type !== e && o(n, "Wrong node type `" + n.type + "`, expected `" + e + "`");
                    else if (i === "loc") {
                        if (n.loc === null) continue;
                        if (n.loc && n.loc.constructor === Object) {
                            if (typeof n.loc.source != "string") i += ".source";
                            else if (!ua(n.loc.start)) i += ".start";
                            else if (!ua(n.loc.end)) i += ".end";
                            else continue;
                        }
                        s = !1;
                    } else if (t.hasOwnProperty(i)) {
                        s = !1;
                        for(let u = 0; !s && u < t[i].length; u++){
                            let c = t[i][u];
                            switch(c){
                                case String:
                                    s = typeof n[i] == "string";
                                    break;
                                case Boolean:
                                    s = typeof n[i] == "boolean";
                                    break;
                                case null:
                                    s = n[i] === null;
                                    break;
                                default:
                                    typeof c == "string" ? s = n[i] && n[i].type === c : Array.isArray(c) && (s = n[i] instanceof D);
                            }
                        }
                    } else o(n, "Unknown field `" + i + "` for " + e + " node type");
                    s || o(n, "Bad value for `" + e + "." + i + "`");
                }
            }
            for(let i in t)ht.call(t, i) && ht.call(n, i) === !1 && o(n, "Field `" + e + "." + i + "` is missed");
        };
    }
    function pc(e, t) {
        let r = t.structure, n = {
            type: String,
            loc: !0
        }, o = {
            type: '"' + e + '"'
        };
        for(let i in r){
            if (ht.call(r, i) === !1) continue;
            let s = [], u = n[i] = Array.isArray(r[i]) ? r[i].slice() : [
                r[i]
            ];
            for(let c = 0; c < u.length; c++){
                let a = u[c];
                if (a === String || a === Boolean) s.push(a.name);
                else if (a === null) s.push("null");
                else if (typeof a == "string") s.push("<" + a + ">");
                else if (Array.isArray(a)) s.push("List");
                else throw new Error("Wrong value `" + a + "` in `" + e + "." + i + "` structure definition");
            }
            o[i] = s.join(" | ");
        }
        return {
            docs: o,
            check: uc(e, n)
        };
    }
    function pa(e) {
        let t = {};
        if (e.node) {
            for(let r in e.node)if (ht.call(e.node, r)) {
                let n = e.node[r];
                if (n.structure) t[r] = pc(r, n);
                else throw new Error("Missed `structure` field in `" + r + "` node type definition");
            }
        }
        return t;
    }
    var hc = Qt(Rt.join(" | "));
    function Yr(e, t, r) {
        let n = {};
        for(let o in e)e[o].syntax && (n[o] = r ? e[o].syntax : Pe(e[o].syntax, {
            compact: t
        }));
        return n;
    }
    function mc(e, t, r) {
        let n = {};
        for (let [o, i] of Object.entries(e))n[o] = {
            prelude: i.prelude && (r ? i.prelude.syntax : Pe(i.prelude.syntax, {
                compact: t
            })),
            descriptors: i.descriptors && Yr(i.descriptors, t, r)
        };
        return n;
    }
    function fc(e) {
        for(let t = 0; t < e.length; t++)if (e[t].value.toLowerCase() === "var(") return !0;
        return !1;
    }
    function ce(e, t, r) {
        return {
            matched: e,
            iterations: r,
            error: t,
            ...jr
        };
    }
    function Ve(e, t, r, n) {
        let o = Zi(r, e.syntax), i;
        return fc(o) ? ce(null, new Error("Matching for a tree with var() is not supported")) : (n && (i = qr(o, e.cssWideKeywordsSyntax, e)), (!n || !i.match) && (i = qr(o, t.match, e), !i.match) ? ce(null, new Ii(i.reason, t.syntax, r, i), i.iterations) : ce(i.match, null, i.iterations));
    }
    var Ke = class {
        constructor(t, r, n){
            if (this.cssWideKeywordsSyntax = hc, this.syntax = r, this.generic = !1, this.units = {
                ..._t
            }, this.atrules = Object.create(null), this.properties = Object.create(null), this.types = Object.create(null), this.structure = n || pa(t), t) {
                if (t.units) for (let o of Object.keys(_t))Array.isArray(t.units[o]) && (this.units[o] = t.units[o]);
                if (t.types) for(let o in t.types)this.addType_(o, t.types[o]);
                if (t.generic) {
                    this.generic = !0;
                    for (let [o, i] of Object.entries(Fi(this.units)))this.addType_(o, i);
                }
                if (t.atrules) for(let o in t.atrules)this.addAtrule_(o, t.atrules[o]);
                if (t.properties) for(let o in t.properties)this.addProperty_(o, t.properties[o]);
            }
        }
        checkStructure(t) {
            function r(i, s) {
                o.push({
                    node: i,
                    message: s
                });
            }
            let n = this.structure, o = [];
            return this.syntax.walk(t, function(i) {
                n.hasOwnProperty(i.type) ? n[i.type].check(i, r) : r(i, "Unknown node type `" + i.type + "`");
            }), o.length ? o : !1;
        }
        createDescriptor(t, r, n, o = null) {
            let i = {
                type: r,
                name: n
            }, s = {
                type: r,
                name: n,
                parent: o,
                serializable: typeof t == "string" || t && typeof t.type == "string",
                syntax: null,
                match: null
            };
            return typeof t == "function" ? s.match = Qt(t, i) : (typeof t == "string" ? Object.defineProperty(s, "syntax", {
                get () {
                    return Object.defineProperty(s, "syntax", {
                        value: Ge(t)
                    }), s.syntax;
                }
            }) : s.syntax = t, Object.defineProperty(s, "match", {
                get () {
                    return Object.defineProperty(s, "match", {
                        value: Qt(s.syntax, i)
                    }), s.match;
                }
            })), s;
        }
        addAtrule_(t, r) {
            !r || (this.atrules[t] = {
                type: "Atrule",
                name: t,
                prelude: r.prelude ? this.createDescriptor(r.prelude, "AtrulePrelude", t) : null,
                descriptors: r.descriptors ? Object.keys(r.descriptors).reduce((n, o)=>(n[o] = this.createDescriptor(r.descriptors[o], "AtruleDescriptor", o, t), n), Object.create(null)) : null
            });
        }
        addProperty_(t, r) {
            !r || (this.properties[t] = this.createDescriptor(r, "Property", t));
        }
        addType_(t, r) {
            !r || (this.types[t] = this.createDescriptor(r, "Type", t));
        }
        checkAtruleName(t) {
            if (!this.getAtrule(t)) return new Ue("Unknown at-rule", "@" + t);
        }
        checkAtrulePrelude(t, r) {
            let n = this.checkAtruleName(t);
            if (n) return n;
            let o = this.getAtrule(t);
            if (!o.prelude && r) return new SyntaxError("At-rule `@" + t + "` should not contain a prelude");
            if (o.prelude && !r && !Ve(this, o.prelude, "", !1).matched) return new SyntaxError("At-rule `@" + t + "` should contain a prelude");
        }
        checkAtruleDescriptorName(t, r) {
            let n = this.checkAtruleName(t);
            if (n) return n;
            let o = this.getAtrule(t), i = zt(r);
            if (!o.descriptors) return new SyntaxError("At-rule `@" + t + "` has no known descriptors");
            if (!o.descriptors[i.name] && !o.descriptors[i.basename]) return new Ue("Unknown at-rule descriptor", r);
        }
        checkPropertyName(t) {
            if (!this.getProperty(t)) return new Ue("Unknown property", t);
        }
        matchAtrulePrelude(t, r) {
            let n = this.checkAtrulePrelude(t, r);
            if (n) return ce(null, n);
            let o = this.getAtrule(t);
            return o.prelude ? Ve(this, o.prelude, r || "", !1) : ce(null, null);
        }
        matchAtruleDescriptor(t, r, n) {
            let o = this.checkAtruleDescriptorName(t, r);
            if (o) return ce(null, o);
            let i = this.getAtrule(t), s = zt(r);
            return Ve(this, i.descriptors[s.name] || i.descriptors[s.basename], n, !1);
        }
        matchDeclaration(t) {
            return t.type !== "Declaration" ? ce(null, new Error("Not a Declaration node")) : this.matchProperty(t.property, t.value);
        }
        matchProperty(t, r) {
            if (kr(t).custom) return ce(null, new Error("Lexer matching doesn't applicable for custom properties"));
            let n = this.checkPropertyName(t);
            return n ? ce(null, n) : Ve(this, this.getProperty(t), r, !0);
        }
        matchType(t, r) {
            let n = this.getType(t);
            return n ? Ve(this, n, r, !1) : ce(null, new Ue("Unknown type", t));
        }
        match(t, r) {
            return typeof t != "string" && (!t || !t.type) ? ce(null, new Ue("Bad syntax")) : ((typeof t == "string" || !t.match) && (t = this.createDescriptor(t, "Type", "anonymous")), Ve(this, t, r, !1));
        }
        findValueFragments(t, r, n, o) {
            return Wr(this, r, this.matchProperty(t, r), n, o);
        }
        findDeclarationValueFragments(t, r, n) {
            return Wr(this, t.value, this.matchDeclaration(t), r, n);
        }
        findAllFragments(t, r, n) {
            let o = [];
            return this.syntax.walk(t, {
                visit: "Declaration",
                enter: (i)=>{
                    o.push.apply(o, this.findDeclarationValueFragments(i, r, n));
                }
            }), o;
        }
        getAtrule(t, r = !0) {
            let n = zt(t);
            return (n.vendor && r ? this.atrules[n.name] || this.atrules[n.basename] : this.atrules[n.name]) || null;
        }
        getAtrulePrelude(t, r = !0) {
            let n = this.getAtrule(t, r);
            return n && n.prelude || null;
        }
        getAtruleDescriptor(t, r) {
            return this.atrules.hasOwnProperty(t) && this.atrules.declarators && this.atrules[t].declarators[r] || null;
        }
        getProperty(t, r = !0) {
            let n = kr(t);
            return (n.vendor && r ? this.properties[n.name] || this.properties[n.basename] : this.properties[n.name]) || null;
        }
        getType(t) {
            return hasOwnProperty.call(this.types, t) ? this.types[t] : null;
        }
        validate() {
            function t(o, i, s, u) {
                if (s.has(i)) return s.get(i);
                s.set(i, !1), u.syntax !== null && Vt(u.syntax, function(c) {
                    if (c.type !== "Type" && c.type !== "Property") return;
                    let a = c.type === "Type" ? o.types : o.properties, l = c.type === "Type" ? r : n;
                    (!hasOwnProperty.call(a, c.name) || t(o, c.name, l, a[c.name])) && s.set(i, !0);
                }, this);
            }
            let r = new Map, n = new Map;
            for(let o in this.types)t(this, o, r, this.types[o]);
            for(let o in this.properties)t(this, o, n, this.properties[o]);
            return r = [
                ...r.keys()
            ].filter((o)=>r.get(o)), n = [
                ...n.keys()
            ].filter((o)=>n.get(o)), r.length || n.length ? {
                types: r,
                properties: n
            } : null;
        }
        dump(t, r) {
            return {
                generic: this.generic,
                units: this.units,
                types: Yr(this.types, !r, t),
                properties: Yr(this.properties, !r, t),
                atrules: mc(this.atrules, !r, t)
            };
        }
        toString() {
            return JSON.stringify(this.dump());
        }
    };
    function Gr(e, t) {
        return typeof t == "string" && /^\s*\|/.test(t) ? typeof e == "string" ? e + t : t.replace(/^\s*\|\s*/, "") : t || null;
    }
    function ha(e, t) {
        let r = Object.create(null);
        for (let [n, o] of Object.entries(e))if (o) {
            r[n] = {};
            for (let i of Object.keys(o))t.includes(i) && (r[n][i] = o[i]);
        }
        return r;
    }
    function mt(e, t) {
        let r = {
            ...e
        };
        for (let [n, o] of Object.entries(t))switch(n){
            case "generic":
                r[n] = Boolean(o);
                break;
            case "units":
                r[n] = {
                    ...e[n]
                };
                for (let [i, s] of Object.entries(o))r[n][i] = Array.isArray(s) ? s : [];
                break;
            case "atrules":
                r[n] = {
                    ...e[n]
                };
                for (let [i, s] of Object.entries(o)){
                    let u = r[n][i] || {}, c = r[n][i] = {
                        prelude: u.prelude || null,
                        descriptors: {
                            ...u.descriptors
                        }
                    };
                    if (!!s) {
                        c.prelude = s.prelude ? Gr(c.prelude, s.prelude) : c.prelude || null;
                        for (let [a, l] of Object.entries(s.descriptors || {}))c.descriptors[a] = l ? Gr(c.descriptors[a], l) : null;
                        Object.keys(c.descriptors).length || (c.descriptors = null);
                    }
                }
                break;
            case "types":
            case "properties":
                r[n] = {
                    ...e[n]
                };
                for (let [i, s] of Object.entries(o))r[n][i] = Gr(r[n][i], s);
                break;
            case "scope":
                r[n] = {
                    ...e[n]
                };
                for (let [i, s] of Object.entries(o))r[n][i] = {
                    ...r[n][i],
                    ...s
                };
                break;
            case "parseContext":
                r[n] = {
                    ...e[n],
                    ...o
                };
                break;
            case "atrule":
            case "pseudo":
                r[n] = {
                    ...e[n],
                    ...ha(o, [
                        "parse"
                    ])
                };
                break;
            case "node":
                r[n] = {
                    ...e[n],
                    ...ha(o, [
                        "name",
                        "structure",
                        "parse",
                        "generate",
                        "walkContext"
                    ])
                };
                break;
        }
        return r;
    }
    function ma(e) {
        let t = $o(e), r = Li(e), n = vi(e), { fromPlainObject: o, toPlainObject: i } = Si(r), s = {
            lexer: null,
            createLexer: (u)=>new Ke(u, s, s.lexer.structure),
            tokenize: ve,
            parse: t,
            generate: n,
            walk: r,
            find: r.find,
            findLast: r.findLast,
            findAll: r.findAll,
            fromPlainObject: o,
            toPlainObject: i,
            fork (u) {
                let c = mt({}, e);
                return ma(typeof u == "function" ? u(c, Object.assign) : mt(c, u));
            }
        };
        return s.lexer = new Ke({
            generic: !0,
            units: e.units,
            types: e.types,
            atrules: e.atrules,
            properties: e.properties,
            node: e.node
        }, s), s;
    }
    var Vr = (e)=>ma(mt({}, e));
    var fa = {
        generic: !0,
        units: {
            angle: [
                "deg",
                "grad",
                "rad",
                "turn"
            ],
            decibel: [
                "db"
            ],
            flex: [
                "fr"
            ],
            frequency: [
                "hz",
                "khz"
            ],
            length: [
                "cm",
                "mm",
                "q",
                "in",
                "pt",
                "pc",
                "px",
                "em",
                "rem",
                "ex",
                "rex",
                "cap",
                "rcap",
                "ch",
                "rch",
                "ic",
                "ric",
                "lh",
                "rlh",
                "vw",
                "svw",
                "lvw",
                "dvw",
                "vh",
                "svh",
                "lvh",
                "dvh",
                "vi",
                "svi",
                "lvi",
                "dvi",
                "vb",
                "svb",
                "lvb",
                "dvb",
                "vmin",
                "svmin",
                "lvmin",
                "dvmin",
                "vmax",
                "svmax",
                "lvmax",
                "dvmax",
                "cqw",
                "cqh",
                "cqi",
                "cqb",
                "cqmin",
                "cqmax"
            ],
            resolution: [
                "dpi",
                "dpcm",
                "dppx",
                "x"
            ],
            semitones: [
                "st"
            ],
            time: [
                "s",
                "ms"
            ]
        },
        types: {
            "abs()": "abs( <calc-sum> )",
            "absolute-size": "xx-small|x-small|small|medium|large|x-large|xx-large|xxx-large",
            "acos()": "acos( <calc-sum> )",
            "alpha-value": "<number>|<percentage>",
            "angle-percentage": "<angle>|<percentage>",
            "angular-color-hint": "<angle-percentage>",
            "angular-color-stop": "<color>&&<color-stop-angle>?",
            "angular-color-stop-list": "[<angular-color-stop> [, <angular-color-hint>]?]# , <angular-color-stop>",
            "animateable-feature": "scroll-position|contents|<custom-ident>",
            "asin()": "asin( <calc-sum> )",
            "atan()": "atan( <calc-sum> )",
            "atan2()": "atan2( <calc-sum> , <calc-sum> )",
            attachment: "scroll|fixed|local",
            "attr()": "attr( <attr-name> <type-or-unit>? [, <attr-fallback>]? )",
            "attr-matcher": "['~'|'|'|'^'|'$'|'*']? '='",
            "attr-modifier": "i|s",
            "attribute-selector": "'[' <wq-name> ']'|'[' <wq-name> <attr-matcher> [<string-token>|<ident-token>] <attr-modifier>? ']'",
            "auto-repeat": "repeat( [auto-fill|auto-fit] , [<line-names>? <fixed-size>]+ <line-names>? )",
            "auto-track-list": "[<line-names>? [<fixed-size>|<fixed-repeat>]]* <line-names>? <auto-repeat> [<line-names>? [<fixed-size>|<fixed-repeat>]]* <line-names>?",
            axis: "block|inline|vertical|horizontal",
            "baseline-position": "[first|last]? baseline",
            "basic-shape": "<inset()>|<circle()>|<ellipse()>|<polygon()>|<path()>",
            "bg-image": "none|<image>",
            "bg-layer": "<bg-image>||<bg-position> [/ <bg-size>]?||<repeat-style>||<attachment>||<box>||<box>",
            "bg-position": "[[left|center|right|top|bottom|<length-percentage>]|[left|center|right|<length-percentage>] [top|center|bottom|<length-percentage>]|[center|[left|right] <length-percentage>?]&&[center|[top|bottom] <length-percentage>?]]",
            "bg-size": "[<length-percentage>|auto]{1,2}|cover|contain",
            "blur()": "blur( <length> )",
            "blend-mode": "normal|multiply|screen|overlay|darken|lighten|color-dodge|color-burn|hard-light|soft-light|difference|exclusion|hue|saturation|color|luminosity",
            box: "border-box|padding-box|content-box",
            "brightness()": "brightness( <number-percentage> )",
            "calc()": "calc( <calc-sum> )",
            "calc-sum": "<calc-product> [['+'|'-'] <calc-product>]*",
            "calc-product": "<calc-value> ['*' <calc-value>|'/' <number>]*",
            "calc-value": "<number>|<dimension>|<percentage>|<calc-constant>|( <calc-sum> )",
            "calc-constant": "e|pi|infinity|-infinity|NaN",
            "cf-final-image": "<image>|<color>",
            "cf-mixing-image": "<percentage>?&&<image>",
            "circle()": "circle( [<shape-radius>]? [at <position>]? )",
            "clamp()": "clamp( <calc-sum>#{3} )",
            "class-selector": "'.' <ident-token>",
            "clip-source": "<url>",
            color: "<rgb()>|<rgba()>|<hsl()>|<hsla()>|<hwb()>|<lab()>|<lch()>|<hex-color>|<named-color>|currentcolor|<deprecated-system-color>",
            "color-stop": "<color-stop-length>|<color-stop-angle>",
            "color-stop-angle": "<angle-percentage>{1,2}",
            "color-stop-length": "<length-percentage>{1,2}",
            "color-stop-list": "[<linear-color-stop> [, <linear-color-hint>]?]# , <linear-color-stop>",
            combinator: "'>'|'+'|'~'|['||']",
            "common-lig-values": "[common-ligatures|no-common-ligatures]",
            "compat-auto": "searchfield|textarea|push-button|slider-horizontal|checkbox|radio|square-button|menulist|listbox|meter|progress-bar|button",
            "composite-style": "clear|copy|source-over|source-in|source-out|source-atop|destination-over|destination-in|destination-out|destination-atop|xor",
            "compositing-operator": "add|subtract|intersect|exclude",
            "compound-selector": "[<type-selector>? <subclass-selector>* [<pseudo-element-selector> <pseudo-class-selector>*]*]!",
            "compound-selector-list": "<compound-selector>#",
            "complex-selector": "<compound-selector> [<combinator>? <compound-selector>]*",
            "complex-selector-list": "<complex-selector>#",
            "conic-gradient()": "conic-gradient( [from <angle>]? [at <position>]? , <angular-color-stop-list> )",
            "contextual-alt-values": "[contextual|no-contextual]",
            "content-distribution": "space-between|space-around|space-evenly|stretch",
            "content-list": "[<string>|contents|<image>|<counter>|<quote>|<target>|<leader()>|<attr()>]+",
            "content-position": "center|start|end|flex-start|flex-end",
            "content-replacement": "<image>",
            "contrast()": "contrast( [<number-percentage>] )",
            "cos()": "cos( <calc-sum> )",
            counter: "<counter()>|<counters()>",
            "counter()": "counter( <counter-name> , <counter-style>? )",
            "counter-name": "<custom-ident>",
            "counter-style": "<counter-style-name>|symbols( )",
            "counter-style-name": "<custom-ident>",
            "counters()": "counters( <counter-name> , <string> , <counter-style>? )",
            "cross-fade()": "cross-fade( <cf-mixing-image> , <cf-final-image>? )",
            "cubic-bezier-timing-function": "ease|ease-in|ease-out|ease-in-out|cubic-bezier( <number [0,1]> , <number> , <number [0,1]> , <number> )",
            "deprecated-system-color": "ActiveBorder|ActiveCaption|AppWorkspace|Background|ButtonFace|ButtonHighlight|ButtonShadow|ButtonText|CaptionText|GrayText|Highlight|HighlightText|InactiveBorder|InactiveCaption|InactiveCaptionText|InfoBackground|InfoText|Menu|MenuText|Scrollbar|ThreeDDarkShadow|ThreeDFace|ThreeDHighlight|ThreeDLightShadow|ThreeDShadow|Window|WindowFrame|WindowText",
            "discretionary-lig-values": "[discretionary-ligatures|no-discretionary-ligatures]",
            "display-box": "contents|none",
            "display-inside": "flow|flow-root|table|flex|grid|ruby",
            "display-internal": "table-row-group|table-header-group|table-footer-group|table-row|table-cell|table-column-group|table-column|table-caption|ruby-base|ruby-text|ruby-base-container|ruby-text-container",
            "display-legacy": "inline-block|inline-list-item|inline-table|inline-flex|inline-grid",
            "display-listitem": "<display-outside>?&&[flow|flow-root]?&&list-item",
            "display-outside": "block|inline|run-in",
            "drop-shadow()": "drop-shadow( <length>{2,3} <color>? )",
            "east-asian-variant-values": "[jis78|jis83|jis90|jis04|simplified|traditional]",
            "east-asian-width-values": "[full-width|proportional-width]",
            "element()": "element( <custom-ident> , [first|start|last|first-except]? )|element( <id-selector> )",
            "ellipse()": "ellipse( [<shape-radius>{2}]? [at <position>]? )",
            "ending-shape": "circle|ellipse",
            "env()": "env( <custom-ident> , <declaration-value>? )",
            "exp()": "exp( <calc-sum> )",
            "explicit-track-list": "[<line-names>? <track-size>]+ <line-names>?",
            "family-name": "<string>|<custom-ident>+",
            "feature-tag-value": "<string> [<integer>|on|off]?",
            "feature-type": "@stylistic|@historical-forms|@styleset|@character-variant|@swash|@ornaments|@annotation",
            "feature-value-block": "<feature-type> '{' <feature-value-declaration-list> '}'",
            "feature-value-block-list": "<feature-value-block>+",
            "feature-value-declaration": "<custom-ident> : <integer>+ ;",
            "feature-value-declaration-list": "<feature-value-declaration>",
            "feature-value-name": "<custom-ident>",
            "fill-rule": "nonzero|evenodd",
            "filter-function": "<blur()>|<brightness()>|<contrast()>|<drop-shadow()>|<grayscale()>|<hue-rotate()>|<invert()>|<opacity()>|<saturate()>|<sepia()>",
            "filter-function-list": "[<filter-function>|<url>]+",
            "final-bg-layer": "<'background-color'>||<bg-image>||<bg-position> [/ <bg-size>]?||<repeat-style>||<attachment>||<box>||<box>",
            "fixed-breadth": "<length-percentage>",
            "fixed-repeat": "repeat( [<integer [1,\u221E]>] , [<line-names>? <fixed-size>]+ <line-names>? )",
            "fixed-size": "<fixed-breadth>|minmax( <fixed-breadth> , <track-breadth> )|minmax( <inflexible-breadth> , <fixed-breadth> )",
            "font-stretch-absolute": "normal|ultra-condensed|extra-condensed|condensed|semi-condensed|semi-expanded|expanded|extra-expanded|ultra-expanded|<percentage>",
            "font-variant-css21": "[normal|small-caps]",
            "font-weight-absolute": "normal|bold|<number [1,1000]>",
            "frequency-percentage": "<frequency>|<percentage>",
            "general-enclosed": "[<function-token> <any-value> )]|( <ident> <any-value> )",
            "generic-family": "serif|sans-serif|cursive|fantasy|monospace|-apple-system",
            "generic-name": "serif|sans-serif|cursive|fantasy|monospace",
            "geometry-box": "<shape-box>|fill-box|stroke-box|view-box",
            gradient: "<linear-gradient()>|<repeating-linear-gradient()>|<radial-gradient()>|<repeating-radial-gradient()>|<conic-gradient()>|<repeating-conic-gradient()>|<-legacy-gradient>",
            "grayscale()": "grayscale( <number-percentage> )",
            "grid-line": "auto|<custom-ident>|[<integer>&&<custom-ident>?]|[span&&[<integer>||<custom-ident>]]",
            "historical-lig-values": "[historical-ligatures|no-historical-ligatures]",
            "hsl()": "hsl( <hue> <percentage> <percentage> [/ <alpha-value>]? )|hsl( <hue> , <percentage> , <percentage> , <alpha-value>? )",
            "hsla()": "hsla( <hue> <percentage> <percentage> [/ <alpha-value>]? )|hsla( <hue> , <percentage> , <percentage> , <alpha-value>? )",
            hue: "<number>|<angle>",
            "hue-rotate()": "hue-rotate( <angle> )",
            "hwb()": "hwb( [<hue>|none] [<percentage>|none] [<percentage>|none] [/ [<alpha-value>|none]]? )",
            "hypot()": "hypot( <calc-sum># )",
            image: "<url>|<image()>|<image-set()>|<element()>|<paint()>|<cross-fade()>|<gradient>",
            "image()": "image( <image-tags>? [<image-src>? , <color>?]! )",
            "image-set()": "image-set( <image-set-option># )",
            "image-set-option": "[<image>|<string>] [<resolution>||type( <string> )]",
            "image-src": "<url>|<string>",
            "image-tags": "ltr|rtl",
            "inflexible-breadth": "<length-percentage>|min-content|max-content|auto",
            "inset()": "inset( <length-percentage>{1,4} [round <'border-radius'>]? )",
            "invert()": "invert( <number-percentage> )",
            "keyframes-name": "<custom-ident>|<string>",
            "keyframe-block": "<keyframe-selector># { <declaration-list> }",
            "keyframe-block-list": "<keyframe-block>+",
            "keyframe-selector": "from|to|<percentage>",
            "lab()": "lab( [<percentage>|<number>|none] [<percentage>|<number>|none] [<percentage>|<number>|none] [/ [<alpha-value>|none]]? )",
            "layer()": "layer( <layer-name> )",
            "layer-name": "<ident> ['.' <ident>]*",
            "lch()": "lch( [<percentage>|<number>|none] [<percentage>|<number>|none] [<hue>|none] [/ [<alpha-value>|none]]? )",
            "leader()": "leader( <leader-type> )",
            "leader-type": "dotted|solid|space|<string>",
            "length-percentage": "<length>|<percentage>",
            "line-names": "'[' <custom-ident>* ']'",
            "line-name-list": "[<line-names>|<name-repeat>]+",
            "line-style": "none|hidden|dotted|dashed|solid|double|groove|ridge|inset|outset",
            "line-width": "<length>|thin|medium|thick",
            "linear-color-hint": "<length-percentage>",
            "linear-color-stop": "<color> <color-stop-length>?",
            "linear-gradient()": "linear-gradient( [<angle>|to <side-or-corner>]? , <color-stop-list> )",
            "log()": "log( <calc-sum> , <calc-sum>? )",
            "mask-layer": "<mask-reference>||<position> [/ <bg-size>]?||<repeat-style>||<geometry-box>||[<geometry-box>|no-clip]||<compositing-operator>||<masking-mode>",
            "mask-position": "[<length-percentage>|left|center|right] [<length-percentage>|top|center|bottom]?",
            "mask-reference": "none|<image>|<mask-source>",
            "mask-source": "<url>",
            "masking-mode": "alpha|luminance|match-source",
            "matrix()": "matrix( <number>#{6} )",
            "matrix3d()": "matrix3d( <number>#{16} )",
            "max()": "max( <calc-sum># )",
            "media-and": "<media-in-parens> [and <media-in-parens>]+",
            "media-condition": "<media-not>|<media-and>|<media-or>|<media-in-parens>",
            "media-condition-without-or": "<media-not>|<media-and>|<media-in-parens>",
            "media-feature": "( [<mf-plain>|<mf-boolean>|<mf-range>] )",
            "media-in-parens": "( <media-condition> )|<media-feature>|<general-enclosed>",
            "media-not": "not <media-in-parens>",
            "media-or": "<media-in-parens> [or <media-in-parens>]+",
            "media-query": "<media-condition>|[not|only]? <media-type> [and <media-condition-without-or>]?",
            "media-query-list": "<media-query>#",
            "media-type": "<ident>",
            "mf-boolean": "<mf-name>",
            "mf-name": "<ident>",
            "mf-plain": "<mf-name> : <mf-value>",
            "mf-range": "<mf-name> ['<'|'>']? '='? <mf-value>|<mf-value> ['<'|'>']? '='? <mf-name>|<mf-value> '<' '='? <mf-name> '<' '='? <mf-value>|<mf-value> '>' '='? <mf-name> '>' '='? <mf-value>",
            "mf-value": "<number>|<dimension>|<ident>|<ratio>",
            "min()": "min( <calc-sum># )",
            "minmax()": "minmax( [<length-percentage>|min-content|max-content|auto] , [<length-percentage>|<flex>|min-content|max-content|auto] )",
            "mod()": "mod( <calc-sum> , <calc-sum> )",
            "name-repeat": "repeat( [<integer [1,\u221E]>|auto-fill] , <line-names>+ )",
            "named-color": "transparent|aliceblue|antiquewhite|aqua|aquamarine|azure|beige|bisque|black|blanchedalmond|blue|blueviolet|brown|burlywood|cadetblue|chartreuse|chocolate|coral|cornflowerblue|cornsilk|crimson|cyan|darkblue|darkcyan|darkgoldenrod|darkgray|darkgreen|darkgrey|darkkhaki|darkmagenta|darkolivegreen|darkorange|darkorchid|darkred|darksalmon|darkseagreen|darkslateblue|darkslategray|darkslategrey|darkturquoise|darkviolet|deeppink|deepskyblue|dimgray|dimgrey|dodgerblue|firebrick|floralwhite|forestgreen|fuchsia|gainsboro|ghostwhite|gold|goldenrod|gray|green|greenyellow|grey|honeydew|hotpink|indianred|indigo|ivory|khaki|lavender|lavenderblush|lawngreen|lemonchiffon|lightblue|lightcoral|lightcyan|lightgoldenrodyellow|lightgray|lightgreen|lightgrey|lightpink|lightsalmon|lightseagreen|lightskyblue|lightslategray|lightslategrey|lightsteelblue|lightyellow|lime|limegreen|linen|magenta|maroon|mediumaquamarine|mediumblue|mediumorchid|mediumpurple|mediumseagreen|mediumslateblue|mediumspringgreen|mediumturquoise|mediumvioletred|midnightblue|mintcream|mistyrose|moccasin|navajowhite|navy|oldlace|olive|olivedrab|orange|orangered|orchid|palegoldenrod|palegreen|paleturquoise|palevioletred|papayawhip|peachpuff|peru|pink|plum|powderblue|purple|rebeccapurple|red|rosybrown|royalblue|saddlebrown|salmon|sandybrown|seagreen|seashell|sienna|silver|skyblue|slateblue|slategray|slategrey|snow|springgreen|steelblue|tan|teal|thistle|tomato|turquoise|violet|wheat|white|whitesmoke|yellow|yellowgreen|<-non-standard-color>",
            "namespace-prefix": "<ident>",
            "ns-prefix": "[<ident-token>|'*']? '|'",
            "number-percentage": "<number>|<percentage>",
            "numeric-figure-values": "[lining-nums|oldstyle-nums]",
            "numeric-fraction-values": "[diagonal-fractions|stacked-fractions]",
            "numeric-spacing-values": "[proportional-nums|tabular-nums]",
            nth: "<an-plus-b>|even|odd",
            "opacity()": "opacity( [<number-percentage>] )",
            "overflow-position": "unsafe|safe",
            "outline-radius": "<length>|<percentage>",
            "page-body": "<declaration>? [; <page-body>]?|<page-margin-box> <page-body>",
            "page-margin-box": "<page-margin-box-type> '{' <declaration-list> '}'",
            "page-margin-box-type": "@top-left-corner|@top-left|@top-center|@top-right|@top-right-corner|@bottom-left-corner|@bottom-left|@bottom-center|@bottom-right|@bottom-right-corner|@left-top|@left-middle|@left-bottom|@right-top|@right-middle|@right-bottom",
            "page-selector-list": "[<page-selector>#]?",
            "page-selector": "<pseudo-page>+|<ident> <pseudo-page>*",
            "page-size": "A5|A4|A3|B5|B4|JIS-B5|JIS-B4|letter|legal|ledger",
            "path()": "path( [<fill-rule> ,]? <string> )",
            "paint()": "paint( <ident> , <declaration-value>? )",
            "perspective()": "perspective( [<length [0,\u221E]>|none] )",
            "polygon()": "polygon( <fill-rule>? , [<length-percentage> <length-percentage>]# )",
            position: "[[left|center|right]||[top|center|bottom]|[left|center|right|<length-percentage>] [top|center|bottom|<length-percentage>]?|[[left|right] <length-percentage>]&&[[top|bottom] <length-percentage>]]",
            "pow()": "pow( <calc-sum> , <calc-sum> )",
            "pseudo-class-selector": "':' <ident-token>|':' <function-token> <any-value> ')'",
            "pseudo-element-selector": "':' <pseudo-class-selector>",
            "pseudo-page": ": [left|right|first|blank]",
            quote: "open-quote|close-quote|no-open-quote|no-close-quote",
            "radial-gradient()": "radial-gradient( [<ending-shape>||<size>]? [at <position>]? , <color-stop-list> )",
            ratio: "<number [0,\u221E]> [/ <number [0,\u221E]>]?",
            "relative-selector": "<combinator>? <complex-selector>",
            "relative-selector-list": "<relative-selector>#",
            "relative-size": "larger|smaller",
            "rem()": "rem( <calc-sum> , <calc-sum> )",
            "repeat-style": "repeat-x|repeat-y|[repeat|space|round|no-repeat]{1,2}",
            "repeating-conic-gradient()": "repeating-conic-gradient( [from <angle>]? [at <position>]? , <angular-color-stop-list> )",
            "repeating-linear-gradient()": "repeating-linear-gradient( [<angle>|to <side-or-corner>]? , <color-stop-list> )",
            "repeating-radial-gradient()": "repeating-radial-gradient( [<ending-shape>||<size>]? [at <position>]? , <color-stop-list> )",
            "reversed-counter-name": "reversed( <counter-name> )",
            "rgb()": "rgb( <percentage>{3} [/ <alpha-value>]? )|rgb( <number>{3} [/ <alpha-value>]? )|rgb( <percentage>#{3} , <alpha-value>? )|rgb( <number>#{3} , <alpha-value>? )",
            "rgba()": "rgba( <percentage>{3} [/ <alpha-value>]? )|rgba( <number>{3} [/ <alpha-value>]? )|rgba( <percentage>#{3} , <alpha-value>? )|rgba( <number>#{3} , <alpha-value>? )",
            "rotate()": "rotate( [<angle>|<zero>] )",
            "rotate3d()": "rotate3d( <number> , <number> , <number> , [<angle>|<zero>] )",
            "rotateX()": "rotateX( [<angle>|<zero>] )",
            "rotateY()": "rotateY( [<angle>|<zero>] )",
            "rotateZ()": "rotateZ( [<angle>|<zero>] )",
            "round()": "round( <rounding-strategy>? , <calc-sum> , <calc-sum> )",
            "rounding-strategy": "nearest|up|down|to-zero",
            "saturate()": "saturate( <number-percentage> )",
            "scale()": "scale( [<number>|<percentage>]#{1,2} )",
            "scale3d()": "scale3d( [<number>|<percentage>]#{3} )",
            "scaleX()": "scaleX( [<number>|<percentage>] )",
            "scaleY()": "scaleY( [<number>|<percentage>] )",
            "scaleZ()": "scaleZ( [<number>|<percentage>] )",
            scroller: "root|nearest",
            "self-position": "center|start|end|self-start|self-end|flex-start|flex-end",
            "shape-radius": "<length-percentage>|closest-side|farthest-side",
            "sign()": "sign( <calc-sum> )",
            "skew()": "skew( [<angle>|<zero>] , [<angle>|<zero>]? )",
            "skewX()": "skewX( [<angle>|<zero>] )",
            "skewY()": "skewY( [<angle>|<zero>] )",
            "sepia()": "sepia( <number-percentage> )",
            shadow: "inset?&&<length>{2,4}&&<color>?",
            "shadow-t": "[<length>{2,3}&&<color>?]",
            shape: "rect( <top> , <right> , <bottom> , <left> )|rect( <top> <right> <bottom> <left> )",
            "shape-box": "<box>|margin-box",
            "side-or-corner": "[left|right]||[top|bottom]",
            "sin()": "sin( <calc-sum> )",
            "single-animation": "<time>||<easing-function>||<time>||<single-animation-iteration-count>||<single-animation-direction>||<single-animation-fill-mode>||<single-animation-play-state>||[none|<keyframes-name>]",
            "single-animation-direction": "normal|reverse|alternate|alternate-reverse",
            "single-animation-fill-mode": "none|forwards|backwards|both",
            "single-animation-iteration-count": "infinite|<number>",
            "single-animation-play-state": "running|paused",
            "single-animation-timeline": "auto|none|<timeline-name>|scroll( <axis>? <scroller>? )",
            "single-transition": "[none|<single-transition-property>]||<time>||<easing-function>||<time>",
            "single-transition-property": "all|<custom-ident>",
            size: "closest-side|farthest-side|closest-corner|farthest-corner|<length>|<length-percentage>{2}",
            "sqrt()": "sqrt( <calc-sum> )",
            "step-position": "jump-start|jump-end|jump-none|jump-both|start|end",
            "step-timing-function": "step-start|step-end|steps( <integer> [, <step-position>]? )",
            "subclass-selector": "<id-selector>|<class-selector>|<attribute-selector>|<pseudo-class-selector>",
            "supports-condition": "not <supports-in-parens>|<supports-in-parens> [and <supports-in-parens>]*|<supports-in-parens> [or <supports-in-parens>]*",
            "supports-in-parens": "( <supports-condition> )|<supports-feature>|<general-enclosed>",
            "supports-feature": "<supports-decl>|<supports-selector-fn>",
            "supports-decl": "( <declaration> )",
            "supports-selector-fn": "selector( <complex-selector> )",
            symbol: "<string>|<image>|<custom-ident>",
            "tan()": "tan( <calc-sum> )",
            target: "<target-counter()>|<target-counters()>|<target-text()>",
            "target-counter()": "target-counter( [<string>|<url>] , <custom-ident> , <counter-style>? )",
            "target-counters()": "target-counters( [<string>|<url>] , <custom-ident> , <string> , <counter-style>? )",
            "target-text()": "target-text( [<string>|<url>] , [content|before|after|first-letter]? )",
            "time-percentage": "<time>|<percentage>",
            "timeline-name": "<custom-ident>|<string>",
            "easing-function": "linear|<cubic-bezier-timing-function>|<step-timing-function>",
            "track-breadth": "<length-percentage>|<flex>|min-content|max-content|auto",
            "track-list": "[<line-names>? [<track-size>|<track-repeat>]]+ <line-names>?",
            "track-repeat": "repeat( [<integer [1,\u221E]>] , [<line-names>? <track-size>]+ <line-names>? )",
            "track-size": "<track-breadth>|minmax( <inflexible-breadth> , <track-breadth> )|fit-content( <length-percentage> )",
            "transform-function": "<matrix()>|<translate()>|<translateX()>|<translateY()>|<scale()>|<scaleX()>|<scaleY()>|<rotate()>|<skew()>|<skewX()>|<skewY()>|<matrix3d()>|<translate3d()>|<translateZ()>|<scale3d()>|<scaleZ()>|<rotate3d()>|<rotateX()>|<rotateY()>|<rotateZ()>|<perspective()>",
            "transform-list": "<transform-function>+",
            "translate()": "translate( <length-percentage> , <length-percentage>? )",
            "translate3d()": "translate3d( <length-percentage> , <length-percentage> , <length> )",
            "translateX()": "translateX( <length-percentage> )",
            "translateY()": "translateY( <length-percentage> )",
            "translateZ()": "translateZ( <length> )",
            "type-or-unit": "string|color|url|integer|number|length|angle|time|frequency|cap|ch|em|ex|ic|lh|rlh|rem|vb|vi|vw|vh|vmin|vmax|mm|Q|cm|in|pt|pc|px|deg|grad|rad|turn|ms|s|Hz|kHz|%",
            "type-selector": "<wq-name>|<ns-prefix>? '*'",
            "var()": "var( <custom-property-name> , <declaration-value>? )",
            "viewport-length": "auto|<length-percentage>",
            "visual-box": "content-box|padding-box|border-box",
            "wq-name": "<ns-prefix>? <ident-token>",
            "-legacy-gradient": "<-webkit-gradient()>|<-legacy-linear-gradient>|<-legacy-repeating-linear-gradient>|<-legacy-radial-gradient>|<-legacy-repeating-radial-gradient>",
            "-legacy-linear-gradient": "-moz-linear-gradient( <-legacy-linear-gradient-arguments> )|-webkit-linear-gradient( <-legacy-linear-gradient-arguments> )|-o-linear-gradient( <-legacy-linear-gradient-arguments> )",
            "-legacy-repeating-linear-gradient": "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )|-webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )|-o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )",
            "-legacy-linear-gradient-arguments": "[<angle>|<side-or-corner>]? , <color-stop-list>",
            "-legacy-radial-gradient": "-moz-radial-gradient( <-legacy-radial-gradient-arguments> )|-webkit-radial-gradient( <-legacy-radial-gradient-arguments> )|-o-radial-gradient( <-legacy-radial-gradient-arguments> )",
            "-legacy-repeating-radial-gradient": "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )|-webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )|-o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )",
            "-legacy-radial-gradient-arguments": "[<position> ,]? [[[<-legacy-radial-gradient-shape>||<-legacy-radial-gradient-size>]|[<length>|<percentage>]{2}] ,]? <color-stop-list>",
            "-legacy-radial-gradient-size": "closest-side|closest-corner|farthest-side|farthest-corner|contain|cover",
            "-legacy-radial-gradient-shape": "circle|ellipse",
            "-non-standard-font": "-apple-system-body|-apple-system-headline|-apple-system-subheadline|-apple-system-caption1|-apple-system-caption2|-apple-system-footnote|-apple-system-short-body|-apple-system-short-headline|-apple-system-short-subheadline|-apple-system-short-caption1|-apple-system-short-footnote|-apple-system-tall-body",
            "-non-standard-color": "-moz-ButtonDefault|-moz-ButtonHoverFace|-moz-ButtonHoverText|-moz-CellHighlight|-moz-CellHighlightText|-moz-Combobox|-moz-ComboboxText|-moz-Dialog|-moz-DialogText|-moz-dragtargetzone|-moz-EvenTreeRow|-moz-Field|-moz-FieldText|-moz-html-CellHighlight|-moz-html-CellHighlightText|-moz-mac-accentdarkestshadow|-moz-mac-accentdarkshadow|-moz-mac-accentface|-moz-mac-accentlightesthighlight|-moz-mac-accentlightshadow|-moz-mac-accentregularhighlight|-moz-mac-accentregularshadow|-moz-mac-chrome-active|-moz-mac-chrome-inactive|-moz-mac-focusring|-moz-mac-menuselect|-moz-mac-menushadow|-moz-mac-menutextselect|-moz-MenuHover|-moz-MenuHoverText|-moz-MenuBarText|-moz-MenuBarHoverText|-moz-nativehyperlinktext|-moz-OddTreeRow|-moz-win-communicationstext|-moz-win-mediatext|-moz-activehyperlinktext|-moz-default-background-color|-moz-default-color|-moz-hyperlinktext|-moz-visitedhyperlinktext|-webkit-activelink|-webkit-focus-ring-color|-webkit-link|-webkit-text",
            "-non-standard-image-rendering": "optimize-contrast|-moz-crisp-edges|-o-crisp-edges|-webkit-optimize-contrast",
            "-non-standard-overflow": "-moz-scrollbars-none|-moz-scrollbars-horizontal|-moz-scrollbars-vertical|-moz-hidden-unscrollable",
            "-non-standard-width": "fill-available|min-intrinsic|intrinsic|-moz-available|-moz-fit-content|-moz-min-content|-moz-max-content|-webkit-min-content|-webkit-max-content",
            "-webkit-gradient()": "-webkit-gradient( <-webkit-gradient-type> , <-webkit-gradient-point> [, <-webkit-gradient-point>|, <-webkit-gradient-radius> , <-webkit-gradient-point>] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )",
            "-webkit-gradient-color-stop": "from( <color> )|color-stop( [<number-zero-one>|<percentage>] , <color> )|to( <color> )",
            "-webkit-gradient-point": "[left|center|right|<length-percentage>] [top|center|bottom|<length-percentage>]",
            "-webkit-gradient-radius": "<length>|<percentage>",
            "-webkit-gradient-type": "linear|radial",
            "-webkit-mask-box-repeat": "repeat|stretch|round",
            "-webkit-mask-clip-style": "border|border-box|padding|padding-box|content|content-box|text",
            "-ms-filter-function-list": "<-ms-filter-function>+",
            "-ms-filter-function": "<-ms-filter-function-progid>|<-ms-filter-function-legacy>",
            "-ms-filter-function-progid": "'progid:' [<ident-token> '.']* [<ident-token>|<function-token> <any-value>? )]",
            "-ms-filter-function-legacy": "<ident-token>|<function-token> <any-value>? )",
            "-ms-filter": "<string>",
            age: "child|young|old",
            "attr-name": "<wq-name>",
            "attr-fallback": "<any-value>",
            "bg-clip": "<box>|border|text",
            bottom: "<length>|auto",
            "container-name": "<custom-ident>",
            "container-condition": "not <query-in-parens>|<query-in-parens> [[and <query-in-parens>]*|[or <query-in-parens>]*]",
            "generic-voice": "[<age>? <gender> <integer>?]",
            gender: "male|female|neutral",
            left: "<length>|auto",
            "mask-image": "<mask-reference>#",
            paint: "none|<color>|<url> [none|<color>]?|context-fill|context-stroke",
            right: "<length>|auto",
            "scroll-timeline-axis": "block|inline|vertical|horizontal",
            "scroll-timeline-name": "none|<custom-ident>",
            "single-animation-composition": "replace|add|accumulate",
            "svg-length": "<percentage>|<length>|<number>",
            "svg-writing-mode": "lr-tb|rl-tb|tb-rl|lr|rl|tb",
            top: "<length>|auto",
            x: "<number>",
            y: "<number>",
            declaration: "<ident-token> : <declaration-value>? ['!' important]?",
            "declaration-list": "[<declaration>? ';']* <declaration>?",
            url: "url( <string> <url-modifier>* )|<url-token>",
            "url-modifier": "<ident>|<function-token> <any-value> )",
            "number-zero-one": "<number [0,1]>",
            "number-one-or-greater": "<number [1,\u221E]>",
            "query-in-parens": "( <container-condition> )|( <size-feature> )|style( <style-query> )|<general-enclosed>",
            "size-feature": "<mf-plain>|<mf-boolean>|<mf-range>",
            "style-feature": "<declaration>",
            "style-query": "<style-condition>|<style-feature>",
            "style-condition": "not <style-in-parens>|<style-in-parens> [[and <style-in-parens>]*|[or <style-in-parens>]*]",
            "style-in-parens": "( <style-condition> )|( <style-feature> )|<general-enclosed>",
            "-non-standard-display": "-ms-inline-flexbox|-ms-grid|-ms-inline-grid|-webkit-flex|-webkit-inline-flex|-webkit-box|-webkit-inline-box|-moz-inline-stack|-moz-box|-moz-inline-box"
        },
        properties: {
            "--*": "<declaration-value>",
            "-ms-accelerator": "false|true",
            "-ms-block-progression": "tb|rl|bt|lr",
            "-ms-content-zoom-chaining": "none|chained",
            "-ms-content-zooming": "none|zoom",
            "-ms-content-zoom-limit": "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
            "-ms-content-zoom-limit-max": "<percentage>",
            "-ms-content-zoom-limit-min": "<percentage>",
            "-ms-content-zoom-snap": "<'-ms-content-zoom-snap-type'>||<'-ms-content-zoom-snap-points'>",
            "-ms-content-zoom-snap-points": "snapInterval( <percentage> , <percentage> )|snapList( <percentage># )",
            "-ms-content-zoom-snap-type": "none|proximity|mandatory",
            "-ms-filter": "<string>",
            "-ms-flow-from": "[none|<custom-ident>]#",
            "-ms-flow-into": "[none|<custom-ident>]#",
            "-ms-grid-columns": "none|<track-list>|<auto-track-list>",
            "-ms-grid-rows": "none|<track-list>|<auto-track-list>",
            "-ms-high-contrast-adjust": "auto|none",
            "-ms-hyphenate-limit-chars": "auto|<integer>{1,3}",
            "-ms-hyphenate-limit-lines": "no-limit|<integer>",
            "-ms-hyphenate-limit-zone": "<percentage>|<length>",
            "-ms-ime-align": "auto|after",
            "-ms-overflow-style": "auto|none|scrollbar|-ms-autohiding-scrollbar",
            "-ms-scrollbar-3dlight-color": "<color>",
            "-ms-scrollbar-arrow-color": "<color>",
            "-ms-scrollbar-base-color": "<color>",
            "-ms-scrollbar-darkshadow-color": "<color>",
            "-ms-scrollbar-face-color": "<color>",
            "-ms-scrollbar-highlight-color": "<color>",
            "-ms-scrollbar-shadow-color": "<color>",
            "-ms-scrollbar-track-color": "<color>",
            "-ms-scroll-chaining": "chained|none",
            "-ms-scroll-limit": "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
            "-ms-scroll-limit-x-max": "auto|<length>",
            "-ms-scroll-limit-x-min": "<length>",
            "-ms-scroll-limit-y-max": "auto|<length>",
            "-ms-scroll-limit-y-min": "<length>",
            "-ms-scroll-rails": "none|railed",
            "-ms-scroll-snap-points-x": "snapInterval( <length-percentage> , <length-percentage> )|snapList( <length-percentage># )",
            "-ms-scroll-snap-points-y": "snapInterval( <length-percentage> , <length-percentage> )|snapList( <length-percentage># )",
            "-ms-scroll-snap-type": "none|proximity|mandatory",
            "-ms-scroll-snap-x": "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
            "-ms-scroll-snap-y": "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
            "-ms-scroll-translation": "none|vertical-to-horizontal",
            "-ms-text-autospace": "none|ideograph-alpha|ideograph-numeric|ideograph-parenthesis|ideograph-space",
            "-ms-touch-select": "grippers|none",
            "-ms-user-select": "none|element|text",
            "-ms-wrap-flow": "auto|both|start|end|maximum|clear",
            "-ms-wrap-margin": "<length>",
            "-ms-wrap-through": "wrap|none",
            "-moz-appearance": "none|button|button-arrow-down|button-arrow-next|button-arrow-previous|button-arrow-up|button-bevel|button-focus|caret|checkbox|checkbox-container|checkbox-label|checkmenuitem|dualbutton|groupbox|listbox|listitem|menuarrow|menubar|menucheckbox|menuimage|menuitem|menuitemtext|menulist|menulist-button|menulist-text|menulist-textfield|menupopup|menuradio|menuseparator|meterbar|meterchunk|progressbar|progressbar-vertical|progresschunk|progresschunk-vertical|radio|radio-container|radio-label|radiomenuitem|range|range-thumb|resizer|resizerpanel|scale-horizontal|scalethumbend|scalethumb-horizontal|scalethumbstart|scalethumbtick|scalethumb-vertical|scale-vertical|scrollbarbutton-down|scrollbarbutton-left|scrollbarbutton-right|scrollbarbutton-up|scrollbarthumb-horizontal|scrollbarthumb-vertical|scrollbartrack-horizontal|scrollbartrack-vertical|searchfield|separator|sheet|spinner|spinner-downbutton|spinner-textfield|spinner-upbutton|splitter|statusbar|statusbarpanel|tab|tabpanel|tabpanels|tab-scroll-arrow-back|tab-scroll-arrow-forward|textfield|textfield-multiline|toolbar|toolbarbutton|toolbarbutton-dropdown|toolbargripper|toolbox|tooltip|treeheader|treeheadercell|treeheadersortarrow|treeitem|treeline|treetwisty|treetwistyopen|treeview|-moz-mac-unified-toolbar|-moz-win-borderless-glass|-moz-win-browsertabbar-toolbox|-moz-win-communicationstext|-moz-win-communications-toolbox|-moz-win-exclude-glass|-moz-win-glass|-moz-win-mediatext|-moz-win-media-toolbox|-moz-window-button-box|-moz-window-button-box-maximized|-moz-window-button-close|-moz-window-button-maximize|-moz-window-button-minimize|-moz-window-button-restore|-moz-window-frame-bottom|-moz-window-frame-left|-moz-window-frame-right|-moz-window-titlebar|-moz-window-titlebar-maximized",
            "-moz-binding": "<url>|none",
            "-moz-border-bottom-colors": "<color>+|none",
            "-moz-border-left-colors": "<color>+|none",
            "-moz-border-right-colors": "<color>+|none",
            "-moz-border-top-colors": "<color>+|none",
            "-moz-context-properties": "none|[fill|fill-opacity|stroke|stroke-opacity]#",
            "-moz-float-edge": "border-box|content-box|margin-box|padding-box",
            "-moz-force-broken-image-icon": "0|1",
            "-moz-image-region": "<shape>|auto",
            "-moz-orient": "inline|block|horizontal|vertical",
            "-moz-outline-radius": "<outline-radius>{1,4} [/ <outline-radius>{1,4}]?",
            "-moz-outline-radius-bottomleft": "<outline-radius>",
            "-moz-outline-radius-bottomright": "<outline-radius>",
            "-moz-outline-radius-topleft": "<outline-radius>",
            "-moz-outline-radius-topright": "<outline-radius>",
            "-moz-stack-sizing": "ignore|stretch-to-fit",
            "-moz-text-blink": "none|blink",
            "-moz-user-focus": "ignore|normal|select-after|select-before|select-menu|select-same|select-all|none",
            "-moz-user-input": "auto|none|enabled|disabled",
            "-moz-user-modify": "read-only|read-write|write-only",
            "-moz-window-dragging": "drag|no-drag",
            "-moz-window-shadow": "default|menu|tooltip|sheet|none",
            "-webkit-appearance": "none|button|button-bevel|caps-lock-indicator|caret|checkbox|default-button|inner-spin-button|listbox|listitem|media-controls-background|media-controls-fullscreen-background|media-current-time-display|media-enter-fullscreen-button|media-exit-fullscreen-button|media-fullscreen-button|media-mute-button|media-overlay-play-button|media-play-button|media-seek-back-button|media-seek-forward-button|media-slider|media-sliderthumb|media-time-remaining-display|media-toggle-closed-captions-button|media-volume-slider|media-volume-slider-container|media-volume-sliderthumb|menulist|menulist-button|menulist-text|menulist-textfield|meter|progress-bar|progress-bar-value|push-button|radio|scrollbarbutton-down|scrollbarbutton-left|scrollbarbutton-right|scrollbarbutton-up|scrollbargripper-horizontal|scrollbargripper-vertical|scrollbarthumb-horizontal|scrollbarthumb-vertical|scrollbartrack-horizontal|scrollbartrack-vertical|searchfield|searchfield-cancel-button|searchfield-decoration|searchfield-results-button|searchfield-results-decoration|slider-horizontal|slider-vertical|sliderthumb-horizontal|sliderthumb-vertical|square-button|textarea|textfield|-apple-pay-button",
            "-webkit-border-before": "<'border-width'>||<'border-style'>||<color>",
            "-webkit-border-before-color": "<color>",
            "-webkit-border-before-style": "<'border-style'>",
            "-webkit-border-before-width": "<'border-width'>",
            "-webkit-box-reflect": "[above|below|right|left]? <length>? <image>?",
            "-webkit-line-clamp": "none|<integer>",
            "-webkit-mask": "[<mask-reference>||<position> [/ <bg-size>]?||<repeat-style>||[<box>|border|padding|content|text]||[<box>|border|padding|content]]#",
            "-webkit-mask-attachment": "<attachment>#",
            "-webkit-mask-clip": "[<box>|border|padding|content|text]#",
            "-webkit-mask-composite": "<composite-style>#",
            "-webkit-mask-image": "<mask-reference>#",
            "-webkit-mask-origin": "[<box>|border|padding|content]#",
            "-webkit-mask-position": "<position>#",
            "-webkit-mask-position-x": "[<length-percentage>|left|center|right]#",
            "-webkit-mask-position-y": "[<length-percentage>|top|center|bottom]#",
            "-webkit-mask-repeat": "<repeat-style>#",
            "-webkit-mask-repeat-x": "repeat|no-repeat|space|round",
            "-webkit-mask-repeat-y": "repeat|no-repeat|space|round",
            "-webkit-mask-size": "<bg-size>#",
            "-webkit-overflow-scrolling": "auto|touch",
            "-webkit-tap-highlight-color": "<color>",
            "-webkit-text-fill-color": "<color>",
            "-webkit-text-stroke": "<length>||<color>",
            "-webkit-text-stroke-color": "<color>",
            "-webkit-text-stroke-width": "<length>",
            "-webkit-touch-callout": "default|none",
            "-webkit-user-modify": "read-only|read-write|read-write-plaintext-only",
            "accent-color": "auto|<color>",
            "align-content": "normal|<baseline-position>|<content-distribution>|<overflow-position>? <content-position>",
            "align-items": "normal|stretch|<baseline-position>|[<overflow-position>? <self-position>]",
            "align-self": "auto|normal|stretch|<baseline-position>|<overflow-position>? <self-position>",
            "align-tracks": "[normal|<baseline-position>|<content-distribution>|<overflow-position>? <content-position>]#",
            all: "initial|inherit|unset|revert|revert-layer",
            animation: "<single-animation>#",
            "animation-composition": "<single-animation-composition>#",
            "animation-delay": "<time>#",
            "animation-direction": "<single-animation-direction>#",
            "animation-duration": "<time>#",
            "animation-fill-mode": "<single-animation-fill-mode>#",
            "animation-iteration-count": "<single-animation-iteration-count>#",
            "animation-name": "[none|<keyframes-name>]#",
            "animation-play-state": "<single-animation-play-state>#",
            "animation-timing-function": "<easing-function>#",
            "animation-timeline": "<single-animation-timeline>#",
            appearance: "none|auto|textfield|menulist-button|<compat-auto>",
            "aspect-ratio": "auto|<ratio>",
            azimuth: "<angle>|[[left-side|far-left|left|center-left|center|center-right|right|far-right|right-side]||behind]|leftwards|rightwards",
            "backdrop-filter": "none|<filter-function-list>",
            "backface-visibility": "visible|hidden",
            background: "[<bg-layer> ,]* <final-bg-layer>",
            "background-attachment": "<attachment>#",
            "background-blend-mode": "<blend-mode>#",
            "background-clip": "<bg-clip>#",
            "background-color": "<color>",
            "background-image": "<bg-image>#",
            "background-origin": "<box>#",
            "background-position": "<bg-position>#",
            "background-position-x": "[center|[[left|right|x-start|x-end]? <length-percentage>?]!]#",
            "background-position-y": "[center|[[top|bottom|y-start|y-end]? <length-percentage>?]!]#",
            "background-repeat": "<repeat-style>#",
            "background-size": "<bg-size>#",
            "block-overflow": "clip|ellipsis|<string>",
            "block-size": "<'width'>",
            border: "<line-width>||<line-style>||<color>",
            "border-block": "<'border-top-width'>||<'border-top-style'>||<color>",
            "border-block-color": "<'border-top-color'>{1,2}",
            "border-block-style": "<'border-top-style'>",
            "border-block-width": "<'border-top-width'>",
            "border-block-end": "<'border-top-width'>||<'border-top-style'>||<color>",
            "border-block-end-color": "<'border-top-color'>",
            "border-block-end-style": "<'border-top-style'>",
            "border-block-end-width": "<'border-top-width'>",
            "border-block-start": "<'border-top-width'>||<'border-top-style'>||<color>",
            "border-block-start-color": "<'border-top-color'>",
            "border-block-start-style": "<'border-top-style'>",
            "border-block-start-width": "<'border-top-width'>",
            "border-bottom": "<line-width>||<line-style>||<color>",
            "border-bottom-color": "<'border-top-color'>",
            "border-bottom-left-radius": "<length-percentage>{1,2}",
            "border-bottom-right-radius": "<length-percentage>{1,2}",
            "border-bottom-style": "<line-style>",
            "border-bottom-width": "<line-width>",
            "border-collapse": "collapse|separate",
            "border-color": "<color>{1,4}",
            "border-end-end-radius": "<length-percentage>{1,2}",
            "border-end-start-radius": "<length-percentage>{1,2}",
            "border-image": "<'border-image-source'>||<'border-image-slice'> [/ <'border-image-width'>|/ <'border-image-width'>? / <'border-image-outset'>]?||<'border-image-repeat'>",
            "border-image-outset": "[<length>|<number>]{1,4}",
            "border-image-repeat": "[stretch|repeat|round|space]{1,2}",
            "border-image-slice": "<number-percentage>{1,4}&&fill?",
            "border-image-source": "none|<image>",
            "border-image-width": "[<length-percentage>|<number>|auto]{1,4}",
            "border-inline": "<'border-top-width'>||<'border-top-style'>||<color>",
            "border-inline-end": "<'border-top-width'>||<'border-top-style'>||<color>",
            "border-inline-color": "<'border-top-color'>{1,2}",
            "border-inline-style": "<'border-top-style'>",
            "border-inline-width": "<'border-top-width'>",
            "border-inline-end-color": "<'border-top-color'>",
            "border-inline-end-style": "<'border-top-style'>",
            "border-inline-end-width": "<'border-top-width'>",
            "border-inline-start": "<'border-top-width'>||<'border-top-style'>||<color>",
            "border-inline-start-color": "<'border-top-color'>",
            "border-inline-start-style": "<'border-top-style'>",
            "border-inline-start-width": "<'border-top-width'>",
            "border-left": "<line-width>||<line-style>||<color>",
            "border-left-color": "<color>",
            "border-left-style": "<line-style>",
            "border-left-width": "<line-width>",
            "border-radius": "<length-percentage>{1,4} [/ <length-percentage>{1,4}]?",
            "border-right": "<line-width>||<line-style>||<color>",
            "border-right-color": "<color>",
            "border-right-style": "<line-style>",
            "border-right-width": "<line-width>",
            "border-spacing": "<length> <length>?",
            "border-start-end-radius": "<length-percentage>{1,2}",
            "border-start-start-radius": "<length-percentage>{1,2}",
            "border-style": "<line-style>{1,4}",
            "border-top": "<line-width>||<line-style>||<color>",
            "border-top-color": "<color>",
            "border-top-left-radius": "<length-percentage>{1,2}",
            "border-top-right-radius": "<length-percentage>{1,2}",
            "border-top-style": "<line-style>",
            "border-top-width": "<line-width>",
            "border-width": "<line-width>{1,4}",
            bottom: "<length>|<percentage>|auto",
            "box-align": "start|center|end|baseline|stretch",
            "box-decoration-break": "slice|clone",
            "box-direction": "normal|reverse|inherit",
            "box-flex": "<number>",
            "box-flex-group": "<integer>",
            "box-lines": "single|multiple",
            "box-ordinal-group": "<integer>",
            "box-orient": "horizontal|vertical|inline-axis|block-axis|inherit",
            "box-pack": "start|center|end|justify",
            "box-shadow": "none|<shadow>#",
            "box-sizing": "content-box|border-box",
            "break-after": "auto|avoid|always|all|avoid-page|page|left|right|recto|verso|avoid-column|column|avoid-region|region",
            "break-before": "auto|avoid|always|all|avoid-page|page|left|right|recto|verso|avoid-column|column|avoid-region|region",
            "break-inside": "auto|avoid|avoid-page|avoid-column|avoid-region",
            "caption-side": "top|bottom|block-start|block-end|inline-start|inline-end",
            caret: "<'caret-color'>||<'caret-shape'>",
            "caret-color": "auto|<color>",
            "caret-shape": "auto|bar|block|underscore",
            clear: "none|left|right|both|inline-start|inline-end",
            clip: "<shape>|auto",
            "clip-path": "<clip-source>|[<basic-shape>||<geometry-box>]|none",
            color: "<color>",
            "print-color-adjust": "economy|exact",
            "color-scheme": "normal|[light|dark|<custom-ident>]+&&only?",
            "column-count": "<integer>|auto",
            "column-fill": "auto|balance|balance-all",
            "column-gap": "normal|<length-percentage>",
            "column-rule": "<'column-rule-width'>||<'column-rule-style'>||<'column-rule-color'>",
            "column-rule-color": "<color>",
            "column-rule-style": "<'border-style'>",
            "column-rule-width": "<'border-width'>",
            "column-span": "none|all",
            "column-width": "<length>|auto",
            columns: "<'column-width'>||<'column-count'>",
            contain: "none|strict|content|[[size||inline-size]||layout||style||paint]",
            "contain-intrinsic-size": "[none|<length>|auto <length>]{1,2}",
            "contain-intrinsic-block-size": "none|<length>|auto <length>",
            "contain-intrinsic-height": "none|<length>|auto <length>",
            "contain-intrinsic-inline-size": "none|<length>|auto <length>",
            "contain-intrinsic-width": "none|<length>|auto <length>",
            content: "normal|none|[<content-replacement>|<content-list>] [/ [<string>|<counter>]+]?",
            "content-visibility": "visible|auto|hidden",
            "counter-increment": "[<counter-name> <integer>?]+|none",
            "counter-reset": "[<counter-name> <integer>?|<reversed-counter-name> <integer>?]+|none",
            "counter-set": "[<counter-name> <integer>?]+|none",
            cursor: "[[<url> [<x> <y>]? ,]* [auto|default|none|context-menu|help|pointer|progress|wait|cell|crosshair|text|vertical-text|alias|copy|move|no-drop|not-allowed|e-resize|n-resize|ne-resize|nw-resize|s-resize|se-resize|sw-resize|w-resize|ew-resize|ns-resize|nesw-resize|nwse-resize|col-resize|row-resize|all-scroll|zoom-in|zoom-out|grab|grabbing|hand|-webkit-grab|-webkit-grabbing|-webkit-zoom-in|-webkit-zoom-out|-moz-grab|-moz-grabbing|-moz-zoom-in|-moz-zoom-out]]",
            direction: "ltr|rtl",
            display: "[<display-outside>||<display-inside>]|<display-listitem>|<display-internal>|<display-box>|<display-legacy>|<-non-standard-display>",
            "empty-cells": "show|hide",
            filter: "none|<filter-function-list>|<-ms-filter-function-list>",
            flex: "none|[<'flex-grow'> <'flex-shrink'>?||<'flex-basis'>]",
            "flex-basis": "content|<'width'>",
            "flex-direction": "row|row-reverse|column|column-reverse",
            "flex-flow": "<'flex-direction'>||<'flex-wrap'>",
            "flex-grow": "<number>",
            "flex-shrink": "<number>",
            "flex-wrap": "nowrap|wrap|wrap-reverse",
            float: "left|right|none|inline-start|inline-end",
            font: "[[<'font-style'>||<font-variant-css21>||<'font-weight'>||<'font-stretch'>]? <'font-size'> [/ <'line-height'>]? <'font-family'>]|caption|icon|menu|message-box|small-caption|status-bar",
            "font-family": "[<family-name>|<generic-family>]#",
            "font-feature-settings": "normal|<feature-tag-value>#",
            "font-kerning": "auto|normal|none",
            "font-language-override": "normal|<string>",
            "font-optical-sizing": "auto|none",
            "font-variation-settings": "normal|[<string> <number>]#",
            "font-size": "<absolute-size>|<relative-size>|<length-percentage>",
            "font-size-adjust": "none|[ex-height|cap-height|ch-width|ic-width|ic-height]? [from-font|<number>]",
            "font-smooth": "auto|never|always|<absolute-size>|<length>",
            "font-stretch": "<font-stretch-absolute>",
            "font-style": "normal|italic|oblique <angle>?",
            "font-synthesis": "none|[weight||style||small-caps]",
            "font-variant": "normal|none|[<common-lig-values>||<discretionary-lig-values>||<historical-lig-values>||<contextual-alt-values>||stylistic( <feature-value-name> )||historical-forms||styleset( <feature-value-name># )||character-variant( <feature-value-name># )||swash( <feature-value-name> )||ornaments( <feature-value-name> )||annotation( <feature-value-name> )||[small-caps|all-small-caps|petite-caps|all-petite-caps|unicase|titling-caps]||<numeric-figure-values>||<numeric-spacing-values>||<numeric-fraction-values>||ordinal||slashed-zero||<east-asian-variant-values>||<east-asian-width-values>||ruby]",
            "font-variant-alternates": "normal|[stylistic( <feature-value-name> )||historical-forms||styleset( <feature-value-name># )||character-variant( <feature-value-name># )||swash( <feature-value-name> )||ornaments( <feature-value-name> )||annotation( <feature-value-name> )]",
            "font-variant-caps": "normal|small-caps|all-small-caps|petite-caps|all-petite-caps|unicase|titling-caps",
            "font-variant-east-asian": "normal|[<east-asian-variant-values>||<east-asian-width-values>||ruby]",
            "font-variant-ligatures": "normal|none|[<common-lig-values>||<discretionary-lig-values>||<historical-lig-values>||<contextual-alt-values>]",
            "font-variant-numeric": "normal|[<numeric-figure-values>||<numeric-spacing-values>||<numeric-fraction-values>||ordinal||slashed-zero]",
            "font-variant-position": "normal|sub|super",
            "font-weight": "<font-weight-absolute>|bolder|lighter",
            "forced-color-adjust": "auto|none",
            gap: "<'row-gap'> <'column-gap'>?",
            grid: "<'grid-template'>|<'grid-template-rows'> / [auto-flow&&dense?] <'grid-auto-columns'>?|[auto-flow&&dense?] <'grid-auto-rows'>? / <'grid-template-columns'>",
            "grid-area": "<grid-line> [/ <grid-line>]{0,3}",
            "grid-auto-columns": "<track-size>+",
            "grid-auto-flow": "[row|column]||dense",
            "grid-auto-rows": "<track-size>+",
            "grid-column": "<grid-line> [/ <grid-line>]?",
            "grid-column-end": "<grid-line>",
            "grid-column-gap": "<length-percentage>",
            "grid-column-start": "<grid-line>",
            "grid-gap": "<'grid-row-gap'> <'grid-column-gap'>?",
            "grid-row": "<grid-line> [/ <grid-line>]?",
            "grid-row-end": "<grid-line>",
            "grid-row-gap": "<length-percentage>",
            "grid-row-start": "<grid-line>",
            "grid-template": "none|[<'grid-template-rows'> / <'grid-template-columns'>]|[<line-names>? <string> <track-size>? <line-names>?]+ [/ <explicit-track-list>]?",
            "grid-template-areas": "none|<string>+",
            "grid-template-columns": "none|<track-list>|<auto-track-list>|subgrid <line-name-list>?",
            "grid-template-rows": "none|<track-list>|<auto-track-list>|subgrid <line-name-list>?",
            "hanging-punctuation": "none|[first||[force-end|allow-end]||last]",
            height: "auto|<length>|<percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )",
            "hyphenate-character": "auto|<string>",
            hyphens: "none|manual|auto",
            "image-orientation": "from-image|<angle>|[<angle>? flip]",
            "image-rendering": "auto|crisp-edges|pixelated|optimizeSpeed|optimizeQuality|<-non-standard-image-rendering>",
            "image-resolution": "[from-image||<resolution>]&&snap?",
            "ime-mode": "auto|normal|active|inactive|disabled",
            "initial-letter": "normal|[<number> <integer>?]",
            "initial-letter-align": "[auto|alphabetic|hanging|ideographic]",
            "inline-size": "<'width'>",
            "input-security": "auto|none",
            inset: "<'top'>{1,4}",
            "inset-block": "<'top'>{1,2}",
            "inset-block-end": "<'top'>",
            "inset-block-start": "<'top'>",
            "inset-inline": "<'top'>{1,2}",
            "inset-inline-end": "<'top'>",
            "inset-inline-start": "<'top'>",
            isolation: "auto|isolate",
            "justify-content": "normal|<content-distribution>|<overflow-position>? [<content-position>|left|right]",
            "justify-items": "normal|stretch|<baseline-position>|<overflow-position>? [<self-position>|left|right]|legacy|legacy&&[left|right|center]",
            "justify-self": "auto|normal|stretch|<baseline-position>|<overflow-position>? [<self-position>|left|right]",
            "justify-tracks": "[normal|<content-distribution>|<overflow-position>? [<content-position>|left|right]]#",
            left: "<length>|<percentage>|auto",
            "letter-spacing": "normal|<length-percentage>",
            "line-break": "auto|loose|normal|strict|anywhere",
            "line-clamp": "none|<integer>",
            "line-height": "normal|<number>|<length>|<percentage>",
            "line-height-step": "<length>",
            "list-style": "<'list-style-type'>||<'list-style-position'>||<'list-style-image'>",
            "list-style-image": "<image>|none",
            "list-style-position": "inside|outside",
            "list-style-type": "<counter-style>|<string>|none",
            margin: "[<length>|<percentage>|auto]{1,4}",
            "margin-block": "<'margin-left'>{1,2}",
            "margin-block-end": "<'margin-left'>",
            "margin-block-start": "<'margin-left'>",
            "margin-bottom": "<length>|<percentage>|auto",
            "margin-inline": "<'margin-left'>{1,2}",
            "margin-inline-end": "<'margin-left'>",
            "margin-inline-start": "<'margin-left'>",
            "margin-left": "<length>|<percentage>|auto",
            "margin-right": "<length>|<percentage>|auto",
            "margin-top": "<length>|<percentage>|auto",
            "margin-trim": "none|in-flow|all",
            mask: "<mask-layer>#",
            "mask-border": "<'mask-border-source'>||<'mask-border-slice'> [/ <'mask-border-width'>? [/ <'mask-border-outset'>]?]?||<'mask-border-repeat'>||<'mask-border-mode'>",
            "mask-border-mode": "luminance|alpha",
            "mask-border-outset": "[<length>|<number>]{1,4}",
            "mask-border-repeat": "[stretch|repeat|round|space]{1,2}",
            "mask-border-slice": "<number-percentage>{1,4} fill?",
            "mask-border-source": "none|<image>",
            "mask-border-width": "[<length-percentage>|<number>|auto]{1,4}",
            "mask-clip": "[<geometry-box>|no-clip]#",
            "mask-composite": "<compositing-operator>#",
            "mask-image": "<mask-reference>#",
            "mask-mode": "<masking-mode>#",
            "mask-origin": "<geometry-box>#",
            "mask-position": "<position>#",
            "mask-repeat": "<repeat-style>#",
            "mask-size": "<bg-size>#",
            "mask-type": "luminance|alpha",
            "masonry-auto-flow": "[pack|next]||[definite-first|ordered]",
            "math-depth": "auto-add|add( <integer> )|<integer>",
            "math-shift": "normal|compact",
            "math-style": "normal|compact",
            "max-block-size": "<'max-width'>",
            "max-height": "none|<length-percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )",
            "max-inline-size": "<'max-width'>",
            "max-lines": "none|<integer>",
            "max-width": "none|<length-percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )|<-non-standard-width>",
            "min-block-size": "<'min-width'>",
            "min-height": "auto|<length>|<percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )",
            "min-inline-size": "<'min-width'>",
            "min-width": "auto|<length>|<percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )|<-non-standard-width>",
            "mix-blend-mode": "<blend-mode>|plus-lighter",
            "object-fit": "fill|contain|cover|none|scale-down",
            "object-position": "<position>",
            offset: "[<'offset-position'>? [<'offset-path'> [<'offset-distance'>||<'offset-rotate'>]?]?]! [/ <'offset-anchor'>]?",
            "offset-anchor": "auto|<position>",
            "offset-distance": "<length-percentage>",
            "offset-path": "none|ray( [<angle>&&<size>&&contain?] )|<path()>|<url>|[<basic-shape>||<geometry-box>]",
            "offset-position": "auto|<position>",
            "offset-rotate": "[auto|reverse]||<angle>",
            opacity: "<alpha-value>",
            order: "<integer>",
            orphans: "<integer>",
            outline: "[<'outline-color'>||<'outline-style'>||<'outline-width'>]",
            "outline-color": "<color>|invert",
            "outline-offset": "<length>",
            "outline-style": "auto|<'border-style'>",
            "outline-width": "<line-width>",
            overflow: "[visible|hidden|clip|scroll|auto]{1,2}|<-non-standard-overflow>",
            "overflow-anchor": "auto|none",
            "overflow-block": "visible|hidden|clip|scroll|auto",
            "overflow-clip-box": "padding-box|content-box",
            "overflow-clip-margin": "<visual-box>||<length [0,\u221E]>",
            "overflow-inline": "visible|hidden|clip|scroll|auto",
            "overflow-wrap": "normal|break-word|anywhere",
            "overflow-x": "visible|hidden|clip|scroll|auto",
            "overflow-y": "visible|hidden|clip|scroll|auto",
            "overscroll-behavior": "[contain|none|auto]{1,2}",
            "overscroll-behavior-block": "contain|none|auto",
            "overscroll-behavior-inline": "contain|none|auto",
            "overscroll-behavior-x": "contain|none|auto",
            "overscroll-behavior-y": "contain|none|auto",
            padding: "[<length>|<percentage>]{1,4}",
            "padding-block": "<'padding-left'>{1,2}",
            "padding-block-end": "<'padding-left'>",
            "padding-block-start": "<'padding-left'>",
            "padding-bottom": "<length>|<percentage>",
            "padding-inline": "<'padding-left'>{1,2}",
            "padding-inline-end": "<'padding-left'>",
            "padding-inline-start": "<'padding-left'>",
            "padding-left": "<length>|<percentage>",
            "padding-right": "<length>|<percentage>",
            "padding-top": "<length>|<percentage>",
            "page-break-after": "auto|always|avoid|left|right|recto|verso",
            "page-break-before": "auto|always|avoid|left|right|recto|verso",
            "page-break-inside": "auto|avoid",
            "paint-order": "normal|[fill||stroke||markers]",
            perspective: "none|<length>",
            "perspective-origin": "<position>",
            "place-content": "<'align-content'> <'justify-content'>?",
            "place-items": "<'align-items'> <'justify-items'>?",
            "place-self": "<'align-self'> <'justify-self'>?",
            "pointer-events": "auto|none|visiblePainted|visibleFill|visibleStroke|visible|painted|fill|stroke|all|inherit",
            position: "static|relative|absolute|sticky|fixed|-webkit-sticky",
            quotes: "none|auto|[<string> <string>]+",
            resize: "none|both|horizontal|vertical|block|inline",
            right: "<length>|<percentage>|auto",
            rotate: "none|<angle>|[x|y|z|<number>{3}]&&<angle>",
            "row-gap": "normal|<length-percentage>",
            "ruby-align": "start|center|space-between|space-around",
            "ruby-merge": "separate|collapse|auto",
            "ruby-position": "[alternate||[over|under]]|inter-character",
            scale: "none|<number>{1,3}",
            "scrollbar-color": "auto|<color>{2}",
            "scrollbar-gutter": "auto|stable&&both-edges?",
            "scrollbar-width": "auto|thin|none",
            "scroll-behavior": "auto|smooth",
            "scroll-margin": "<length>{1,4}",
            "scroll-margin-block": "<length>{1,2}",
            "scroll-margin-block-start": "<length>",
            "scroll-margin-block-end": "<length>",
            "scroll-margin-bottom": "<length>",
            "scroll-margin-inline": "<length>{1,2}",
            "scroll-margin-inline-start": "<length>",
            "scroll-margin-inline-end": "<length>",
            "scroll-margin-left": "<length>",
            "scroll-margin-right": "<length>",
            "scroll-margin-top": "<length>",
            "scroll-padding": "[auto|<length-percentage>]{1,4}",
            "scroll-padding-block": "[auto|<length-percentage>]{1,2}",
            "scroll-padding-block-start": "auto|<length-percentage>",
            "scroll-padding-block-end": "auto|<length-percentage>",
            "scroll-padding-bottom": "auto|<length-percentage>",
            "scroll-padding-inline": "[auto|<length-percentage>]{1,2}",
            "scroll-padding-inline-start": "auto|<length-percentage>",
            "scroll-padding-inline-end": "auto|<length-percentage>",
            "scroll-padding-left": "auto|<length-percentage>",
            "scroll-padding-right": "auto|<length-percentage>",
            "scroll-padding-top": "auto|<length-percentage>",
            "scroll-snap-align": "[none|start|end|center]{1,2}",
            "scroll-snap-coordinate": "none|<position>#",
            "scroll-snap-destination": "<position>",
            "scroll-snap-points-x": "none|repeat( <length-percentage> )",
            "scroll-snap-points-y": "none|repeat( <length-percentage> )",
            "scroll-snap-stop": "normal|always",
            "scroll-snap-type": "none|[x|y|block|inline|both] [mandatory|proximity]?",
            "scroll-snap-type-x": "none|mandatory|proximity",
            "scroll-snap-type-y": "none|mandatory|proximity",
            "scroll-timeline": "<scroll-timeline-name>||<scroll-timeline-axis>",
            "scroll-timeline-axis": "block|inline|vertical|horizontal",
            "scroll-timeline-name": "none|<custom-ident>",
            "shape-image-threshold": "<alpha-value>",
            "shape-margin": "<length-percentage>",
            "shape-outside": "none|[<shape-box>||<basic-shape>]|<image>",
            "tab-size": "<integer>|<length>",
            "table-layout": "auto|fixed",
            "text-align": "start|end|left|right|center|justify|match-parent",
            "text-align-last": "auto|start|end|left|right|center|justify",
            "text-combine-upright": "none|all|[digits <integer>?]",
            "text-decoration": "<'text-decoration-line'>||<'text-decoration-style'>||<'text-decoration-color'>||<'text-decoration-thickness'>",
            "text-decoration-color": "<color>",
            "text-decoration-line": "none|[underline||overline||line-through||blink]|spelling-error|grammar-error",
            "text-decoration-skip": "none|[objects||[spaces|[leading-spaces||trailing-spaces]]||edges||box-decoration]",
            "text-decoration-skip-ink": "auto|all|none",
            "text-decoration-style": "solid|double|dotted|dashed|wavy",
            "text-decoration-thickness": "auto|from-font|<length>|<percentage>",
            "text-emphasis": "<'text-emphasis-style'>||<'text-emphasis-color'>",
            "text-emphasis-color": "<color>",
            "text-emphasis-position": "[over|under]&&[right|left]",
            "text-emphasis-style": "none|[[filled|open]||[dot|circle|double-circle|triangle|sesame]]|<string>",
            "text-indent": "<length-percentage>&&hanging?&&each-line?",
            "text-justify": "auto|inter-character|inter-word|none",
            "text-orientation": "mixed|upright|sideways",
            "text-overflow": "[clip|ellipsis|<string>]{1,2}",
            "text-rendering": "auto|optimizeSpeed|optimizeLegibility|geometricPrecision",
            "text-shadow": "none|<shadow-t>#",
            "text-size-adjust": "none|auto|<percentage>",
            "text-transform": "none|capitalize|uppercase|lowercase|full-width|full-size-kana",
            "text-underline-offset": "auto|<length>|<percentage>",
            "text-underline-position": "auto|from-font|[under||[left|right]]",
            top: "<length>|<percentage>|auto",
            "touch-action": "auto|none|[[pan-x|pan-left|pan-right]||[pan-y|pan-up|pan-down]||pinch-zoom]|manipulation",
            transform: "none|<transform-list>",
            "transform-box": "content-box|border-box|fill-box|stroke-box|view-box",
            "transform-origin": "[<length-percentage>|left|center|right|top|bottom]|[[<length-percentage>|left|center|right]&&[<length-percentage>|top|center|bottom]] <length>?",
            "transform-style": "flat|preserve-3d",
            transition: "<single-transition>#",
            "transition-delay": "<time>#",
            "transition-duration": "<time>#",
            "transition-property": "none|<single-transition-property>#",
            "transition-timing-function": "<easing-function>#",
            translate: "none|<length-percentage> [<length-percentage> <length>?]?",
            "unicode-bidi": "normal|embed|isolate|bidi-override|isolate-override|plaintext|-moz-isolate|-moz-isolate-override|-moz-plaintext|-webkit-isolate|-webkit-isolate-override|-webkit-plaintext",
            "user-select": "auto|text|none|contain|all",
            "vertical-align": "baseline|sub|super|text-top|text-bottom|middle|top|bottom|<percentage>|<length>",
            visibility: "visible|hidden|collapse",
            "white-space": "normal|pre|nowrap|pre-wrap|pre-line|break-spaces",
            widows: "<integer>",
            width: "auto|<length>|<percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )|fill|stretch|intrinsic|-moz-max-content|-webkit-max-content|-moz-fit-content|-webkit-fit-content",
            "will-change": "auto|<animateable-feature>#",
            "word-break": "normal|break-all|keep-all|break-word",
            "word-spacing": "normal|<length>",
            "word-wrap": "normal|break-word",
            "writing-mode": "horizontal-tb|vertical-rl|vertical-lr|sideways-rl|sideways-lr|<svg-writing-mode>",
            "z-index": "auto|<integer>",
            zoom: "normal|reset|<number>|<percentage>",
            "-moz-background-clip": "padding|border",
            "-moz-border-radius-bottomleft": "<'border-bottom-left-radius'>",
            "-moz-border-radius-bottomright": "<'border-bottom-right-radius'>",
            "-moz-border-radius-topleft": "<'border-top-left-radius'>",
            "-moz-border-radius-topright": "<'border-bottom-right-radius'>",
            "-moz-control-character-visibility": "visible|hidden",
            "-moz-osx-font-smoothing": "auto|grayscale",
            "-moz-user-select": "none|text|all|-moz-none",
            "-ms-flex-align": "start|end|center|baseline|stretch",
            "-ms-flex-item-align": "auto|start|end|center|baseline|stretch",
            "-ms-flex-line-pack": "start|end|center|justify|distribute|stretch",
            "-ms-flex-negative": "<'flex-shrink'>",
            "-ms-flex-pack": "start|end|center|justify|distribute",
            "-ms-flex-order": "<integer>",
            "-ms-flex-positive": "<'flex-grow'>",
            "-ms-flex-preferred-size": "<'flex-basis'>",
            "-ms-interpolation-mode": "nearest-neighbor|bicubic",
            "-ms-grid-column-align": "start|end|center|stretch",
            "-ms-grid-row-align": "start|end|center|stretch",
            "-ms-hyphenate-limit-last": "none|always|column|page|spread",
            "-webkit-background-clip": "[<box>|border|padding|content|text]#",
            "-webkit-column-break-after": "always|auto|avoid",
            "-webkit-column-break-before": "always|auto|avoid",
            "-webkit-column-break-inside": "always|auto|avoid",
            "-webkit-font-smoothing": "auto|none|antialiased|subpixel-antialiased",
            "-webkit-mask-box-image": "[<url>|<gradient>|none] [<length-percentage>{4} <-webkit-mask-box-repeat>{2}]?",
            "-webkit-print-color-adjust": "economy|exact",
            "-webkit-text-security": "none|circle|disc|square",
            "-webkit-user-drag": "none|element|auto",
            "-webkit-user-select": "auto|none|text|all",
            "alignment-baseline": "auto|baseline|before-edge|text-before-edge|middle|central|after-edge|text-after-edge|ideographic|alphabetic|hanging|mathematical",
            "baseline-shift": "baseline|sub|super|<svg-length>",
            behavior: "<url>+",
            "clip-rule": "nonzero|evenodd",
            container: "<'container-name'> [/ <'container-type'>]?",
            "container-name": "none|<custom-ident>+",
            "container-type": "normal||[size|inline-size]",
            cue: "<'cue-before'> <'cue-after'>?",
            "cue-after": "<url> <decibel>?|none",
            "cue-before": "<url> <decibel>?|none",
            "dominant-baseline": "auto|use-script|no-change|reset-size|ideographic|alphabetic|hanging|mathematical|central|middle|text-after-edge|text-before-edge",
            fill: "<paint>",
            "fill-opacity": "<number-zero-one>",
            "fill-rule": "nonzero|evenodd",
            "glyph-orientation-horizontal": "<angle>",
            "glyph-orientation-vertical": "<angle>",
            kerning: "auto|<svg-length>",
            marker: "none|<url>",
            "marker-end": "none|<url>",
            "marker-mid": "none|<url>",
            "marker-start": "none|<url>",
            pause: "<'pause-before'> <'pause-after'>?",
            "pause-after": "<time>|none|x-weak|weak|medium|strong|x-strong",
            "pause-before": "<time>|none|x-weak|weak|medium|strong|x-strong",
            rest: "<'rest-before'> <'rest-after'>?",
            "rest-after": "<time>|none|x-weak|weak|medium|strong|x-strong",
            "rest-before": "<time>|none|x-weak|weak|medium|strong|x-strong",
            "shape-rendering": "auto|optimizeSpeed|crispEdges|geometricPrecision",
            src: "[<url> [format( <string># )]?|local( <family-name> )]#",
            speak: "auto|none|normal",
            "speak-as": "normal|spell-out||digits||[literal-punctuation|no-punctuation]",
            stroke: "<paint>",
            "stroke-dasharray": "none|[<svg-length>+]#",
            "stroke-dashoffset": "<svg-length>",
            "stroke-linecap": "butt|round|square",
            "stroke-linejoin": "miter|round|bevel",
            "stroke-miterlimit": "<number-one-or-greater>",
            "stroke-opacity": "<number-zero-one>",
            "stroke-width": "<svg-length>",
            "text-anchor": "start|middle|end",
            "unicode-range": "<urange>#",
            "voice-balance": "<number>|left|center|right|leftwards|rightwards",
            "voice-duration": "auto|<time>",
            "voice-family": "[[<family-name>|<generic-voice>] ,]* [<family-name>|<generic-voice>]|preserve",
            "voice-pitch": "<frequency>&&absolute|[[x-low|low|medium|high|x-high]||[<frequency>|<semitones>|<percentage>]]",
            "voice-range": "<frequency>&&absolute|[[x-low|low|medium|high|x-high]||[<frequency>|<semitones>|<percentage>]]",
            "voice-rate": "[normal|x-slow|slow|medium|fast|x-fast]||<percentage>",
            "voice-stress": "normal|strong|moderate|none|reduced",
            "voice-volume": "silent|[[x-soft|soft|medium|loud|x-loud]||<decibel>]"
        },
        atrules: {
            charset: {
                prelude: "<string>",
                descriptors: null
            },
            "counter-style": {
                prelude: "<counter-style-name>",
                descriptors: {
                    "additive-symbols": "[<integer>&&<symbol>]#",
                    fallback: "<counter-style-name>",
                    negative: "<symbol> <symbol>?",
                    pad: "<integer>&&<symbol>",
                    prefix: "<symbol>",
                    range: "[[<integer>|infinite]{2}]#|auto",
                    "speak-as": "auto|bullets|numbers|words|spell-out|<counter-style-name>",
                    suffix: "<symbol>",
                    symbols: "<symbol>+",
                    system: "cyclic|numeric|alphabetic|symbolic|additive|[fixed <integer>?]|[extends <counter-style-name>]"
                }
            },
            document: {
                prelude: "[<url>|url-prefix( <string> )|domain( <string> )|media-document( <string> )|regexp( <string> )]#",
                descriptors: null
            },
            "font-face": {
                prelude: null,
                descriptors: {
                    "ascent-override": "normal|<percentage>",
                    "descent-override": "normal|<percentage>",
                    "font-display": "[auto|block|swap|fallback|optional]",
                    "font-family": "<family-name>",
                    "font-feature-settings": "normal|<feature-tag-value>#",
                    "font-variation-settings": "normal|[<string> <number>]#",
                    "font-stretch": "<font-stretch-absolute>{1,2}",
                    "font-style": "normal|italic|oblique <angle>{0,2}",
                    "font-weight": "<font-weight-absolute>{1,2}",
                    "font-variant": "normal|none|[<common-lig-values>||<discretionary-lig-values>||<historical-lig-values>||<contextual-alt-values>||stylistic( <feature-value-name> )||historical-forms||styleset( <feature-value-name># )||character-variant( <feature-value-name># )||swash( <feature-value-name> )||ornaments( <feature-value-name> )||annotation( <feature-value-name> )||[small-caps|all-small-caps|petite-caps|all-petite-caps|unicase|titling-caps]||<numeric-figure-values>||<numeric-spacing-values>||<numeric-fraction-values>||ordinal||slashed-zero||<east-asian-variant-values>||<east-asian-width-values>||ruby]",
                    "line-gap-override": "normal|<percentage>",
                    "size-adjust": "<percentage>",
                    src: "[<url> [format( <string># )]?|local( <family-name> )]#",
                    "unicode-range": "<urange>#"
                }
            },
            "font-feature-values": {
                prelude: "<family-name>#",
                descriptors: null
            },
            import: {
                prelude: "[<string>|<url>] [layer|layer( <layer-name> )]? [supports( [<supports-condition>|<declaration>] )]? <media-query-list>?",
                descriptors: null
            },
            keyframes: {
                prelude: "<keyframes-name>",
                descriptors: null
            },
            layer: {
                prelude: "[<layer-name>#|<layer-name>?]",
                descriptors: null
            },
            media: {
                prelude: "<media-query-list>",
                descriptors: null
            },
            namespace: {
                prelude: "<namespace-prefix>? [<string>|<url>]",
                descriptors: null
            },
            page: {
                prelude: "<page-selector-list>",
                descriptors: {
                    bleed: "auto|<length>",
                    marks: "none|[crop||cross]",
                    size: "<length>{1,2}|auto|[<page-size>||[portrait|landscape]]"
                }
            },
            property: {
                prelude: "<custom-property-name>",
                descriptors: {
                    syntax: "<string>",
                    inherits: "true|false",
                    "initial-value": "<string>"
                }
            },
            "scroll-timeline": {
                prelude: "<timeline-name>",
                descriptors: null
            },
            supports: {
                prelude: "<supports-condition>",
                descriptors: null
            },
            viewport: {
                prelude: null,
                descriptors: {
                    height: "<viewport-length>{1,2}",
                    "max-height": "<viewport-length>",
                    "max-width": "<viewport-length>",
                    "max-zoom": "auto|<number>|<percentage>",
                    "min-height": "<viewport-length>",
                    "min-width": "<viewport-length>",
                    "min-zoom": "auto|<number>|<percentage>",
                    orientation: "auto|portrait|landscape",
                    "user-zoom": "zoom|fixed",
                    "viewport-fit": "auto|contain|cover",
                    width: "<viewport-length>{1,2}",
                    zoom: "auto|<number>|<percentage>"
                }
            },
            container: {
                prelude: "[<container-name>]? <container-condition>",
                descriptors: null
            },
            nest: {
                prelude: "<complex-selector-list>",
                descriptors: null
            }
        }
    };
    var gt = {};
    b(gt, {
        AnPlusB: ()=>Xr,
        Atrule: ()=>Zr,
        AtrulePrelude: ()=>en,
        AttributeSelector: ()=>nn,
        Block: ()=>an,
        Brackets: ()=>ln,
        CDC: ()=>un,
        CDO: ()=>hn,
        ClassSelector: ()=>fn,
        Combinator: ()=>gn,
        Comment: ()=>xn,
        Declaration: ()=>kn,
        DeclarationList: ()=>Sn,
        Dimension: ()=>An,
        Function: ()=>En,
        Hash: ()=>Pn,
        IdSelector: ()=>Nn,
        Identifier: ()=>Dn,
        MediaFeature: ()=>Mn,
        MediaQuery: ()=>Fn,
        MediaQueryList: ()=>_n,
        NestingSelector: ()=>Un,
        Nth: ()=>Wn,
        Number: ()=>Yn,
        Operator: ()=>Vn,
        Parentheses: ()=>Qn,
        Percentage: ()=>$n,
        PseudoClassSelector: ()=>Jn,
        PseudoElementSelector: ()=>to,
        Ratio: ()=>no,
        Raw: ()=>io,
        Rule: ()=>so,
        Selector: ()=>co,
        SelectorList: ()=>po,
        String: ()=>bo,
        StyleSheet: ()=>yo,
        TypeSelector: ()=>vo,
        UnicodeRange: ()=>Ao,
        Url: ()=>Do,
        Value: ()=>No,
        WhiteSpace: ()=>Mo
    });
    var Xr = {};
    b(Xr, {
        generate: ()=>xc,
        name: ()=>gc,
        parse: ()=>Qr,
        structure: ()=>bc
    });
    var me = 43, re = 45, Xt = 110, Ie = !0, dc = !1;
    function $t(e, t) {
        let r = this.tokenStart + e, n = this.charCodeAt(r);
        for((n === me || n === re) && (t && this.error("Number sign is not allowed"), r++); r < this.tokenEnd; r++)B(this.charCodeAt(r)) || this.error("Integer is expected", r);
    }
    function Qe(e) {
        return $t.call(this, 0, e);
    }
    function Ce(e, t) {
        if (!this.cmpChar(this.tokenStart + e, t)) {
            let r = "";
            switch(t){
                case Xt:
                    r = "N is expected";
                    break;
                case re:
                    r = "HyphenMinus is expected";
                    break;
            }
            this.error(r, this.tokenStart + e);
        }
    }
    function Kr() {
        let e = 0, t = 0, r = this.tokenType;
        for(; r === 13 || r === 25;)r = this.lookupType(++e);
        if (r !== 10) {
            if (this.isDelim(me, e) || this.isDelim(re, e)) {
                t = this.isDelim(me, e) ? me : re;
                do r = this.lookupType(++e);
                while (r === 13 || r === 25);
                r !== 10 && (this.skip(e), Qe.call(this, Ie));
            } else return null;
        }
        return e > 0 && this.skip(e), t === 0 && (r = this.charCodeAt(this.tokenStart), r !== me && r !== re && this.error("Number sign is expected")), Qe.call(this, t !== 0), t === re ? "-" + this.consume(10) : this.consume(10);
    }
    var gc = "AnPlusB", bc = {
        a: [
            String,
            null
        ],
        b: [
            String,
            null
        ]
    };
    function Qr() {
        let e = this.tokenStart, t = null, r = null;
        if (this.tokenType === 10) Qe.call(this, dc), r = this.consume(10);
        else if (this.tokenType === 1 && this.cmpChar(this.tokenStart, re)) switch(t = "-1", Ce.call(this, 1, Xt), this.tokenEnd - this.tokenStart){
            case 2:
                this.next(), r = Kr.call(this);
                break;
            case 3:
                Ce.call(this, 2, re), this.next(), this.skipSC(), Qe.call(this, Ie), r = "-" + this.consume(10);
                break;
            default:
                Ce.call(this, 2, re), $t.call(this, 3, Ie), this.next(), r = this.substrToCursor(e + 2);
        }
        else if (this.tokenType === 1 || this.isDelim(me) && this.lookupType(1) === 1) {
            let n = 0;
            switch(t = "1", this.isDelim(me) && (n = 1, this.next()), Ce.call(this, 0, Xt), this.tokenEnd - this.tokenStart){
                case 1:
                    this.next(), r = Kr.call(this);
                    break;
                case 2:
                    Ce.call(this, 1, re), this.next(), this.skipSC(), Qe.call(this, Ie), r = "-" + this.consume(10);
                    break;
                default:
                    Ce.call(this, 1, re), $t.call(this, 2, Ie), this.next(), r = this.substrToCursor(e + n + 1);
            }
        } else if (this.tokenType === 12) {
            let n = this.charCodeAt(this.tokenStart), o = n === me || n === re, i = this.tokenStart + o;
            for(; i < this.tokenEnd && B(this.charCodeAt(i)); i++);
            i === this.tokenStart + o && this.error("Integer is expected", this.tokenStart + o), Ce.call(this, i - this.tokenStart, Xt), t = this.substring(e, i), i + 1 === this.tokenEnd ? (this.next(), r = Kr.call(this)) : (Ce.call(this, i - this.tokenStart + 1, re), i + 2 === this.tokenEnd ? (this.next(), this.skipSC(), Qe.call(this, Ie), r = "-" + this.consume(10)) : ($t.call(this, i - this.tokenStart + 2, Ie), this.next(), r = this.substrToCursor(i + 1)));
        } else this.error();
        return t !== null && t.charCodeAt(0) === me && (t = t.substr(1)), r !== null && r.charCodeAt(0) === me && (r = r.substr(1)), {
            type: "AnPlusB",
            loc: this.getLocation(e, this.tokenStart),
            a: t,
            b: r
        };
    }
    function xc(e) {
        if (e.a) {
            let t = e.a === "+1" && "n" || e.a === "1" && "n" || e.a === "-1" && "-n" || e.a + "n";
            if (e.b) {
                let r = e.b[0] === "-" || e.b[0] === "+" ? e.b : "+" + e.b;
                this.tokenize(t + r);
            } else this.tokenize(t);
        } else this.tokenize(e.b);
    }
    var Zr = {};
    b(Zr, {
        generate: ()=>Sc,
        name: ()=>kc,
        parse: ()=>$r,
        structure: ()=>vc,
        walkContext: ()=>wc
    });
    function da(e) {
        return this.Raw(e, this.consumeUntilLeftCurlyBracketOrSemicolon, !0);
    }
    function yc() {
        for(let e = 1, t; t = this.lookupType(e); e++){
            if (t === 24) return !0;
            if (t === 23 || t === 3) return !1;
        }
        return !1;
    }
    var kc = "Atrule", wc = "atrule", vc = {
        name: String,
        prelude: [
            "AtrulePrelude",
            "Raw",
            null
        ],
        block: [
            "Block",
            null
        ]
    };
    function $r(e = !1) {
        let t = this.tokenStart, r, n, o = null, i = null;
        switch(this.eat(3), r = this.substrToCursor(t + 1), n = r.toLowerCase(), this.skipSC(), this.eof === !1 && this.tokenType !== 23 && this.tokenType !== 17 && (this.parseAtrulePrelude ? o = this.parseWithFallback(this.AtrulePrelude.bind(this, r, e), da) : o = da.call(this, this.tokenIndex), this.skipSC()), this.tokenType){
            case 17:
                this.next();
                break;
            case 23:
                hasOwnProperty.call(this.atrule, n) && typeof this.atrule[n].block == "function" ? i = this.atrule[n].block.call(this, e) : i = this.Block(yc.call(this));
                break;
        }
        return {
            type: "Atrule",
            loc: this.getLocation(t, this.tokenStart),
            name: r,
            prelude: o,
            block: i
        };
    }
    function Sc(e) {
        this.token(3, "@" + e.name), e.prelude !== null && this.node(e.prelude), e.block ? this.node(e.block) : this.token(17, ";");
    }
    var en = {};
    b(en, {
        generate: ()=>Ec,
        name: ()=>Cc,
        parse: ()=>Jr,
        structure: ()=>Tc,
        walkContext: ()=>Ac
    });
    var Cc = "AtrulePrelude", Ac = "atrulePrelude", Tc = {
        children: [
            []
        ]
    };
    function Jr(e) {
        let t = null;
        return e !== null && (e = e.toLowerCase()), this.skipSC(), hasOwnProperty.call(this.atrule, e) && typeof this.atrule[e].prelude == "function" ? t = this.atrule[e].prelude.call(this) : t = this.readSequence(this.scope.AtrulePrelude), this.skipSC(), this.eof !== !0 && this.tokenType !== 23 && this.tokenType !== 17 && this.error("Semicolon or block is expected"), {
            type: "AtrulePrelude",
            loc: this.getLocationFromList(t),
            children: t
        };
    }
    function Ec(e) {
        this.children(e);
    }
    var nn = {};
    b(nn, {
        generate: ()=>Mc,
        name: ()=>Nc,
        parse: ()=>rn,
        structure: ()=>zc
    });
    var Lc = 36, ga = 42, Zt = 61, Pc = 94, tn = 124, Ic = 126;
    function Dc() {
        this.eof && this.error("Unexpected end of input");
        let e = this.tokenStart, t = !1;
        return this.isDelim(ga) ? (t = !0, this.next()) : this.isDelim(tn) || this.eat(1), this.isDelim(tn) ? this.charCodeAt(this.tokenStart + 1) !== Zt ? (this.next(), this.eat(1)) : t && this.error("Identifier is expected", this.tokenEnd) : t && this.error("Vertical line is expected"), {
            type: "Identifier",
            loc: this.getLocation(e, this.tokenStart),
            name: this.substrToCursor(e)
        };
    }
    function Oc() {
        let e = this.tokenStart, t = this.charCodeAt(e);
        return t !== Zt && t !== Ic && t !== Pc && t !== Lc && t !== ga && t !== tn && this.error("Attribute selector (=, ~=, ^=, $=, *=, |=) is expected"), this.next(), t !== Zt && (this.isDelim(Zt) || this.error("Equal sign is expected"), this.next()), this.substrToCursor(e);
    }
    var Nc = "AttributeSelector", zc = {
        name: "Identifier",
        matcher: [
            String,
            null
        ],
        value: [
            "String",
            "Identifier",
            null
        ],
        flags: [
            String,
            null
        ]
    };
    function rn() {
        let e = this.tokenStart, t, r = null, n = null, o = null;
        return this.eat(19), this.skipSC(), t = Dc.call(this), this.skipSC(), this.tokenType !== 20 && (this.tokenType !== 1 && (r = Oc.call(this), this.skipSC(), n = this.tokenType === 5 ? this.String() : this.Identifier(), this.skipSC()), this.tokenType === 1 && (o = this.consume(1), this.skipSC())), this.eat(20), {
            type: "AttributeSelector",
            loc: this.getLocation(e, this.tokenStart),
            name: t,
            matcher: r,
            value: n,
            flags: o
        };
    }
    function Mc(e) {
        this.token(9, "["), this.node(e.name), e.matcher !== null && (this.tokenize(e.matcher), this.node(e.value)), e.flags !== null && this.token(1, e.flags), this.token(9, "]");
    }
    var an = {};
    b(an, {
        generate: ()=>Uc,
        name: ()=>Bc,
        parse: ()=>on,
        structure: ()=>qc,
        walkContext: ()=>_c
    });
    var Rc = 38;
    function ya(e) {
        return this.Raw(e, null, !0);
    }
    function ba() {
        return this.parseWithFallback(this.Rule, ya);
    }
    function xa(e) {
        return this.Raw(e, this.consumeUntilSemicolonIncluded, !0);
    }
    function Fc() {
        if (this.tokenType === 17) return xa.call(this, this.tokenIndex);
        let e = this.parseWithFallback(this.Declaration, xa);
        return this.tokenType === 17 && this.next(), e;
    }
    var Bc = "Block", _c = "block", qc = {
        children: [
            [
                "Atrule",
                "Rule",
                "Declaration"
            ]
        ]
    };
    function on(e) {
        let t = e ? Fc : ba, r = this.tokenStart, n = this.createList();
        this.eat(23);
        e: for(; !this.eof;)switch(this.tokenType){
            case 24:
                break e;
            case 13:
            case 25:
                this.next();
                break;
            case 3:
                n.push(this.parseWithFallback(this.Atrule.bind(this, e), ya));
                break;
            default:
                e && this.isDelim(Rc) ? n.push(ba.call(this)) : n.push(t.call(this));
        }
        return this.eof || this.eat(24), {
            type: "Block",
            loc: this.getLocation(r, this.tokenStart),
            children: n
        };
    }
    function Uc(e) {
        this.token(23, "{"), this.children(e, (t)=>{
            t.type === "Declaration" && this.token(17, ";");
        }), this.token(24, "}");
    }
    var ln = {};
    b(ln, {
        generate: ()=>Hc,
        name: ()=>jc,
        parse: ()=>sn,
        structure: ()=>Wc
    });
    var jc = "Brackets", Wc = {
        children: [
            []
        ]
    };
    function sn(e, t) {
        let r = this.tokenStart, n = null;
        return this.eat(19), n = e.call(this, t), this.eof || this.eat(20), {
            type: "Brackets",
            loc: this.getLocation(r, this.tokenStart),
            children: n
        };
    }
    function Hc(e) {
        this.token(9, "["), this.children(e), this.token(9, "]");
    }
    var un = {};
    b(un, {
        generate: ()=>Vc,
        name: ()=>Yc,
        parse: ()=>cn,
        structure: ()=>Gc
    });
    var Yc = "CDC", Gc = [];
    function cn() {
        let e = this.tokenStart;
        return this.eat(15), {
            type: "CDC",
            loc: this.getLocation(e, this.tokenStart)
        };
    }
    function Vc() {
        this.token(15, "-->");
    }
    var hn = {};
    b(hn, {
        generate: ()=>Xc,
        name: ()=>Kc,
        parse: ()=>pn,
        structure: ()=>Qc
    });
    var Kc = "CDO", Qc = [];
    function pn() {
        let e = this.tokenStart;
        return this.eat(14), {
            type: "CDO",
            loc: this.getLocation(e, this.tokenStart)
        };
    }
    function Xc() {
        this.token(14, "<!--");
    }
    var fn = {};
    b(fn, {
        generate: ()=>eu,
        name: ()=>Zc,
        parse: ()=>mn,
        structure: ()=>Jc
    });
    var $c = 46, Zc = "ClassSelector", Jc = {
        name: String
    };
    function mn() {
        return this.eatDelim($c), {
            type: "ClassSelector",
            loc: this.getLocation(this.tokenStart - 1, this.tokenEnd),
            name: this.consume(1)
        };
    }
    function eu(e) {
        this.token(9, "."), this.token(1, e.name);
    }
    var gn = {};
    b(gn, {
        generate: ()=>au,
        name: ()=>ou,
        parse: ()=>dn,
        structure: ()=>iu
    });
    var tu = 43, ka = 47, ru = 62, nu = 126, ou = "Combinator", iu = {
        name: String
    };
    function dn() {
        let e = this.tokenStart, t;
        switch(this.tokenType){
            case 13:
                t = " ";
                break;
            case 9:
                switch(this.charCodeAt(this.tokenStart)){
                    case ru:
                    case tu:
                    case nu:
                        this.next();
                        break;
                    case ka:
                        this.next(), this.eatIdent("deep"), this.eatDelim(ka);
                        break;
                    default:
                        this.error("Combinator is expected");
                }
                t = this.substrToCursor(e);
                break;
        }
        return {
            type: "Combinator",
            loc: this.getLocation(e, this.tokenStart),
            name: t
        };
    }
    function au(e) {
        this.tokenize(e.name);
    }
    var xn = {};
    b(xn, {
        generate: ()=>pu,
        name: ()=>cu,
        parse: ()=>bn,
        structure: ()=>uu
    });
    var su = 42, lu = 47, cu = "Comment", uu = {
        value: String
    };
    function bn() {
        let e = this.tokenStart, t = this.tokenEnd;
        return this.eat(25), t - e + 2 >= 2 && this.charCodeAt(t - 2) === su && this.charCodeAt(t - 1) === lu && (t -= 2), {
            type: "Comment",
            loc: this.getLocation(e, this.tokenStart),
            value: this.substring(e + 2, t)
        };
    }
    function pu(e) {
        this.token(25, "/*" + e.value + "*/");
    }
    var kn = {};
    b(kn, {
        generate: ()=>Su,
        name: ()=>ku,
        parse: ()=>yn,
        structure: ()=>vu,
        walkContext: ()=>wu
    });
    var va = 33, hu = 35, mu = 36, fu = 38, du = 42, gu = 43, wa = 47;
    function bu(e) {
        return this.Raw(e, this.consumeUntilExclamationMarkOrSemicolon, !0);
    }
    function xu(e) {
        return this.Raw(e, this.consumeUntilExclamationMarkOrSemicolon, !1);
    }
    function yu() {
        let e = this.tokenIndex, t = this.Value();
        return t.type !== "Raw" && this.eof === !1 && this.tokenType !== 17 && this.isDelim(va) === !1 && this.isBalanceEdge(e) === !1 && this.error(), t;
    }
    var ku = "Declaration", wu = "declaration", vu = {
        important: [
            Boolean,
            String
        ],
        property: String,
        value: [
            "Value",
            "Raw"
        ]
    };
    function yn() {
        let e = this.tokenStart, t = this.tokenIndex, r = Cu.call(this), n = Mt(r), o = n ? this.parseCustomProperty : this.parseValue, i = n ? xu : bu, s = !1, u;
        this.skipSC(), this.eat(16);
        let c = this.tokenIndex;
        if (n || this.skipSC(), o ? u = this.parseWithFallback(yu, i) : u = i.call(this, this.tokenIndex), n && u.type === "Value" && u.children.isEmpty) {
            for(let a = c - this.tokenIndex; a <= 0; a++)if (this.lookupType(a) === 13) {
                u.children.appendData({
                    type: "WhiteSpace",
                    loc: null,
                    value: " "
                });
                break;
            }
        }
        return this.isDelim(va) && (s = Au.call(this), this.skipSC()), this.eof === !1 && this.tokenType !== 17 && this.isBalanceEdge(t) === !1 && this.error(), {
            type: "Declaration",
            loc: this.getLocation(e, this.tokenStart),
            important: s,
            property: r,
            value: u
        };
    }
    function Su(e) {
        this.token(1, e.property), this.token(16, ":"), this.node(e.value), e.important && (this.token(9, "!"), this.token(1, e.important === !0 ? "important" : e.important));
    }
    function Cu() {
        let e = this.tokenStart;
        if (this.tokenType === 9) switch(this.charCodeAt(this.tokenStart)){
            case du:
            case mu:
            case gu:
            case hu:
            case fu:
                this.next();
                break;
            case wa:
                this.next(), this.isDelim(wa) && this.next();
                break;
        }
        return this.tokenType === 4 ? this.eat(4) : this.eat(1), this.substrToCursor(e);
    }
    function Au() {
        this.eat(9), this.skipSC();
        let e = this.consume(1);
        return e === "important" ? !0 : e;
    }
    var Sn = {};
    b(Sn, {
        generate: ()=>Pu,
        name: ()=>Eu,
        parse: ()=>vn,
        structure: ()=>Lu
    });
    var Tu = 38;
    function wn(e) {
        return this.Raw(e, this.consumeUntilSemicolonIncluded, !0);
    }
    var Eu = "DeclarationList", Lu = {
        children: [
            [
                "Declaration",
                "Atrule",
                "Rule"
            ]
        ]
    };
    function vn() {
        let e = this.createList();
        for(; !this.eof;)switch(this.tokenType){
            case 13:
            case 25:
            case 17:
                this.next();
                break;
            case 3:
                e.push(this.parseWithFallback(this.Atrule.bind(this, !0), wn));
                break;
            default:
                this.isDelim(Tu) ? e.push(this.parseWithFallback(this.Rule, wn)) : e.push(this.parseWithFallback(this.Declaration, wn));
        }
        return {
            type: "DeclarationList",
            loc: this.getLocationFromList(e),
            children: e
        };
    }
    function Pu(e) {
        this.children(e, (t)=>{
            t.type === "Declaration" && this.token(17, ";");
        });
    }
    var An = {};
    b(An, {
        generate: ()=>Ou,
        name: ()=>Iu,
        parse: ()=>Cn,
        structure: ()=>Du
    });
    var Iu = "Dimension", Du = {
        value: String,
        unit: String
    };
    function Cn() {
        let e = this.tokenStart, t = this.consumeNumber(12);
        return {
            type: "Dimension",
            loc: this.getLocation(e, this.tokenStart),
            value: t,
            unit: this.substring(e + t.length, this.tokenStart)
        };
    }
    function Ou(e) {
        this.token(12, e.value + e.unit);
    }
    var En = {};
    b(En, {
        generate: ()=>Ru,
        name: ()=>Nu,
        parse: ()=>Tn,
        structure: ()=>Mu,
        walkContext: ()=>zu
    });
    var Nu = "Function", zu = "function", Mu = {
        name: String,
        children: [
            []
        ]
    };
    function Tn(e, t) {
        let r = this.tokenStart, n = this.consumeFunctionName(), o = n.toLowerCase(), i;
        return i = t.hasOwnProperty(o) ? t[o].call(this, t) : e.call(this, t), this.eof || this.eat(22), {
            type: "Function",
            loc: this.getLocation(r, this.tokenStart),
            name: n,
            children: i
        };
    }
    function Ru(e) {
        this.token(2, e.name + "("), this.children(e), this.token(22, ")");
    }
    var Pn = {};
    b(Pn, {
        generate: ()=>qu,
        name: ()=>Bu,
        parse: ()=>Ln,
        structure: ()=>_u,
        xxx: ()=>Fu
    });
    var Fu = "XXX", Bu = "Hash", _u = {
        value: String
    };
    function Ln() {
        let e = this.tokenStart;
        return this.eat(4), {
            type: "Hash",
            loc: this.getLocation(e, this.tokenStart),
            value: this.substrToCursor(e + 1)
        };
    }
    function qu(e) {
        this.token(4, "#" + e.value);
    }
    var Dn = {};
    b(Dn, {
        generate: ()=>Wu,
        name: ()=>Uu,
        parse: ()=>In,
        structure: ()=>ju
    });
    var Uu = "Identifier", ju = {
        name: String
    };
    function In() {
        return {
            type: "Identifier",
            loc: this.getLocation(this.tokenStart, this.tokenEnd),
            name: this.consume(1)
        };
    }
    function Wu(e) {
        this.token(1, e.name);
    }
    var Nn = {};
    b(Nn, {
        generate: ()=>Gu,
        name: ()=>Hu,
        parse: ()=>On,
        structure: ()=>Yu
    });
    var Hu = "IdSelector", Yu = {
        name: String
    };
    function On() {
        let e = this.tokenStart;
        return this.eat(4), {
            type: "IdSelector",
            loc: this.getLocation(e, this.tokenStart),
            name: this.substrToCursor(e + 1)
        };
    }
    function Gu(e) {
        this.token(9, "#" + e.name);
    }
    var Mn = {};
    b(Mn, {
        generate: ()=>Qu,
        name: ()=>Vu,
        parse: ()=>zn,
        structure: ()=>Ku
    });
    var Vu = "MediaFeature", Ku = {
        name: String,
        value: [
            "Identifier",
            "Number",
            "Dimension",
            "Ratio",
            null
        ]
    };
    function zn() {
        let e = this.tokenStart, t, r = null;
        if (this.eat(21), this.skipSC(), t = this.consume(1), this.skipSC(), this.tokenType !== 22) {
            switch(this.eat(16), this.skipSC(), this.tokenType){
                case 10:
                    this.lookupNonWSType(1) === 9 ? r = this.Ratio() : r = this.Number();
                    break;
                case 12:
                    r = this.Dimension();
                    break;
                case 1:
                    r = this.Identifier();
                    break;
                default:
                    this.error("Number, dimension, ratio or identifier is expected");
            }
            this.skipSC();
        }
        return this.eat(22), {
            type: "MediaFeature",
            loc: this.getLocation(e, this.tokenStart),
            name: t,
            value: r
        };
    }
    function Qu(e) {
        this.token(21, "("), this.token(1, e.name), e.value !== null && (this.token(16, ":"), this.node(e.value)), this.token(22, ")");
    }
    var Fn = {};
    b(Fn, {
        generate: ()=>Zu,
        name: ()=>Xu,
        parse: ()=>Rn,
        structure: ()=>$u
    });
    var Xu = "MediaQuery", $u = {
        children: [
            [
                "Identifier",
                "MediaFeature",
                "WhiteSpace"
            ]
        ]
    };
    function Rn() {
        let e = this.createList(), t = null;
        this.skipSC();
        e: for(; !this.eof;){
            switch(this.tokenType){
                case 25:
                case 13:
                    this.next();
                    continue;
                case 1:
                    t = this.Identifier();
                    break;
                case 21:
                    t = this.MediaFeature();
                    break;
                default:
                    break e;
            }
            e.push(t);
        }
        return t === null && this.error("Identifier or parenthesis is expected"), {
            type: "MediaQuery",
            loc: this.getLocationFromList(e),
            children: e
        };
    }
    function Zu(e) {
        this.children(e);
    }
    var _n = {};
    b(_n, {
        generate: ()=>tp,
        name: ()=>Ju,
        parse: ()=>Bn,
        structure: ()=>ep
    });
    var Ju = "MediaQueryList", ep = {
        children: [
            [
                "MediaQuery"
            ]
        ]
    };
    function Bn() {
        let e = this.createList();
        for(this.skipSC(); !this.eof && (e.push(this.MediaQuery()), this.tokenType === 18);)this.next();
        return {
            type: "MediaQueryList",
            loc: this.getLocationFromList(e),
            children: e
        };
    }
    function tp(e) {
        this.children(e, ()=>this.token(18, ","));
    }
    var Un = {};
    b(Un, {
        generate: ()=>ip,
        name: ()=>np,
        parse: ()=>qn,
        structure: ()=>op
    });
    var rp = 38, np = "NestingSelector", op = {};
    function qn() {
        let e = this.tokenStart;
        return this.eatDelim(rp), {
            type: "NestingSelector",
            loc: this.getLocation(e, this.tokenStart)
        };
    }
    function ip() {
        this.token(9, "&");
    }
    var Wn = {};
    b(Wn, {
        generate: ()=>lp,
        name: ()=>ap,
        parse: ()=>jn,
        structure: ()=>sp
    });
    var ap = "Nth", sp = {
        nth: [
            "AnPlusB",
            "Identifier"
        ],
        selector: [
            "SelectorList",
            null
        ]
    };
    function jn() {
        this.skipSC();
        let e = this.tokenStart, t = e, r = null, n;
        return this.lookupValue(0, "odd") || this.lookupValue(0, "even") ? n = this.Identifier() : n = this.AnPlusB(), t = this.tokenStart, this.skipSC(), this.lookupValue(0, "of") && (this.next(), r = this.SelectorList(), t = this.tokenStart), {
            type: "Nth",
            loc: this.getLocation(e, t),
            nth: n,
            selector: r
        };
    }
    function lp(e) {
        this.node(e.nth), e.selector !== null && (this.token(1, "of"), this.node(e.selector));
    }
    var Yn = {};
    b(Yn, {
        generate: ()=>pp,
        name: ()=>cp,
        parse: ()=>Hn,
        structure: ()=>up
    });
    var cp = "Number", up = {
        value: String
    };
    function Hn() {
        return {
            type: "Number",
            loc: this.getLocation(this.tokenStart, this.tokenEnd),
            value: this.consume(10)
        };
    }
    function pp(e) {
        this.token(10, e.value);
    }
    var Vn = {};
    b(Vn, {
        generate: ()=>fp,
        name: ()=>hp,
        parse: ()=>Gn,
        structure: ()=>mp
    });
    var hp = "Operator", mp = {
        value: String
    };
    function Gn() {
        let e = this.tokenStart;
        return this.next(), {
            type: "Operator",
            loc: this.getLocation(e, this.tokenStart),
            value: this.substrToCursor(e)
        };
    }
    function fp(e) {
        this.tokenize(e.value);
    }
    var Qn = {};
    b(Qn, {
        generate: ()=>bp,
        name: ()=>dp,
        parse: ()=>Kn,
        structure: ()=>gp
    });
    var dp = "Parentheses", gp = {
        children: [
            []
        ]
    };
    function Kn(e, t) {
        let r = this.tokenStart, n = null;
        return this.eat(21), n = e.call(this, t), this.eof || this.eat(22), {
            type: "Parentheses",
            loc: this.getLocation(r, this.tokenStart),
            children: n
        };
    }
    function bp(e) {
        this.token(21, "("), this.children(e), this.token(22, ")");
    }
    var $n = {};
    b($n, {
        generate: ()=>kp,
        name: ()=>xp,
        parse: ()=>Xn,
        structure: ()=>yp
    });
    var xp = "Percentage", yp = {
        value: String
    };
    function Xn() {
        return {
            type: "Percentage",
            loc: this.getLocation(this.tokenStart, this.tokenEnd),
            value: this.consumeNumber(11)
        };
    }
    function kp(e) {
        this.token(11, e.value + "%");
    }
    var Jn = {};
    b(Jn, {
        generate: ()=>Cp,
        name: ()=>wp,
        parse: ()=>Zn,
        structure: ()=>Sp,
        walkContext: ()=>vp
    });
    var wp = "PseudoClassSelector", vp = "function", Sp = {
        name: String,
        children: [
            [
                "Raw"
            ],
            null
        ]
    };
    function Zn() {
        let e = this.tokenStart, t = null, r, n;
        return this.eat(16), this.tokenType === 2 ? (r = this.consumeFunctionName(), n = r.toLowerCase(), hasOwnProperty.call(this.pseudo, n) ? (this.skipSC(), t = this.pseudo[n].call(this), this.skipSC()) : (t = this.createList(), t.push(this.Raw(this.tokenIndex, null, !1))), this.eat(22)) : r = this.consume(1), {
            type: "PseudoClassSelector",
            loc: this.getLocation(e, this.tokenStart),
            name: r,
            children: t
        };
    }
    function Cp(e) {
        this.token(16, ":"), e.children === null ? this.token(1, e.name) : (this.token(2, e.name + "("), this.children(e), this.token(22, ")"));
    }
    var to = {};
    b(to, {
        generate: ()=>Lp,
        name: ()=>Ap,
        parse: ()=>eo,
        structure: ()=>Ep,
        walkContext: ()=>Tp
    });
    var Ap = "PseudoElementSelector", Tp = "function", Ep = {
        name: String,
        children: [
            [
                "Raw"
            ],
            null
        ]
    };
    function eo() {
        let e = this.tokenStart, t = null, r, n;
        return this.eat(16), this.eat(16), this.tokenType === 2 ? (r = this.consumeFunctionName(), n = r.toLowerCase(), hasOwnProperty.call(this.pseudo, n) ? (this.skipSC(), t = this.pseudo[n].call(this), this.skipSC()) : (t = this.createList(), t.push(this.Raw(this.tokenIndex, null, !1))), this.eat(22)) : r = this.consume(1), {
            type: "PseudoElementSelector",
            loc: this.getLocation(e, this.tokenStart),
            name: r,
            children: t
        };
    }
    function Lp(e) {
        this.token(16, ":"), this.token(16, ":"), e.children === null ? this.token(1, e.name) : (this.token(2, e.name + "("), this.children(e), this.token(22, ")"));
    }
    var no = {};
    b(no, {
        generate: ()=>Np,
        name: ()=>Dp,
        parse: ()=>ro,
        structure: ()=>Op
    });
    var Pp = 47, Ip = 46;
    function Sa() {
        this.skipSC();
        let e = this.consume(10);
        for(let t = 0; t < e.length; t++){
            let r = e.charCodeAt(t);
            !B(r) && r !== Ip && this.error("Unsigned number is expected", this.tokenStart - e.length + t);
        }
        return Number(e) === 0 && this.error("Zero number is not allowed", this.tokenStart - e.length), e;
    }
    var Dp = "Ratio", Op = {
        left: String,
        right: String
    };
    function ro() {
        let e = this.tokenStart, t = Sa.call(this), r;
        return this.skipSC(), this.eatDelim(Pp), r = Sa.call(this), {
            type: "Ratio",
            loc: this.getLocation(e, this.tokenStart),
            left: t,
            right: r
        };
    }
    function Np(e) {
        this.token(10, e.left), this.token(9, "/"), this.token(10, e.right);
    }
    var io = {};
    b(io, {
        generate: ()=>Fp,
        name: ()=>Mp,
        parse: ()=>oo,
        structure: ()=>Rp
    });
    function zp() {
        return this.tokenIndex > 0 && this.lookupType(-1) === 13 ? this.tokenIndex > 1 ? this.getTokenStart(this.tokenIndex - 1) : this.firstCharOffset : this.tokenStart;
    }
    var Mp = "Raw", Rp = {
        value: String
    };
    function oo(e, t, r) {
        let n = this.getTokenStart(e), o;
        return this.skipUntilBalanced(e, t || this.consumeUntilBalanceEnd), r && this.tokenStart > n ? o = zp.call(this) : o = this.tokenStart, {
            type: "Raw",
            loc: this.getLocation(n, o),
            value: this.substring(n, o)
        };
    }
    function Fp(e) {
        this.tokenize(e.value);
    }
    var so = {};
    b(so, {
        generate: ()=>jp,
        name: ()=>_p,
        parse: ()=>ao,
        structure: ()=>Up,
        walkContext: ()=>qp
    });
    function Ca(e) {
        return this.Raw(e, this.consumeUntilLeftCurlyBracket, !0);
    }
    function Bp() {
        let e = this.SelectorList();
        return e.type !== "Raw" && this.eof === !1 && this.tokenType !== 23 && this.error(), e;
    }
    var _p = "Rule", qp = "rule", Up = {
        prelude: [
            "SelectorList",
            "Raw"
        ],
        block: [
            "Block"
        ]
    };
    function ao() {
        let e = this.tokenIndex, t = this.tokenStart, r, n;
        return this.parseRulePrelude ? r = this.parseWithFallback(Bp, Ca) : r = Ca.call(this, e), n = this.Block(!0), {
            type: "Rule",
            loc: this.getLocation(t, this.tokenStart),
            prelude: r,
            block: n
        };
    }
    function jp(e) {
        this.node(e.prelude), this.node(e.block);
    }
    var co = {};
    b(co, {
        generate: ()=>Yp,
        name: ()=>Wp,
        parse: ()=>lo,
        structure: ()=>Hp
    });
    var Wp = "Selector", Hp = {
        children: [
            [
                "TypeSelector",
                "IdSelector",
                "ClassSelector",
                "AttributeSelector",
                "PseudoClassSelector",
                "PseudoElementSelector",
                "Combinator",
                "WhiteSpace"
            ]
        ]
    };
    function lo() {
        let e = this.readSequence(this.scope.Selector);
        return this.getFirstListNode(e) === null && this.error("Selector is expected"), {
            type: "Selector",
            loc: this.getLocationFromList(e),
            children: e
        };
    }
    function Yp(e) {
        this.children(e);
    }
    var po = {};
    b(po, {
        generate: ()=>Qp,
        name: ()=>Gp,
        parse: ()=>uo,
        structure: ()=>Kp,
        walkContext: ()=>Vp
    });
    var Gp = "SelectorList", Vp = "selector", Kp = {
        children: [
            [
                "Selector",
                "Raw"
            ]
        ]
    };
    function uo() {
        let e = this.createList();
        for(; !this.eof;){
            if (e.push(this.Selector()), this.tokenType === 18) {
                this.next();
                continue;
            }
            break;
        }
        return {
            type: "SelectorList",
            loc: this.getLocationFromList(e),
            children: e
        };
    }
    function Qp(e) {
        this.children(e, ()=>this.token(18, ","));
    }
    var bo = {};
    b(bo, {
        generate: ()=>Zp,
        name: ()=>Xp,
        parse: ()=>go,
        structure: ()=>$p
    });
    var fo = {};
    b(fo, {
        decode: ()=>ft,
        encode: ()=>mo
    });
    var ho = 92, Aa = 34, Ta = 39;
    function ft(e) {
        let t = e.length, r = e.charCodeAt(0), n = r === Aa || r === Ta ? 1 : 0, o = n === 1 && t > 1 && e.charCodeAt(t - 1) === r ? t - 2 : t - 1, i = "";
        for(let s = n; s <= o; s++){
            let u = e.charCodeAt(s);
            if (u === ho) {
                if (s === o) {
                    s !== t - 1 && (i = e.substr(s + 1));
                    break;
                }
                if (u = e.charCodeAt(++s), $(ho, u)) {
                    let c = s - 1, a = se(e, c);
                    s = a - 1, i += Re(e.substring(c + 1, a));
                } else u === 13 && e.charCodeAt(s + 1) === 10 && s++;
            } else i += e[s];
        }
        return i;
    }
    function mo(e, t) {
        let r = t ? "'" : '"', n = t ? Ta : Aa, o = "", i = !1;
        for(let s = 0; s < e.length; s++){
            let u = e.charCodeAt(s);
            if (u === 0) {
                o += "\uFFFD";
                continue;
            }
            if (u <= 31 || u === 127) {
                o += "\\" + u.toString(16), i = !0;
                continue;
            }
            u === n || u === ho ? (o += "\\" + e.charAt(s), i = !1) : (i && (ee(u) || pe(u)) && (o += " "), o += e.charAt(s), i = !1);
        }
        return r + o + r;
    }
    var Xp = "String", $p = {
        value: String
    };
    function go() {
        return {
            type: "String",
            loc: this.getLocation(this.tokenStart, this.tokenEnd),
            value: ft(this.consume(5))
        };
    }
    function Zp(e) {
        this.token(5, mo(e.value));
    }
    var yo = {};
    b(yo, {
        generate: ()=>nh,
        name: ()=>eh,
        parse: ()=>xo,
        structure: ()=>rh,
        walkContext: ()=>th
    });
    var Jp = 33;
    function Ea(e) {
        return this.Raw(e, null, !1);
    }
    var eh = "StyleSheet", th = "stylesheet", rh = {
        children: [
            [
                "Comment",
                "CDO",
                "CDC",
                "Atrule",
                "Rule",
                "Raw"
            ]
        ]
    };
    function xo() {
        let e = this.tokenStart, t = this.createList(), r;
        for(; !this.eof;){
            switch(this.tokenType){
                case 13:
                    this.next();
                    continue;
                case 25:
                    if (this.charCodeAt(this.tokenStart + 2) !== Jp) {
                        this.next();
                        continue;
                    }
                    r = this.Comment();
                    break;
                case 14:
                    r = this.CDO();
                    break;
                case 15:
                    r = this.CDC();
                    break;
                case 3:
                    r = this.parseWithFallback(this.Atrule, Ea);
                    break;
                default:
                    r = this.parseWithFallback(this.Rule, Ea);
            }
            t.push(r);
        }
        return {
            type: "StyleSheet",
            loc: this.getLocation(e, this.tokenStart),
            children: t
        };
    }
    function nh(e) {
        this.children(e);
    }
    var vo = {};
    b(vo, {
        generate: ()=>sh,
        name: ()=>ih,
        parse: ()=>wo,
        structure: ()=>ah
    });
    var oh = 42, La = 124;
    function ko() {
        this.tokenType !== 1 && this.isDelim(oh) === !1 && this.error("Identifier or asterisk is expected"), this.next();
    }
    var ih = "TypeSelector", ah = {
        name: String
    };
    function wo() {
        let e = this.tokenStart;
        return this.isDelim(La) ? (this.next(), ko.call(this)) : (ko.call(this), this.isDelim(La) && (this.next(), ko.call(this))), {
            type: "TypeSelector",
            loc: this.getLocation(e, this.tokenStart),
            name: this.substrToCursor(e)
        };
    }
    function sh(e) {
        this.tokenize(e.name);
    }
    var Ao = {};
    b(Ao, {
        generate: ()=>hh,
        name: ()=>uh,
        parse: ()=>Co,
        structure: ()=>ph
    });
    var Pa = 43, Ia = 45, So = 63;
    function dt(e, t) {
        let r = 0;
        for(let n = this.tokenStart + e; n < this.tokenEnd; n++){
            let o = this.charCodeAt(n);
            if (o === Ia && t && r !== 0) return dt.call(this, e + r + 1, !1), -1;
            ee(o) || this.error(t && r !== 0 ? "Hyphen minus" + (r < 6 ? " or hex digit" : "") + " is expected" : r < 6 ? "Hex digit is expected" : "Unexpected input", n), ++r > 6 && this.error("Too many hex digits", n);
        }
        return this.next(), r;
    }
    function Jt(e) {
        let t = 0;
        for(; this.isDelim(So);)++t > e && this.error("Too many question marks"), this.next();
    }
    function lh(e) {
        this.charCodeAt(this.tokenStart) !== e && this.error((e === Pa ? "Plus sign" : "Hyphen minus") + " is expected");
    }
    function ch() {
        let e = 0;
        switch(this.tokenType){
            case 10:
                if (e = dt.call(this, 1, !0), this.isDelim(So)) {
                    Jt.call(this, 6 - e);
                    break;
                }
                if (this.tokenType === 12 || this.tokenType === 10) {
                    lh.call(this, Ia), dt.call(this, 1, !1);
                    break;
                }
                break;
            case 12:
                e = dt.call(this, 1, !0), e > 0 && Jt.call(this, 6 - e);
                break;
            default:
                if (this.eatDelim(Pa), this.tokenType === 1) {
                    e = dt.call(this, 0, !0), e > 0 && Jt.call(this, 6 - e);
                    break;
                }
                if (this.isDelim(So)) {
                    this.next(), Jt.call(this, 5);
                    break;
                }
                this.error("Hex digit or question mark is expected");
        }
    }
    var uh = "UnicodeRange", ph = {
        value: String
    };
    function Co() {
        let e = this.tokenStart;
        return this.eatIdent("u"), ch.call(this), {
            type: "UnicodeRange",
            loc: this.getLocation(e, this.tokenStart),
            value: this.substrToCursor(e)
        };
    }
    function hh(e) {
        this.tokenize(e.value);
    }
    var Do = {};
    b(Do, {
        generate: ()=>yh,
        name: ()=>bh,
        parse: ()=>Io,
        structure: ()=>xh
    });
    var Po = {};
    b(Po, {
        decode: ()=>Eo,
        encode: ()=>Lo
    });
    var mh = 32, To = 92, fh = 34, dh = 39, gh = 40, Da = 41;
    function Eo(e) {
        let t = e.length, r = 4, n = e.charCodeAt(t - 1) === Da ? t - 2 : t - 1, o = "";
        for(; r < n && pe(e.charCodeAt(r));)r++;
        for(; r < n && pe(e.charCodeAt(n));)n--;
        for(let i = r; i <= n; i++){
            let s = e.charCodeAt(i);
            if (s === To) {
                if (i === n) {
                    i !== t - 1 && (o = e.substr(i + 1));
                    break;
                }
                if (s = e.charCodeAt(++i), $(To, s)) {
                    let u = i - 1, c = se(e, u);
                    i = c - 1, o += Re(e.substring(u + 1, c));
                } else s === 13 && e.charCodeAt(i + 1) === 10 && i++;
            } else o += e[i];
        }
        return o;
    }
    function Lo(e) {
        let t = "", r = !1;
        for(let n = 0; n < e.length; n++){
            let o = e.charCodeAt(n);
            if (o === 0) {
                t += "\uFFFD";
                continue;
            }
            if (o <= 31 || o === 127) {
                t += "\\" + o.toString(16), r = !0;
                continue;
            }
            o === mh || o === To || o === fh || o === dh || o === gh || o === Da ? (t += "\\" + e.charAt(n), r = !1) : (r && ee(o) && (t += " "), t += e.charAt(n), r = !1);
        }
        return "url(" + t + ")";
    }
    var bh = "Url", xh = {
        value: String
    };
    function Io() {
        let e = this.tokenStart, t;
        switch(this.tokenType){
            case 7:
                t = Eo(this.consume(7));
                break;
            case 2:
                this.cmpStr(this.tokenStart, this.tokenEnd, "url(") || this.error("Function name must be `url`"), this.eat(2), this.skipSC(), t = ft(this.consume(5)), this.skipSC(), this.eof || this.eat(22);
                break;
            default:
                this.error("Url or Function is expected");
        }
        return {
            type: "Url",
            loc: this.getLocation(e, this.tokenStart),
            value: t
        };
    }
    function yh(e) {
        this.token(7, Lo(e.value));
    }
    var No = {};
    b(No, {
        generate: ()=>vh,
        name: ()=>kh,
        parse: ()=>Oo,
        structure: ()=>wh
    });
    var kh = "Value", wh = {
        children: [
            []
        ]
    };
    function Oo() {
        let e = this.tokenStart, t = this.readSequence(this.scope.Value);
        return {
            type: "Value",
            loc: this.getLocation(e, this.tokenStart),
            children: t
        };
    }
    function vh(e) {
        this.children(e);
    }
    var Mo = {};
    b(Mo, {
        generate: ()=>Th,
        name: ()=>Ch,
        parse: ()=>zo,
        structure: ()=>Ah
    });
    var Sh = Object.freeze({
        type: "WhiteSpace",
        loc: null,
        value: " "
    }), Ch = "WhiteSpace", Ah = {
        value: String
    };
    function zo() {
        return this.eat(13), Sh;
    }
    function Th(e) {
        this.token(13, e.value);
    }
    var Oa = {
        generic: !0,
        ...fa,
        node: gt
    };
    var Ro = {};
    b(Ro, {
        AtrulePrelude: ()=>za,
        Selector: ()=>Ra,
        Value: ()=>qa
    });
    var Eh = 35, Lh = 42, Na = 43, Ph = 45, Ih = 47, Dh = 117;
    function bt(e) {
        switch(this.tokenType){
            case 4:
                return this.Hash();
            case 18:
                return this.Operator();
            case 21:
                return this.Parentheses(this.readSequence, e.recognizer);
            case 19:
                return this.Brackets(this.readSequence, e.recognizer);
            case 5:
                return this.String();
            case 12:
                return this.Dimension();
            case 11:
                return this.Percentage();
            case 10:
                return this.Number();
            case 2:
                return this.cmpStr(this.tokenStart, this.tokenEnd, "url(") ? this.Url() : this.Function(this.readSequence, e.recognizer);
            case 7:
                return this.Url();
            case 1:
                return this.cmpChar(this.tokenStart, Dh) && this.cmpChar(this.tokenStart + 1, Na) ? this.UnicodeRange() : this.Identifier();
            case 9:
                {
                    let t = this.charCodeAt(this.tokenStart);
                    if (t === Ih || t === Lh || t === Na || t === Ph) return this.Operator();
                    t === Eh && this.error("Hex or identifier is expected", this.tokenStart + 1);
                    break;
                }
        }
    }
    var za = {
        getNode: bt
    };
    var Oh = 35, Nh = 38, zh = 42, Mh = 43, Rh = 47, Ma = 46, Fh = 62, Bh = 124, _h = 126;
    function qh(e, t) {
        t.last !== null && t.last.type !== "Combinator" && e !== null && e.type !== "Combinator" && t.push({
            type: "Combinator",
            loc: null,
            name: " "
        });
    }
    function Uh() {
        switch(this.tokenType){
            case 19:
                return this.AttributeSelector();
            case 4:
                return this.IdSelector();
            case 16:
                return this.lookupType(1) === 16 ? this.PseudoElementSelector() : this.PseudoClassSelector();
            case 1:
                return this.TypeSelector();
            case 10:
            case 11:
                return this.Percentage();
            case 12:
                this.charCodeAt(this.tokenStart) === Ma && this.error("Identifier is expected", this.tokenStart + 1);
                break;
            case 9:
                switch(this.charCodeAt(this.tokenStart)){
                    case Mh:
                    case Fh:
                    case _h:
                    case Rh:
                        return this.Combinator();
                    case Ma:
                        return this.ClassSelector();
                    case zh:
                    case Bh:
                        return this.TypeSelector();
                    case Oh:
                        return this.IdSelector();
                    case Nh:
                        return this.NestingSelector();
                }
                break;
        }
    }
    var Ra = {
        onWhiteSpace: qh,
        getNode: Uh
    };
    function Fa() {
        return this.createSingleNodeList(this.Raw(this.tokenIndex, null, !1));
    }
    function Ba() {
        let e = this.createList();
        if (this.skipSC(), e.push(this.Identifier()), this.skipSC(), this.tokenType === 18) {
            e.push(this.Operator());
            let t = this.tokenIndex, r = this.parseCustomProperty ? this.Value(null) : this.Raw(this.tokenIndex, this.consumeUntilExclamationMarkOrSemicolon, !1);
            if (r.type === "Value" && r.children.isEmpty) {
                for(let n = t - this.tokenIndex; n <= 0; n++)if (this.lookupType(n) === 13) {
                    r.children.appendData({
                        type: "WhiteSpace",
                        loc: null,
                        value: " "
                    });
                    break;
                }
            }
            e.push(r);
        }
        return e;
    }
    function _a(e) {
        return e !== null && e.type === "Operator" && (e.value[e.value.length - 1] === "-" || e.value[e.value.length - 1] === "+");
    }
    var qa = {
        getNode: bt,
        onWhiteSpace (e, t) {
            _a(e) && (e.value = " " + e.value), _a(t.last) && (t.last.value += " ");
        },
        expression: Fa,
        var: Ba
    };
    var Ua = {
        parse: {
            prelude: null,
            block () {
                return this.Block(!0);
            }
        }
    };
    var ja = {
        parse: {
            prelude () {
                let e = this.createList();
                switch(this.skipSC(), this.tokenType){
                    case 5:
                        e.push(this.String());
                        break;
                    case 7:
                    case 2:
                        e.push(this.Url());
                        break;
                    default:
                        this.error("String or url() is expected");
                }
                return (this.lookupNonWSType(0) === 1 || this.lookupNonWSType(0) === 21) && e.push(this.MediaQueryList()), e;
            },
            block: null
        }
    };
    var Wa = {
        parse: {
            prelude () {
                return this.createSingleNodeList(this.MediaQueryList());
            },
            block (e = !1) {
                return this.Block(e);
            }
        }
    };
    var Ha = {
        parse: {
            prelude () {
                return this.createSingleNodeList(this.SelectorList());
            },
            block () {
                return this.Block(!0);
            }
        }
    };
    var Ya = {
        parse: {
            prelude () {
                return this.createSingleNodeList(this.SelectorList());
            },
            block () {
                return this.Block(!0);
            }
        }
    };
    function jh() {
        return this.createSingleNodeList(this.Raw(this.tokenIndex, null, !1));
    }
    function Wh() {
        return this.skipSC(), this.tokenType === 1 && this.lookupNonWSType(1) === 16 ? this.createSingleNodeList(this.Declaration()) : Ga.call(this);
    }
    function Ga() {
        let e = this.createList(), t;
        this.skipSC();
        e: for(; !this.eof;){
            switch(this.tokenType){
                case 25:
                case 13:
                    this.next();
                    continue;
                case 2:
                    t = this.Function(jh, this.scope.AtrulePrelude);
                    break;
                case 1:
                    t = this.Identifier();
                    break;
                case 21:
                    t = this.Parentheses(Wh, this.scope.AtrulePrelude);
                    break;
                default:
                    break e;
            }
            e.push(t);
        }
        return e;
    }
    var Va = {
        parse: {
            prelude () {
                let e = Ga.call(this);
                return this.getFirstListNode(e) === null && this.error("Condition is expected"), e;
            },
            block (e = !1) {
                return this.Block(e);
            }
        }
    };
    var Ka = {
        "font-face": Ua,
        import: ja,
        media: Wa,
        nest: Ha,
        page: Ya,
        supports: Va
    };
    var De = {
        parse () {
            return this.createSingleNodeList(this.SelectorList());
        }
    }, Fo = {
        parse () {
            return this.createSingleNodeList(this.Selector());
        }
    }, Qa = {
        parse () {
            return this.createSingleNodeList(this.Identifier());
        }
    }, er = {
        parse () {
            return this.createSingleNodeList(this.Nth());
        }
    }, Xa = {
        dir: Qa,
        has: De,
        lang: Qa,
        matches: De,
        is: De,
        "-moz-any": De,
        "-webkit-any": De,
        where: De,
        not: De,
        "nth-child": er,
        "nth-last-child": er,
        "nth-last-of-type": er,
        "nth-of-type": er,
        slotted: Fo,
        host: Fo,
        "host-context": Fo
    };
    var Bo = {};
    b(Bo, {
        AnPlusB: ()=>Qr,
        Atrule: ()=>$r,
        AtrulePrelude: ()=>Jr,
        AttributeSelector: ()=>rn,
        Block: ()=>on,
        Brackets: ()=>sn,
        CDC: ()=>cn,
        CDO: ()=>pn,
        ClassSelector: ()=>mn,
        Combinator: ()=>dn,
        Comment: ()=>bn,
        Declaration: ()=>yn,
        DeclarationList: ()=>vn,
        Dimension: ()=>Cn,
        Function: ()=>Tn,
        Hash: ()=>Ln,
        IdSelector: ()=>On,
        Identifier: ()=>In,
        MediaFeature: ()=>zn,
        MediaQuery: ()=>Rn,
        MediaQueryList: ()=>Bn,
        NestingSelector: ()=>qn,
        Nth: ()=>jn,
        Number: ()=>Hn,
        Operator: ()=>Gn,
        Parentheses: ()=>Kn,
        Percentage: ()=>Xn,
        PseudoClassSelector: ()=>Zn,
        PseudoElementSelector: ()=>eo,
        Ratio: ()=>ro,
        Raw: ()=>oo,
        Rule: ()=>ao,
        Selector: ()=>lo,
        SelectorList: ()=>uo,
        String: ()=>go,
        StyleSheet: ()=>xo,
        TypeSelector: ()=>wo,
        UnicodeRange: ()=>Co,
        Url: ()=>Io,
        Value: ()=>Oo,
        WhiteSpace: ()=>zo
    });
    var $a = {
        parseContext: {
            default: "StyleSheet",
            stylesheet: "StyleSheet",
            atrule: "Atrule",
            atrulePrelude (e) {
                return this.AtrulePrelude(e.atrule ? String(e.atrule) : null);
            },
            mediaQueryList: "MediaQueryList",
            mediaQuery: "MediaQuery",
            rule: "Rule",
            selectorList: "SelectorList",
            selector: "Selector",
            block () {
                return this.Block(!0);
            },
            declarationList: "DeclarationList",
            declaration: "Declaration",
            value: "Value"
        },
        scope: Ro,
        atrule: Ka,
        pseudo: Xa,
        node: Bo
    };
    var Za = {
        node: gt
    };
    var Ja = Vr({
        ...Oa,
        ...$a,
        ...Za
    });
    var ts = {};
    b(ts, {
        decode: ()=>Hh,
        encode: ()=>Yh
    });
    var es = 92;
    function Hh(e) {
        let t = e.length - 1, r = "";
        for(let n = 0; n < e.length; n++){
            let o = e.charCodeAt(n);
            if (o === es) {
                if (n === t) break;
                if (o = e.charCodeAt(++n), $(es, o)) {
                    let i = n - 1, s = se(e, i);
                    n = s - 1, r += Re(e.substring(i + 1, s));
                } else o === 13 && e.charCodeAt(n + 1) === 10 && n++;
            } else r += e[n];
        }
        return r;
    }
    function Yh(e) {
        let t = "";
        if (e.length === 1 && e.charCodeAt(0) === 45) return "\\-";
        for(let r = 0; r < e.length; r++){
            let n = e.charCodeAt(r);
            if (n === 0) {
                t += "\uFFFD";
                continue;
            }
            if (n <= 31 || n === 127 || n >= 48 && n <= 57 && (r === 0 || r === 1 && e.charCodeAt(0) === 45)) {
                t += "\\" + n.toString(16) + " ";
                continue;
            }
            Ne(n) ? t += e.charAt(r) : t += "\\" + e.charAt(r);
        }
        return t;
    }
    var { tokenize: fb, parse: db, generate: gb, lexer: bb, createLexer: xb, walk: yb, find: kb, findLast: wb, findAll: vb, toPlainObject: Sb, fromPlainObject: Cb, fork: Ab } = Ja;
    // CSS Syntax Module Level 3
    // https://www.w3.org/TR/css-syntax-3/
    const EOF = 0; // <EOF-token>
    const Ident = 1; // <ident-token>
    const Function$1 = 2; // <function-token>
    const Delim = 9; // <delim-token>
    const Number$1 = 10; // <number-token>
    const Dimension = 12; // <dimension-token>
    const WhiteSpace = 13; // <whitespace-token>
    const Colon = 16; // <colon-token>     :
    const LeftParenthesis = 21; // <(-token>
    const RightParenthesis = 22; // <)-token>
    const LeftCurlyBracket = 23; // <{-token>
    const Comment$2 = 25;
    // https://drafts.csswg.org/css-syntax-3/
    // § 4.2. Definitions
    // digit
    // A code point between U+0030 DIGIT ZERO (0) and U+0039 DIGIT NINE (9).
    function isDigit(code) {
        return code >= 0x0030 && code <= 0x0039;
    }
    // uppercase letter
    // A code point between U+0041 LATIN CAPITAL LETTER A (A) and U+005A LATIN CAPITAL LETTER Z (Z).
    function isUppercaseLetter(code) {
        return code >= 0x0041 && code <= 0x005A;
    }
    // lowercase letter
    // A code point between U+0061 LATIN SMALL LETTER A (a) and U+007A LATIN SMALL LETTER Z (z).
    function isLowercaseLetter(code) {
        return code >= 0x0061 && code <= 0x007A;
    }
    // letter
    // An uppercase letter or a lowercase letter.
    function isLetter(code) {
        return isUppercaseLetter(code) || isLowercaseLetter(code);
    }
    // non-ASCII code point
    // A code point with a value equal to or greater than U+0080 <control>.
    function isNonAscii(code) {
        return code >= 0x0080;
    }
    // name-start code point
    // A letter, a non-ASCII code point, or U+005F LOW LINE (_).
    function isNameStart(code) {
        return isLetter(code) || isNonAscii(code) || code === 0x005F;
    }
    // non-printable code point
    // A code point between U+0000 NULL and U+0008 BACKSPACE, or U+000B LINE TABULATION,
    // or a code point between U+000E SHIFT OUT and U+001F INFORMATION SEPARATOR ONE, or U+007F DELETE.
    function isNonPrintable(code) {
        return code >= 0x0000 && code <= 0x0008 || code === 0x000B || code >= 0x000E && code <= 0x001F || code === 0x007F;
    }
    // newline
    // U+000A LINE FEED. Note that U+000D CARRIAGE RETURN and U+000C FORM FEED are not included in this definition,
    // as they are converted to U+000A LINE FEED during preprocessing.
    // TODO: we doesn't do a preprocessing, so check a code point for U+000D CARRIAGE RETURN and U+000C FORM FEED
    function isNewline(code) {
        return code === 0x000A || code === 0x000D || code === 0x000C;
    }
    // whitespace
    // A newline, U+0009 CHARACTER TABULATION, or U+0020 SPACE.
    function isWhiteSpace(code) {
        return isNewline(code) || code === 0x0020 || code === 0x0009;
    }
    // Fast code category
    // Only ASCII code points has a special meaning, that's why we define a maps for 0..127 codes only
    const CATEGORY = new Array(0x80);
    const EofCategory = 0x80;
    const WhiteSpaceCategory = 0x82;
    const DigitCategory = 0x83;
    const NameStartCategory = 0x84;
    const NonPrintableCategory = 0x85;
    for(let i = 0; i < CATEGORY.length; i++)CATEGORY[i] = isWhiteSpace(i) && WhiteSpaceCategory || isDigit(i) && DigitCategory || isNameStart(i) && NameStartCategory || isNonPrintable(i) && NonPrintableCategory || i || EofCategory;
    // @ts-nocheck
    const name$6 = "Comparison";
    const structure$6 = {
        value: String
    };
    function parse$8() {
        const start = this.tokenStart;
        const char1 = this.consume(Delim);
        // The first character in the comparison operator must match '<', '=', or '>'.
        if (char1 !== "<" && char1 !== ">" && char1 !== "=") this.error("Malformed comparison operator");
        let char2;
        if (this.tokenType === Delim) {
            char2 = this.consume(Delim);
            // The second character in the comparison operator must match '='.
            if (char2 !== "=") this.error("Malformed comparison operator");
        }
        // If the next token is also 'Delim' then it is malformed.
        if (this.tokenType === Delim) this.error("Malformed comparison operator");
        const value = char2 ? `${char1}${char2}` : char1;
        return {
            type: "Comparison",
            loc: this.getLocation(start, this.tokenStart),
            value: value
        };
    }
    function generate$6(node) {
        for(let index = 0; index < node.value.length; index++)this.token(Delim, node.value.charAt(index));
    }
    var comparison = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        generate: generate$6,
        name: name$6,
        parse: parse$8,
        structure: structure$6
    });
    // @ts-nocheck
    const name$5 = "ContainerFeatureStyle";
    const structure$5 = {
        name: String,
        value: [
            "Function",
            "Identifier",
            "Number",
            "Dimension",
            "QueryCSSFunction",
            "Ratio",
            null
        ]
    };
    function parse$7() {
        const start = this.tokenStart;
        let value = null;
        const function_name = this.consumeFunctionName();
        if (function_name !== "style") this.error('Unknown container style query identifier; "style" is expected');
        this.skipSC();
        const name = this.consume(Ident);
        this.skipSC();
        if (this.tokenType !== RightParenthesis) {
            this.eat(Colon);
            this.skipSC();
            switch(this.tokenType){
                case Number$1:
                    if (this.lookupNonWSType(1) === Delim) value = this.Ratio();
                    else value = this.Number();
                    break;
                case Dimension:
                    value = this.Dimension();
                    break;
                case Function$1:
                    value = this.QueryCSSFunction();
                    break;
                case Ident:
                    value = this.Identifier();
                    break;
                default:
                    this.error("Number, dimension, ratio, function or identifier is expected");
                    break;
            }
            this.skipSC();
        }
        this.eat(RightParenthesis);
        return {
            type: "ContainerFeatureStyle",
            loc: this.getLocation(start, this.tokenStart),
            name: name,
            value: value
        };
    }
    function generate$5(node) {
        this.token(Function$1, "style(");
        this.token(Ident, node.name);
        if (node.value !== null) {
            this.token(Colon, ":");
            this.node(node.value);
        }
        this.token(RightParenthesis, ")");
    }
    var container_feature_style = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        generate: generate$5,
        name: name$5,
        parse: parse$7,
        structure: structure$5
    });
    // @ts-nocheck
    /**
 * Looks ahead to determine if query feature is a range query. This involves locating at least one delimiter and no
 * colon tokens.
 *
 * @returns {boolean} Is potential range query.
 */ function lookahead_is_range() {
        let type;
        let offset = 0;
        let count = 0;
        let delim_found = false;
        let no_colon = true;
        // A range query has maximum 5 tokens when formatted as 'mf-range' /
        // '<mf-value> <mf-lt> <mf-name> <mf-lt> <mf-value>'. So only look ahead maximum of 6 non-whitespace tokens.
        do {
            type = this.lookupNonWSType(offset++);
            if (type !== WhiteSpace) count++;
            if (type === Delim) delim_found = true;
            if (type === Colon) no_colon = false;
            if (type === LeftCurlyBracket || type === RightParenthesis) break;
        }while (type !== EOF && count <= 6);
        return delim_found && no_colon;
    }
    // @ts-nocheck
    const CONTAINER_QUERY_KEYWORDS = new Set([
        "none",
        "and",
        "not",
        "or"
    ]);
    const name$4 = "ContainerQuery";
    const structure$4 = {
        name: "Identifier",
        children: [
            [
                "Identifier",
                "QueryFeature",
                "QueryFeatureRange",
                "ContainerFeatureStyle",
                "WhiteSpace"
            ]
        ]
    };
    function parse$6() {
        const start = this.tokenStart;
        const children = this.createList();
        let child = null;
        let name = null;
        // Parse potential container name.
        if (this.tokenType === Ident) {
            const container_name = this.substring(this.tokenStart, this.tokenEnd);
            // Container name doesn't match a query keyword, so assign it as container name.
            if (!CONTAINER_QUERY_KEYWORDS.has(container_name.toLowerCase())) {
                name = container_name;
                this.eat(Ident);
            }
        }
        this.skipSC();
        scan: while(!this.eof){
            switch(this.tokenType){
                case Comment$2:
                case WhiteSpace:
                    this.next();
                    continue;
                case Ident:
                    child = this.Identifier();
                    break;
                case Function$1:
                    child = this.ContainerFeatureStyle();
                    break;
                case LeftParenthesis:
                    // Lookahead to determine if range feature.
                    child = lookahead_is_range.call(this) ? this.QueryFeatureRange() : this.QueryFeature();
                    break;
                default:
                    break scan;
            }
            children.push(child);
        }
        if (child === null) this.error("Identifier or parenthesis is expected");
        return {
            type: "ContainerQuery",
            loc: this.getLocation(start, this.tokenStart - 1),
            name: name,
            children: children
        };
    }
    function generate$4(node) {
        if (typeof node.name === "string") this.token(Ident, node.name);
        this.children(node);
    }
    var container_query = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        generate: generate$4,
        name: name$4,
        parse: parse$6,
        structure: structure$4
    });
    // @ts-nocheck
    const name$3 = "MediaQuery";
    const structure$3 = {
        children: [
            [
                "Identifier",
                "QueryFeature",
                "QueryFeatureRange",
                "WhiteSpace"
            ]
        ]
    };
    function parse$5() {
        const children = this.createList();
        let child = null;
        this.skipSC();
        scan: while(!this.eof){
            switch(this.tokenType){
                case Comment$2:
                case WhiteSpace:
                    this.next();
                    continue;
                case Ident:
                    child = this.Identifier();
                    break;
                case LeftParenthesis:
                    // Lookahead to determine if range feature.
                    child = lookahead_is_range.call(this) ? this.QueryFeatureRange() : this.QueryFeature();
                    break;
                default:
                    break scan;
            }
            children.push(child);
        }
        if (child === null) this.error("Identifier or parenthesis is expected");
        return {
            type: "MediaQuery",
            loc: this.getLocationFromList(children),
            children: children
        };
    }
    function generate$3(node) {
        this.children(node);
    }
    var media_query = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        generate: generate$3,
        name: name$3,
        parse: parse$5,
        structure: structure$3
    });
    // @ts-nocheck
    const name$2 = "QueryFeature";
    const structure$2 = {
        name: String,
        value: [
            "Identifier",
            "Number",
            "Dimension",
            "QueryCSSFunction",
            "Ratio",
            null
        ]
    };
    function parse$4() {
        const start = this.tokenStart;
        let value = null;
        this.eat(LeftParenthesis);
        this.skipSC();
        const name = this.consume(Ident);
        this.skipSC();
        if (this.tokenType !== RightParenthesis) {
            this.eat(Colon);
            this.skipSC();
            switch(this.tokenType){
                case Number$1:
                    if (this.lookupNonWSType(1) === Delim) value = this.Ratio();
                    else value = this.Number();
                    break;
                case Dimension:
                    value = this.Dimension();
                    break;
                case Function$1:
                    value = this.QueryCSSFunction();
                    break;
                case Ident:
                    value = this.Identifier();
                    break;
                default:
                    this.error("Number, dimension, ratio, function, or identifier is expected");
                    break;
            }
            this.skipSC();
        }
        this.eat(RightParenthesis);
        return {
            type: "QueryFeature",
            loc: this.getLocation(start, this.tokenStart),
            name: name,
            value: value
        };
    }
    function generate$2(node) {
        this.token(LeftParenthesis, "(");
        this.token(Ident, node.name);
        if (node.value !== null) {
            this.token(Colon, ":");
            this.node(node.value);
        }
        this.token(RightParenthesis, ")");
    }
    var query_feature = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        generate: generate$2,
        name: name$2,
        parse: parse$4,
        structure: structure$2
    });
    // @ts-nocheck
    const name$1 = "QueryFeatureRange";
    const structure$1 = {
        name: String,
        value: [
            "Identifier",
            "Number",
            "Comparison",
            "Dimension",
            "QueryCSSFunction",
            "Ratio",
            null
        ]
    };
    function lookup_non_ws_type_and_value(offset, type, reference_str) {
        let current_type;
        do {
            current_type = this.lookupType(offset++);
            if (current_type !== WhiteSpace) break;
        }while (current_type !== 0); // NULL -> 0
        return current_type === type ? this.lookupValue(offset - 1, reference_str) : false;
    }
    function parse$3() {
        const start = this.tokenStart;
        const children = this.createList();
        let child = null;
        this.eat(LeftParenthesis);
        this.skipSC();
        while(!this.eof && this.tokenType !== RightParenthesis){
            switch(this.tokenType){
                case Number$1:
                    if (lookup_non_ws_type_and_value.call(this, 1, Delim, "/")) child = this.Ratio();
                    else child = this.Number();
                    break;
                case Delim:
                    child = this.Comparison();
                    break;
                case Dimension:
                    child = this.Dimension();
                    break;
                case Function$1:
                    child = this.QueryCSSFunction();
                    break;
                case Ident:
                    child = this.Identifier();
                    break;
                default:
                    this.error("Number, dimension, comparison, ratio, function, or identifier is expected");
                    break;
            }
            children.push(child);
            this.skipSC();
        }
        this.eat(RightParenthesis);
        return {
            type: "QueryFeatureRange",
            loc: this.getLocation(start, this.tokenStart),
            children: children
        };
    }
    function generate$1(node) {
        this.children(node);
    }
    var query_feature_range = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        generate: generate$1,
        name: name$1,
        parse: parse$3,
        structure: structure$1
    });
    // @ts-nocheck
    const QUERY_CSS_FUNCTIONS = new Set([
        "calc",
        "clamp",
        "min",
        "max"
    ]);
    const name = "QueryCSSFunction";
    const structure = {
        name: String,
        expression: String
    };
    function parse$2() {
        const start = this.tokenStart;
        const name = this.consumeFunctionName();
        if (!QUERY_CSS_FUNCTIONS.has(name)) this.error('Unknown query single value function; expected: "calc", "clamp", "max", min"');
        const body = this.Raw(this.tokenIndex, null, false);
        this.eat(RightParenthesis);
        return {
            type: "QueryCSSFunction",
            loc: this.getLocation(start, this.tokenStart),
            name: name,
            expression: body.value
        };
    }
    function generate(node) {
        this.token(Function, `${node.name}(`);
        this.node(node.expression);
        this.token(RightParenthesis, ")");
    }
    var query_css_function = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        generate: generate,
        name: name,
        parse: parse$2,
        structure: structure
    });
    var node = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        Comparison: comparison,
        ContainerFeatureStyle: container_feature_style,
        ContainerQuery: container_query,
        MediaQuery: media_query,
        QueryCSSFunction: query_css_function,
        QueryFeature: query_feature,
        QueryFeatureRange: query_feature_range
    });
    // @ts-nocheck
    /**
 * Extends `css-tree` for container query support by forking and adding new nodes and at-rule support for `@container`.
 *
 * The new nodes are located in `./node`.
 */ const cq_syntax = Ab({
        atrule: {
            // extend or override at-rule dictionary
            container: {
                parse: {
                    prelude () {
                        return this.createSingleNodeList(this.ContainerQuery());
                    },
                    block (is_style_block = false) {
                        return this.Block(is_style_block);
                    }
                }
            }
        },
        node: node
    });
    const parse$1 = cq_syntax.parse;
    // @ts-ignore
    // import parse from 'css-tree/parser'; // When css-tree supports container queries uncomment.
    const regex_closing_style_tag = /<\/style\s*>/;
    const regex_starts_with_closing_style_tag = /^<\/style\s*>/;
    /**
 *
 * @param {import('../index.js').Parser} parser
 * @param {number} start
 * @param {import('estree').Node[]} attributes
 * @returns {import('../../interfaces.js').Style}
 */ function read_style(parser, start, attributes) {
        const content_start = parser.index;
        const styles = parser.read_until(regex_closing_style_tag, parser_errors.unclosed_style);
        if (parser.index >= parser.template.length) parser.error(parser_errors.unclosed_style);
        const content_end = parser.index;
        // discard styles when css is disabled
        if (parser.css_mode === "none") {
            parser.read(regex_starts_with_closing_style_tag);
            return null;
        }
        let ast;
        try {
            ast = parse$1(styles, {
                positions: true,
                offset: content_start,
                onParseError (error) {
                    throw error;
                }
            });
        } catch (err) {
            if (err.name === "SyntaxError") parser.error(parser_errors.css_syntax_error(err.message), err.offset);
            else throw err;
        }
        ast = JSON.parse(JSON.stringify(ast));
        // tidy up AST
        walk(ast, {
            /** @param {any} node */ enter: (node)=>{
                // `any` because this isn't an ESTree node
                // replace `ref:a` nodes
                if (node.type === "Selector") for(let i = 0; i < node.children.length; i += 1){
                    const a = node.children[i];
                    const b = node.children[i + 1];
                    if (is_ref_selector(a, b)) parser.error(parser_errors.invalid_ref_selector, a.loc.start.offset);
                }
                if (node.type === "Declaration" && node.value.type === "Value" && node.value.children.length === 0) parser.error(parser_errors.invalid_declaration, node.start);
                if (node.type === "PseudoClassSelector" && node.name === "global" && node.children === null) parser.error(parser_errors.empty_global_selector, node.loc.start.offset);
                if (node.loc) {
                    node.start = node.loc.start.offset;
                    node.end = node.loc.end.offset;
                    delete node.loc;
                }
            }
        });
        parser.read(regex_starts_with_closing_style_tag);
        const end = parser.index;
        return {
            type: "Style",
            start: start,
            end: end,
            attributes: attributes,
            children: ast.children,
            content: {
                start: content_start,
                end: content_end,
                styles: styles
            }
        };
    }
    /**
 * @param {any} a
 * @param {any} b
 */ function is_ref_selector(a, b) {
        // TODO add CSS node types
        if (!b) return false;
        return a.type === "TypeSelector" && a.name === "ref" && b.type === "PseudoClassSelector";
    }
    // https://html.spec.whatwg.org/entities.json from https://dev.w3.org/html5/html-author/charref
    var entities = {
        "CounterClockwiseContourIntegral;": 8755,
        "ClockwiseContourIntegral;": 8754,
        "DoubleLongLeftRightArrow;": 10234,
        "NotNestedGreaterGreater;": 10914,
        "DiacriticalDoubleAcute;": 733,
        "NotSquareSupersetEqual;": 8931,
        "CloseCurlyDoubleQuote;": 8221,
        "DoubleContourIntegral;": 8751,
        "FilledVerySmallSquare;": 9642,
        "NegativeVeryThinSpace;": 8203,
        "NotPrecedesSlantEqual;": 8928,
        "NotRightTriangleEqual;": 8941,
        "NotSucceedsSlantEqual;": 8929,
        "CapitalDifferentialD;": 8517,
        "DoubleLeftRightArrow;": 8660,
        "DoubleLongRightArrow;": 10233,
        "EmptyVerySmallSquare;": 9643,
        "NestedGreaterGreater;": 8811,
        "NotDoubleVerticalBar;": 8742,
        "NotGreaterSlantEqual;": 10878,
        "NotLeftTriangleEqual;": 8940,
        "NotSquareSubsetEqual;": 8930,
        "OpenCurlyDoubleQuote;": 8220,
        "ReverseUpEquilibrium;": 10607,
        "DoubleLongLeftArrow;": 10232,
        "DownLeftRightVector;": 10576,
        "LeftArrowRightArrow;": 8646,
        "NegativeMediumSpace;": 8203,
        "NotGreaterFullEqual;": 8807,
        "NotRightTriangleBar;": 10704,
        "RightArrowLeftArrow;": 8644,
        "SquareSupersetEqual;": 8850,
        "leftrightsquigarrow;": 8621,
        "DownRightTeeVector;": 10591,
        "DownRightVectorBar;": 10583,
        "LongLeftRightArrow;": 10231,
        "Longleftrightarrow;": 10234,
        "NegativeThickSpace;": 8203,
        "NotLeftTriangleBar;": 10703,
        "PrecedesSlantEqual;": 8828,
        "ReverseEquilibrium;": 8651,
        "RightDoubleBracket;": 10215,
        "RightDownTeeVector;": 10589,
        "RightDownVectorBar;": 10581,
        "RightTriangleEqual;": 8885,
        "SquareIntersection;": 8851,
        "SucceedsSlantEqual;": 8829,
        "blacktriangleright;": 9656,
        "longleftrightarrow;": 10231,
        "DoubleUpDownArrow;": 8661,
        "DoubleVerticalBar;": 8741,
        "DownLeftTeeVector;": 10590,
        "DownLeftVectorBar;": 10582,
        "FilledSmallSquare;": 9724,
        "GreaterSlantEqual;": 10878,
        "LeftDoubleBracket;": 10214,
        "LeftDownTeeVector;": 10593,
        "LeftDownVectorBar;": 10585,
        "LeftTriangleEqual;": 8884,
        "NegativeThinSpace;": 8203,
        "NotGreaterGreater;": 8811,
        "NotLessSlantEqual;": 10877,
        "NotNestedLessLess;": 10913,
        "NotReverseElement;": 8716,
        "NotSquareSuperset;": 8848,
        "NotTildeFullEqual;": 8775,
        "RightAngleBracket;": 10217,
        "RightUpDownVector;": 10575,
        "SquareSubsetEqual;": 8849,
        "VerticalSeparator;": 10072,
        "blacktriangledown;": 9662,
        "blacktriangleleft;": 9666,
        "leftrightharpoons;": 8651,
        "rightleftharpoons;": 8652,
        "twoheadrightarrow;": 8608,
        "DiacriticalAcute;": 180,
        "DiacriticalGrave;": 96,
        "DiacriticalTilde;": 732,
        "DoubleRightArrow;": 8658,
        "DownArrowUpArrow;": 8693,
        "EmptySmallSquare;": 9723,
        "GreaterEqualLess;": 8923,
        "GreaterFullEqual;": 8807,
        "LeftAngleBracket;": 10216,
        "LeftUpDownVector;": 10577,
        "LessEqualGreater;": 8922,
        "NonBreakingSpace;": 160,
        "NotPrecedesEqual;": 10927,
        "NotRightTriangle;": 8939,
        "NotSucceedsEqual;": 10928,
        "NotSucceedsTilde;": 8831,
        "NotSupersetEqual;": 8841,
        "RightTriangleBar;": 10704,
        "RightUpTeeVector;": 10588,
        "RightUpVectorBar;": 10580,
        "UnderParenthesis;": 9181,
        "UpArrowDownArrow;": 8645,
        "circlearrowright;": 8635,
        "downharpoonright;": 8642,
        "ntrianglerighteq;": 8941,
        "rightharpoondown;": 8641,
        "rightrightarrows;": 8649,
        "twoheadleftarrow;": 8606,
        "vartriangleright;": 8883,
        "CloseCurlyQuote;": 8217,
        "ContourIntegral;": 8750,
        "DoubleDownArrow;": 8659,
        "DoubleLeftArrow;": 8656,
        "DownRightVector;": 8641,
        "LeftRightVector;": 10574,
        "LeftTriangleBar;": 10703,
        "LeftUpTeeVector;": 10592,
        "LeftUpVectorBar;": 10584,
        "LowerRightArrow;": 8600,
        "NotGreaterEqual;": 8817,
        "NotGreaterTilde;": 8821,
        "NotHumpDownHump;": 8782,
        "NotLeftTriangle;": 8938,
        "NotSquareSubset;": 8847,
        "OverParenthesis;": 9180,
        "RightDownVector;": 8642,
        "ShortRightArrow;": 8594,
        "UpperRightArrow;": 8599,
        "bigtriangledown;": 9661,
        "circlearrowleft;": 8634,
        "curvearrowright;": 8631,
        "downharpoonleft;": 8643,
        "leftharpoondown;": 8637,
        "leftrightarrows;": 8646,
        "nLeftrightarrow;": 8654,
        "nleftrightarrow;": 8622,
        "ntrianglelefteq;": 8940,
        "rightleftarrows;": 8644,
        "rightsquigarrow;": 8605,
        "rightthreetimes;": 8908,
        "straightepsilon;": 1013,
        "trianglerighteq;": 8885,
        "vartriangleleft;": 8882,
        "DiacriticalDot;": 729,
        "DoubleRightTee;": 8872,
        "DownLeftVector;": 8637,
        "GreaterGreater;": 10914,
        "HorizontalLine;": 9472,
        "InvisibleComma;": 8291,
        "InvisibleTimes;": 8290,
        "LeftDownVector;": 8643,
        "LeftRightArrow;": 8596,
        "Leftrightarrow;": 8660,
        "LessSlantEqual;": 10877,
        "LongRightArrow;": 10230,
        "Longrightarrow;": 10233,
        "LowerLeftArrow;": 8601,
        "NestedLessLess;": 8810,
        "NotGreaterLess;": 8825,
        "NotLessGreater;": 8824,
        "NotSubsetEqual;": 8840,
        "NotVerticalBar;": 8740,
        "OpenCurlyQuote;": 8216,
        "ReverseElement;": 8715,
        "RightTeeVector;": 10587,
        "RightVectorBar;": 10579,
        "ShortDownArrow;": 8595,
        "ShortLeftArrow;": 8592,
        "SquareSuperset;": 8848,
        "TildeFullEqual;": 8773,
        "UpperLeftArrow;": 8598,
        "ZeroWidthSpace;": 8203,
        "curvearrowleft;": 8630,
        "doublebarwedge;": 8966,
        "downdownarrows;": 8650,
        "hookrightarrow;": 8618,
        "leftleftarrows;": 8647,
        "leftrightarrow;": 8596,
        "leftthreetimes;": 8907,
        "longrightarrow;": 10230,
        "looparrowright;": 8620,
        "nshortparallel;": 8742,
        "ntriangleright;": 8939,
        "rightarrowtail;": 8611,
        "rightharpoonup;": 8640,
        "trianglelefteq;": 8884,
        "upharpoonright;": 8638,
        "ApplyFunction;": 8289,
        "DifferentialD;": 8518,
        "DoubleLeftTee;": 10980,
        "DoubleUpArrow;": 8657,
        "LeftTeeVector;": 10586,
        "LeftVectorBar;": 10578,
        "LessFullEqual;": 8806,
        "LongLeftArrow;": 10229,
        "Longleftarrow;": 10232,
        "NotEqualTilde;": 8770,
        "NotTildeEqual;": 8772,
        "NotTildeTilde;": 8777,
        "Poincareplane;": 8460,
        "PrecedesEqual;": 10927,
        "PrecedesTilde;": 8830,
        "RightArrowBar;": 8677,
        "RightTeeArrow;": 8614,
        "RightTriangle;": 8883,
        "RightUpVector;": 8638,
        "SucceedsEqual;": 10928,
        "SucceedsTilde;": 8831,
        "SupersetEqual;": 8839,
        "UpEquilibrium;": 10606,
        "VerticalTilde;": 8768,
        "VeryThinSpace;": 8202,
        "bigtriangleup;": 9651,
        "blacktriangle;": 9652,
        "divideontimes;": 8903,
        "fallingdotseq;": 8786,
        "hookleftarrow;": 8617,
        "leftarrowtail;": 8610,
        "leftharpoonup;": 8636,
        "longleftarrow;": 10229,
        "looparrowleft;": 8619,
        "measuredangle;": 8737,
        "ntriangleleft;": 8938,
        "shortparallel;": 8741,
        "smallsetminus;": 8726,
        "triangleright;": 9657,
        "upharpoonleft;": 8639,
        "varsubsetneqq;": 10955,
        "varsupsetneqq;": 10956,
        "DownArrowBar;": 10515,
        "DownTeeArrow;": 8615,
        "ExponentialE;": 8519,
        "GreaterEqual;": 8805,
        "GreaterTilde;": 8819,
        "HilbertSpace;": 8459,
        "HumpDownHump;": 8782,
        "Intersection;": 8898,
        "LeftArrowBar;": 8676,
        "LeftTeeArrow;": 8612,
        "LeftTriangle;": 8882,
        "LeftUpVector;": 8639,
        "NotCongruent;": 8802,
        "NotHumpEqual;": 8783,
        "NotLessEqual;": 8816,
        "NotLessTilde;": 8820,
        "Proportional;": 8733,
        "RightCeiling;": 8969,
        "RoundImplies;": 10608,
        "ShortUpArrow;": 8593,
        "SquareSubset;": 8847,
        "UnderBracket;": 9141,
        "VerticalLine;": 124,
        "blacklozenge;": 10731,
        "exponentiale;": 8519,
        "risingdotseq;": 8787,
        "triangledown;": 9663,
        "triangleleft;": 9667,
        "varsubsetneq;": 8842,
        "varsupsetneq;": 8843,
        "CircleMinus;": 8854,
        "CircleTimes;": 8855,
        "Equilibrium;": 8652,
        "GreaterLess;": 8823,
        "LeftCeiling;": 8968,
        "LessGreater;": 8822,
        "MediumSpace;": 8287,
        "NotLessLess;": 8810,
        "NotPrecedes;": 8832,
        "NotSucceeds;": 8833,
        "NotSuperset;": 8835,
        "OverBracket;": 9140,
        "RightVector;": 8640,
        "Rrightarrow;": 8667,
        "RuleDelayed;": 10740,
        "SmallCircle;": 8728,
        "SquareUnion;": 8852,
        "SubsetEqual;": 8838,
        "UpDownArrow;": 8597,
        "Updownarrow;": 8661,
        "VerticalBar;": 8739,
        "backepsilon;": 1014,
        "blacksquare;": 9642,
        "circledcirc;": 8858,
        "circleddash;": 8861,
        "curlyeqprec;": 8926,
        "curlyeqsucc;": 8927,
        "diamondsuit;": 9830,
        "eqslantless;": 10901,
        "expectation;": 8496,
        "nRightarrow;": 8655,
        "nrightarrow;": 8603,
        "preccurlyeq;": 8828,
        "precnapprox;": 10937,
        "quaternions;": 8461,
        "straightphi;": 981,
        "succcurlyeq;": 8829,
        "succnapprox;": 10938,
        "thickapprox;": 8776,
        "updownarrow;": 8597,
        "Bernoullis;": 8492,
        "CirclePlus;": 8853,
        "EqualTilde;": 8770,
        "Fouriertrf;": 8497,
        "ImaginaryI;": 8520,
        "Laplacetrf;": 8466,
        "LeftVector;": 8636,
        "Lleftarrow;": 8666,
        "NotElement;": 8713,
        "NotGreater;": 8815,
        "Proportion;": 8759,
        "RightArrow;": 8594,
        "RightFloor;": 8971,
        "Rightarrow;": 8658,
        "ThickSpace;": 8287,
        "TildeEqual;": 8771,
        "TildeTilde;": 8776,
        "UnderBrace;": 9183,
        "UpArrowBar;": 10514,
        "UpTeeArrow;": 8613,
        "circledast;": 8859,
        "complement;": 8705,
        "curlywedge;": 8911,
        "eqslantgtr;": 10902,
        "gtreqqless;": 10892,
        "lessapprox;": 10885,
        "lesseqqgtr;": 10891,
        "lmoustache;": 9136,
        "longmapsto;": 10236,
        "mapstodown;": 8615,
        "mapstoleft;": 8612,
        "nLeftarrow;": 8653,
        "nleftarrow;": 8602,
        "nsubseteqq;": 10949,
        "nsupseteqq;": 10950,
        "precapprox;": 10935,
        "rightarrow;": 8594,
        "rmoustache;": 9137,
        "sqsubseteq;": 8849,
        "sqsupseteq;": 8850,
        "subsetneqq;": 10955,
        "succapprox;": 10936,
        "supsetneqq;": 10956,
        "upuparrows;": 8648,
        "varepsilon;": 1013,
        "varnothing;": 8709,
        "Backslash;": 8726,
        "CenterDot;": 183,
        "CircleDot;": 8857,
        "Congruent;": 8801,
        "Coproduct;": 8720,
        "DoubleDot;": 168,
        "DownArrow;": 8595,
        "DownBreve;": 785,
        "Downarrow;": 8659,
        "HumpEqual;": 8783,
        "LeftArrow;": 8592,
        "LeftFloor;": 8970,
        "Leftarrow;": 8656,
        "LessTilde;": 8818,
        "Mellintrf;": 8499,
        "MinusPlus;": 8723,
        "NotCupCap;": 8813,
        "NotExists;": 8708,
        "NotSubset;": 8834,
        "OverBrace;": 9182,
        "PlusMinus;": 177,
        "Therefore;": 8756,
        "ThinSpace;": 8201,
        "TripleDot;": 8411,
        "UnionPlus;": 8846,
        "backprime;": 8245,
        "backsimeq;": 8909,
        "bigotimes;": 10754,
        "centerdot;": 183,
        "checkmark;": 10003,
        "complexes;": 8450,
        "dotsquare;": 8865,
        "downarrow;": 8595,
        "gtrapprox;": 10886,
        "gtreqless;": 8923,
        "gvertneqq;": 8809,
        "heartsuit;": 9829,
        "leftarrow;": 8592,
        "lesseqgtr;": 8922,
        "lvertneqq;": 8808,
        "ngeqslant;": 10878,
        "nleqslant;": 10877,
        "nparallel;": 8742,
        "nshortmid;": 8740,
        "nsubseteq;": 8840,
        "nsupseteq;": 8841,
        "pitchfork;": 8916,
        "rationals;": 8474,
        "spadesuit;": 9824,
        "subseteqq;": 10949,
        "subsetneq;": 8842,
        "supseteqq;": 10950,
        "supsetneq;": 8843,
        "therefore;": 8756,
        "triangleq;": 8796,
        "varpropto;": 8733,
        "DDotrahd;": 10513,
        "DotEqual;": 8784,
        "Integral;": 8747,
        "LessLess;": 10913,
        "NotEqual;": 8800,
        "NotTilde;": 8769,
        "PartialD;": 8706,
        "Precedes;": 8826,
        "RightTee;": 8866,
        "Succeeds;": 8827,
        "SuchThat;": 8715,
        "Superset;": 8835,
        "Uarrocir;": 10569,
        "UnderBar;": 95,
        "andslope;": 10840,
        "angmsdaa;": 10664,
        "angmsdab;": 10665,
        "angmsdac;": 10666,
        "angmsdad;": 10667,
        "angmsdae;": 10668,
        "angmsdaf;": 10669,
        "angmsdag;": 10670,
        "angmsdah;": 10671,
        "angrtvbd;": 10653,
        "approxeq;": 8778,
        "awconint;": 8755,
        "backcong;": 8780,
        "barwedge;": 8965,
        "bbrktbrk;": 9142,
        "bigoplus;": 10753,
        "bigsqcup;": 10758,
        "biguplus;": 10756,
        "bigwedge;": 8896,
        "boxminus;": 8863,
        "boxtimes;": 8864,
        "bsolhsub;": 10184,
        "capbrcup;": 10825,
        "circledR;": 174,
        "circledS;": 9416,
        "cirfnint;": 10768,
        "clubsuit;": 9827,
        "cupbrcap;": 10824,
        "curlyvee;": 8910,
        "cwconint;": 8754,
        "doteqdot;": 8785,
        "dotminus;": 8760,
        "drbkarow;": 10512,
        "dzigrarr;": 10239,
        "elinters;": 9191,
        "emptyset;": 8709,
        "eqvparsl;": 10725,
        "fpartint;": 10765,
        "geqslant;": 10878,
        "gesdotol;": 10884,
        "gnapprox;": 10890,
        "hksearow;": 10533,
        "hkswarow;": 10534,
        "imagline;": 8464,
        "imagpart;": 8465,
        "infintie;": 10717,
        "integers;": 8484,
        "intercal;": 8890,
        "intlarhk;": 10775,
        "laemptyv;": 10676,
        "ldrushar;": 10571,
        "leqslant;": 10877,
        "lesdotor;": 10883,
        "llcorner;": 8990,
        "lnapprox;": 10889,
        "lrcorner;": 8991,
        "lurdshar;": 10570,
        "mapstoup;": 8613,
        "multimap;": 8888,
        "naturals;": 8469,
        "ncongdot;": 10861,
        "notindot;": 8949,
        "otimesas;": 10806,
        "parallel;": 8741,
        "plusacir;": 10787,
        "pointint;": 10773,
        "precneqq;": 10933,
        "precnsim;": 8936,
        "profalar;": 9006,
        "profline;": 8978,
        "profsurf;": 8979,
        "raemptyv;": 10675,
        "realpart;": 8476,
        "rppolint;": 10770,
        "rtriltri;": 10702,
        "scpolint;": 10771,
        "setminus;": 8726,
        "shortmid;": 8739,
        "smeparsl;": 10724,
        "sqsubset;": 8847,
        "sqsupset;": 8848,
        "subseteq;": 8838,
        "succneqq;": 10934,
        "succnsim;": 8937,
        "supseteq;": 8839,
        "thetasym;": 977,
        "thicksim;": 8764,
        "timesbar;": 10801,
        "triangle;": 9653,
        "triminus;": 10810,
        "trpezium;": 9186,
        "ulcorner;": 8988,
        "urcorner;": 8989,
        "varkappa;": 1008,
        "varsigma;": 962,
        "vartheta;": 977,
        "Because;": 8757,
        "Cayleys;": 8493,
        "Cconint;": 8752,
        "Cedilla;": 184,
        "Diamond;": 8900,
        "DownTee;": 8868,
        "Element;": 8712,
        "Epsilon;": 917,
        "Implies;": 8658,
        "LeftTee;": 8867,
        "NewLine;": 10,
        "NoBreak;": 8288,
        "NotLess;": 8814,
        "Omicron;": 927,
        "OverBar;": 8254,
        "Product;": 8719,
        "UpArrow;": 8593,
        "Uparrow;": 8657,
        "Upsilon;": 933,
        "alefsym;": 8501,
        "angrtvb;": 8894,
        "angzarr;": 9084,
        "asympeq;": 8781,
        "backsim;": 8765,
        "because;": 8757,
        "bemptyv;": 10672,
        "between;": 8812,
        "bigcirc;": 9711,
        "bigodot;": 10752,
        "bigstar;": 9733,
        "bnequiv;": 8801,
        "boxplus;": 8862,
        "ccupssm;": 10832,
        "cemptyv;": 10674,
        "cirscir;": 10690,
        "coloneq;": 8788,
        "congdot;": 10861,
        "cudarrl;": 10552,
        "cudarrr;": 10549,
        "cularrp;": 10557,
        "curarrm;": 10556,
        "dbkarow;": 10511,
        "ddagger;": 8225,
        "ddotseq;": 10871,
        "demptyv;": 10673,
        "diamond;": 8900,
        "digamma;": 989,
        "dotplus;": 8724,
        "dwangle;": 10662,
        "epsilon;": 949,
        "eqcolon;": 8789,
        "equivDD;": 10872,
        "gesdoto;": 10882,
        "gtquest;": 10876,
        "gtrless;": 8823,
        "harrcir;": 10568,
        "intprod;": 10812,
        "isindot;": 8949,
        "larrbfs;": 10527,
        "larrsim;": 10611,
        "lbrksld;": 10639,
        "lbrkslu;": 10637,
        "ldrdhar;": 10599,
        "lesdoto;": 10881,
        "lessdot;": 8918,
        "lessgtr;": 8822,
        "lesssim;": 8818,
        "lotimes;": 10804,
        "lozenge;": 9674,
        "ltquest;": 10875,
        "luruhar;": 10598,
        "maltese;": 10016,
        "minusdu;": 10794,
        "napprox;": 8777,
        "natural;": 9838,
        "nearrow;": 8599,
        "nexists;": 8708,
        "notinva;": 8713,
        "notinvb;": 8951,
        "notinvc;": 8950,
        "notniva;": 8716,
        "notnivb;": 8958,
        "notnivc;": 8957,
        "npolint;": 10772,
        "npreceq;": 10927,
        "nsqsube;": 8930,
        "nsqsupe;": 8931,
        "nsubset;": 8834,
        "nsucceq;": 10928,
        "nsupset;": 8835,
        "nvinfin;": 10718,
        "nvltrie;": 8884,
        "nvrtrie;": 8885,
        "nwarrow;": 8598,
        "olcross;": 10683,
        "omicron;": 959,
        "orderof;": 8500,
        "orslope;": 10839,
        "pertenk;": 8241,
        "planckh;": 8462,
        "pluscir;": 10786,
        "plussim;": 10790,
        "plustwo;": 10791,
        "precsim;": 8830,
        "quatint;": 10774,
        "questeq;": 8799,
        "rarrbfs;": 10528,
        "rarrsim;": 10612,
        "rbrksld;": 10638,
        "rbrkslu;": 10640,
        "rdldhar;": 10601,
        "realine;": 8475,
        "rotimes;": 10805,
        "ruluhar;": 10600,
        "searrow;": 8600,
        "simplus;": 10788,
        "simrarr;": 10610,
        "subedot;": 10947,
        "submult;": 10945,
        "subplus;": 10943,
        "subrarr;": 10617,
        "succsim;": 8831,
        "supdsub;": 10968,
        "supedot;": 10948,
        "suphsol;": 10185,
        "suphsub;": 10967,
        "suplarr;": 10619,
        "supmult;": 10946,
        "supplus;": 10944,
        "swarrow;": 8601,
        "topfork;": 10970,
        "triplus;": 10809,
        "tritime;": 10811,
        "uparrow;": 8593,
        "upsilon;": 965,
        "uwangle;": 10663,
        "vzigzag;": 10650,
        "zigrarr;": 8669,
        "Aacute;": 193,
        "Abreve;": 258,
        "Agrave;": 192,
        "Assign;": 8788,
        "Atilde;": 195,
        "Barwed;": 8966,
        "Bumpeq;": 8782,
        "Cacute;": 262,
        "Ccaron;": 268,
        "Ccedil;": 199,
        "Colone;": 10868,
        "Conint;": 8751,
        "CupCap;": 8781,
        "Dagger;": 8225,
        "Dcaron;": 270,
        "DotDot;": 8412,
        "Dstrok;": 272,
        "Eacute;": 201,
        "Ecaron;": 282,
        "Egrave;": 200,
        "Exists;": 8707,
        "ForAll;": 8704,
        "Gammad;": 988,
        "Gbreve;": 286,
        "Gcedil;": 290,
        "HARDcy;": 1066,
        "Hstrok;": 294,
        "Iacute;": 205,
        "Igrave;": 204,
        "Itilde;": 296,
        "Jsercy;": 1032,
        "Kcedil;": 310,
        "Lacute;": 313,
        "Lambda;": 923,
        "Lcaron;": 317,
        "Lcedil;": 315,
        "Lmidot;": 319,
        "Lstrok;": 321,
        "Nacute;": 323,
        "Ncaron;": 327,
        "Ncedil;": 325,
        "Ntilde;": 209,
        "Oacute;": 211,
        "Odblac;": 336,
        "Ograve;": 210,
        "Oslash;": 216,
        "Otilde;": 213,
        "Otimes;": 10807,
        "Racute;": 340,
        "Rarrtl;": 10518,
        "Rcaron;": 344,
        "Rcedil;": 342,
        "SHCHcy;": 1065,
        "SOFTcy;": 1068,
        "Sacute;": 346,
        "Scaron;": 352,
        "Scedil;": 350,
        "Square;": 9633,
        "Subset;": 8912,
        "Supset;": 8913,
        "Tcaron;": 356,
        "Tcedil;": 354,
        "Tstrok;": 358,
        "Uacute;": 218,
        "Ubreve;": 364,
        "Udblac;": 368,
        "Ugrave;": 217,
        "Utilde;": 360,
        "Vdashl;": 10982,
        "Verbar;": 8214,
        "Vvdash;": 8874,
        "Yacute;": 221,
        "Zacute;": 377,
        "Zcaron;": 381,
        "aacute;": 225,
        "abreve;": 259,
        "agrave;": 224,
        "andand;": 10837,
        "angmsd;": 8737,
        "angsph;": 8738,
        "apacir;": 10863,
        "approx;": 8776,
        "atilde;": 227,
        "barvee;": 8893,
        "barwed;": 8965,
        "becaus;": 8757,
        "bernou;": 8492,
        "bigcap;": 8898,
        "bigcup;": 8899,
        "bigvee;": 8897,
        "bkarow;": 10509,
        "bottom;": 8869,
        "bowtie;": 8904,
        "boxbox;": 10697,
        "bprime;": 8245,
        "brvbar;": 166,
        "bullet;": 8226,
        "bumpeq;": 8783,
        "cacute;": 263,
        "capand;": 10820,
        "capcap;": 10827,
        "capcup;": 10823,
        "capdot;": 10816,
        "ccaron;": 269,
        "ccedil;": 231,
        "circeq;": 8791,
        "cirmid;": 10991,
        "colone;": 8788,
        "commat;": 64,
        "compfn;": 8728,
        "conint;": 8750,
        "coprod;": 8720,
        "copysr;": 8471,
        "cularr;": 8630,
        "cupcap;": 10822,
        "cupcup;": 10826,
        "cupdot;": 8845,
        "curarr;": 8631,
        "curren;": 164,
        "cylcty;": 9005,
        "dagger;": 8224,
        "daleth;": 8504,
        "dcaron;": 271,
        "dfisht;": 10623,
        "divide;": 247,
        "divonx;": 8903,
        "dlcorn;": 8990,
        "dlcrop;": 8973,
        "dollar;": 36,
        "drcorn;": 8991,
        "drcrop;": 8972,
        "dstrok;": 273,
        "eacute;": 233,
        "easter;": 10862,
        "ecaron;": 283,
        "ecolon;": 8789,
        "egrave;": 232,
        "egsdot;": 10904,
        "elsdot;": 10903,
        "emptyv;": 8709,
        "emsp13;": 8196,
        "emsp14;": 8197,
        "eparsl;": 10723,
        "eqcirc;": 8790,
        "equals;": 61,
        "equest;": 8799,
        "female;": 9792,
        "ffilig;": 64259,
        "ffllig;": 64260,
        "forall;": 8704,
        "frac12;": 189,
        "frac13;": 8531,
        "frac14;": 188,
        "frac15;": 8533,
        "frac16;": 8537,
        "frac18;": 8539,
        "frac23;": 8532,
        "frac25;": 8534,
        "frac34;": 190,
        "frac35;": 8535,
        "frac38;": 8540,
        "frac45;": 8536,
        "frac56;": 8538,
        "frac58;": 8541,
        "frac78;": 8542,
        "gacute;": 501,
        "gammad;": 989,
        "gbreve;": 287,
        "gesdot;": 10880,
        "gesles;": 10900,
        "gtlPar;": 10645,
        "gtrarr;": 10616,
        "gtrdot;": 8919,
        "gtrsim;": 8819,
        "hairsp;": 8202,
        "hamilt;": 8459,
        "hardcy;": 1098,
        "hearts;": 9829,
        "hellip;": 8230,
        "hercon;": 8889,
        "homtht;": 8763,
        "horbar;": 8213,
        "hslash;": 8463,
        "hstrok;": 295,
        "hybull;": 8259,
        "hyphen;": 8208,
        "iacute;": 237,
        "igrave;": 236,
        "iiiint;": 10764,
        "iinfin;": 10716,
        "incare;": 8453,
        "inodot;": 305,
        "intcal;": 8890,
        "iquest;": 191,
        "isinsv;": 8947,
        "itilde;": 297,
        "jsercy;": 1112,
        "kappav;": 1008,
        "kcedil;": 311,
        "kgreen;": 312,
        "lAtail;": 10523,
        "lacute;": 314,
        "lagran;": 8466,
        "lambda;": 955,
        "langle;": 10216,
        "larrfs;": 10525,
        "larrhk;": 8617,
        "larrlp;": 8619,
        "larrpl;": 10553,
        "larrtl;": 8610,
        "latail;": 10521,
        "lbrace;": 123,
        "lbrack;": 91,
        "lcaron;": 318,
        "lcedil;": 316,
        "ldquor;": 8222,
        "lesdot;": 10879,
        "lesges;": 10899,
        "lfisht;": 10620,
        "lfloor;": 8970,
        "lharul;": 10602,
        "llhard;": 10603,
        "lmidot;": 320,
        "lmoust;": 9136,
        "loplus;": 10797,
        "lowast;": 8727,
        "lowbar;": 95,
        "lparlt;": 10643,
        "lrhard;": 10605,
        "lsaquo;": 8249,
        "lsquor;": 8218,
        "lstrok;": 322,
        "lthree;": 8907,
        "ltimes;": 8905,
        "ltlarr;": 10614,
        "ltrPar;": 10646,
        "mapsto;": 8614,
        "marker;": 9646,
        "mcomma;": 10793,
        "midast;": 42,
        "midcir;": 10992,
        "middot;": 183,
        "minusb;": 8863,
        "minusd;": 8760,
        "mnplus;": 8723,
        "models;": 8871,
        "mstpos;": 8766,
        "nVDash;": 8879,
        "nVdash;": 8878,
        "nacute;": 324,
        "nbumpe;": 8783,
        "ncaron;": 328,
        "ncedil;": 326,
        "nearhk;": 10532,
        "nequiv;": 8802,
        "nesear;": 10536,
        "nexist;": 8708,
        "nltrie;": 8940,
        "notinE;": 8953,
        "nparsl;": 11005,
        "nprcue;": 8928,
        "nrarrc;": 10547,
        "nrarrw;": 8605,
        "nrtrie;": 8941,
        "nsccue;": 8929,
        "nsimeq;": 8772,
        "ntilde;": 241,
        "numero;": 8470,
        "nvDash;": 8877,
        "nvHarr;": 10500,
        "nvdash;": 8876,
        "nvlArr;": 10498,
        "nvrArr;": 10499,
        "nwarhk;": 10531,
        "nwnear;": 10535,
        "oacute;": 243,
        "odblac;": 337,
        "odsold;": 10684,
        "ograve;": 242,
        "ominus;": 8854,
        "origof;": 8886,
        "oslash;": 248,
        "otilde;": 245,
        "otimes;": 8855,
        "parsim;": 10995,
        "percnt;": 37,
        "period;": 46,
        "permil;": 8240,
        "phmmat;": 8499,
        "planck;": 8463,
        "plankv;": 8463,
        "plusdo;": 8724,
        "plusdu;": 10789,
        "plusmn;": 177,
        "preceq;": 10927,
        "primes;": 8473,
        "prnsim;": 8936,
        "propto;": 8733,
        "prurel;": 8880,
        "puncsp;": 8200,
        "qprime;": 8279,
        "rAtail;": 10524,
        "racute;": 341,
        "rangle;": 10217,
        "rarrap;": 10613,
        "rarrfs;": 10526,
        "rarrhk;": 8618,
        "rarrlp;": 8620,
        "rarrpl;": 10565,
        "rarrtl;": 8611,
        "ratail;": 10522,
        "rbrace;": 125,
        "rbrack;": 93,
        "rcaron;": 345,
        "rcedil;": 343,
        "rdquor;": 8221,
        "rfisht;": 10621,
        "rfloor;": 8971,
        "rharul;": 10604,
        "rmoust;": 9137,
        "roplus;": 10798,
        "rpargt;": 10644,
        "rsaquo;": 8250,
        "rsquor;": 8217,
        "rthree;": 8908,
        "rtimes;": 8906,
        "sacute;": 347,
        "scaron;": 353,
        "scedil;": 351,
        "scnsim;": 8937,
        "searhk;": 10533,
        "seswar;": 10537,
        "sfrown;": 8994,
        "shchcy;": 1097,
        "sigmaf;": 962,
        "sigmav;": 962,
        "simdot;": 10858,
        "smashp;": 10803,
        "softcy;": 1100,
        "solbar;": 9023,
        "spades;": 9824,
        "sqcaps;": 8851,
        "sqcups;": 8852,
        "sqsube;": 8849,
        "sqsupe;": 8850,
        "square;": 9633,
        "squarf;": 9642,
        "ssetmn;": 8726,
        "ssmile;": 8995,
        "sstarf;": 8902,
        "subdot;": 10941,
        "subset;": 8834,
        "subsim;": 10951,
        "subsub;": 10965,
        "subsup;": 10963,
        "succeq;": 10928,
        "supdot;": 10942,
        "supset;": 8835,
        "supsim;": 10952,
        "supsub;": 10964,
        "supsup;": 10966,
        "swarhk;": 10534,
        "swnwar;": 10538,
        "target;": 8982,
        "tcaron;": 357,
        "tcedil;": 355,
        "telrec;": 8981,
        "there4;": 8756,
        "thetav;": 977,
        "thinsp;": 8201,
        "thksim;": 8764,
        "timesb;": 8864,
        "timesd;": 10800,
        "topbot;": 9014,
        "topcir;": 10993,
        "tprime;": 8244,
        "tridot;": 9708,
        "tstrok;": 359,
        "uacute;": 250,
        "ubreve;": 365,
        "udblac;": 369,
        "ufisht;": 10622,
        "ugrave;": 249,
        "ulcorn;": 8988,
        "ulcrop;": 8975,
        "urcorn;": 8989,
        "urcrop;": 8974,
        "utilde;": 361,
        "vangrt;": 10652,
        "varphi;": 981,
        "varrho;": 1009,
        "veebar;": 8891,
        "vellip;": 8942,
        "verbar;": 124,
        "vsubnE;": 10955,
        "vsubne;": 8842,
        "vsupnE;": 10956,
        "vsupne;": 8843,
        "wedbar;": 10847,
        "wedgeq;": 8793,
        "weierp;": 8472,
        "wreath;": 8768,
        "xoplus;": 10753,
        "xotime;": 10754,
        "xsqcup;": 10758,
        "xuplus;": 10756,
        "xwedge;": 8896,
        "yacute;": 253,
        "zacute;": 378,
        "zcaron;": 382,
        "zeetrf;": 8488,
        "AElig;": 198,
        Aacute: 193,
        "Acirc;": 194,
        Agrave: 192,
        "Alpha;": 913,
        "Amacr;": 256,
        "Aogon;": 260,
        "Aring;": 197,
        Atilde: 195,
        "Breve;": 728,
        Ccedil: 199,
        "Ccirc;": 264,
        "Colon;": 8759,
        "Cross;": 10799,
        "Dashv;": 10980,
        "Delta;": 916,
        Eacute: 201,
        "Ecirc;": 202,
        Egrave: 200,
        "Emacr;": 274,
        "Eogon;": 280,
        "Equal;": 10869,
        "Gamma;": 915,
        "Gcirc;": 284,
        "Hacek;": 711,
        "Hcirc;": 292,
        "IJlig;": 306,
        Iacute: 205,
        "Icirc;": 206,
        Igrave: 204,
        "Imacr;": 298,
        "Iogon;": 302,
        "Iukcy;": 1030,
        "Jcirc;": 308,
        "Jukcy;": 1028,
        "Kappa;": 922,
        Ntilde: 209,
        "OElig;": 338,
        Oacute: 211,
        "Ocirc;": 212,
        Ograve: 210,
        "Omacr;": 332,
        "Omega;": 937,
        Oslash: 216,
        Otilde: 213,
        "Prime;": 8243,
        "RBarr;": 10512,
        "Scirc;": 348,
        "Sigma;": 931,
        "THORN;": 222,
        "TRADE;": 8482,
        "TSHcy;": 1035,
        "Theta;": 920,
        "Tilde;": 8764,
        Uacute: 218,
        "Ubrcy;": 1038,
        "Ucirc;": 219,
        Ugrave: 217,
        "Umacr;": 362,
        "Union;": 8899,
        "Uogon;": 370,
        "UpTee;": 8869,
        "Uring;": 366,
        "VDash;": 8875,
        "Vdash;": 8873,
        "Wcirc;": 372,
        "Wedge;": 8896,
        Yacute: 221,
        "Ycirc;": 374,
        aacute: 225,
        "acirc;": 226,
        "acute;": 180,
        "aelig;": 230,
        agrave: 224,
        "aleph;": 8501,
        "alpha;": 945,
        "amacr;": 257,
        "amalg;": 10815,
        "angle;": 8736,
        "angrt;": 8735,
        "angst;": 197,
        "aogon;": 261,
        "aring;": 229,
        "asymp;": 8776,
        atilde: 227,
        "awint;": 10769,
        "bcong;": 8780,
        "bdquo;": 8222,
        "bepsi;": 1014,
        "blank;": 9251,
        "blk12;": 9618,
        "blk14;": 9617,
        "blk34;": 9619,
        "block;": 9608,
        "boxDL;": 9559,
        "boxDR;": 9556,
        "boxDl;": 9558,
        "boxDr;": 9555,
        "boxHD;": 9574,
        "boxHU;": 9577,
        "boxHd;": 9572,
        "boxHu;": 9575,
        "boxUL;": 9565,
        "boxUR;": 9562,
        "boxUl;": 9564,
        "boxUr;": 9561,
        "boxVH;": 9580,
        "boxVL;": 9571,
        "boxVR;": 9568,
        "boxVh;": 9579,
        "boxVl;": 9570,
        "boxVr;": 9567,
        "boxdL;": 9557,
        "boxdR;": 9554,
        "boxdl;": 9488,
        "boxdr;": 9484,
        "boxhD;": 9573,
        "boxhU;": 9576,
        "boxhd;": 9516,
        "boxhu;": 9524,
        "boxuL;": 9563,
        "boxuR;": 9560,
        "boxul;": 9496,
        "boxur;": 9492,
        "boxvH;": 9578,
        "boxvL;": 9569,
        "boxvR;": 9566,
        "boxvh;": 9532,
        "boxvl;": 9508,
        "boxvr;": 9500,
        "breve;": 728,
        brvbar: 166,
        "bsemi;": 8271,
        "bsime;": 8909,
        "bsolb;": 10693,
        "bumpE;": 10926,
        "bumpe;": 8783,
        "caret;": 8257,
        "caron;": 711,
        "ccaps;": 10829,
        ccedil: 231,
        "ccirc;": 265,
        "ccups;": 10828,
        "cedil;": 184,
        "check;": 10003,
        "clubs;": 9827,
        "colon;": 58,
        "comma;": 44,
        "crarr;": 8629,
        "cross;": 10007,
        "csube;": 10961,
        "csupe;": 10962,
        "ctdot;": 8943,
        "cuepr;": 8926,
        "cuesc;": 8927,
        "cupor;": 10821,
        curren: 164,
        "cuvee;": 8910,
        "cuwed;": 8911,
        "cwint;": 8753,
        "dashv;": 8867,
        "dblac;": 733,
        "ddarr;": 8650,
        "delta;": 948,
        "dharl;": 8643,
        "dharr;": 8642,
        "diams;": 9830,
        "disin;": 8946,
        divide: 247,
        "doteq;": 8784,
        "dtdot;": 8945,
        "dtrif;": 9662,
        "duarr;": 8693,
        "duhar;": 10607,
        "eDDot;": 10871,
        eacute: 233,
        "ecirc;": 234,
        "efDot;": 8786,
        egrave: 232,
        "emacr;": 275,
        "empty;": 8709,
        "eogon;": 281,
        "eplus;": 10865,
        "epsiv;": 1013,
        "eqsim;": 8770,
        "equiv;": 8801,
        "erDot;": 8787,
        "erarr;": 10609,
        "esdot;": 8784,
        "exist;": 8707,
        "fflig;": 64256,
        "filig;": 64257,
        "fjlig;": 102,
        "fllig;": 64258,
        "fltns;": 9649,
        "forkv;": 10969,
        frac12: 189,
        frac14: 188,
        frac34: 190,
        "frasl;": 8260,
        "frown;": 8994,
        "gamma;": 947,
        "gcirc;": 285,
        "gescc;": 10921,
        "gimel;": 8503,
        "gneqq;": 8809,
        "gnsim;": 8935,
        "grave;": 96,
        "gsime;": 10894,
        "gsiml;": 10896,
        "gtcir;": 10874,
        "gtdot;": 8919,
        "harrw;": 8621,
        "hcirc;": 293,
        "hoarr;": 8703,
        iacute: 237,
        "icirc;": 238,
        "iexcl;": 161,
        igrave: 236,
        "iiint;": 8749,
        "iiota;": 8489,
        "ijlig;": 307,
        "imacr;": 299,
        "image;": 8465,
        "imath;": 305,
        "imped;": 437,
        "infin;": 8734,
        "iogon;": 303,
        "iprod;": 10812,
        iquest: 191,
        "isinE;": 8953,
        "isins;": 8948,
        "isinv;": 8712,
        "iukcy;": 1110,
        "jcirc;": 309,
        "jmath;": 567,
        "jukcy;": 1108,
        "kappa;": 954,
        "lAarr;": 8666,
        "lBarr;": 10510,
        "langd;": 10641,
        "laquo;": 171,
        "larrb;": 8676,
        "lates;": 10925,
        "lbarr;": 10508,
        "lbbrk;": 10098,
        "lbrke;": 10635,
        "lceil;": 8968,
        "ldquo;": 8220,
        "lescc;": 10920,
        "lhard;": 8637,
        "lharu;": 8636,
        "lhblk;": 9604,
        "llarr;": 8647,
        "lltri;": 9722,
        "lneqq;": 8808,
        "lnsim;": 8934,
        "loang;": 10220,
        "loarr;": 8701,
        "lobrk;": 10214,
        "lopar;": 10629,
        "lrarr;": 8646,
        "lrhar;": 8651,
        "lrtri;": 8895,
        "lsime;": 10893,
        "lsimg;": 10895,
        "lsquo;": 8216,
        "ltcir;": 10873,
        "ltdot;": 8918,
        "ltrie;": 8884,
        "ltrif;": 9666,
        "mDDot;": 8762,
        "mdash;": 8212,
        "micro;": 181,
        middot: 183,
        "minus;": 8722,
        "mumap;": 8888,
        "nabla;": 8711,
        "napid;": 8779,
        "napos;": 329,
        "natur;": 9838,
        "nbump;": 8782,
        "ncong;": 8775,
        "ndash;": 8211,
        "neArr;": 8663,
        "nearr;": 8599,
        "nedot;": 8784,
        "nesim;": 8770,
        "ngeqq;": 8807,
        "ngsim;": 8821,
        "nhArr;": 8654,
        "nharr;": 8622,
        "nhpar;": 10994,
        "nlArr;": 8653,
        "nlarr;": 8602,
        "nleqq;": 8806,
        "nless;": 8814,
        "nlsim;": 8820,
        "nltri;": 8938,
        "notin;": 8713,
        "notni;": 8716,
        "npart;": 8706,
        "nprec;": 8832,
        "nrArr;": 8655,
        "nrarr;": 8603,
        "nrtri;": 8939,
        "nsime;": 8772,
        "nsmid;": 8740,
        "nspar;": 8742,
        "nsubE;": 10949,
        "nsube;": 8840,
        "nsucc;": 8833,
        "nsupE;": 10950,
        "nsupe;": 8841,
        ntilde: 241,
        "numsp;": 8199,
        "nvsim;": 8764,
        "nwArr;": 8662,
        "nwarr;": 8598,
        oacute: 243,
        "ocirc;": 244,
        "odash;": 8861,
        "oelig;": 339,
        "ofcir;": 10687,
        ograve: 242,
        "ohbar;": 10677,
        "olarr;": 8634,
        "olcir;": 10686,
        "oline;": 8254,
        "omacr;": 333,
        "omega;": 969,
        "operp;": 10681,
        "oplus;": 8853,
        "orarr;": 8635,
        "order;": 8500,
        oslash: 248,
        otilde: 245,
        "ovbar;": 9021,
        "parsl;": 11005,
        "phone;": 9742,
        "plusb;": 8862,
        "pluse;": 10866,
        plusmn: 177,
        "pound;": 163,
        "prcue;": 8828,
        "prime;": 8242,
        "prnap;": 10937,
        "prsim;": 8830,
        "quest;": 63,
        "rAarr;": 8667,
        "rBarr;": 10511,
        "radic;": 8730,
        "rangd;": 10642,
        "range;": 10661,
        "raquo;": 187,
        "rarrb;": 8677,
        "rarrc;": 10547,
        "rarrw;": 8605,
        "ratio;": 8758,
        "rbarr;": 10509,
        "rbbrk;": 10099,
        "rbrke;": 10636,
        "rceil;": 8969,
        "rdquo;": 8221,
        "reals;": 8477,
        "rhard;": 8641,
        "rharu;": 8640,
        "rlarr;": 8644,
        "rlhar;": 8652,
        "rnmid;": 10990,
        "roang;": 10221,
        "roarr;": 8702,
        "robrk;": 10215,
        "ropar;": 10630,
        "rrarr;": 8649,
        "rsquo;": 8217,
        "rtrie;": 8885,
        "rtrif;": 9656,
        "sbquo;": 8218,
        "sccue;": 8829,
        "scirc;": 349,
        "scnap;": 10938,
        "scsim;": 8831,
        "sdotb;": 8865,
        "sdote;": 10854,
        "seArr;": 8664,
        "searr;": 8600,
        "setmn;": 8726,
        "sharp;": 9839,
        "sigma;": 963,
        "simeq;": 8771,
        "simgE;": 10912,
        "simlE;": 10911,
        "simne;": 8774,
        "slarr;": 8592,
        "smile;": 8995,
        "smtes;": 10924,
        "sqcap;": 8851,
        "sqcup;": 8852,
        "sqsub;": 8847,
        "sqsup;": 8848,
        "srarr;": 8594,
        "starf;": 9733,
        "strns;": 175,
        "subnE;": 10955,
        "subne;": 8842,
        "supnE;": 10956,
        "supne;": 8843,
        "swArr;": 8665,
        "swarr;": 8601,
        "szlig;": 223,
        "theta;": 952,
        "thkap;": 8776,
        "thorn;": 254,
        "tilde;": 732,
        "times;": 215,
        "trade;": 8482,
        "trisb;": 10701,
        "tshcy;": 1115,
        "twixt;": 8812,
        uacute: 250,
        "ubrcy;": 1118,
        "ucirc;": 251,
        "udarr;": 8645,
        "udhar;": 10606,
        ugrave: 249,
        "uharl;": 8639,
        "uharr;": 8638,
        "uhblk;": 9600,
        "ultri;": 9720,
        "umacr;": 363,
        "uogon;": 371,
        "uplus;": 8846,
        "upsih;": 978,
        "uring;": 367,
        "urtri;": 9721,
        "utdot;": 8944,
        "utrif;": 9652,
        "uuarr;": 8648,
        "vBarv;": 10985,
        "vDash;": 8872,
        "varpi;": 982,
        "vdash;": 8866,
        "veeeq;": 8794,
        "vltri;": 8882,
        "vnsub;": 8834,
        "vnsup;": 8835,
        "vprop;": 8733,
        "vrtri;": 8883,
        "wcirc;": 373,
        "wedge;": 8743,
        "xcirc;": 9711,
        "xdtri;": 9661,
        "xhArr;": 10234,
        "xharr;": 10231,
        "xlArr;": 10232,
        "xlarr;": 10229,
        "xodot;": 10752,
        "xrArr;": 10233,
        "xrarr;": 10230,
        "xutri;": 9651,
        yacute: 253,
        "ycirc;": 375,
        AElig: 198,
        Acirc: 194,
        "Aopf;": 120120,
        Aring: 197,
        "Ascr;": 119964,
        "Auml;": 196,
        "Barv;": 10983,
        "Beta;": 914,
        "Bopf;": 120121,
        "Bscr;": 8492,
        "CHcy;": 1063,
        "COPY;": 169,
        "Cdot;": 266,
        "Copf;": 8450,
        "Cscr;": 119966,
        "DJcy;": 1026,
        "DScy;": 1029,
        "DZcy;": 1039,
        "Darr;": 8609,
        "Dopf;": 120123,
        "Dscr;": 119967,
        Ecirc: 202,
        "Edot;": 278,
        "Eopf;": 120124,
        "Escr;": 8496,
        "Esim;": 10867,
        "Euml;": 203,
        "Fopf;": 120125,
        "Fscr;": 8497,
        "GJcy;": 1027,
        "Gdot;": 288,
        "Gopf;": 120126,
        "Gscr;": 119970,
        "Hopf;": 8461,
        "Hscr;": 8459,
        "IEcy;": 1045,
        "IOcy;": 1025,
        Icirc: 206,
        "Idot;": 304,
        "Iopf;": 120128,
        "Iota;": 921,
        "Iscr;": 8464,
        "Iuml;": 207,
        "Jopf;": 120129,
        "Jscr;": 119973,
        "KHcy;": 1061,
        "KJcy;": 1036,
        "Kopf;": 120130,
        "Kscr;": 119974,
        "LJcy;": 1033,
        "Lang;": 10218,
        "Larr;": 8606,
        "Lopf;": 120131,
        "Lscr;": 8466,
        "Mopf;": 120132,
        "Mscr;": 8499,
        "NJcy;": 1034,
        "Nopf;": 8469,
        "Nscr;": 119977,
        Ocirc: 212,
        "Oopf;": 120134,
        "Oscr;": 119978,
        "Ouml;": 214,
        "Popf;": 8473,
        "Pscr;": 119979,
        "QUOT;": 34,
        "Qopf;": 8474,
        "Qscr;": 119980,
        "Rang;": 10219,
        "Rarr;": 8608,
        "Ropf;": 8477,
        "Rscr;": 8475,
        "SHcy;": 1064,
        "Sopf;": 120138,
        "Sqrt;": 8730,
        "Sscr;": 119982,
        "Star;": 8902,
        THORN: 222,
        "TScy;": 1062,
        "Topf;": 120139,
        "Tscr;": 119983,
        "Uarr;": 8607,
        Ucirc: 219,
        "Uopf;": 120140,
        "Upsi;": 978,
        "Uscr;": 119984,
        "Uuml;": 220,
        "Vbar;": 10987,
        "Vert;": 8214,
        "Vopf;": 120141,
        "Vscr;": 119985,
        "Wopf;": 120142,
        "Wscr;": 119986,
        "Xopf;": 120143,
        "Xscr;": 119987,
        "YAcy;": 1071,
        "YIcy;": 1031,
        "YUcy;": 1070,
        "Yopf;": 120144,
        "Yscr;": 119988,
        "Yuml;": 376,
        "ZHcy;": 1046,
        "Zdot;": 379,
        "Zeta;": 918,
        "Zopf;": 8484,
        "Zscr;": 119989,
        acirc: 226,
        acute: 180,
        aelig: 230,
        "andd;": 10844,
        "andv;": 10842,
        "ange;": 10660,
        "aopf;": 120146,
        "apid;": 8779,
        "apos;": 39,
        aring: 229,
        "ascr;": 119990,
        "auml;": 228,
        "bNot;": 10989,
        "bbrk;": 9141,
        "beta;": 946,
        "beth;": 8502,
        "bnot;": 8976,
        "bopf;": 120147,
        "boxH;": 9552,
        "boxV;": 9553,
        "boxh;": 9472,
        "boxv;": 9474,
        "bscr;": 119991,
        "bsim;": 8765,
        "bsol;": 92,
        "bull;": 8226,
        "bump;": 8782,
        "caps;": 8745,
        "cdot;": 267,
        cedil: 184,
        "cent;": 162,
        "chcy;": 1095,
        "cirE;": 10691,
        "circ;": 710,
        "cire;": 8791,
        "comp;": 8705,
        "cong;": 8773,
        "copf;": 120148,
        "copy;": 169,
        "cscr;": 119992,
        "csub;": 10959,
        "csup;": 10960,
        "cups;": 8746,
        "dArr;": 8659,
        "dHar;": 10597,
        "darr;": 8595,
        "dash;": 8208,
        "diam;": 8900,
        "djcy;": 1106,
        "dopf;": 120149,
        "dscr;": 119993,
        "dscy;": 1109,
        "dsol;": 10742,
        "dtri;": 9663,
        "dzcy;": 1119,
        "eDot;": 8785,
        "ecir;": 8790,
        ecirc: 234,
        "edot;": 279,
        "emsp;": 8195,
        "ensp;": 8194,
        "eopf;": 120150,
        "epar;": 8917,
        "epsi;": 949,
        "escr;": 8495,
        "esim;": 8770,
        "euml;": 235,
        "euro;": 8364,
        "excl;": 33,
        "flat;": 9837,
        "fnof;": 402,
        "fopf;": 120151,
        "fork;": 8916,
        "fscr;": 119995,
        "gdot;": 289,
        "geqq;": 8807,
        "gesl;": 8923,
        "gjcy;": 1107,
        "gnap;": 10890,
        "gneq;": 10888,
        "gopf;": 120152,
        "gscr;": 8458,
        "gsim;": 8819,
        "gtcc;": 10919,
        "gvnE;": 8809,
        "hArr;": 8660,
        "half;": 189,
        "harr;": 8596,
        "hbar;": 8463,
        "hopf;": 120153,
        "hscr;": 119997,
        icirc: 238,
        "iecy;": 1077,
        iexcl: 161,
        "imof;": 8887,
        "iocy;": 1105,
        "iopf;": 120154,
        "iota;": 953,
        "iscr;": 119998,
        "isin;": 8712,
        "iuml;": 239,
        "jopf;": 120155,
        "jscr;": 119999,
        "khcy;": 1093,
        "kjcy;": 1116,
        "kopf;": 120156,
        "kscr;": 120000,
        "lArr;": 8656,
        "lHar;": 10594,
        "lang;": 10216,
        laquo: 171,
        "larr;": 8592,
        "late;": 10925,
        "lcub;": 123,
        "ldca;": 10550,
        "ldsh;": 8626,
        "leqq;": 8806,
        "lesg;": 8922,
        "ljcy;": 1113,
        "lnap;": 10889,
        "lneq;": 10887,
        "lopf;": 120157,
        "lozf;": 10731,
        "lpar;": 40,
        "lscr;": 120001,
        "lsim;": 8818,
        "lsqb;": 91,
        "ltcc;": 10918,
        "ltri;": 9667,
        "lvnE;": 8808,
        "macr;": 175,
        "male;": 9794,
        "malt;": 10016,
        micro: 181,
        "mlcp;": 10971,
        "mldr;": 8230,
        "mopf;": 120158,
        "mscr;": 120002,
        "nGtv;": 8811,
        "nLtv;": 8810,
        "nang;": 8736,
        "napE;": 10864,
        "nbsp;": 160,
        "ncap;": 10819,
        "ncup;": 10818,
        "ngeq;": 8817,
        "nges;": 10878,
        "ngtr;": 8815,
        "nisd;": 8954,
        "njcy;": 1114,
        "nldr;": 8229,
        "nleq;": 8816,
        "nles;": 10877,
        "nmid;": 8740,
        "nopf;": 120159,
        "npar;": 8742,
        "npre;": 10927,
        "nsce;": 10928,
        "nscr;": 120003,
        "nsim;": 8769,
        "nsub;": 8836,
        "nsup;": 8837,
        "ntgl;": 8825,
        "ntlg;": 8824,
        "nvap;": 8781,
        "nvge;": 8805,
        "nvgt;": 62,
        "nvle;": 8804,
        "nvlt;": 60,
        "oast;": 8859,
        "ocir;": 8858,
        ocirc: 244,
        "odiv;": 10808,
        "odot;": 8857,
        "ogon;": 731,
        "oint;": 8750,
        "omid;": 10678,
        "oopf;": 120160,
        "opar;": 10679,
        "ordf;": 170,
        "ordm;": 186,
        "oror;": 10838,
        "oscr;": 8500,
        "osol;": 8856,
        "ouml;": 246,
        "para;": 182,
        "part;": 8706,
        "perp;": 8869,
        "phiv;": 981,
        "plus;": 43,
        "popf;": 120161,
        pound: 163,
        "prap;": 10935,
        "prec;": 8826,
        "prnE;": 10933,
        "prod;": 8719,
        "prop;": 8733,
        "pscr;": 120005,
        "qint;": 10764,
        "qopf;": 120162,
        "qscr;": 120006,
        "quot;": 34,
        "rArr;": 8658,
        "rHar;": 10596,
        "race;": 8765,
        "rang;": 10217,
        raquo: 187,
        "rarr;": 8594,
        "rcub;": 125,
        "rdca;": 10551,
        "rdsh;": 8627,
        "real;": 8476,
        "rect;": 9645,
        "rhov;": 1009,
        "ring;": 730,
        "ropf;": 120163,
        "rpar;": 41,
        "rscr;": 120007,
        "rsqb;": 93,
        "rtri;": 9657,
        "scap;": 10936,
        "scnE;": 10934,
        "sdot;": 8901,
        "sect;": 167,
        "semi;": 59,
        "sext;": 10038,
        "shcy;": 1096,
        "sime;": 8771,
        "simg;": 10910,
        "siml;": 10909,
        "smid;": 8739,
        "smte;": 10924,
        "solb;": 10692,
        "sopf;": 120164,
        "spar;": 8741,
        "squf;": 9642,
        "sscr;": 120008,
        "star;": 9734,
        "subE;": 10949,
        "sube;": 8838,
        "succ;": 8827,
        "sung;": 9834,
        "sup1;": 185,
        "sup2;": 178,
        "sup3;": 179,
        "supE;": 10950,
        "supe;": 8839,
        szlig: 223,
        "tbrk;": 9140,
        "tdot;": 8411,
        thorn: 254,
        times: 215,
        "tint;": 8749,
        "toea;": 10536,
        "topf;": 120165,
        "tosa;": 10537,
        "trie;": 8796,
        "tscr;": 120009,
        "tscy;": 1094,
        "uArr;": 8657,
        "uHar;": 10595,
        "uarr;": 8593,
        ucirc: 251,
        "uopf;": 120166,
        "upsi;": 965,
        "uscr;": 120010,
        "utri;": 9653,
        "uuml;": 252,
        "vArr;": 8661,
        "vBar;": 10984,
        "varr;": 8597,
        "vert;": 124,
        "vopf;": 120167,
        "vscr;": 120011,
        "wopf;": 120168,
        "wscr;": 120012,
        "xcap;": 8898,
        "xcup;": 8899,
        "xmap;": 10236,
        "xnis;": 8955,
        "xopf;": 120169,
        "xscr;": 120013,
        "xvee;": 8897,
        "yacy;": 1103,
        "yicy;": 1111,
        "yopf;": 120170,
        "yscr;": 120014,
        "yucy;": 1102,
        "yuml;": 255,
        "zdot;": 380,
        "zeta;": 950,
        "zhcy;": 1078,
        "zopf;": 120171,
        "zscr;": 120015,
        "zwnj;": 8204,
        "AMP;": 38,
        "Acy;": 1040,
        "Afr;": 120068,
        "And;": 10835,
        Auml: 196,
        "Bcy;": 1041,
        "Bfr;": 120069,
        COPY: 169,
        "Cap;": 8914,
        "Cfr;": 8493,
        "Chi;": 935,
        "Cup;": 8915,
        "Dcy;": 1044,
        "Del;": 8711,
        "Dfr;": 120071,
        "Dot;": 168,
        "ENG;": 330,
        "ETH;": 208,
        "Ecy;": 1069,
        "Efr;": 120072,
        "Eta;": 919,
        Euml: 203,
        "Fcy;": 1060,
        "Ffr;": 120073,
        "Gcy;": 1043,
        "Gfr;": 120074,
        "Hat;": 94,
        "Hfr;": 8460,
        "Icy;": 1048,
        "Ifr;": 8465,
        "Int;": 8748,
        Iuml: 207,
        "Jcy;": 1049,
        "Jfr;": 120077,
        "Kcy;": 1050,
        "Kfr;": 120078,
        "Lcy;": 1051,
        "Lfr;": 120079,
        "Lsh;": 8624,
        "Map;": 10501,
        "Mcy;": 1052,
        "Mfr;": 120080,
        "Ncy;": 1053,
        "Nfr;": 120081,
        "Not;": 10988,
        "Ocy;": 1054,
        "Ofr;": 120082,
        Ouml: 214,
        "Pcy;": 1055,
        "Pfr;": 120083,
        "Phi;": 934,
        "Psi;": 936,
        QUOT: 34,
        "Qfr;": 120084,
        "REG;": 174,
        "Rcy;": 1056,
        "Rfr;": 8476,
        "Rho;": 929,
        "Rsh;": 8625,
        "Scy;": 1057,
        "Sfr;": 120086,
        "Sub;": 8912,
        "Sum;": 8721,
        "Sup;": 8913,
        "Tab;": 9,
        "Tau;": 932,
        "Tcy;": 1058,
        "Tfr;": 120087,
        "Ucy;": 1059,
        "Ufr;": 120088,
        Uuml: 220,
        "Vcy;": 1042,
        "Vee;": 8897,
        "Vfr;": 120089,
        "Wfr;": 120090,
        "Xfr;": 120091,
        "Ycy;": 1067,
        "Yfr;": 120092,
        "Zcy;": 1047,
        "Zfr;": 8488,
        "acE;": 8766,
        "acd;": 8767,
        "acy;": 1072,
        "afr;": 120094,
        "amp;": 38,
        "and;": 8743,
        "ang;": 8736,
        "apE;": 10864,
        "ape;": 8778,
        "ast;": 42,
        auml: 228,
        "bcy;": 1073,
        "bfr;": 120095,
        "bne;": 61,
        "bot;": 8869,
        "cap;": 8745,
        cent: 162,
        "cfr;": 120096,
        "chi;": 967,
        "cir;": 9675,
        copy: 169,
        "cup;": 8746,
        "dcy;": 1076,
        "deg;": 176,
        "dfr;": 120097,
        "die;": 168,
        "div;": 247,
        "dot;": 729,
        "ecy;": 1101,
        "efr;": 120098,
        "egs;": 10902,
        "ell;": 8467,
        "els;": 10901,
        "eng;": 331,
        "eta;": 951,
        "eth;": 240,
        euml: 235,
        "fcy;": 1092,
        "ffr;": 120099,
        "gEl;": 10892,
        "gap;": 10886,
        "gcy;": 1075,
        "gel;": 8923,
        "geq;": 8805,
        "ges;": 10878,
        "gfr;": 120100,
        "ggg;": 8921,
        "glE;": 10898,
        "gla;": 10917,
        "glj;": 10916,
        "gnE;": 8809,
        "gne;": 10888,
        "hfr;": 120101,
        "icy;": 1080,
        "iff;": 8660,
        "ifr;": 120102,
        "int;": 8747,
        iuml: 239,
        "jcy;": 1081,
        "jfr;": 120103,
        "kcy;": 1082,
        "kfr;": 120104,
        "lEg;": 10891,
        "lap;": 10885,
        "lat;": 10923,
        "lcy;": 1083,
        "leg;": 8922,
        "leq;": 8804,
        "les;": 10877,
        "lfr;": 120105,
        "lgE;": 10897,
        "lnE;": 8808,
        "lne;": 10887,
        "loz;": 9674,
        "lrm;": 8206,
        "lsh;": 8624,
        macr: 175,
        "map;": 8614,
        "mcy;": 1084,
        "mfr;": 120106,
        "mho;": 8487,
        "mid;": 8739,
        "nGg;": 8921,
        "nGt;": 8811,
        "nLl;": 8920,
        "nLt;": 8810,
        "nap;": 8777,
        nbsp: 160,
        "ncy;": 1085,
        "nfr;": 120107,
        "ngE;": 8807,
        "nge;": 8817,
        "ngt;": 8815,
        "nis;": 8956,
        "niv;": 8715,
        "nlE;": 8806,
        "nle;": 8816,
        "nlt;": 8814,
        "not;": 172,
        "npr;": 8832,
        "nsc;": 8833,
        "num;": 35,
        "ocy;": 1086,
        "ofr;": 120108,
        "ogt;": 10689,
        "ohm;": 937,
        "olt;": 10688,
        "ord;": 10845,
        ordf: 170,
        ordm: 186,
        "orv;": 10843,
        ouml: 246,
        "par;": 8741,
        para: 182,
        "pcy;": 1087,
        "pfr;": 120109,
        "phi;": 966,
        "piv;": 982,
        "prE;": 10931,
        "pre;": 10927,
        "psi;": 968,
        "qfr;": 120110,
        quot: 34,
        "rcy;": 1088,
        "reg;": 174,
        "rfr;": 120111,
        "rho;": 961,
        "rlm;": 8207,
        "rsh;": 8625,
        "scE;": 10932,
        "sce;": 10928,
        "scy;": 1089,
        sect: 167,
        "sfr;": 120112,
        "shy;": 173,
        "sim;": 8764,
        "smt;": 10922,
        "sol;": 47,
        "squ;": 9633,
        "sub;": 8834,
        "sum;": 8721,
        sup1: 185,
        sup2: 178,
        sup3: 179,
        "sup;": 8835,
        "tau;": 964,
        "tcy;": 1090,
        "tfr;": 120113,
        "top;": 8868,
        "ucy;": 1091,
        "ufr;": 120114,
        "uml;": 168,
        uuml: 252,
        "vcy;": 1074,
        "vee;": 8744,
        "vfr;": 120115,
        "wfr;": 120116,
        "xfr;": 120117,
        "ycy;": 1099,
        "yen;": 165,
        "yfr;": 120118,
        yuml: 255,
        "zcy;": 1079,
        "zfr;": 120119,
        "zwj;": 8205,
        AMP: 38,
        "DD;": 8517,
        ETH: 208,
        "GT;": 62,
        "Gg;": 8921,
        "Gt;": 8811,
        "Im;": 8465,
        "LT;": 60,
        "Ll;": 8920,
        "Lt;": 8810,
        "Mu;": 924,
        "Nu;": 925,
        "Or;": 10836,
        "Pi;": 928,
        "Pr;": 10939,
        REG: 174,
        "Re;": 8476,
        "Sc;": 10940,
        "Xi;": 926,
        "ac;": 8766,
        "af;": 8289,
        amp: 38,
        "ap;": 8776,
        "dd;": 8518,
        deg: 176,
        "ee;": 8519,
        "eg;": 10906,
        "el;": 10905,
        eth: 240,
        "gE;": 8807,
        "ge;": 8805,
        "gg;": 8811,
        "gl;": 8823,
        "gt;": 62,
        "ic;": 8291,
        "ii;": 8520,
        "in;": 8712,
        "it;": 8290,
        "lE;": 8806,
        "le;": 8804,
        "lg;": 8822,
        "ll;": 8810,
        "lt;": 60,
        "mp;": 8723,
        "mu;": 956,
        "ne;": 8800,
        "ni;": 8715,
        not: 172,
        "nu;": 957,
        "oS;": 9416,
        "or;": 8744,
        "pi;": 960,
        "pm;": 177,
        "pr;": 8826,
        reg: 174,
        "rx;": 8478,
        "sc;": 8827,
        shy: 173,
        uml: 168,
        "wp;": 8472,
        "wr;": 8768,
        "xi;": 958,
        yen: 165,
        GT: 62,
        LT: 60,
        gt: 62,
        lt: 60
    };
    const windows_1252 = [
        8364,
        129,
        8218,
        402,
        8222,
        8230,
        8224,
        8225,
        710,
        8240,
        352,
        8249,
        338,
        141,
        381,
        143,
        144,
        8216,
        8217,
        8220,
        8221,
        8226,
        8211,
        8212,
        732,
        8482,
        353,
        8250,
        339,
        157,
        382,
        376
    ];
    /**
 * @param {string} entity_name
 * @param {boolean} is_attribute_value
 */ function reg_exp_entity(entity_name, is_attribute_value) {
        // https://html.spec.whatwg.org/multipage/parsing.html#named-character-reference-state
        // doesn't decode the html entity which not ends with ; and next character is =, number or alphabet in attribute value.
        if (is_attribute_value && !entity_name.endsWith(";")) return `${entity_name}\\b(?!=)`;
        return entity_name;
    }
    /**
 * @param {boolean} is_attribute_value
 */ function get_entity_pattern(is_attribute_value) {
        const reg_exp_num = "#(?:x[a-fA-F\\d]+|\\d+)(?:;)?";
        const reg_exp_entities = Object.keys(entities).map((entity_name)=>reg_exp_entity(entity_name, is_attribute_value));
        const entity_pattern = new RegExp(`&(${reg_exp_num}|${reg_exp_entities.join("|")})`, "g");
        return entity_pattern;
    }
    const entity_pattern_content = get_entity_pattern(false);
    const entity_pattern_attr_value = get_entity_pattern(true);
    /**
 * @param {string} html
 * @param {boolean} is_attribute_value
 */ function decode_character_references(html, is_attribute_value) {
        const entity_pattern = is_attribute_value ? entity_pattern_attr_value : entity_pattern_content;
        return html.replace(entity_pattern, (match, entity)=>{
            let code;
            // Handle named entities
            if (entity[0] !== "#") code = entities[entity];
            else if (entity[1] === "x") code = parseInt(entity.substring(2), 16);
            else code = parseInt(entity.substring(1), 10);
            if (!code) return match;
            return String.fromCodePoint(validate_code(code));
        });
    }
    const NUL = 0;
    // some code points are verboten. If we were inserting HTML, the browser would replace the illegal
    // code points with alternatives in some cases - since we're bypassing that mechanism, we need
    // to replace them ourselves
    //
    // Source: http://en.wikipedia.org/wiki/Character_encodings_in_HTML#Illegal_characters
    /**
 * @param {number} code
 */ function validate_code(code) {
        // line feed becomes generic whitespace
        if (code === 10) return 32;
        // ASCII range. (Why someone would use HTML entities for ASCII characters I don't know, but...)
        if (code < 128) return code;
        // code points 128-159 are dealt with leniently by browsers, but they're incorrect. We need
        // to correct the mistake or we'll end up with missing € signs and so on
        if (code <= 159) return windows_1252[code - 128];
        // basic multilingual plane
        if (code < 55296) return code;
        // UTF-16 surrogate halves
        if (code <= 57343) return NUL;
        // rest of the basic multilingual plane
        if (code <= 65535) return code;
        // supplementary multilingual plane 0x10000 - 0x1ffff
        if (code >= 65536 && code <= 131071) return code;
        // supplementary ideographic plane 0x20000 - 0x2ffff
        if (code >= 131072 && code <= 196607) return code;
        return NUL;
    }
    // based on http://developers.whatwg.org/syntax.html#syntax-tag-omission
    const disallowed_contents = new Map([
        [
            "li",
            new Set([
                "li"
            ])
        ],
        [
            "dt",
            new Set([
                "dt",
                "dd"
            ])
        ],
        [
            "dd",
            new Set([
                "dt",
                "dd"
            ])
        ],
        [
            "p",
            new Set("address article aside blockquote div dl fieldset footer form h1 h2 h3 h4 h5 h6 header hgroup hr main menu nav ol p pre section table ul".split(" "))
        ],
        [
            "rt",
            new Set([
                "rt",
                "rp"
            ])
        ],
        [
            "rp",
            new Set([
                "rt",
                "rp"
            ])
        ],
        [
            "optgroup",
            new Set([
                "optgroup"
            ])
        ],
        [
            "option",
            new Set([
                "option",
                "optgroup"
            ])
        ],
        [
            "thead",
            new Set([
                "tbody",
                "tfoot"
            ])
        ],
        [
            "tbody",
            new Set([
                "tbody",
                "tfoot"
            ])
        ],
        [
            "tfoot",
            new Set([
                "tbody"
            ])
        ],
        [
            "tr",
            new Set([
                "tr",
                "tbody"
            ])
        ],
        [
            "td",
            new Set([
                "td",
                "th",
                "tr"
            ])
        ],
        [
            "th",
            new Set([
                "td",
                "th",
                "tr"
            ])
        ]
    ]);
    // can this be a child of the parent element, or does it implicitly
    // close it, like `<li>one<li>two`?
    /**
 * @param {string} current
 * @param {string} [next]
 */ function closing_tag_omitted(current, next) {
        if (disallowed_contents.has(current)) {
            if (!next || disallowed_contents.get(current).has(next)) return true;
        }
        return false;
    }
    // eslint-disable-next-line no-useless-escape
    const valid_tag_name = /^\!?[a-zA-Z]{1,}:?[a-zA-Z0-9\-]*/;
    /** Invalid attribute characters if the attribute is not surrounded by quotes */ const regex_starts_with_invalid_attr_value = /^(\/>|[\s"'=<>`])/;
    const meta_tags = new Map([
        [
            "svelte:head",
            "Head"
        ],
        [
            "svelte:options",
            "Options"
        ],
        [
            "svelte:window",
            "Window"
        ],
        [
            "svelte:document",
            "Document"
        ],
        [
            "svelte:body",
            "Body"
        ]
    ]);
    const valid_meta_tags = Array.from(meta_tags.keys()).concat("svelte:self", "svelte:component", "svelte:fragment", "svelte:element");
    const specials = new Map([
        [
            "script",
            {
                read: read_script,
                property: "js"
            }
        ],
        [
            "style",
            {
                read: read_style,
                property: "css"
            }
        ]
    ]);
    const SELF = /^svelte:self(?=[\s/>])/;
    const COMPONENT = /^svelte:component(?=[\s/>])/;
    const SLOT = /^svelte:fragment(?=[\s/>])/;
    const ELEMENT = /^svelte:element(?=[\s/>])/;
    function parent_is_head(stack) {
        let i = stack.length;
        while(i--){
            const { type: type } = stack[i];
            if (type === "Head") return true;
            if (type === "Element" || type === "InlineComponent") return false;
        }
        return false;
    }
    const regex_closing_textarea_tag = /^<\/textarea(\s[^>]*)?>/i;
    const regex_closing_comment = /-->/;
    const regex_capital_letter = /[A-Z]/;
    /**
 * @param {import('../index.js').Parser} parser
 */ function tag(parser) {
        const start = parser.index++;
        let parent = parser.current();
        if (parser.eat("!--")) {
            const data = parser.read_until(regex_closing_comment);
            parser.eat("-->", true, parser_errors.unclosed_comment);
            parser.current().children.push({
                start: start,
                end: parser.index,
                type: "Comment",
                data: data,
                ignores: extract_svelte_ignore(data)
            });
            return;
        }
        const is_closing_tag = parser.eat("/");
        const name = read_tag_name(parser);
        if (meta_tags.has(name)) {
            const slug = meta_tags.get(name).toLowerCase();
            if (is_closing_tag) {
                if ((name === "svelte:window" || name === "svelte:body") && parser.current().children.length) parser.error(parser_errors.invalid_element_content(slug, name), parser.current().children[0].start);
            } else {
                if (name in parser.meta_tags) parser.error(parser_errors.duplicate_element(slug, name), start);
                if (parser.stack.length > 1) parser.error(parser_errors.invalid_element_placement(slug, name), start);
                parser.meta_tags[name] = true;
            }
        }
        const type = meta_tags.has(name) ? meta_tags.get(name) : regex_capital_letter.test(name[0]) || name === "svelte:self" || name === "svelte:component" ? "InlineComponent" : name === "svelte:fragment" ? "SlotTemplate" : name === "title" && parent_is_head(parser.stack) ? "Title" : name === "slot" ? "Slot" : "Element";
        /**
	 * @type {import('../../interfaces.js').TemplateNode}
	 */ const element = {
            start: start,
            end: null,
            type: type,
            name: name,
            attributes: [],
            children: []
        };
        parser.allow_whitespace();
        if (is_closing_tag) {
            if (is_void(name)) parser.error(parser_errors.invalid_void_content(name), start);
            parser.eat(">", true);
            // close any elements that don't have their own closing tags, e.g. <div><p></div>
            while(parent.name !== name){
                if (parent.type !== "Element") {
                    const error = parser.last_auto_closed_tag && parser.last_auto_closed_tag.tag === name ? parser_errors.invalid_closing_tag_autoclosed(name, parser.last_auto_closed_tag.reason) : parser_errors.invalid_closing_tag_unopened(name);
                    parser.error(error, start);
                }
                parent.end = start;
                parser.stack.pop();
                parent = parser.current();
            }
            parent.end = parser.index;
            parser.stack.pop();
            if (parser.last_auto_closed_tag && parser.stack.length < parser.last_auto_closed_tag.depth) parser.last_auto_closed_tag = null;
            return;
        } else if (closing_tag_omitted(parent.name, name)) {
            parent.end = start;
            parser.stack.pop();
            parser.last_auto_closed_tag = {
                tag: parent.name,
                reason: name,
                depth: parser.stack.length
            };
        }
        /**
	 * @type {Set<string>}
	 */ const unique_names = new Set();
        const is_top_level_script_or_style = specials.has(name) && parser.stack.length === 1;
        let attribute;
        while(attribute = read_attribute(parser, unique_names, is_top_level_script_or_style)){
            element.attributes.push(attribute);
            parser.allow_whitespace();
        }
        if (name === "svelte:component") {
            const index = element.attributes.findIndex((attr)=>attr.type === "Attribute" && attr.name === "this");
            if (index === -1) parser.error(parser_errors.missing_component_definition, start);
            const definition = element.attributes.splice(index, 1)[0];
            if (definition.value === true || definition.value.length !== 1 || definition.value[0].type === "Text") parser.error(parser_errors.invalid_component_definition, definition.start);
            element.expression = definition.value[0].expression;
        }
        if (name === "svelte:element") {
            const index = element.attributes.findIndex((attr)=>attr.type === "Attribute" && attr.name === "this");
            if (index === -1) parser.error(parser_errors.missing_element_definition, start);
            const definition = element.attributes.splice(index, 1)[0];
            if (definition.value === true) parser.error(parser_errors.invalid_element_definition, definition.start);
            element.tag = definition.value[0].data || definition.value[0].expression;
        }
        if (is_top_level_script_or_style) {
            const special = specials.get(name);
            parser.eat(">", true);
            const content = special.read(parser, start, element.attributes);
            if (content) parser[special.property].push(content);
            return;
        }
        parser.current().children.push(element);
        const self_closing = parser.eat("/") || is_void(name);
        parser.eat(">", true);
        if (self_closing) // don't push self-closing elements onto the stack
        element.end = parser.index;
        else if (name === "textarea") {
            // special case
            element.children = read_sequence(parser, ()=>regex_closing_textarea_tag.test(parser.template.slice(parser.index)), "inside <textarea>");
            parser.read(regex_closing_textarea_tag);
            element.end = parser.index;
        } else if (name === "script" || name === "style") {
            // special case
            const start = parser.index;
            const data = parser.read_until(new RegExp(`</${name}>`));
            const end = parser.index;
            element.children.push({
                start: start,
                end: end,
                type: "Text",
                data: data
            });
            parser.eat(`</${name}>`, true);
            element.end = parser.index;
        } else parser.stack.push(element);
    }
    const regex_whitespace_or_slash_or_closing_tag = /(\s|\/|>)/;
    /**
 * @param {import('../index.js').Parser} parser
 */ function read_tag_name(parser) {
        const start = parser.index;
        if (parser.read(SELF)) {
            // check we're inside a block, otherwise this
            // will cause infinite recursion
            let i = parser.stack.length;
            let legal = false;
            while(i--){
                const fragment = parser.stack[i];
                if (fragment.type === "IfBlock" || fragment.type === "EachBlock" || fragment.type === "InlineComponent") {
                    legal = true;
                    break;
                }
            }
            if (!legal) parser.error(parser_errors.invalid_self_placement, start);
            return "svelte:self";
        }
        if (parser.read(COMPONENT)) return "svelte:component";
        if (parser.read(ELEMENT)) return "svelte:element";
        if (parser.read(SLOT)) return "svelte:fragment";
        const name = parser.read_until(regex_whitespace_or_slash_or_closing_tag);
        if (meta_tags.has(name)) return name;
        if (name.startsWith("svelte:")) {
            const match = fuzzymatch(name.slice(7), valid_meta_tags);
            parser.error(parser_errors.invalid_tag_name_svelte_element(valid_meta_tags, match), start);
        }
        if (!valid_tag_name.test(name)) parser.error(parser_errors.invalid_tag_name, start);
        return name;
    }
    // eslint-disable-next-line no-useless-escape
    const regex_token_ending_character = /[\s=\/>"']/;
    const regex_starts_with_quote_characters = /^["']/;
    /**
 * @param {import('../index.js').Parser} parser
 * @param {Set<string>} unique_names
 * @param {boolean} is_static If `true`, `{` and `}` are not treated as delimiters for expressions
 */ function read_attribute(parser, unique_names, is_static) {
        const start = parser.index;
        /**
	 * @param {string} name
	 */ function check_unique(name) {
            if (unique_names.has(name)) parser.error(parser_errors.duplicate_attribute, start);
            unique_names.add(name);
        }
        if (!is_static && parser.eat("{")) {
            parser.allow_whitespace();
            if (parser.eat("...")) {
                const expression = read_expression(parser);
                parser.allow_whitespace();
                parser.eat("}", true);
                return {
                    start: start,
                    end: parser.index,
                    type: "Spread",
                    expression: expression
                };
            } else {
                const value_start = parser.index;
                const name = parser.read_identifier();
                parser.allow_whitespace();
                parser.eat("}", true);
                if (name === null) parser.error(parser_errors.empty_attribute_shorthand, start);
                check_unique(name);
                return {
                    start: start,
                    end: parser.index,
                    type: "Attribute",
                    name: name,
                    value: [
                        {
                            start: value_start,
                            end: value_start + name.length,
                            type: "AttributeShorthand",
                            expression: {
                                start: value_start,
                                end: value_start + name.length,
                                type: "Identifier",
                                name: name
                            }
                        }
                    ]
                };
            }
        }
        const name = parser.read_until(regex_token_ending_character);
        if (!name) return null;
        let end = parser.index;
        parser.allow_whitespace();
        const colon_index = name.indexOf(":");
        const type = colon_index !== -1 && get_directive_type(name.slice(0, colon_index));
        /**
	 * @type {any[] | true}
	 */ let value = true;
        if (parser.eat("=")) {
            parser.allow_whitespace();
            value = read_attribute_value(parser, is_static);
            end = parser.index;
        } else if (parser.match_regex(regex_starts_with_quote_characters)) parser.error(parser_errors.unexpected_token("="), parser.index);
        if (!is_static && type) {
            const [directive_name, ...modifiers] = name.slice(colon_index + 1).split("|");
            if (directive_name === "") parser.error(parser_errors.empty_directive_name(type), start + colon_index + 1);
            if (type === "Binding" && directive_name !== "this") check_unique(directive_name);
            else if (type !== "EventHandler" && type !== "Action") check_unique(name);
            if (type === "Ref") parser.error(parser_errors.invalid_ref_directive(directive_name), start);
            if (type === "StyleDirective") return {
                start: start,
                end: end,
                type: type,
                name: directive_name,
                modifiers: modifiers,
                value: value
            };
            const first_value = value[0];
            let expression = null;
            if (first_value) {
                const attribute_contains_text = /** @type {any[]} */ value.length > 1 || first_value.type === "Text";
                if (attribute_contains_text) parser.error(parser_errors.invalid_directive_value, first_value.start);
                else expression = first_value.expression;
            }
            const directive = {
                start: start,
                end: end,
                type: type,
                name: directive_name,
                modifiers: modifiers,
                expression: expression
            };
            if (type === "Transition") {
                const direction = name.slice(0, colon_index);
                directive.intro = direction === "in" || direction === "transition";
                directive.outro = direction === "out" || direction === "transition";
            }
            // Directive name is expression, e.g. <p class:isRed />
            if (!directive.expression && (type === "Binding" || type === "Class")) directive.expression = {
                start: directive.start + colon_index + 1,
                end: directive.end,
                type: "Identifier",
                name: directive.name
            };
            return directive;
        }
        check_unique(name);
        return {
            start: start,
            end: end,
            type: "Attribute",
            name: name,
            value: value
        };
    }
    /**
 * @param {string} name
 * @returns {import('../../interfaces.js').DirectiveType}
 */ function get_directive_type(name) {
        if (name === "use") return "Action";
        if (name === "animate") return "Animation";
        if (name === "bind") return "Binding";
        if (name === "class") return "Class";
        if (name === "style") return "StyleDirective";
        if (name === "on") return "EventHandler";
        if (name === "let") return "Let";
        if (name === "in" || name === "out" || name === "transition") return "Transition";
    }
    const regex_attribute_value = /^(?:"([^"]*)"|'([^'])*'|([^>\s]+))/;
    /**
 * @param {import('../index.js').Parser} parser
 * @param {boolean} is_static If `true`, `{` and `}` are not treated as delimiters for expressions
 */ function read_attribute_value(parser, is_static) {
        if (is_static) {
            let value = parser.match_regex(regex_attribute_value);
            if (!value) parser.error(parser_errors.missing_attribute_value);
            parser.index += value.length;
            const quoted = value[0] === '"' || value[0] === "'";
            if (quoted) value = value.slice(1, -1);
            return [
                {
                    start: parser.index - value.length - (quoted ? 1 : 0),
                    end: quoted ? parser.index - 1 : parser.index,
                    type: "Text",
                    raw: value,
                    data: decode_character_references(value, true)
                }
            ];
        }
        const quote_mark = parser.eat("'") ? "'" : parser.eat('"') ? '"' : null;
        if (quote_mark && parser.eat(quote_mark)) return [
            {
                start: parser.index - 1,
                end: parser.index - 1,
                type: "Text",
                raw: "",
                data: ""
            }
        ];
        let value;
        try {
            value = read_sequence(parser, ()=>{
                // handle common case of quote marks existing outside of regex for performance reasons
                if (quote_mark) return parser.match(quote_mark);
                return !!parser.match_regex(regex_starts_with_invalid_attr_value);
            }, "in attribute value");
        } catch (error) {
            if (error.code === "parse-error") // if the attribute value didn't close + self-closing tag
            // eg: `<Component test={{a:1} />`
            // acorn may throw a `Unterminated regular expression` because of `/>`
            {
                if (parser.template.slice(error.pos - 1, error.pos + 1) === "/>") {
                    parser.index = error.pos;
                    parser.error(parser_errors.unclosed_attribute_value(quote_mark || "}"));
                }
            }
            throw error;
        }
        if (value.length === 0 && !quote_mark) parser.error(parser_errors.missing_attribute_value);
        if (quote_mark) parser.index += 1;
        return value;
    }
    /**
 * @param {import('../index.js').Parser} parser
 * @param {() => boolean} done
 * @param {string} location
 * @returns {import('../../interfaces.js').TemplateNode[]}
 */ function read_sequence(parser, done, location) {
        /**
	 * @type {import('../../interfaces.js').Text}
	 */ let current_chunk = {
            start: parser.index,
            end: null,
            type: "Text",
            raw: "",
            data: null
        };
        /**
	 * @type {import('../../interfaces.js').TemplateNode[]}
	 */ const chunks = [];
        /**
	 * @param {number} end
	 */ function flush(end) {
            if (current_chunk.raw) {
                current_chunk.data = decode_character_references(current_chunk.raw, true);
                current_chunk.end = end;
                chunks.push(current_chunk);
            }
        }
        while(parser.index < parser.template.length){
            const index = parser.index;
            if (done()) {
                flush(parser.index);
                return chunks;
            } else if (parser.eat("{")) {
                if (parser.match("#")) {
                    const index = parser.index - 1;
                    parser.eat("#");
                    const name = parser.read_until(/[^a-z]/);
                    parser.error(parser_errors.invalid_logic_block_placement(location, name), index);
                } else if (parser.match("@")) {
                    const index = parser.index - 1;
                    parser.eat("@");
                    const name = parser.read_until(/[^a-z]/);
                    parser.error(parser_errors.invalid_tag_placement(location, name), index);
                }
                flush(parser.index - 1);
                parser.allow_whitespace();
                const expression = read_expression(parser);
                parser.allow_whitespace();
                parser.eat("}", true);
                chunks.push({
                    start: index,
                    end: parser.index,
                    type: "MustacheTag",
                    expression: expression
                });
                current_chunk = {
                    start: parser.index,
                    end: null,
                    type: "Text",
                    raw: "",
                    data: null
                };
            } else current_chunk.raw += parser.template[parser.index++];
        }
        parser.error(parser_errors.unexpected_eof);
    }
    // Adapted from https://github.com/acornjs/acorn/blob/6584815dca7440e00de841d1dad152302fdd7ca5/src/tokenize.js
    // Reproduced under MIT License https://github.com/acornjs/acorn/blob/master/LICENSE
    /**
 * @param {string} str
 * @param {number} i
 * @returns {number}
 */ function full_char_code_at(str, i) {
        const code = str.charCodeAt(i);
        if (code <= 0xd7ff || code >= 0xe000) return code;
        const next = str.charCodeAt(i + 1);
        return (code << 10) + next - 0x35fdc00;
    }
    const SQUARE_BRACKET_OPEN = "[".charCodeAt(0);
    const SQUARE_BRACKET_CLOSE = "]".charCodeAt(0);
    const CURLY_BRACKET_OPEN = "{".charCodeAt(0);
    const CURLY_BRACKET_CLOSE = "}".charCodeAt(0);
    function is_bracket_open(code) {
        return code === SQUARE_BRACKET_OPEN || code === CURLY_BRACKET_OPEN;
    }
    function is_bracket_close(code) {
        return code === SQUARE_BRACKET_CLOSE || code === CURLY_BRACKET_CLOSE;
    }
    function is_bracket_pair(open, close) {
        return open === SQUARE_BRACKET_OPEN && close === SQUARE_BRACKET_CLOSE || open === CURLY_BRACKET_OPEN && close === CURLY_BRACKET_CLOSE;
    }
    function get_bracket_close(open) {
        if (open === SQUARE_BRACKET_OPEN) return SQUARE_BRACKET_CLOSE;
        if (open === CURLY_BRACKET_OPEN) return CURLY_BRACKET_CLOSE;
    }
    /**
 * @param {import('../index.js').Parser} parser
 * @returns {import('estree').Pattern & { start: number; end: number }}
 */ function read_context(parser) {
        const start = parser.index;
        let i = parser.index;
        const code = full_char_code_at(parser.template, i);
        if (isIdentifierStart(code, true)) return {
            type: "Identifier",
            name: parser.read_identifier(),
            start: start,
            end: parser.index
        };
        if (!is_bracket_open(code)) parser.error(parser_errors.unexpected_token_destructure);
        const bracket_stack = [
            code
        ];
        i += code <= 0xffff ? 1 : 2;
        while(i < parser.template.length){
            const code = full_char_code_at(parser.template, i);
            if (is_bracket_open(code)) bracket_stack.push(code);
            else if (is_bracket_close(code)) {
                if (!is_bracket_pair(bracket_stack[bracket_stack.length - 1], code)) parser.error(parser_errors.unexpected_token(String.fromCharCode(get_bracket_close(bracket_stack[bracket_stack.length - 1]))));
                bracket_stack.pop();
                if (bracket_stack.length === 0) {
                    i += code <= 0xffff ? 1 : 2;
                    break;
                }
            }
            i += code <= 0xffff ? 1 : 2;
        }
        parser.index = i;
        const pattern_string = parser.template.slice(start, i);
        try {
            // the length of the `space_with_newline` has to be start - 1
            // because we added a `(` in front of the pattern_string,
            // which shifted the entire string to right by 1
            // so we offset it by removing 1 character in the `space_with_newline`
            // to achieve that, we remove the 1st space encountered,
            // so it will not affect the `column` of the node
            let space_with_newline = parser.template.slice(0, start).replace(regex_not_newline_characters, " ");
            const first_space = space_with_newline.indexOf(" ");
            space_with_newline = space_with_newline.slice(0, first_space) + space_with_newline.slice(first_space + 1);
            return parse_expression_at(`${space_with_newline}(${pattern_string} = 1)`, start - 1).left;
        } catch (error) {
            parser.acorn_error(error);
        }
    }
    /**
 * @param {string} str
 */ function trim_start(str) {
        return str.replace(regex_starts_with_whitespaces, "");
    }
    /**
 * @param {string} str
 */ function trim_end(str) {
        return str.replace(regex_ends_with_whitespaces, "");
    }
    /**
 * @param {import("../../interfaces.js").TemplateNode} node
 */ function to_string$1(node) {
        switch(node.type){
            case "IfBlock":
                return "{#if} block";
            case "ThenBlock":
                return "{:then} block";
            case "ElseBlock":
                return "{:else} block";
            case "PendingBlock":
            case "AwaitBlock":
                return "{#await} block";
            case "CatchBlock":
                return "{:catch} block";
            case "EachBlock":
                return "{#each} block";
            case "RawMustacheTag":
                return "{@html} block";
            case "DebugTag":
                return "{@debug} block";
            case "ConstTag":
                return "{@const} tag";
            case "Element":
            case "InlineComponent":
            case "Slot":
            case "Title":
                return `<${node.name}> tag`;
            default:
                return node.type;
        }
    }
    /**
 * @param {import('../../interfaces.js').TemplateNode} block
 * @param {boolean} trim_before
 * @param {boolean} trim_after
 */ function trim_whitespace(block, trim_before, trim_after) {
        if (!block.children || block.children.length === 0) return; // AwaitBlock
        const first_child = block.children[0];
        const last_child = block.children[block.children.length - 1];
        if (first_child.type === "Text" && trim_before) {
            first_child.data = trim_start(first_child.data);
            if (!first_child.data) block.children.shift();
        }
        if (last_child.type === "Text" && trim_after) {
            last_child.data = trim_end(last_child.data);
            if (!last_child.data) block.children.pop();
        }
        if (block.else) trim_whitespace(block.else, trim_before, trim_after);
        if (first_child.elseif) trim_whitespace(first_child, trim_before, trim_after);
    }
    const regex_whitespace_with_closing_curly_brace = /^\s*}/;
    /**
 * @param {import('../index.js').Parser} parser
 */ function mustache(parser) {
        const start = parser.index;
        parser.index += 1;
        parser.allow_whitespace();
        // {/if}, {/each}, {/await} or {/key}
        if (parser.eat("/")) {
            let block = parser.current();
            let expected;
            if (closing_tag_omitted(block.name)) {
                block.end = start;
                parser.stack.pop();
                block = parser.current();
            }
            if (block.type === "ElseBlock" || block.type === "PendingBlock" || block.type === "ThenBlock" || block.type === "CatchBlock") {
                block.end = start;
                parser.stack.pop();
                block = parser.current();
                expected = "await";
            }
            if (block.type === "IfBlock") expected = "if";
            else if (block.type === "EachBlock") expected = "each";
            else if (block.type === "AwaitBlock") expected = "await";
            else if (block.type === "KeyBlock") expected = "key";
            else parser.error(parser_errors.unexpected_block_close);
            parser.eat(expected, true);
            parser.allow_whitespace();
            parser.eat("}", true);
            while(block.elseif){
                block.end = parser.index;
                parser.stack.pop();
                block = parser.current();
                if (block.else) block.else.end = start;
            }
            // strip leading/trailing whitespace as necessary
            const char_before = parser.template[block.start - 1];
            const char_after = parser.template[parser.index];
            const trim_before = !char_before || regex_whitespace.test(char_before);
            const trim_after = !char_after || regex_whitespace.test(char_after);
            trim_whitespace(block, trim_before, trim_after);
            block.end = parser.index;
            parser.stack.pop();
        } else if (parser.eat(":else")) {
            if (parser.eat("if")) parser.error(parser_errors.invalid_elseif);
            parser.allow_whitespace();
            // :else if
            if (parser.eat("if")) {
                const block = parser.current();
                if (block.type !== "IfBlock") parser.error(parser.stack.some((block)=>block.type === "IfBlock") ? parser_errors.invalid_elseif_placement_unclosed_block(to_string$1(block)) : parser_errors.invalid_elseif_placement_outside_if);
                parser.require_whitespace();
                const expression = read_expression(parser);
                parser.allow_whitespace();
                parser.eat("}", true);
                block.else = {
                    start: parser.index,
                    end: null,
                    type: "ElseBlock",
                    children: [
                        {
                            start: parser.index,
                            end: null,
                            type: "IfBlock",
                            elseif: true,
                            expression: expression,
                            children: []
                        }
                    ]
                };
                parser.stack.push(block.else.children[0]);
            } else {
                // :else
                const block = parser.current();
                if (block.type !== "IfBlock" && block.type !== "EachBlock") parser.error(parser.stack.some((block)=>block.type === "IfBlock" || block.type === "EachBlock") ? parser_errors.invalid_else_placement_unclosed_block(to_string$1(block)) : parser_errors.invalid_else_placement_outside_if);
                parser.allow_whitespace();
                parser.eat("}", true);
                block.else = {
                    start: parser.index,
                    end: null,
                    type: "ElseBlock",
                    children: []
                };
                parser.stack.push(block.else);
            }
        } else if (parser.match(":then") || parser.match(":catch")) {
            const block = parser.current();
            const is_then = parser.eat(":then") || !parser.eat(":catch");
            if (is_then) {
                if (block.type !== "PendingBlock") parser.error(parser.stack.some((block)=>block.type === "PendingBlock") ? parser_errors.invalid_then_placement_unclosed_block(to_string$1(block)) : parser_errors.invalid_then_placement_without_await);
            } else if (block.type !== "ThenBlock" && block.type !== "PendingBlock") parser.error(parser.stack.some((block)=>block.type === "ThenBlock" || block.type === "PendingBlock") ? parser_errors.invalid_catch_placement_unclosed_block(to_string$1(block)) : parser_errors.invalid_catch_placement_without_await);
            block.end = start;
            parser.stack.pop();
            const await_block = parser.current();
            if (!parser.eat("}")) {
                parser.require_whitespace();
                await_block[is_then ? "value" : "error"] = read_context(parser);
                parser.allow_whitespace();
                parser.eat("}", true);
            }
            const new_block = {
                start: start,
                end: null,
                type: is_then ? "ThenBlock" : "CatchBlock",
                children: [],
                skip: false
            };
            await_block[is_then ? "then" : "catch"] = new_block;
            parser.stack.push(new_block);
        } else if (parser.eat("#")) {
            // {#if foo}, {#each foo} or {#await foo}
            let type;
            if (parser.eat("if")) type = "IfBlock";
            else if (parser.eat("each")) type = "EachBlock";
            else if (parser.eat("await")) type = "AwaitBlock";
            else if (parser.eat("key")) type = "KeyBlock";
            else parser.error(parser_errors.expected_block_type);
            parser.require_whitespace();
            const expression = read_expression(parser);
            const block = type === "AwaitBlock" ? {
                start: start,
                end: null,
                type: type,
                expression: expression,
                value: null,
                error: null,
                pending: {
                    start: null,
                    end: null,
                    type: "PendingBlock",
                    children: [],
                    skip: true
                },
                then: {
                    start: null,
                    end: null,
                    type: "ThenBlock",
                    children: [],
                    skip: true
                },
                catch: {
                    start: null,
                    end: null,
                    type: "CatchBlock",
                    children: [],
                    skip: true
                }
            } : {
                start: start,
                end: null,
                type: type,
                expression: expression,
                children: []
            };
            parser.allow_whitespace();
            // {#each} blocks must declare a context – {#each list as item}
            if (type === "EachBlock") {
                parser.eat("as", true);
                parser.require_whitespace();
                block.context = read_context(parser);
                parser.allow_whitespace();
                if (parser.eat(",")) {
                    parser.allow_whitespace();
                    block.index = parser.read_identifier();
                    if (!block.index) parser.error(parser_errors.expected_name);
                    parser.allow_whitespace();
                }
                if (parser.eat("(")) {
                    parser.allow_whitespace();
                    block.key = read_expression(parser);
                    parser.allow_whitespace();
                    parser.eat(")", true);
                    parser.allow_whitespace();
                }
            }
            const await_block_shorthand = type === "AwaitBlock" && parser.eat("then");
            if (await_block_shorthand) {
                if (parser.match_regex(regex_whitespace_with_closing_curly_brace)) parser.allow_whitespace();
                else {
                    parser.require_whitespace();
                    block.value = read_context(parser);
                    parser.allow_whitespace();
                }
            }
            const await_block_catch_shorthand = !await_block_shorthand && type === "AwaitBlock" && parser.eat("catch");
            if (await_block_catch_shorthand) {
                if (parser.match_regex(regex_whitespace_with_closing_curly_brace)) parser.allow_whitespace();
                else {
                    parser.require_whitespace();
                    block.error = read_context(parser);
                    parser.allow_whitespace();
                }
            }
            parser.eat("}", true);
            parser.current().children.push(block);
            parser.stack.push(block);
            if (type === "AwaitBlock") {
                let child_block;
                if (await_block_shorthand) {
                    block.then.skip = false;
                    child_block = block.then;
                } else if (await_block_catch_shorthand) {
                    block.catch.skip = false;
                    child_block = block.catch;
                } else {
                    block.pending.skip = false;
                    child_block = block.pending;
                }
                child_block.start = parser.index;
                parser.stack.push(child_block);
            }
        } else if (parser.eat("@html")) {
            // {@html content} tag
            parser.require_whitespace();
            const expression = read_expression(parser);
            parser.allow_whitespace();
            parser.eat("}", true);
            parser.current().children.push({
                start: start,
                end: parser.index,
                type: "RawMustacheTag",
                expression: expression
            });
        } else if (parser.eat("@debug")) {
            let identifiers;
            // Implies {@debug} which indicates "debug all"
            if (parser.read(regex_whitespace_with_closing_curly_brace)) identifiers = [];
            else {
                const expression = read_expression(parser);
                identifiers = expression.type === "SequenceExpression" ? expression.expressions : [
                    expression
                ];
                identifiers.forEach((node)=>{
                    if (node.type !== "Identifier") parser.error(parser_errors.invalid_debug_args, node.start);
                });
                parser.allow_whitespace();
                parser.eat("}", true);
            }
            parser.current().children.push({
                start: start,
                end: parser.index,
                type: "DebugTag",
                identifiers: identifiers
            });
        } else if (parser.eat("@const")) {
            // {@const a = b}
            parser.require_whitespace();
            const expression = read_expression(parser);
            if (!(expression.type === "AssignmentExpression" && expression.operator === "=")) parser.error({
                code: "invalid-const-args",
                message: "{@const ...} must be an assignment."
            }, start);
            parser.allow_whitespace();
            parser.eat("}", true);
            parser.current().children.push({
                start: start,
                end: parser.index,
                type: "ConstTag",
                expression: expression
            });
        } else {
            const expression = read_expression(parser);
            parser.allow_whitespace();
            parser.eat("}", true);
            parser.current().children.push({
                start: start,
                end: parser.index,
                type: "MustacheTag",
                expression: expression
            });
        }
    }
    /**
 * @param {import('../index.js').Parser} parser
 */ function text(parser) {
        const start = parser.index;
        let data = "";
        while(parser.index < parser.template.length && !parser.match("<") && !parser.match("{"))data += parser.template[parser.index++];
        const node = {
            start: start,
            end: parser.index,
            type: "Text",
            raw: data,
            data: decode_character_references(data, false)
        };
        parser.current().children.push(node);
    }
    /**
 * @param {import('../index.js').Parser} parser
 */ function fragment(parser) {
        if (parser.match("<")) return tag;
        if (parser.match("{")) return mustache;
        return text;
    }
    const reserved = new Set([
        "arguments",
        "await",
        "break",
        "case",
        "catch",
        "class",
        "const",
        "continue",
        "debugger",
        "default",
        "delete",
        "do",
        "else",
        "enum",
        "eval",
        "export",
        "extends",
        "false",
        "finally",
        "for",
        "function",
        "if",
        "implements",
        "import",
        "in",
        "instanceof",
        "interface",
        "let",
        "new",
        "null",
        "package",
        "private",
        "protected",
        "public",
        "return",
        "static",
        "super",
        "switch",
        "this",
        "throw",
        "true",
        "try",
        "typeof",
        "var",
        "void",
        "while",
        "with",
        "yield"
    ]);
    /**
 * @param {string} str
 * @returns {boolean}
 */ function is_valid(str) {
        let i = 0;
        while(i < str.length){
            const code = full_char_code_at(str, i);
            if (!(i === 0 ? isIdentifierStart : isIdentifierChar)(code, true)) return false;
            i += code <= 0xffff ? 1 : 2;
        }
        return true;
    }
    const regex_non_standard_characters = /[^a-zA-Z0-9_]+/g;
    const regex_starts_with_number = /^[0-9]/;
    /**
 * @param {string} name
 */ function sanitize(name) {
        return name.replace(regex_non_standard_characters, "_").replace(regex_starts_with_underscore, "").replace(regex_ends_with_underscore, "").replace(regex_starts_with_number, "_$&");
    }
    /** @typedef {import('./types').Location} Location */ /**
 * @param {import('./types').Range} range
 * @param {number} index
 */ function rangeContains(range, index) {
        return range.start <= index && index < range.end;
    }
    /**
 * @param {string} source
 * @param {import('./types').Options} [options]
 */ function getLocator$1(source, options = {}) {
        const { offsetLine: offsetLine = 0, offsetColumn: offsetColumn = 0 } = options;
        let start = 0;
        const ranges = source.split("\n").map((line, i)=>{
            const end = start + line.length + 1;
            /** @type {import('./types').Range} */ const range = {
                start: start,
                end: end,
                line: i
            };
            start = end;
            return range;
        });
        let i = 0;
        /**
	 * @param {string | number} search
	 * @param {number} [index]
	 * @returns {Location | undefined}
	 */ function locator(search, index) {
            if (typeof search === "string") search = source.indexOf(search, index ?? 0);
            if (search === -1) return undefined;
            let range = ranges[i];
            const d = search >= range.end ? 1 : -1;
            while(range){
                if (rangeContains(range, search)) return {
                    line: offsetLine + range.line,
                    column: offsetColumn + search - range.start,
                    character: search
                };
                i += d;
                range = ranges[i];
            }
        }
        return locator;
    }
    /**
 * @param {string} source
 * @param {string | number} search
 * @param {import('./types').Options} [options]
 * @returns {Location | undefined}
 */ function locate(source, search, options) {
        return getLocator$1(source, options)(search, options && options.startIndex);
    }
    const regex_tabs = /^\t+/;
    /**
 * @param {string} str
 */ function tabs_to_spaces(str) {
        return str.replace(regex_tabs, (match)=>match.split("	").join("  "));
    }
    /**
 * @param {string} source
 * @param {number} line
 * @param {number} column
 */ function get_code_frame(source, line, column) {
        const lines = source.split("\n");
        const frame_start = Math.max(0, line - 2);
        const frame_end = Math.min(line + 3, lines.length);
        const digits = String(frame_end + 1).length;
        return lines.slice(frame_start, frame_end).map((str, i)=>{
            const is_error_line = frame_start + i === line;
            const line_num = String(i + frame_start + 1).padStart(digits, " ");
            if (is_error_line) {
                const indicator = " ".repeat(digits + 2 + tabs_to_spaces(str.slice(0, column)).length) + "^";
                return `${line_num}: ${tabs_to_spaces(str)}\n${indicator}`;
            }
            return `${line_num}: ${tabs_to_spaces(str)}`;
        }).join("\n");
    }
    /**
 * @extends Error
 */ class CompileError extends Error {
        /**
	 * @type {string}
	 */ code = undefined;
        /**
	 * @type {{ line: number; column: number }}
	 */ start = undefined;
        /**
	 * @type {{ line: number; column: number }}
	 */ end = undefined;
        /**
	 * @type {number}
	 */ pos = undefined;
        /**
	 * @type {string}
	 */ filename = undefined;
        /**
	 * @type {string}
	 */ frame = undefined;
        toString() {
            return `${this.message} (${this.start.line}:${this.start.column})\n${this.frame}`;
        }
    }
    /**
 * @param {string} message
 * @param {{
 * 		name: string;
 * 		code: string;
 * 		source: string;
 * 		filename: string;
 * 		start: number;
 * 		end?: number;
 * 	}} props
 * @returns {never}
 */ function error(message, props) {
        const error = new CompileError(message);
        error.name = props.name;
        const start = locate(props.source, props.start, {
            offsetLine: 1
        });
        const end = locate(props.source, props.end || props.start, {
            offsetLine: 1
        });
        error.code = props.code;
        error.start = start;
        error.end = end;
        error.pos = props.start;
        error.filename = props.filename;
        error.frame = get_code_frame(props.source, start.line - 1, start.column);
        throw error;
    }
    const regex_position_indicator = / \(\d+:\d+\)$/;
    class Parser {
        /**
	 * @readonly
	 * @type {string}
	 */ template = undefined;
        /**
	 * @readonly
	 * @type {string}
	 */ filename = undefined;
        /**
	 * @readonly
	 * @type {boolean}
	 */ customElement = undefined;
        /**
	 * @readonly
	 * @type {'injected' | 'external' | 'none' | boolean}
	 */ css_mode = undefined;
        index = 0;
        /**
	 * @type {import('../interfaces.js').TemplateNode[]}
	 */ stack = [];
        /**
	 * @type {import('../interfaces.js').Fragment}
	 */ html = undefined;
        /**
	 * @type {import('../interfaces.js').Style[]}
	 */ css = [];
        /**
	 * @type {import('../interfaces.js').Script[]}
	 */ js = [];
        meta_tags = {};
        /**
	 * @type {{tag: string; reason: string; depth: number;}}
	 */ last_auto_closed_tag = undefined;
        /**
	 * @param {string} template
	 * @param {import('../interfaces.js').ParserOptions} options
	 */ constructor(template, options){
            if (typeof template !== "string") throw new TypeError("Template must be a string");
            this.template = template.trimRight();
            this.filename = options.filename;
            this.customElement = options.customElement;
            this.css_mode = options.css;
            this.html = {
                start: null,
                end: null,
                type: "Fragment",
                children: []
            };
            this.stack.push(this.html);
            /**
		 * @typedef {(parser: Parser) => ParserState | void} ParserState
		 */ /** @type {ParserState} */ let state = fragment;
            while(this.index < this.template.length)state = state(this) || fragment;
            if (this.stack.length > 1) {
                const current = this.current();
                const type = current.type === "Element" ? `<${current.name}>` : "Block";
                const slug = current.type === "Element" ? "element" : "block";
                this.error({
                    code: `unclosed-${slug}`,
                    message: `${type} was left open`
                }, current.start);
            }
            if (state !== fragment) this.error({
                code: "unexpected-eof",
                message: "Unexpected end of input"
            });
            if (this.html.children.length) {
                let start = this.html.children[0].start;
                while(regex_whitespace.test(template[start]))start += 1;
                let end = this.html.children[this.html.children.length - 1].end;
                while(regex_whitespace.test(template[end - 1]))end -= 1;
                this.html.start = start;
                this.html.end = end;
            } else this.html.start = this.html.end = null;
        }
        current() {
            return this.stack[this.stack.length - 1];
        }
        /**
	 * @param {any} err
	 */ acorn_error(err) {
            this.error({
                code: "parse-error",
                message: err.message.replace(regex_position_indicator, "")
            }, err.pos);
        }
        /**
	 * @param {{ code: string; message: string }} err
	 */ error({ code: code, message: message }, index = this.index) {
            error(message, {
                name: "ParseError",
                code: code,
                source: this.template,
                start: index,
                filename: this.filename
            });
        }
        /**
	 * @param {string} str
	 * @param {boolean} [required]
	 * @param {{ code: string; message: string }} [error]
	 */ eat(str, required, error) {
            if (this.match(str)) {
                this.index += str.length;
                return true;
            }
            if (required) this.error(error || (this.index === this.template.length ? parser_errors.unexpected_eof_token(str) : parser_errors.unexpected_token(str)));
            return false;
        }
        /**
	 * @param {string} str
	 */ match(str) {
            return this.template.slice(this.index, this.index + str.length) === str;
        }
        /**
	 * Match a regex at the current index
	 * @param {RegExp} pattern  Should have a ^ anchor at the start so the regex doesn't search past the beginning, resulting in worse performance
	 */ match_regex(pattern) {
            const match = pattern.exec(this.template.slice(this.index));
            if (!match || match.index !== 0) return null;
            return match[0];
        }
        allow_whitespace() {
            while(this.index < this.template.length && regex_whitespace.test(this.template[this.index]))this.index++;
        }
        /**
	 * Search for a regex starting at the current index and return the result if it matches
	 * @param {RegExp} pattern  Should have a ^ anchor at the start so the regex doesn't search past the beginning, resulting in worse performance
	 */ read(pattern) {
            const result = this.match_regex(pattern);
            if (result) this.index += result.length;
            return result;
        }
        read_identifier(allow_reserved = false) {
            const start = this.index;
            let i = this.index;
            const code = full_char_code_at(this.template, i);
            if (!isIdentifierStart(code, true)) return null;
            i += code <= 0xffff ? 1 : 2;
            while(i < this.template.length){
                const code = full_char_code_at(this.template, i);
                if (!isIdentifierChar(code, true)) break;
                i += code <= 0xffff ? 1 : 2;
            }
            const identifier = this.template.slice(this.index, this.index = i);
            if (!allow_reserved && reserved.has(identifier)) this.error({
                code: "unexpected-reserved-word",
                message: `'${identifier}' is a reserved word in JavaScript and cannot be used here`
            }, start);
            return identifier;
        }
        /**
	 * @param {RegExp} pattern
	 * @param {Parameters<Parser['error']>[0]} [error_message]
	 */ read_until(pattern, error_message) {
            if (this.index >= this.template.length) this.error(error_message || {
                code: "unexpected-eof",
                message: "Unexpected end of input"
            });
            const start = this.index;
            const match = pattern.exec(this.template.slice(start));
            if (match) {
                this.index = start + match.index;
                return this.template.slice(start, this.index);
            }
            this.index = this.template.length;
            return this.template.slice(start);
        }
        require_whitespace() {
            if (!regex_whitespace.test(this.template[this.index])) this.error({
                code: "missing-whitespace",
                message: "Expected whitespace"
            });
            this.allow_whitespace();
        }
    }
    /**
 * The parse function parses a component, returning only its abstract syntax tree.
 *
 * https://svelte.dev/docs/svelte-compiler#svelte-parse
 * @param {string} template
 * @param {import('../interfaces.js').ParserOptions} options
 * @returns {import('../interfaces.js').Ast}
 */ function parse(template, options = {}) {
        const parser = new Parser(template, options);
        // TODO we may want to allow multiple <style> tags —
        // one scoped, one global. for now, only allow one
        if (parser.css.length > 1) parser.error(parser_errors.duplicate_style, parser.css[1].start);
        const instance_scripts = parser.js.filter((script)=>script.context === "default");
        const module_scripts = parser.js.filter((script)=>script.context === "module");
        if (instance_scripts.length > 1) parser.error(parser_errors.invalid_script_instance, instance_scripts[1].start);
        if (module_scripts.length > 1) parser.error(parser_errors.invalid_script_module, module_scripts[1].start);
        return {
            html: parser.html,
            css: parser.css[0],
            instance: instance_scripts[0],
            module: module_scripts[0]
        };
    }
    /**
 * @param {import("estree").Node} node
 */ function is_head(node) {
        return node && node.type === "MemberExpression" && node.object["name"] === "@_document" && node.property["name"] === "head";
    }
    let Block$1 = class Block {
        /**
	 * @typedef {Object} Bindings
	 * @property {import('estree').Identifier} object
	 * @property {import('estree').Identifier} property
	 * @property {import('estree').Node} snippet
	 * @property {string} store
	 * @property {(node:import('estree').Node) => import('estree').Node} modifier
	 */ /**
	 * @typedef {Object} BlockOptions
	 * @property {Block} [parent]
	 * @property {import('estree').Identifier} name
	 * @property {string} type
	 * @property {import('./Renderer.js').default} [renderer]
	 * @property {string} [comment]
	 * @property {import('estree').Identifier} [key]
	 * @property {Map<string,Bindings>} [bindings]
	 * @property {Set<string>} [dependencies]
	 */ /** @type {Block} */ parent;
        /** @type {import('./Renderer.js').default} */ renderer;
        /** @type {import('estree').Identifier} */ name;
        /** @type {string} */ type;
        /** @type {string} */ comment;
        /** @type {import('./wrappers/shared/Wrapper.js').default[]} */ wrappers;
        /** @type {import('estree').Identifier} */ key;
        /** @type {import('estree').Identifier} */ first;
        /** @type {Set<string>} */ dependencies = new Set();
        /** @type {Map<string, Bindings>} */ bindings;
        /** @type {Set<string>} */ binding_group_initialised = new Set();
        /** @type {Set<import('./Renderer.js').BindingGroup>} */ binding_groups = new Set();
        /**
	 * @type {{
	 * 		declarations: Array<import('estree').Node | import('estree').Node[]>;
	 * 		init: Array<import('estree').Node | import('estree').Node[]>;
	 * 		create: Array<import('estree').Node | import('estree').Node[]>;
	 * 		claim: Array<import('estree').Node | import('estree').Node[]>;
	 * 		hydrate: Array<import('estree').Node | import('estree').Node[]>;
	 * 		mount: Array<import('estree').Node | import('estree').Node[]>;
	 * 		measure: Array<import('estree').Node | import('estree').Node[]>;
	 * 		restore_measurements: Array<import('estree').Node | import('estree').Node[]>;
	 * 		fix: Array<import('estree').Node | import('estree').Node[]>;
	 * 		animate: Array<import('estree').Node | import('estree').Node[]>;
	 * 		intro: Array<import('estree').Node | import('estree').Node[]>;
	 * 		update: Array<import('estree').Node | import('estree').Node[]>;
	 * 		outro: Array<import('estree').Node | import('estree').Node[]>;
	 * 		destroy: Array<import('estree').Node | import('estree').Node[]>;
	 * 	}}
	 */ chunks;
        /** @type {import('estree').Node[]} */ event_listeners = [];
        /** @type {boolean} */ maintain_context;
        /** @type {boolean} */ has_animation;
        /** @type {boolean} */ has_intros;
        /** @type {boolean} */ has_outros;
        /** @type {boolean} */ has_intro_method;
        /** @type {boolean} */ has_outro_method;
        /** @type {number} */ outros;
        /** @type {Map<string, import('estree').Identifier>} */ aliases;
        /** @type {Map<string, { id: import('estree').Identifier; init?: import('estree').Node }>} */ variables = new Map();
        /** @type {(name: string) => import('estree').Identifier} */ get_unique_name;
        /** */ has_update_method = false;
        /** @type {{ element_var: string; condition_expression?: any }} */ autofocus;
        /** @param {BlockOptions} options */ constructor(options){
            this.parent = options.parent;
            this.renderer = options.renderer;
            this.name = options.name;
            this.type = options.type;
            this.comment = options.comment;
            this.wrappers = [];
            // for keyed each blocks
            this.key = options.key;
            this.first = null;
            this.bindings = options.bindings;
            this.chunks = {
                declarations: [],
                init: [],
                create: [],
                claim: [],
                hydrate: [],
                mount: [],
                measure: [],
                restore_measurements: [],
                fix: [],
                animate: [],
                intro: [],
                update: [],
                outro: [],
                destroy: []
            };
            this.has_animation = false;
            this.has_intro_method = false; // a block could have an intro method but not intro transitions, e.g. if a sibling block has intros
            this.has_outro_method = false;
            this.outros = 0;
            this.get_unique_name = this.renderer.component.get_unique_name_maker();
            this.aliases = new Map();
            if (this.key) this.aliases.set("key", this.get_unique_name("key"));
        }
        assign_variable_names() {
            /** @type {Set<string>} */ const seen = new Set();
            /** @type {Set<string>} */ const dupes = new Set();
            let i = this.wrappers.length;
            while(i--){
                const wrapper = this.wrappers[i];
                if (!wrapper.var) continue;
                if (seen.has(wrapper.var.name)) dupes.add(wrapper.var.name);
                seen.add(wrapper.var.name);
            }
            const counts = new Map();
            i = this.wrappers.length;
            while(i--){
                const wrapper = this.wrappers[i];
                if (!wrapper.var) continue;
                let suffix = "";
                if (dupes.has(wrapper.var.name)) {
                    const i = counts.get(wrapper.var.name) || 0;
                    counts.set(wrapper.var.name, i + 1);
                    suffix = i;
                }
                wrapper.var.name = this.get_unique_name(wrapper.var.name + suffix).name;
            }
        }
        /** @param {Set<string>} dependencies */ add_dependencies(dependencies) {
            dependencies.forEach((dependency)=>{
                this.dependencies.add(dependency);
            });
            this.has_update_method = true;
            if (this.parent) this.parent.add_dependencies(dependencies);
        }
        /**
	 * @param {import('estree').Identifier} id
	 * @param {import('estree').Node} render_statement
	 * @param {import('estree').Node} claim_statement
	 * @param {import('estree').Node} parent_node
	 * @param {boolean} [no_detach]
	 */ add_element(id, render_statement, claim_statement, parent_node, no_detach) {
            this.add_variable(id);
            this.chunks.create.push(b$1`${id} = ${render_statement};`);
            if (this.renderer.options.hydratable) this.chunks.claim.push(b$1`${id} = ${claim_statement || render_statement};`);
            if (parent_node) {
                this.chunks.mount.push(b$1`@append(${parent_node}, ${id});`);
                if (is_head(parent_node) && !no_detach) this.chunks.destroy.push(b$1`@detach(${id});`);
            } else {
                this.chunks.mount.push(b$1`@insert(#target, ${id}, #anchor);`);
                if (!no_detach) this.chunks.destroy.push(b$1`if (detaching) @detach(${id});`);
            }
        }
        /** @param {boolean} [local] */ add_intro(local) {
            this.has_intros = this.has_intro_method = true;
            if (!local && this.parent) this.parent.add_intro();
        }
        /** @param {boolean} [local] */ add_outro(local) {
            this.has_outros = this.has_outro_method = true;
            this.outros += 1;
            if (!local && this.parent) this.parent.add_outro();
        }
        add_animation() {
            this.has_animation = true;
        }
        /**
	 * @param {import('estree').Identifier} id
	 * @param {import('estree').Node} [init]
	 */ add_variable(id, init) {
            if (this.variables.has(id.name)) throw new Error(`Variable '${id.name}' already initialised with a different value`);
            this.variables.set(id.name, {
                id: id,
                init: init
            });
        }
        /** @param {string} name */ alias(name) {
            if (!this.aliases.has(name)) this.aliases.set(name, this.get_unique_name(name));
            return this.aliases.get(name);
        }
        /** @param {BlockOptions} options */ child(options) {
            return new Block(Object.assign({}, this, {
                key: null
            }, options, {
                parent: this
            }));
        }
        /** @param {any} [key] */ get_contents(key) {
            const { dev: dev } = this.renderer.options;
            if (this.has_outros) {
                this.add_variable({
                    type: "Identifier",
                    name: "#current"
                });
                if (this.chunks.intro.length > 0) {
                    this.chunks.intro.push(b$1`#current = true;`);
                    this.chunks.mount.push(b$1`#current = true;`);
                }
                if (this.chunks.outro.length > 0) this.chunks.outro.push(b$1`#current = false;`);
            }
            if (this.autofocus) {
                if (this.autofocus.condition_expression) this.chunks.mount.push(b$1`if (${this.autofocus.condition_expression}) ${this.autofocus.element_var}.focus();`);
                else this.chunks.mount.push(b$1`${this.autofocus.element_var}.focus();`);
            }
            this.render_binding_groups();
            this.render_listeners();
            /** @type {Record<string, any>} */ const properties = {};
            const noop = x$1`@noop`;
            properties.key = key;
            if (this.first) {
                properties.first = x$1`null`;
                this.chunks.hydrate.push(b$1`this.first = ${this.first};`);
            }
            if (this.chunks.create.length === 0 && this.chunks.hydrate.length === 0) properties.create = noop;
            else {
                const hydrate = this.chunks.hydrate.length > 0 && (this.renderer.options.hydratable ? b$1`this.h();` : this.chunks.hydrate);
                properties.create = x$1`function #create() {
				${this.chunks.create}
				${hydrate}
			}`;
            }
            if (this.renderer.options.hydratable || this.chunks.claim.length > 0) {
                if (this.chunks.claim.length === 0 && this.chunks.hydrate.length === 0) properties.claim = noop;
                else properties.claim = x$1`function #claim(#nodes) {
					${this.chunks.claim}
					${this.renderer.options.hydratable && this.chunks.hydrate.length > 0 && b$1`this.h();`}
				}`;
            }
            if (this.renderer.options.hydratable && this.chunks.hydrate.length > 0) properties.hydrate = x$1`function #hydrate() {
				${this.chunks.hydrate}
			}`;
            if (this.chunks.mount.length === 0) properties.mount = noop;
            else if (this.event_listeners.length === 0) properties.mount = x$1`function #mount(#target, #anchor) {
				${this.chunks.mount}
			}`;
            else properties.mount = x$1`function #mount(#target, #anchor) {
				${this.chunks.mount}
			}`;
            if (this.has_update_method || this.maintain_context) {
                if (this.chunks.update.length === 0 && !this.maintain_context) properties.update = noop;
                else {
                    const ctx = this.maintain_context ? x$1`#new_ctx` : x$1`#ctx`;
                    /** @type {import('estree').Identifier | import('estree').ArrayPattern} */ let dirty = {
                        type: "Identifier",
                        name: "#dirty"
                    };
                    if (!this.renderer.context_overflow && !this.parent) dirty = {
                        type: "ArrayPattern",
                        elements: [
                            dirty
                        ]
                    };
                    properties.update = x$1`function #update(${ctx}, ${dirty}) {
					${this.maintain_context && b$1`#ctx = ${ctx};`}
					${this.chunks.update}
				}`;
                }
            }
            if (this.has_animation) {
                properties.measure = x$1`function #measure() {
				${this.chunks.measure}
			}`;
                if (this.chunks.restore_measurements.length) properties.restore_measurements = x$1`function #restore_measurements(#measurement) {
					${this.chunks.restore_measurements}
				}`;
                properties.fix = x$1`function #fix() {
				${this.chunks.fix}
			}`;
                properties.animate = x$1`function #animate() {
				${this.chunks.animate}
			}`;
            }
            if (this.has_intro_method || this.has_outro_method) {
                if (this.chunks.intro.length === 0) properties.intro = noop;
                else properties.intro = x$1`function #intro(#local) {
					${this.has_outros && b$1`if (#current) return;`}
					${this.chunks.intro}
				}`;
                if (this.chunks.outro.length === 0) properties.outro = noop;
                else properties.outro = x$1`function #outro(#local) {
					${this.chunks.outro}
				}`;
            }
            if (this.chunks.destroy.length === 0) properties.destroy = noop;
            else {
                const dispose_elements = [];
                // Coalesce if blocks with the same condition
                const others = flatten$1(this.chunks.destroy).filter(/** @param {import('estree').Node} node */ (node)=>{
                    if (node.type === "IfStatement" && node.test.type === "Identifier" && node.test.name === "detaching") {
                        dispose_elements.push(node.consequent);
                        return false;
                    } else return true;
                });
                properties.destroy = x$1`function #destroy(detaching) {
				${dispose_elements.length ? b$1`if (detaching) { ${dispose_elements} }` : null}
				${others}
			}`;
            }
            if (!this.renderer.component.compile_options.dev) // allow shorthand names
            for(const name in properties){
                const property = properties[name];
                if (property) property.id = null;
            }
            /** @type {any} */ const return_value = x$1`{
			key: ${properties.key},
			first: ${properties.first},
			c: ${properties.create},
			l: ${properties.claim},
			h: ${properties.hydrate},
			m: ${properties.mount},
			p: ${properties.update},
			r: ${properties.measure},
			s: ${properties.restore_measurements},
			f: ${properties.fix},
			a: ${properties.animate},
			i: ${properties.intro},
			o: ${properties.outro},
			d: ${properties.destroy}
		}`;
            const block = dev && this.get_unique_name("block");
            const body = b$1`
			${this.chunks.declarations}

			${Array.from(this.variables.values()).map(({ id: id, init: init })=>{
                return init ? b$1`let ${id} = ${init}` : b$1`let ${id}`;
            })}

			${this.chunks.init}

			${dev ? b$1`
					const ${block} = ${return_value};
					@dispatch_dev("SvelteRegisterBlock", {
						block: ${block},
						id: ${this.name || "create_fragment"}.name,
						type: "${this.type}",
						source: "${this.comment ? this.comment.replace(regex_double_quotes, '\\"') : ""}",
						ctx: #ctx
					});
					return ${block};` : b$1`
					return ${return_value};`}
		`;
            return body;
        }
        /** @returns {boolean} */ has_content() {
            return !!this.first || this.event_listeners.length > 0 || this.chunks.intro.length > 0 || this.chunks.outro.length > 0 || this.chunks.create.length > 0 || this.chunks.hydrate.length > 0 || this.chunks.claim.length > 0 || this.chunks.mount.length > 0 || this.chunks.update.length > 0 || this.chunks.destroy.length > 0 || this.has_animation;
        }
        render() {
            const key = this.key && this.get_unique_name("key");
            /** @type {any[]} */ const args = [
                x$1`#ctx`
            ];
            if (key) args.unshift(key);
            const fn = b$1`function ${this.name}(${args}) {
			${this.get_contents(key)}
		}`;
            return this.comment ? b$1`
				// ${this.comment}
				${fn}` : fn;
        }
        /** @param {string} chunk */ render_listeners(chunk = "") {
            if (this.event_listeners.length > 0) {
                this.add_variable({
                    type: "Identifier",
                    name: "#mounted"
                });
                this.chunks.destroy.push(b$1`#mounted = false`);
                /** @type {import('estree').Identifier} */ const dispose = {
                    type: "Identifier",
                    name: `#dispose${chunk}`
                };
                this.add_variable(dispose);
                if (this.event_listeners.length === 1) {
                    this.chunks.mount.push(b$1`
						if (!#mounted) {
							${dispose} = ${this.event_listeners[0]};
							#mounted = true;
						}
					`);
                    this.chunks.destroy.push(b$1`${dispose}();`);
                } else {
                    this.chunks.mount.push(b$1`
					if (!#mounted) {
						${dispose} = [
							${this.event_listeners}
						];
						#mounted = true;
					}
				`);
                    this.chunks.destroy.push(b$1`@run_all(${dispose});`);
                }
            }
        }
        render_binding_groups() {
            for (const binding_group of this.binding_groups)binding_group.render(this);
        }
    };
    /**
 * @template {import('../../../../interfaces.js').TemplateNode} [NodeType=import('../../../../interfaces.js').TemplateNode]
 */ class Wrapper {
        /** @type {import('../../Renderer.js').default} */ renderer;
        /** @type {Wrapper} */ parent;
        /** @type {NodeType} */ node;
        /** @type {Wrapper | null} */ prev;
        /** @type {Wrapper | null} */ next;
        /** @type {import('estree').Identifier} */ var;
        /**
	 * @param {import('../../Renderer.js').default} renderer
	 * @param {import('../../Block.js').default} block
	 * @param {Wrapper} parent
	 * @param {NodeType} node
	 */ constructor(renderer, block, parent, node){
            this.node = node;
            // make these non-enumerable so that they can be logged sensibly
            // (TODO in dev only?)
            Object.defineProperties(this, {
                renderer: {
                    value: renderer
                },
                parent: {
                    value: parent
                }
            });
            block.wrappers.push(this);
        }
        /**
	 * @param {import('../../Block.js').default} block
	 * @param {import('estree').Identifier} parent_node
	 * @param {import('estree').Identifier} parent_nodes
	 */ get_or_create_anchor(block, parent_node, parent_nodes) {
            // TODO use this in EachBlock and IfBlock — tricky because
            // children need to be created first
            const needs_anchor = this.next ? !this.next.is_dom_node() : !parent_node || !this.parent.is_dom_node();
            const anchor = needs_anchor ? block.get_unique_name(`${this.var.name}_anchor`) : this.next && this.next.var || {
                type: "Identifier",
                name: "null"
            };
            if (needs_anchor) block.add_element(anchor, x$1`@empty()`, parent_nodes && x$1`@empty()`, /** @type {import('estree').Identifier} */ parent_node);
            return anchor;
        }
        /**
	 * @param {import('estree').Identifier} anchor
	 * @returns {import('estree').Identifier}
	 */ get_update_mount_node(anchor) {
            return /** @type {import('estree').Identifier} */ this.parent && this.parent.is_dom_node() ? this.parent.var : x$1`${anchor}.parentNode`;
        }
        is_dom_node() {
            return this.node.type === "Element" || this.node.type === "Text" || this.node.type === "MustacheTag";
        }
        /**
	 * @param {import('../../Block.js').default} _block
	 * @param {import('estree').Identifier} _parent_node
	 * @param {import('estree').Identifier} _parent_nodes
	 * @param {Record<string, any>} _data
	 */ render(_block, _parent_node, _parent_nodes, _data) {
            throw Error("Wrapper class is not renderable");
        }
    }
    /**
 * @param {import('../../../nodes/interfaces.js').INode} node
 * @param {import('../../../Component.js').default} component
 */ function create_debugging_comment(node, component) {
        const { locate: locate, source: source } = component;
        let c = node.start;
        if (node.type === "ElseBlock") {
            while(source[c - 1] !== "{")c -= 1;
            while(source[c - 1] === "{")c -= 1;
        }
        /** @type {number} */ let d;
        if (node.type === "InlineComponent" || node.type === "Element" || node.type === "SlotTemplate") {
            if (node.children.length) {
                d = node.children[0].start;
                while(source[d - 1] !== ">")d -= 1;
            } else {
                d = node.start;
                while(source[d] !== ">")d += 1;
                d += 1;
            }
        } else if (node.type === "Text" || node.type === "Comment") d = node.end;
        else {
            // @ts-ignore
            d = node.expression ? node.expression.node.end : c;
            while(source[d] !== "}" && d <= source.length)d += 1;
            while(source[d] === "}")d += 1;
        }
        const start = locate(c);
        const loc = `(${start.line}:${start.column})`;
        return `${loc} ${source.slice(c, d)}`.replace(regex_whitespace_characters, " ");
    }
    /**
 * @template {string} Type
 * @template {import('../interfaces.js').INode} [Parent=import('../interfaces.js').INode]
 */ class Node {
        /**
	 * @readonly
	 * @type {number}
	 */ start;
        /**
	 * @readonly
	 * @type {number}
	 */ end;
        /**
	 * @readonly
	 * @type {import('../../Component.js').default}
	 */ component;
        /**
	 * @readonly
	 * @type {Parent}
	 */ parent;
        /**
	 * @readonly
	 * @type {Type}
	 */ type;
        /** @type {import('../interfaces.js').INode} */ prev;
        /** @type {import('../interfaces.js').INode} */ next;
        /** @type {boolean} */ can_use_innerhtml;
        /** @type {boolean} */ is_static_content;
        /** @type {string} */ var;
        /** @type {import('../Attribute.js').default[]} */ attributes = [];
        /**
	 * @param {import('../../Component.js').default} component
	 * @param {Node} parent
	 * @param {any} _scope
	 * @param {import('../../../interfaces.js').TemplateNode} info
	 */ constructor(component, parent, _scope, info){
            this.start = info.start;
            this.end = info.end;
            this.type = /** @type {Type} */ info.type;
            // this makes properties non-enumerable, which makes logging
            // bearable. might have a performance cost. TODO remove in prod?
            Object.defineProperties(this, {
                component: {
                    value: component
                },
                parent: {
                    value: parent
                }
            });
            this.can_use_innerhtml = true;
            this.is_static_content = true;
        }
        cannot_use_innerhtml() {
            if (this.can_use_innerhtml !== false) {
                this.can_use_innerhtml = false;
                if (this.parent) this.parent.cannot_use_innerhtml();
            }
        }
        not_static_content() {
            this.is_static_content = false;
            if (this.parent) this.parent.not_static_content();
        }
        /** @param {RegExp} selector */ find_nearest(selector) {
            if (selector.test(this.type)) return this;
            if (this.parent) return this.parent.find_nearest(selector);
        }
        /** @param {string} name */ get_static_attribute_value(name) {
            const attribute = this.attributes.find(/** @param {import('../Attribute.js').default} attr */ (attr)=>attr.type === "Attribute" && attr.name.toLowerCase() === name);
            if (!attribute) return null;
            if (attribute.is_true) return true;
            if (attribute.chunks.length === 0) return "";
            if (attribute.chunks.length === 1 && attribute.chunks[0].type === "Text") return /** @type {import('../Text.js').default} */ attribute.chunks[0].data;
            return null;
        }
        /** @param {string} type */ has_ancestor(type) {
            return this.parent ? this.parent.type === type || this.parent.has_ancestor(type) : false;
        }
    }
    /**
 * @internal
 */ var compiler_warnings = {
        tag_option_deprecated: {
            code: "tag-option-deprecated",
            message: "'tag' option is deprecated \u2014 use 'customElement' instead"
        },
        unused_export_let: /**
	 * @param {string} component
	 * @param {string} property
	 */ (component, property)=>({
                code: "unused-export-let",
                message: `${component} has unused export property '${property}'. If it is for external reference only, please consider using \`export const ${property}\``
            }),
        module_script_reactive_declaration: {
            code: "module-script-reactive-declaration",
            message: "$: has no effect in a module script"
        },
        non_top_level_reactive_declaration: {
            code: "non-top-level-reactive-declaration",
            message: "$: has no effect outside of the top-level"
        },
        module_script_variable_reactive_declaration: /** @param {string[]} names */ (names)=>({
                code: "module-script-reactive-declaration",
                message: `${names.map((name)=>`"${name}"`).join(", ")} ${names.length > 1 ? "are" : "is"} declared in a module script and will not be reactive`
            }),
        missing_declaration: /**
	 * @param {string} name
	 * @param {boolean} has_script
	 */ (name, has_script)=>({
                code: "missing-declaration",
                message: `'${name}' is not defined` + (has_script ? "" : `. Consider adding a <script> block with 'export let ${name}' to declare a prop`)
            }),
        missing_custom_element_compile_options: {
            code: "missing-custom-element-compile-options",
            message: "The 'customElement' option is used when generating a custom element. Did you forget the 'customElement: true' compile option?"
        },
        css_unused_selector: /** @param {string} selector */ (selector)=>({
                code: "css-unused-selector",
                message: `Unused CSS selector "${selector}"`
            }),
        empty_block: {
            code: "empty-block",
            message: "Empty block"
        },
        reactive_component: /** @param {string} name */ (name)=>({
                code: "reactive-component",
                message: `<${name}/> will not be reactive if ${name} changes. Use <svelte:component this={${name}}/> if you want this reactivity.`
            }),
        component_name_lowercase: /** @param {string} name */ (name)=>({
                code: "component-name-lowercase",
                message: `<${name}> will be treated as an HTML element unless it begins with a capital letter`
            }),
        avoid_is: {
            code: "avoid-is",
            message: "The 'is' attribute is not supported cross-browser and should be avoided"
        },
        invalid_html_attribute: /**
	 * @param {string} name
	 * @param {string} suggestion
	 */ (name, suggestion)=>({
                code: "invalid-html-attribute",
                message: `'${name}' is not a valid HTML attribute. Did you mean '${suggestion}'?`
            }),
        a11y_aria_attributes: /** @param {string} name */ (name)=>({
                code: "a11y-aria-attributes",
                message: `A11y: <${name}> should not have aria-* attributes`
            }),
        a11y_incorrect_attribute_type: /**
	 * @param {import('aria-query').ARIAPropertyDefinition} schema
	 * @param {string} attribute
	 */ (schema, attribute)=>{
            let message;
            switch(schema.type){
                case "boolean":
                    message = `The value of '${attribute}' must be exactly one of true or false`;
                    break;
                case "id":
                    message = `The value of '${attribute}' must be a string that represents a DOM element ID`;
                    break;
                case "idlist":
                    message = `The value of '${attribute}' must be a space-separated list of strings that represent DOM element IDs`;
                    break;
                case "tristate":
                    message = `The value of '${attribute}' must be exactly one of true, false, or mixed`;
                    break;
                case "token":
                    message = `The value of '${attribute}' must be exactly one of ${(schema.values || []).join(", ")}`;
                    break;
                case "tokenlist":
                    message = `The value of '${attribute}' must be a space-separated list of one or more of ${(schema.values || []).join(", ")}`;
                    break;
                default:
                    message = `The value of '${attribute}' must be of type ${schema.type}`;
            }
            return {
                code: "a11y-incorrect-aria-attribute-type",
                message: `A11y: ${message}`
            };
        },
        a11y_unknown_aria_attribute: /**
	 * @param {string} attribute
	 * @param {string} [suggestion]
	 */ (attribute, suggestion)=>({
                code: "a11y-unknown-aria-attribute",
                message: `A11y: Unknown aria attribute 'aria-${attribute}'` + (suggestion ? ` (did you mean '${suggestion}'?)` : "")
            }),
        a11y_hidden: /** @param {string} name */ (name)=>({
                code: "a11y-hidden",
                message: `A11y: <${name}> element should not be hidden`
            }),
        a11y_misplaced_role: /** @param {string} name */ (name)=>({
                code: "a11y-misplaced-role",
                message: `A11y: <${name}> should not have role attribute`
            }),
        a11y_unknown_role: /**
	 * @param {string | boolean} role
	 * @param {string} [suggestion]
	 */ (role, suggestion)=>({
                code: "a11y-unknown-role",
                message: `A11y: Unknown role '${role}'` + (suggestion ? ` (did you mean '${suggestion}'?)` : "")
            }),
        a11y_no_abstract_role: /** @param {string | boolean} role */ (role)=>({
                code: "a11y-no-abstract-role",
                message: `A11y: Abstract role '${role}' is forbidden`
            }),
        a11y_no_redundant_roles: /** @param {string | boolean} role */ (role)=>({
                code: "a11y-no-redundant-roles",
                message: `A11y: Redundant role '${role}'`
            }),
        a11y_no_static_element_interactions: /**
	 * @param {string} element
	 * @param {string[]} handlers
	 */ (element, handlers)=>({
                code: "a11y-no-static-element-interactions",
                message: `A11y: <${element}> with ${handlers.join(", ")} ${handlers.length === 1 ? "handler" : "handlers"} must have an ARIA role`
            }),
        a11y_no_interactive_element_to_noninteractive_role: /**
	 * @param {string | boolean} role
	 * @param {string} element
	 */ (role, element)=>({
                code: "a11y-no-interactive-element-to-noninteractive-role",
                message: `A11y: <${element}> cannot have role '${role}'`
            }),
        a11y_no_noninteractive_element_interactions: /** @param {string} element */ (element)=>({
                code: "a11y-no-noninteractive-element-interactions",
                message: `A11y: Non-interactive element <${element}> should not be assigned mouse or keyboard event listeners.`
            }),
        a11y_no_noninteractive_element_to_interactive_role: /**
	 * @param {string | boolean} role
	 * @param {string} element
	 */ (role, element)=>({
                code: "a11y-no-noninteractive-element-to-interactive-role",
                message: `A11y: Non-interactive element <${element}> cannot have interactive role '${role}'`
            }),
        a11y_role_has_required_aria_props: /**
	 * @param {string} role
	 * @param {string[]} props
	 */ (role, props)=>({
                code: "a11y-role-has-required-aria-props",
                message: `A11y: Elements with the ARIA role "${role}" must have the following attributes defined: ${props.map((name)=>`"${name}"`).join(", ")}`
            }),
        a11y_role_supports_aria_props: /**
	 * @param {string} attribute
	 * @param {string} role
	 * @param {boolean} is_implicit
	 * @param {string} name
	 */ (attribute, role, is_implicit, name)=>{
            let message = `The attribute '${attribute}' is not supported by the role '${role}'.`;
            if (is_implicit) message += ` This role is implicit on the element <${name}>.`;
            return {
                code: "a11y-role-supports-aria-props",
                message: `A11y: ${message}`
            };
        },
        a11y_accesskey: {
            code: "a11y-accesskey",
            message: "A11y: Avoid using accesskey"
        },
        a11y_autofocus: {
            code: "a11y-autofocus",
            message: "A11y: Avoid using autofocus"
        },
        a11y_misplaced_scope: {
            code: "a11y-misplaced-scope",
            message: "A11y: The scope attribute should only be used with <th> elements"
        },
        a11y_positive_tabindex: {
            code: "a11y-positive-tabindex",
            message: "A11y: avoid tabindex values above zero"
        },
        a11y_invalid_attribute: /**
	 * @param {string} href_attribute
	 * @param {string} href_value
	 */ (href_attribute, href_value)=>({
                code: "a11y-invalid-attribute",
                message: `A11y: '${href_value}' is not a valid ${href_attribute} attribute`
            }),
        a11y_missing_attribute: /**
	 * @param {string} name
	 * @param {string} article
	 * @param {string} sequence
	 */ (name, article, sequence)=>({
                code: "a11y-missing-attribute",
                message: `A11y: <${name}> element should have ${article} ${sequence} attribute`
            }),
        a11y_autocomplete_valid: /**
	 * @param {null | true | string} type
	 * @param {null | true | string} value
	 */ (type, value)=>({
                code: "a11y-autocomplete-valid",
                message: `A11y: The value '${value}' is not supported by the attribute 'autocomplete' on element <input type="${type || "..."}">`
            }),
        a11y_img_redundant_alt: {
            code: "a11y-img-redundant-alt",
            message: "A11y: Screenreaders already announce <img> elements as an image."
        },
        a11y_interactive_supports_focus: /** @param {string} role */ (role)=>({
                code: "a11y-interactive-supports-focus",
                message: `A11y: Elements with the '${role}' interactive role must have a tabindex value.`
            }),
        a11y_label_has_associated_control: {
            code: "a11y-label-has-associated-control",
            message: "A11y: A form label must be associated with a control."
        },
        a11y_media_has_caption: {
            code: "a11y-media-has-caption",
            message: 'A11y: <video> elements must have a <track kind="captions">'
        },
        a11y_distracting_elements: /** @param {string} name */ (name)=>({
                code: "a11y-distracting-elements",
                message: `A11y: Avoid <${name}> elements`
            }),
        a11y_structure_immediate: {
            code: "a11y-structure",
            message: "A11y: <figcaption> must be an immediate child of <figure>"
        },
        a11y_structure_first_or_last: {
            code: "a11y-structure",
            message: "A11y: <figcaption> must be first or last child of <figure>"
        },
        a11y_mouse_events_have_key_events: /**
	 * @param {string} event
	 * @param {string} accompanied_by
	 */ (event, accompanied_by)=>({
                code: "a11y-mouse-events-have-key-events",
                message: `A11y: on:${event} must be accompanied by on:${accompanied_by}`
            }),
        a11y_click_events_have_key_events: {
            code: "a11y-click-events-have-key-events",
            message: 'A11y: visible, non-interactive elements with an on:click event must be accompanied by a keyboard event handler. Consider whether an interactive element such as <button type="button"> or <a> might be more appropriate. See https://svelte.dev/docs/accessibility-warnings#a11y-click-events-have-key-events for more details.'
        },
        a11y_missing_content: /** @param {string} name */ (name)=>({
                code: "a11y-missing-content",
                message: `A11y: <${name}> element should have child content`
            }),
        a11y_no_noninteractive_tabindex: {
            code: "a11y-no-noninteractive-tabindex",
            message: "A11y: noninteractive element cannot have nonnegative tabIndex value"
        },
        a11y_aria_activedescendant_has_tabindex: {
            code: "a11y-aria-activedescendant-has-tabindex",
            message: "A11y: Elements with attribute aria-activedescendant should have tabindex value"
        },
        redundant_event_modifier_for_touch: {
            code: "redundant-event-modifier",
            message: "Touch event handlers that don't use the 'event' object are passive by default"
        },
        redundant_event_modifier_passive: {
            code: "redundant-event-modifier",
            message: "The passive modifier only works with wheel and touch events"
        },
        invalid_rest_eachblock_binding: /** @param {string} rest_element_name */ (rest_element_name)=>({
                code: "invalid-rest-eachblock-binding",
                message: `The rest operator (...) will create a new object and binding '${rest_element_name}' with the original object will not work`
            }),
        avoid_mouse_events_on_document: {
            code: "avoid-mouse-events-on-document",
            message: "Mouse enter/leave events on the document are not supported in all browsers and should be avoided"
        },
        illegal_attribute_character: {
            code: "illegal-attribute-character",
            message: "Attributes should not contain ':' characters to prevent ambiguity with Svelte directives"
        }
    };
    const regex_non_whitespace_characters$1 = /[^ \r\n\f\v\t]/;
    /**
 * @template {string} Type
 * @extends Node<Type>
 */ class AbstractBlock extends Node {
        /** @type {import('../../render_dom/Block.js').default} */ block;
        /** @type {import('../interfaces.js').INode[]} */ children;
        /**
	 * @param {import('../../Component.js').default} component
	 * @param {any} parent
	 * @param {any} scope
	 * @param {any} info
	 */ constructor(component, parent, scope, info){
            super(component, parent, scope, info);
        }
        warn_if_empty_block() {
            if (!this.children || this.children.length > 1) return;
            const child = this.children[0];
            if (!child || child.type === "Text" && !regex_non_whitespace_characters$1.test(child.data)) this.component.warn(this, compiler_warnings.empty_block);
        }
    }
    /**
 * @param {import('estree').Node} node
 */ function flatten_reference(node) {
        /** @type {any[]} */ const nodes = [];
        /** @type {string[]} */ const parts = [];
        while(node.type === "MemberExpression"){
            nodes.unshift(node.property);
            if (!node.computed) parts.unshift(/** @type {import('estree').Identifier} */ node.property.name);
            else {
                const computed_property = to_string(node.property);
                if (computed_property) parts.unshift(`[${computed_property}]`);
            }
            node = node.object;
        }
        const name = node.type === "Identifier" ? node.name : node.type === "ThisExpression" ? "this" : null;
        nodes.unshift(node);
        parts.unshift(name);
        return {
            name: name,
            nodes: nodes,
            parts: parts
        };
    }
    /**
 * @param {import('estree').Node} node
 */ function to_string(node) {
        switch(node.type){
            case "Literal":
                return String(node.value);
            case "Identifier":
                return node.name;
        }
    }
    /**
 * @param {import('estree').Node} expression
 */ function create_scopes(expression) {
        return analyze(expression);
    }
    /**
 * @param {import('estree').Node} node
 */ function get_object(node) {
        while(node.type === "MemberExpression")node = node.object;
        return /** @type {import('estree').Identifier} */ node;
    }
    const reserved_keywords = new Set([
        "$$props",
        "$$restProps",
        "$$slots"
    ]);
    /** @param {string} name */ function is_reserved_keyword(name) {
        return reserved_keywords.has(name);
    }
    /** @param {import('../../../../interfaces.js').Var} variable */ function is_dynamic$1(variable) {
        if (variable) {
            // Only variables declared in the instance script tags should be considered dynamic
            const is_declared_in_reactive_context = !variable.module && !variable.global;
            if (is_declared_in_reactive_context && (variable.mutated || variable.reassigned)) return true; // dynamic internal state
            if (is_declared_in_reactive_context && variable.writable && variable.export_name) return true; // writable props
            if (is_reserved_keyword(variable.name)) return true;
        }
        return false;
    }
    function nodes_match(a, b, ignore_keys = []) {
        if (!!a !== !!b) return false;
        if (Array.isArray(a) !== Array.isArray(b)) return false;
        if (a && typeof a === "object") {
            if (Array.isArray(a)) {
                if (a.length !== b.length) return false;
                return a.every((child, i)=>nodes_match(child, b[i]));
            }
            const a_keys = Object.keys(a).sort().filter((key)=>!ignore_keys.includes(key));
            const b_keys = Object.keys(b).sort().filter((key)=>!ignore_keys.includes(key));
            if (a_keys.length !== b_keys.length) return false;
            let i = a_keys.length;
            while(i--){
                const key = a_keys[i];
                if (b_keys[i] !== key) return false;
                if (key === "start" || key === "end") continue;
                if (!nodes_match(a[key], b[key])) return false;
            }
            return true;
        }
        return a === b;
    }
    /**
 * @param {import('./Renderer.js').default} renderer
 * @param {import('periscopic').Scope} scope
 * @param {import('estree').Node} node
 * @param {Set<string>} names
 * @param {boolean} main_execution_context
 * @returns {any}
 */ function invalidate(renderer, scope, node, names, main_execution_context = false) {
        const { component: component } = renderer;
        const [head, ...tail] = /** @type {import('../../interfaces.js').Var[]} */ Array.from(names).filter((name)=>{
            const owner = scope.find_owner(name);
            return !owner || owner === component.instance_scope;
        }).map((name)=>component.var_lookup.get(name)).filter((variable)=>{
            return variable && !variable.hoistable && !variable.global && !variable.module && (variable.referenced || variable.subscribable || variable.is_reactive_dependency || variable.export_name || variable.name[0] === "$");
        });
        /**
	 * @param {import('../../interfaces.js').Var} variable
	 * @param {import('estree').Expression} [node]
	 */ function get_invalidated(variable, node) {
            if (main_execution_context && !variable.subscribable && variable.name[0] !== "$") return node;
            return renderer_invalidate(renderer, variable.name, undefined, main_execution_context);
        }
        if (!head) return node;
        component.has_reactive_assignments = true;
        if (node.type === "AssignmentExpression" && node.operator === "=" && nodes_match(node.left, node.right, [
            "trailingComments",
            "leadingComments"
        ]) && tail.length === 0) return get_invalidated(head, node);
        const is_store_value = head.name[0] === "$" && head.name[1] !== "$";
        const extra_args = tail.map((variable)=>get_invalidated(variable)).filter(Boolean);
        if (is_store_value) return x$1`@set_store_value(${head.name.slice(1)}, ${node}, ${head.name}, ${extra_args})`;
        let invalidate;
        if (!main_execution_context) {
            const pass_value = extra_args.length > 0 || node.type === "AssignmentExpression" && node.left.type !== "Identifier" || node.type === "UpdateExpression" && (!node.prefix || node.argument.type !== "Identifier");
            if (pass_value) extra_args.unshift({
                type: "Identifier",
                name: head.name
            });
            invalidate = x$1`$$invalidate(${renderer.context_lookup.get(head.name).index}, ${node}, ${extra_args})`;
        } else // skip `$$invalidate` if it is in the main execution context
        invalidate = extra_args.length ? [
            node,
            ...extra_args
        ] : node;
        if (head.subscribable && head.reassigned) {
            const subscribe = `$$subscribe_${head.name}`;
            invalidate = x$1`${subscribe}(${invalidate})`;
        }
        return invalidate;
    }
    /**
 * @param {import('./Renderer.js').default} renderer
 * @param {string} name
 * @param {any} [value]
 * @param {boolean} [main_execution_context]
 * @returns {import('estree').Node}
 */ function renderer_invalidate(renderer, name, value, main_execution_context = false) {
        const variable = renderer.component.var_lookup.get(name);
        if (variable && variable.subscribable && (variable.reassigned || variable.export_name)) {
            if (main_execution_context) return x$1`${`$$subscribe_${name}`}(${value || name})`;
            else {
                const member = renderer.context_lookup.get(name);
                return x$1`${`$$subscribe_${name}`}($$invalidate(${member.index}, ${value || name}))`;
            }
        }
        if (name[0] === "$" && name[1] !== "$") return x$1`${name.slice(1)}.set(${value || name})`;
        if (variable && (variable.module || !variable.referenced && !variable.is_reactive_dependency && !variable.export_name && !name.startsWith("$$"))) return value || name;
        if (value) {
            if (main_execution_context) return x$1`${value}`;
            else {
                const member = renderer.context_lookup.get(name);
                return x$1`$$invalidate(${member.index}, ${value})`;
            }
        }
        if (main_execution_context) return;
        // if this is a reactive declaration, invalidate dependencies recursively
        const deps = new Set([
            name
        ]);
        deps.forEach((name)=>{
            const reactive_declarations = renderer.component.reactive_declarations.filter((x)=>x.assignees.has(name));
            reactive_declarations.forEach((declaration)=>{
                declaration.dependencies.forEach((name)=>{
                    deps.add(name);
                });
            });
        });
        // TODO ideally globals etc wouldn't be here in the first place
        const filtered = Array.from(deps).filter((n)=>renderer.context_lookup.has(n));
        if (!filtered.length) return null;
        return filtered.map((n)=>x$1`$$invalidate(${renderer.context_lookup.get(n).index}, ${n})`).reduce((lhs, rhs)=>x$1`${lhs}, ${rhs}`);
    }
    /**
 * @param {import('estree').Node} node
 * @param {import('estree').Node} replacement
 */ function replace_object(node, replacement) {
        if (node.type === "Identifier") return replacement;
        const ancestor = node;
        let parent;
        while(node.type === "MemberExpression"){
            parent = node;
            node = node.object;
        }
        parent.object = /** @type {any} */ replacement;
        return ancestor;
    }
    /**
 * @param {import('../../Component.js').default} component
 * @param {import('./TemplateScope.js').default} scope
 * @param {string} name
 */ function is_contextual(component, scope, name) {
        if (is_reserved_keyword(name)) return true;
        // if it's a name below root scope, it's contextual
        if (!scope.is_top_level(name)) return true;
        const variable = component.var_lookup.get(name);
        // hoistables, module declarations, and imports are non-contextual
        if (!variable || variable.hoistable) return false;
        // assume contextual
        return true;
    }
    // adapted from klona v2.0.4 - https://github.com/lukeed/klona
    // (c) Luke Edwards, under MIT License
    // The sole modification is to skip function values in objects when cloning, so we don't break tests.
    function clone(val) {
        let k, out, tmp;
        if (Array.isArray(val)) {
            out = Array(k = val.length);
            while(k--)out[k] = (tmp = val[k]) && typeof tmp === "object" ? clone(tmp) : tmp;
            return out;
        }
        if (Object.prototype.toString.call(val) === "[object Object]") {
            out = {}; // null
            for(k in val){
                if (k === "__proto__") Object.defineProperty(out, k, {
                    value: clone(val[k]),
                    configurable: true,
                    enumerable: true,
                    writable: true
                });
                else if (typeof val[k] !== "function") // MODIFICATION: skip functions
                out[k] = (tmp = val[k]) && typeof tmp === "object" ? clone(tmp) : tmp;
            }
            return out;
        }
        return val;
    }
    // All compiler errors should be listed and accessed from here
    /**
 * @internal
 */ var compiler_errors = {
        invalid_binding_elements: /**
	 * @param {string} element
	 * @param {string} binding
	 */ (element, binding)=>({
                code: "invalid-binding",
                message: `'${binding}' is not a valid binding on <${element}> elements`
            }),
        invalid_binding_element_with: /**
	 * @param {string} elements
	 * @param {string} binding
	 */ (elements, binding)=>({
                code: "invalid-binding",
                message: `'${binding}' binding can only be used with ${elements}`
            }),
        invalid_binding_on: /**
	 * @param {string} binding
	 * @param {string} element
	 * @param {string} [post]
	 */ (binding, element, post)=>({
                code: "invalid-binding",
                message: `'${binding}' is not a valid binding on ${element}` + (post || "")
            }),
        invalid_binding_foreign: /** @param {string} binding */ (binding)=>({
                code: "invalid-binding",
                message: `'${binding}' is not a valid binding. Foreign elements only support bind:this`
            }),
        invalid_binding_no_checkbox: /**
	 * @param {string} binding
	 * @param {boolean} is_radio
	 */ (binding, is_radio)=>({
                code: "invalid-binding",
                message: `'${binding}' binding can only be used with <input type="checkbox">` + (is_radio ? " \u2014 for <input type=\"radio\">, use 'group' binding" : "")
            }),
        invalid_binding: /** @param {string} binding */ (binding)=>({
                code: "invalid-binding",
                message: `'${binding}' is not a valid binding`
            }),
        invalid_binding_window: /** @param {string[]} parts */ (parts)=>({
                code: "invalid-binding",
                message: `Bindings on <svelte:window> must be to top-level properties, e.g. '${parts[parts.length - 1]}' rather than '${parts.join(".")}'`
            }),
        invalid_binding_let: {
            code: "invalid-binding",
            message: "Cannot bind to a variable declared with the let: directive"
        },
        invalid_binding_await: {
            code: "invalid-binding",
            message: "Cannot bind to a variable declared with {#await ... then} or {:catch} blocks"
        },
        invalid_binding_const: {
            code: "invalid-binding",
            message: "Cannot bind to a variable declared with {@const ...}"
        },
        invalid_binding_writable: {
            code: "invalid-binding",
            message: "Cannot bind to a variable which is not writable"
        },
        binding_undeclared: /** @param {string} name */ (name)=>({
                code: "binding-undeclared",
                message: `${name} is not declared`
            }),
        invalid_type: {
            code: "invalid-type",
            message: "'type' attribute cannot be dynamic if input uses two-way binding"
        },
        missing_type: {
            code: "missing-type",
            message: "'type' attribute must be specified"
        },
        dynamic_multiple_attribute: {
            code: "dynamic-multiple-attribute",
            message: "'multiple' attribute cannot be dynamic if select uses two-way binding"
        },
        missing_contenteditable_attribute: {
            code: "missing-contenteditable-attribute",
            message: "'contenteditable' attribute is required for textContent, innerHTML and innerText two-way bindings"
        },
        dynamic_contenteditable_attribute: {
            code: "dynamic-contenteditable-attribute",
            message: "'contenteditable' attribute cannot be dynamic if element uses two-way binding"
        },
        invalid_event_modifier_combination: /**
	 * @param {string} modifier1
	 * @param {string} modifier2
	 */ (modifier1, modifier2)=>({
                code: "invalid-event-modifier",
                message: `The '${modifier1}' and '${modifier2}' modifiers cannot be used together`
            }),
        invalid_event_modifier_legacy: /** @param {string} modifier */ (modifier)=>({
                code: "invalid-event-modifier",
                message: `The '${modifier}' modifier cannot be used in legacy mode`
            }),
        invalid_event_modifier: /** @param {string} valid */ (valid)=>({
                code: "invalid-event-modifier",
                message: `Valid event modifiers are ${valid}`
            }),
        invalid_event_modifier_component: {
            code: "invalid-event-modifier",
            message: "Event modifiers other than 'once' can only be used on DOM elements"
        },
        textarea_duplicate_value: {
            code: "textarea-duplicate-value",
            message: "A <textarea> can have either a value attribute or (equivalently) child content, but not both"
        },
        illegal_attribute: /** @param {string} name */ (name)=>({
                code: "illegal-attribute",
                message: `'${name}' is not a valid attribute name`
            }),
        invalid_slot_attribute: {
            code: "invalid-slot-attribute",
            message: "slot attribute cannot have a dynamic value"
        },
        duplicate_slot_attribute: /** @param {string} name */ (name)=>({
                code: "duplicate-slot-attribute",
                message: `Duplicate '${name}' slot`
            }),
        invalid_slotted_content: {
            code: "invalid-slotted-content",
            message: "Element with a slot='...' attribute must be a child of a component or a descendant of a custom element"
        },
        invalid_attribute_head: {
            code: "invalid-attribute",
            message: "<svelte:head> should not have any attributes or directives"
        },
        invalid_action: {
            code: "invalid-action",
            message: "Actions can only be applied to DOM elements, not components"
        },
        invalid_animation: {
            code: "invalid-animation",
            message: "Animations can only be applied to DOM elements, not components"
        },
        invalid_class: {
            code: "invalid-class",
            message: "Classes can only be applied to DOM elements, not components"
        },
        invalid_transition: {
            code: "invalid-transition",
            message: "Transitions can only be applied to DOM elements, not components"
        },
        invalid_let: {
            code: "invalid-let",
            message: "let directive value must be an identifier or an object/array pattern"
        },
        invalid_slot_directive: {
            code: "invalid-slot-directive",
            message: "<slot> cannot have directives"
        },
        dynamic_slot_name: {
            code: "dynamic-slot-name",
            message: "<slot> name cannot be dynamic"
        },
        invalid_slot_name: {
            code: "invalid-slot-name",
            message: "default is a reserved word \u2014 it cannot be used as a slot name"
        },
        invalid_slot_attribute_value_missing: {
            code: "invalid-slot-attribute",
            message: "slot attribute value is missing"
        },
        invalid_slotted_content_fragment: {
            code: "invalid-slotted-content",
            message: "<svelte:fragment> must be a child of a component"
        },
        illegal_attribute_title: {
            code: "illegal-attribute",
            message: "<title> cannot have attributes"
        },
        illegal_structure_title: {
            code: "illegal-structure",
            message: "<title> can only contain text and {tags}"
        },
        duplicate_transition: /**
	 * @param {string} directive
	 * @param {string} parent_directive
	 */ (directive, parent_directive)=>{
            /** @param {string} _directive */ function describe(_directive) {
                return _directive === "transition" ? "a 'transition'" : `an '${_directive}'`;
            }
            const message = directive === parent_directive ? `An element can only have one '${directive}' directive` : `An element cannot have both ${describe(parent_directive)} directive and ${describe(directive)} directive`;
            return {
                code: "duplicate-transition",
                message: message
            };
        },
        contextual_store: {
            code: "contextual-store",
            message: "Stores must be declared at the top level of the component (this may change in a future version of Svelte)"
        },
        default_export: {
            code: "default-export",
            message: "A component cannot have a default export"
        },
        illegal_declaration: {
            code: "illegal-declaration",
            message: "The $ prefix is reserved, and cannot be used for variable and import names"
        },
        illegal_subscription: {
            code: "illegal-subscription",
            message: 'Cannot reference store value inside <script context="module">'
        },
        illegal_global: /** @param {string} name */ (name)=>({
                code: "illegal-global",
                message: `${name} is an illegal variable name`
            }),
        illegal_variable_declaration: {
            code: "illegal-variable-declaration",
            message: 'Cannot declare same variable name which is imported inside <script context="module">'
        },
        cyclical_reactive_declaration: /** @param {string[]} cycle */ (cycle)=>({
                code: "cyclical-reactive-declaration",
                message: `Cyclical dependency detected: ${cycle.join(" \u2192 ")}`
            }),
        invalid_tag_property: {
            code: "invalid-tag-property",
            message: "tag name must be two or more words joined by the '-' character"
        },
        invalid_customElement_attribute: {
            code: "invalid-customElement-attribute",
            message: "'customElement' must be a string literal defining a valid custom element name or an object of the form { tag: string; shadow?: 'open' | 'none'; props?: { [key: string]: { attribute?: string; reflect?: boolean; type: .. } } }"
        },
        invalid_tag_attribute: {
            code: "invalid-tag-attribute",
            message: "'tag' must be a string literal"
        },
        invalid_shadow_attribute: {
            code: "invalid-shadow-attribute",
            message: "'shadow' must be either 'open' or 'none'"
        },
        invalid_props_attribute: {
            code: "invalid-props-attribute",
            message: "'props' must be a statically analyzable object literal of the form '{ [key: string]: { attribute?: string; reflect?: boolean; type?: 'String' | 'Boolean' | 'Number' | 'Array' | 'Object' }'"
        },
        invalid_namespace_property: /**
	 * @param {string} namespace
	 * @param {string} [suggestion]
	 */ (namespace, suggestion)=>({
                code: "invalid-namespace-property",
                message: `Invalid namespace '${namespace}'` + (suggestion ? ` (did you mean '${suggestion}'?)` : "")
            }),
        invalid_namespace_attribute: {
            code: "invalid-namespace-attribute",
            message: "The 'namespace' attribute must be a string literal representing a valid namespace"
        },
        invalid_attribute_value: /** @param {string} name */ (name)=>({
                code: `invalid-${name}-value`,
                message: `${name} attribute must be true or false`
            }),
        invalid_options_attribute_unknown: /** @param {string} name */ (name)=>({
                code: "invalid-options-attribute",
                message: `<svelte:options> unknown attribute '${name}'`
            }),
        invalid_options_attribute: {
            code: "invalid-options-attribute",
            message: "<svelte:options> can only have static 'tag', 'namespace', 'accessors', 'immutable' and 'preserveWhitespace' attributes"
        },
        css_invalid_global: {
            code: "css-invalid-global",
            message: ":global(...) can be at the start or end of a selector sequence, but not in the middle"
        },
        css_invalid_global_selector: {
            code: "css-invalid-global-selector",
            message: ":global(...) must contain a single selector"
        },
        css_invalid_global_selector_position: {
            code: "css-invalid-global-selector-position",
            message: ":global(...) not at the start of a selector sequence should not contain type or universal selectors"
        },
        css_invalid_selector: /** @param {string} selector */ (selector)=>({
                code: "css-invalid-selector",
                message: `Invalid selector "${selector}"`
            }),
        duplicate_animation: {
            code: "duplicate-animation",
            message: "An element can only have one 'animate' directive"
        },
        invalid_animation_immediate: {
            code: "invalid-animation",
            message: "An element that uses the animate directive must be the immediate child of a keyed each block"
        },
        invalid_animation_key: {
            code: "invalid-animation",
            message: "An element that uses the animate directive must be used inside a keyed each block. Did you forget to add a key to your each block?"
        },
        invalid_animation_sole: {
            code: "invalid-animation",
            message: "An element that uses the animate directive must be the sole child of a keyed each block"
        },
        invalid_animation_dynamic_element: {
            code: "invalid-animation",
            message: "<svelte:element> cannot have a animate directive"
        },
        invalid_directive_value: {
            code: "invalid-directive-value",
            message: "Can only bind to an identifier (e.g. `foo`) or a member expression (e.g. `foo.bar` or `foo[baz]`)"
        },
        invalid_const_placement: {
            code: "invalid-const-placement",
            message: "{@const} must be the immediate child of {#if}, {:else if}, {:else}, {#each}, {:then}, {:catch}, <svelte:fragment> or <Component>"
        },
        invalid_const_declaration: /** @param {string} name */ (name)=>({
                code: "invalid-const-declaration",
                message: `'${name}' has already been declared`
            }),
        invalid_const_update: /** @param {string} name */ (name)=>({
                code: "invalid-const-update",
                message: `'${name}' is declared using {@const ...} and is read-only`
            }),
        cyclical_const_tags: /** @param {string[]} cycle */ (cycle)=>({
                code: "cyclical-const-tags",
                message: `Cyclical dependency detected: ${cycle.join(" \u2192 ")}`
            }),
        invalid_component_style_directive: {
            code: "invalid-component-style-directive",
            message: "Style directives cannot be used on components"
        },
        invalid_var_declaration: {
            code: "invalid_var_declaration",
            message: '"var" scope should not extend outside the reactive block'
        },
        invalid_style_directive_modifier: /** @param {string} valid */ (valid)=>({
                code: "invalid-style-directive-modifier",
                message: `Valid modifiers for style directives are: ${valid}`
            })
    };
    const regex_contains_term_function_expression$1 = /FunctionExpression/;
    class Expression {
        /** @type {'Expression'} */ type = "Expression";
        /** @type {import('../../Component.js').default} */ component;
        /** @type {import('../interfaces.js').INode} */ owner;
        /** @type {import('estree').Node} */ node;
        /** @type {Set<string>} */ references = new Set();
        /**
	 * Dependencies declared in the script block
	 * @type {Set<string>}
	 */ dependencies = new Set();
        /**
	 * Dependencies declared in the HTML-like template section
	 * @type {Set<string>}
	 */ contextual_dependencies = new Set();
        /** @type {import('./TemplateScope.js').default} */ template_scope;
        /** @type {import('../../utils/scope.js').Scope} */ scope;
        /** @type {WeakMap<import('estree').Node, import('../../utils/scope.js').Scope>} */ scope_map;
        /** @type {Array<import('estree').Node | import('estree').Node[]>} */ declarations = [];
        /** @type {boolean} */ uses_context = false;
        /** @type {import('estree').Node} */ manipulated;
        /**
	 * @param {import('../../Component.js').default} component  *
	 * @param {import('../interfaces.js').INode} owner  *
	 * @param {import('./TemplateScope.js').default} template_scope  *
	 * @param {import('estree').Node} info  *
	 * @param {boolean} [lazy]  undefined
	 */ constructor(component, owner, template_scope, info, lazy){
            // TODO revert to direct property access in prod?
            Object.defineProperties(this, {
                component: {
                    value: component
                }
            });
            this.node = info;
            this.template_scope = template_scope;
            this.owner = owner;
            const { dependencies: dependencies, contextual_dependencies: contextual_dependencies, references: references } = this;
            let { map: map, scope: scope } = create_scopes(info);
            this.scope = scope;
            this.scope_map = map;
            const expression = this;
            let function_expression;
            // discover dependencies, but don't change the code yet
            walk(info, {
                /**
			 * @param {any} node
			 * @param {import('estree').Node} parent
			 * @param {string} key
			 */ enter (node, parent, key) {
                    // don't manipulate shorthand props twice
                    if (key === "key" && /** @type {import('estree').Property} */ parent.shorthand) return;
                    // don't manipulate `import.meta`, `new.target`
                    if (node.type === "MetaProperty") return this.skip();
                    if (map.has(node)) scope = map.get(node);
                    if (!function_expression && regex_contains_term_function_expression$1.test(node.type)) function_expression = node;
                    if (is_reference(node, parent)) {
                        const { name: name, nodes: nodes } = flatten_reference(node);
                        references.add(name);
                        if (scope.has(name)) return;
                        if (name[0] === "$") {
                            const store_name = name.slice(1);
                            if (template_scope.names.has(store_name) || scope.has(store_name)) return component.error(node, compiler_errors.contextual_store);
                        }
                        if (template_scope.is_let(name)) {
                            if (!lazy) {
                                contextual_dependencies.add(name);
                                dependencies.add(name);
                            }
                        } else if (template_scope.names.has(name)) {
                            expression.uses_context = true;
                            contextual_dependencies.add(name);
                            const owner = template_scope.get_owner(name);
                            const is_index = owner.type === "EachBlock" && owner.key && name === owner.index;
                            if (!lazy || is_index) template_scope.dependencies_for_name.get(name).forEach((name)=>dependencies.add(name));
                        } else {
                            if (!lazy) {
                                const variable = component.var_lookup.get(name);
                                if (!variable || !variable.imported || variable.mutated || variable.reassigned) dependencies.add(name);
                            }
                            component.add_reference(node, name);
                            component.warn_if_undefined(name, nodes[0], template_scope, owner);
                        }
                        this.skip();
                    }
                    // track any assignments from template expressions as mutable
                    let names;
                    let deep = false;
                    if (function_expression) {
                        if (node.type === "AssignmentExpression") {
                            deep = node.left.type === "MemberExpression";
                            names = extract_names(deep ? get_object(node.left) : node.left);
                        } else if (node.type === "UpdateExpression") {
                            deep = node.argument.type === "MemberExpression";
                            names = extract_names(get_object(node.argument));
                        }
                    }
                    if (names) names.forEach((name)=>{
                        if (template_scope.names.has(name)) {
                            if (template_scope.is_const(name)) component.error(node, compiler_errors.invalid_const_update(name));
                            template_scope.dependencies_for_name.get(name).forEach((name)=>{
                                const variable = component.var_lookup.get(name);
                                if (variable) variable[deep ? "mutated" : "reassigned"] = true;
                            });
                            const each_block = template_scope.get_owner(name);
                            /** @type {import('../EachBlock.js').default} */ each_block.has_binding = true;
                        } else {
                            component.add_reference(node, name);
                            const variable = component.var_lookup.get(name);
                            if (variable) variable[deep ? "mutated" : "reassigned"] = true;
                            const declaration = scope.find_owner(name)?.declarations.get(name);
                            if (declaration) {
                                if (/** @type {import('estree').VariableDeclaration} */ declaration.kind === "const" && !deep) component.error(node, {
                                    code: "assignment-to-const",
                                    message: "You are assigning to a const"
                                });
                            } else if (variable && variable.writable === false && !deep) component.error(node, {
                                code: "assignment-to-const",
                                message: "You are assigning to a const"
                            });
                        }
                    });
                },
                /** @type {import('estree-walker').SyncHandler} */ leave (node) {
                    if (map.has(node)) scope = scope.parent;
                    if (node === function_expression) function_expression = null;
                }
            });
        }
        dynamic_dependencies() {
            return Array.from(this.dependencies).filter((name)=>{
                if (this.template_scope.is_let(name)) return true;
                if (is_reserved_keyword(name)) return true;
                const variable = this.component.var_lookup.get(name);
                return is_dynamic$1(variable);
            });
        }
        dynamic_contextual_dependencies() {
            return Array.from(this.contextual_dependencies).filter((name)=>{
                return Array.from(this.template_scope.dependencies_for_name.get(name)).some((variable_name)=>{
                    const variable = this.component.var_lookup.get(variable_name);
                    return is_dynamic$1(variable);
                });
            });
        }
        // TODO move this into a render-dom wrapper?
        /**
	 * @param {import('../../render_dom/Block.js').default} [block]
	 * @param {string | void} [ctx]
	 */ manipulate(block, ctx) {
            // TODO ideally we wouldn't end up calling this method
            // multiple times
            if (this.manipulated) return this.manipulated;
            const { component: component, declarations: declarations, scope_map: map, template_scope: template_scope, owner: owner } = this;
            let scope = this.scope;
            /** @type {import('estree').FunctionExpression | import('estree').ArrowFunctionExpression | null} */ let function_expression;
            /** @type {Set<string>} */ let dependencies;
            /** @type {Set<string>} */ let contextual_dependencies;
            const node = walk(this.node, {
                /** @type {import('estree-walker').SyncHandler} */ enter (node, parent) {
                    if (node.type === "Property" && node.shorthand) {
                        node.value = clone(node.value);
                        node.shorthand = false;
                    }
                    if (map.has(node)) scope = map.get(node);
                    if (node.type === "Identifier" && is_reference(node, parent)) {
                        const { name: name } = flatten_reference(node);
                        if (scope.has(name)) return;
                        if (function_expression) {
                            if (template_scope.names.has(name)) {
                                contextual_dependencies.add(name);
                                template_scope.dependencies_for_name.get(name).forEach((dependency)=>{
                                    dependencies.add(dependency);
                                });
                            } else {
                                dependencies.add(name);
                                component.add_reference(node, name); // TODO is this redundant/misplaced?
                            }
                        } else if (is_contextual(component, template_scope, name)) {
                            const reference = block.renderer.reference(node, ctx);
                            this.replace(reference);
                        }
                        this.skip();
                    }
                    if (!function_expression) {
                        node.type;
                        if (node.type === "FunctionExpression" || node.type === "ArrowFunctionExpression") {
                            function_expression = node;
                            dependencies = new Set();
                            contextual_dependencies = new Set();
                        }
                    }
                },
                /** @type {import('estree-walker').SyncHandler} */ leave (node, parent) {
                    if (map.has(node)) scope = scope.parent;
                    if (node === function_expression) {
                        const id = component.get_unique_name(sanitize(get_function_name(node, owner)));
                        const declaration = b$1`const ${id} = ${node}`;
                        const extract_functions = ()=>{
                            const deps = Array.from(contextual_dependencies);
                            const function_expression = /** @type {import('estree').FunctionExpression} */ node;
                            const has_args = function_expression.params.length > 0;
                            function_expression.params = [
                                ...deps.map((name)=>/** @type {import('estree').Identifier} */ ({
                                        type: "Identifier",
                                        name: name
                                    })),
                                ...function_expression.params
                            ];
                            const context_args = deps.map((name)=>block.renderer.reference(name, ctx));
                            component.partly_hoisted.push(declaration);
                            block.renderer.add_to_context(id.name);
                            const callee = block.renderer.reference(id);
                            this.replace(id);
                            const func_declaration = has_args ? b$1`function ${id}(...args) {
								return ${callee}(${context_args}, ...args);
							}` : b$1`function ${id}() {
								return ${callee}(${context_args});
							}`;
                            return {
                                deps: deps,
                                func_declaration: func_declaration
                            };
                        };
                        if (owner.type === "ConstTag") {
                            // we need a combo block/init recipe
                            if (contextual_dependencies.size === 0) {
                                let child_scope = scope;
                                walk(node, {
                                    /** @type {import('estree-walker').SyncHandler} */ enter (node, parent) {
                                        if (map.has(node)) child_scope = map.get(node);
                                        if (node.type === "Identifier" && is_reference(node, parent)) {
                                            if (child_scope.has(node.name)) return;
                                            this.replace(block.renderer.reference(node, ctx));
                                        }
                                    },
                                    /** @param {import('estree').Node} node */ leave (node) {
                                        if (map.has(node)) child_scope = child_scope.parent;
                                    }
                                });
                            } else {
                                const { func_declaration: func_declaration } = extract_functions();
                                this.replace(func_declaration[0]);
                            }
                        } else if (dependencies.size === 0 && contextual_dependencies.size === 0) {
                            // we can hoist this out of the component completely
                            component.fully_hoisted.push(declaration);
                            this.replace(id);
                            component.add_var(node, {
                                name: id.name,
                                internal: true,
                                hoistable: true,
                                referenced: true
                            });
                        } else if (contextual_dependencies.size === 0) {
                            // function can be hoisted inside the component init
                            component.partly_hoisted.push(declaration);
                            block.renderer.add_to_context(id.name);
                            this.replace(block.renderer.reference(id));
                        } else {
                            // we need a combo block/init recipe
                            const { deps: deps, func_declaration: func_declaration } = extract_functions();
                            if (owner.type === "Attribute" && owner.parent.name === "slot") {
                                /** @type {Set<import('../interfaces.js').INode>} */ const dep_scopes = new Set(deps.map((name)=>template_scope.get_owner(name)));
                                // find the nearest scopes
                                /** @type {import('../interfaces.js').INode} */ let node = owner.parent;
                                while(node && !dep_scopes.has(node))node = node.parent;
                                const func_expression = func_declaration[0];
                                if (node.type === "SlotTemplate") // <svelte:fragment let:data />
                                this.replace(func_expression);
                                else {
                                    // {#each}, {#await}
                                    const func_id = component.get_unique_name(id.name + "_func");
                                    block.renderer.add_to_context(func_id.name, true);
                                    // rename #ctx -> child_ctx;
                                    walk(func_expression, {
                                        /** @param {import('estree').Node} node */ enter (node) {
                                            if (node.type === "Identifier" && node.name === "#ctx") node.name = "child_ctx";
                                        }
                                    });
                                    // add to get_xxx_context
                                    // child_ctx[x] = function () { ... }
                                    /** @type {import('../EachBlock.js').default} */ template_scope.get_owner(deps[0]).contexts.push({
                                        type: "DestructuredVariable",
                                        key: func_id,
                                        modifier: ()=>func_expression,
                                        default_modifier: (node)=>node
                                    });
                                    this.replace(block.renderer.reference(func_id));
                                }
                            } else declarations.push(func_declaration);
                        }
                        function_expression = null;
                        dependencies = null;
                        contextual_dependencies = null;
                        if (parent && parent.type === "Property") parent.method = false;
                    }
                    if (node.type === "AssignmentExpression" || node.type === "UpdateExpression") {
                        const assignee = node.type === "AssignmentExpression" ? node.left : node.argument;
                        const object_name = get_object(assignee).name;
                        if (scope.has(object_name)) return;
                        // normally (`a = 1`, `b.c = 2`), there'll be a single name
                        // (a or b). In destructuring cases (`[d, e] = [e, d]`) there
                        // may be more, in which case we need to tack the extra ones
                        // onto the initial function call
                        const names = new Set(extract_names(/** @type {import('estree').Node} */ assignee));
                        /** @type {Set<string>} */ const traced = new Set();
                        names.forEach((name)=>{
                            const dependencies = template_scope.dependencies_for_name.get(name);
                            if (dependencies) dependencies.forEach((name)=>traced.add(name));
                            else traced.add(name);
                        });
                        const context = block.bindings.get(object_name);
                        if (context) {
                            // for `{#each array as item}`
                            // replace `item = 1` to `each_array[each_index] = 1`, this allow us to mutate the array
                            // rather than mutating the local `item` variable
                            const { snippet: snippet, object: object, property: property } = context;
                            /** @type {any} */ const replaced = replace_object(assignee, snippet);
                            if (node.type === "AssignmentExpression") node.left = replaced;
                            else node.argument = replaced;
                            contextual_dependencies.add(object.name);
                            contextual_dependencies.add(property.name);
                        }
                        this.replace(invalidate(block.renderer, scope, node, traced));
                    }
                }
            });
            if (declarations.length > 0) {
                block.maintain_context = true;
                declarations.forEach((declaration)=>{
                    block.chunks.init.push(declaration);
                });
            }
            return this.manipulated = /** @type {import('estree').Node} */ node;
        }
    }
    /**
 * @param {import('estree').Node} _node
 * @param {import('../interfaces.js').INode} parent
 */ function get_function_name(_node, parent) {
        if (parent.type === "EventHandler") return `${parent.name}_handler`;
        if (parent.type === "Action") return `${parent.name}_function`;
        return "func";
    }
    /**
 * @param {{
 * 	contexts: Context[];
 * 	node: import('estree').Pattern;
 * 	modifier?: DestructuredVariable['modifier'];
 * 	default_modifier?: DestructuredVariable['default_modifier'];
 * 	scope: import('./TemplateScope.js').default;
 * 	component: import('../../Component.js').default;
 * 	context_rest_properties: Map<string, import('estree').Node>;
 * 	in_rest_element?: boolean;
 * }} params
 */ function unpack_destructuring({ contexts: contexts, node: node, modifier: modifier = (node)=>node, default_modifier: default_modifier = (node)=>node, scope: scope, component: component, context_rest_properties: context_rest_properties, in_rest_element: in_rest_element = false }) {
        if (!node) return;
        if (node.type === "Identifier") {
            contexts.push({
                type: "DestructuredVariable",
                key: /** @type {import('estree').Identifier} */ node,
                modifier: modifier,
                default_modifier: default_modifier
            });
            if (in_rest_element) context_rest_properties.set(node.name, node);
            component.used_names.add(node.name);
        } else if (node.type === "ArrayPattern") node.elements.forEach((element, i)=>{
            if (!element) return;
            else if (element.type === "RestElement") unpack_destructuring({
                contexts: contexts,
                node: element.argument,
                modifier: (node)=>/** @type {import('estree').Node} */ x$1`${modifier(node)}.slice(${i})`,
                default_modifier: default_modifier,
                scope: scope,
                component: component,
                context_rest_properties: context_rest_properties,
                in_rest_element: true
            });
            else if (element.type === "AssignmentPattern") {
                const n = contexts.length;
                mark_referenced(element.right, scope, component);
                unpack_destructuring({
                    contexts: contexts,
                    node: element.left,
                    modifier: (node)=>x$1`${modifier(node)}[${i}]`,
                    default_modifier: (node, to_ctx)=>/** @type {import('estree').Node} */ x$1`${node} !== undefined ? ${node} : ${update_reference(contexts, n, element.right, to_ctx)}`,
                    scope: scope,
                    component: component,
                    context_rest_properties: context_rest_properties,
                    in_rest_element: in_rest_element
                });
            } else unpack_destructuring({
                contexts: contexts,
                node: element,
                modifier: (node)=>/** @type {import('estree').Node} */ x$1`${modifier(node)}[${i}]`,
                default_modifier: default_modifier,
                scope: scope,
                component: component,
                context_rest_properties: context_rest_properties,
                in_rest_element: in_rest_element
            });
        });
        else if (node.type === "ObjectPattern") {
            const used_properties = [];
            node.properties.forEach((property)=>{
                if (property.type === "RestElement") unpack_destructuring({
                    contexts: contexts,
                    node: property.argument,
                    modifier: (node)=>/** @type {import('estree').Node} */ x$1`@object_without_properties(${modifier(node)}, [${used_properties}])`,
                    default_modifier: default_modifier,
                    scope: scope,
                    component: component,
                    context_rest_properties: context_rest_properties,
                    in_rest_element: true
                });
                else if (property.type === "Property") {
                    const key = property.key;
                    const value = property.value;
                    /** @type {(node: import('estree').Node) => import('estree').Node} */ let new_modifier;
                    if (property.computed) {
                        // e.g { [computedProperty]: ... }
                        const property_name = component.get_unique_name("computed_property");
                        contexts.push({
                            type: "ComputedProperty",
                            property_name: property_name,
                            key: key
                        });
                        new_modifier = (node)=>x$1`${modifier(node)}[${property_name}]`;
                        used_properties.push(x$1`${property_name}`);
                    } else if (key.type === "Identifier") {
                        // e.g. { someProperty: ... }
                        const property_name = key.name;
                        new_modifier = (node)=>x$1`${modifier(node)}.${property_name}`;
                        used_properties.push(x$1`"${property_name}"`);
                    } else if (key.type === "Literal") {
                        // e.g. { "property-in-quotes": ... } or { 14: ... }
                        const property_name = key.value;
                        new_modifier = (node)=>x$1`${modifier(node)}["${property_name}"]`;
                        used_properties.push(x$1`"${property_name}"`);
                    }
                    if (value.type === "AssignmentPattern") {
                        // e.g. { property = default } or { property: newName = default }
                        const n = contexts.length;
                        mark_referenced(value.right, scope, component);
                        unpack_destructuring({
                            contexts: contexts,
                            node: value.left,
                            modifier: new_modifier,
                            default_modifier: (node, to_ctx)=>/** @type {import('estree').Node} */ x$1`${node} !== undefined ? ${node} : ${update_reference(contexts, n, value.right, to_ctx)}`,
                            scope: scope,
                            component: component,
                            context_rest_properties: context_rest_properties,
                            in_rest_element: in_rest_element
                        });
                    } else // e.g. { property } or { property: newName }
                    unpack_destructuring({
                        contexts: contexts,
                        node: value,
                        modifier: new_modifier,
                        default_modifier: default_modifier,
                        scope: scope,
                        component: component,
                        context_rest_properties: context_rest_properties,
                        in_rest_element: in_rest_element
                    });
                }
            });
        }
    }
    /**
 * @param {Context[]} contexts
 * @param {number} n
 * @param {import('estree').Expression} expression
 * @param {(name: string) => import('estree').Node} to_ctx
 * @returns {import('estree').Node}
 */ function update_reference(contexts, n, expression, to_ctx) {
        /** @param {import('estree').Identifier} node */ const find_from_context = (node)=>{
            for(let i = n; i < contexts.length; i++){
                const cur_context = contexts[i];
                if (cur_context.type !== "DestructuredVariable") continue;
                const { key: key } = cur_context;
                if (node.name === key.name) throw new Error(`Cannot access '${node.name}' before initialization`);
            }
            return to_ctx(node.name);
        };
        if (expression.type === "Identifier") return find_from_context(expression);
        // NOTE: avoid unnecessary deep clone?
        expression = /** @type {import('estree').Expression} */ clone(expression);
        walk(expression, {
            enter (node, parent) {
                if (is_reference(/** @type {import('is-reference').NodeWithPropertyDefinition} */ node, /** @type {import('is-reference').NodeWithPropertyDefinition} */ parent)) {
                    this.replace(find_from_context(/** @type {import('estree').Identifier} */ node));
                    this.skip();
                }
            }
        });
        return expression;
    }
    /**
 * @param {import('estree').Node} node
 * @param {import('./TemplateScope.js').default} scope
 * @param {import('../../Component.js').default} component
 */ function mark_referenced(node, scope, component) {
        walk(node, {
            enter (node, parent) {
                if (is_reference(node, parent)) {
                    const { name: name } = flatten_reference(node);
                    if (!scope.is_let(name) && !scope.names.has(name)) component.add_reference(node, name);
                }
            }
        });
    }
    /** @typedef {DestructuredVariable | ComputedProperty} Context */ /**
 * @typedef {Object} ComputedProperty
 * @property {'ComputedProperty'} type
 * @property {import('estree').Identifier} property_name
 * @property {import('estree').Expression|import('estree').PrivateIdentifier} key
 */ /**
 * @typedef {Object} DestructuredVariable
 * @property {'DestructuredVariable'} type
 * @property {import('estree').Identifier} key
 * @property {string} [name]
 * @property {(node:import('estree').Node)=>import('estree').Node} modifier
 * @property {(node:import('estree').Node,to_ctx:(name:string)=>import('estree').Node)=>import('estree').Node} default_modifier
 */ const allowed_parents = new Set([
        "EachBlock",
        "CatchBlock",
        "ThenBlock",
        "InlineComponent",
        "SlotTemplate",
        "IfBlock",
        "ElseBlock"
    ]);
    /** @extends Node<'ConstTag'> */ class ConstTag extends Node {
        /** @type {import('./shared/Expression.js').default} */ expression;
        /** @type {import('./shared/Context.js').Context[]} */ contexts = [];
        /** @type {import('../../interfaces.js').ConstTag} */ node;
        /** @type {import('./shared/TemplateScope.js').default} */ scope;
        /** @type {Map<string, import('estree').Node>} */ context_rest_properties = new Map();
        /** @type {Set<string>} */ assignees = new Set();
        /** @type {Set<string>} */ dependencies = new Set();
        /**
	 * @param {import('../Component.js').default} component
	 * @param {import('./interfaces.js').INodeAllowConstTag} parent
	 * @param {import('./shared/TemplateScope.js').default} scope
	 * @param {import('../../interfaces.js').ConstTag} info
	 */ constructor(component, parent, scope, info){
            super(component, parent, scope, info);
            if (!allowed_parents.has(parent.type)) component.error(info, compiler_errors.invalid_const_placement);
            this.node = info;
            this.scope = scope;
            const { assignees: assignees, dependencies: dependencies } = this;
            extract_identifiers(info.expression.left).forEach(({ name: name })=>{
                assignees.add(name);
                const owner = this.scope.get_owner(name);
                if (owner === parent) component.error(info, compiler_errors.invalid_const_declaration(name));
            });
            walk(info.expression.right, {
                /**
			 * @type {import('estree-walker').SyncHandler}
			 */ enter (node, parent) {
                    if (is_reference(/** @type {import('is-reference').NodeWithPropertyDefinition} */ node, /** @type {import('is-reference').NodeWithPropertyDefinition} */ parent)) {
                        const identifier = get_object(node);
                        const { name: name } = identifier;
                        dependencies.add(name);
                    }
                }
            });
        }
        parse_expression() {
            unpack_destructuring({
                contexts: this.contexts,
                node: this.node.expression.left,
                scope: this.scope,
                component: this.component,
                context_rest_properties: this.context_rest_properties
            });
            this.expression = new Expression(this.component, this, this.scope, this.node.expression.right);
            this.contexts.forEach((context)=>{
                if (context.type !== "DestructuredVariable") return;
                const owner = this.scope.get_owner(context.key.name);
                if (owner && owner.type === "ConstTag" && owner.parent === this.parent) this.component.error(this.node, compiler_errors.invalid_const_declaration(context.key.name));
                this.scope.add(context.key.name, this.expression.dependencies, this);
            });
        }
    }
    /** @extends AbstractBlock<'PendingBlock'> */ class PendingBlock extends AbstractBlock {
        /**
	 * @param {import('../Component.js').default} component
	 * @param {import('./shared/Node.js').default} parent
	 * @param {import('./shared/TemplateScope.js').default} scope
	 * @param {import('../../interfaces.js').TemplateNode} info
	 */ constructor(component, parent, scope, info){
            super(component, parent, scope, info);
            this.children = map_children(component, parent, scope, info.children);
            if (!info.skip) this.warn_if_empty_block();
        }
    }
    /** @extends AbstractBlock<'CatchBlock'> */ class CatchBlock extends AbstractBlock {
        /** @type {import('./shared/TemplateScope.js').default} */ scope;
        /** @type {import('./ConstTag.js').default[]} */ const_tags;
        /**
	 * @param {import('../Component.js').default} component
	 * @param {import('./AwaitBlock.js').default} parent
	 * @param {import('./shared/TemplateScope.js').default} scope
	 * @param {import('../../interfaces.js').TemplateNode} info
	 */ constructor(component, parent, scope, info){
            super(component, parent, scope, info);
            this.scope = scope.child();
            if (parent.catch_node) parent.catch_contexts.forEach((context)=>{
                if (context.type !== "DestructuredVariable") return;
                this.scope.add(context.key.name, parent.expression.dependencies, this);
            });
            [this.const_tags, this.children] = get_const_tags$1(info.children, component, this, parent);
            if (!info.skip) this.warn_if_empty_block();
        }
    }
    /** @extends Node<'AwaitBlock'> */ let AwaitBlock$1 = class AwaitBlock extends Node {
        /** @type {import('./shared/Expression.js').default} */ expression;
        /** @type {import('./shared/Context.js').Context[]} */ then_contexts;
        /** @type {import('./shared/Context.js').Context[]} */ catch_contexts;
        /** @type {import('estree').Node | null} */ then_node;
        /** @type {import('estree').Node | null} */ catch_node;
        /** @type {import('./PendingBlock.js').default} */ pending;
        /** @type {import('./ThenBlock.js').default} */ then;
        /** @type {import('./CatchBlock.js').default} */ catch;
        /** @type {Map<string, import('estree').Node>} */ context_rest_properties = new Map();
        /**
	 * @param {import('../Component.js').default} component
	 * @param {import('./shared/Node.js').default} parent
	 * @param {import('./shared/TemplateScope.js').default} scope
	 * @param {import('../../interfaces.js').TemplateNode} info
	 */ constructor(component, parent, scope, info){
            super(component, parent, scope, info);
            this.cannot_use_innerhtml();
            this.not_static_content();
            this.expression = new Expression(component, this, scope, info.expression);
            this.then_node = info.value;
            this.catch_node = info.error;
            if (this.then_node) {
                this.then_contexts = [];
                unpack_destructuring({
                    contexts: this.then_contexts,
                    node: info.value,
                    scope: scope,
                    component: component,
                    context_rest_properties: this.context_rest_properties
                });
            }
            if (this.catch_node) {
                this.catch_contexts = [];
                unpack_destructuring({
                    contexts: this.catch_contexts,
                    node: info.error,
                    scope: scope,
                    component: component,
                    context_rest_properties: this.context_rest_properties
                });
            }
            this.pending = new PendingBlock(component, this, scope, info.pending);
            this.then = new ThenBlock(component, this, scope, info.then);
            this.catch = new CatchBlock(component, this, scope, info.catch);
        }
    };
    const regex_contains_term_function_expression = /FunctionExpression/;
    /** @extends Node<'EventHandler'> */ class EventHandler extends Node {
        /** @type {string} */ name;
        /** @type {Set<string>} */ modifiers;
        /** @type {import('./shared/Expression.js').default} */ expression;
        /** @type {import('estree').Identifier} */ handler_name;
        /** */ uses_context = false;
        /** */ can_make_passive = false;
        /**
	 * @param {import('../Component.js').default} component
	 * @param {import('./shared/Node.js').default} parent
	 * @param {import('./shared/TemplateScope.js').default} template_scope
	 * @param {import('../../interfaces.js').TemplateNode} info
	 */ constructor(component, parent, template_scope, info){
            super(component, parent, template_scope, info);
            this.name = info.name;
            this.modifiers = new Set(info.modifiers);
            if (info.expression) {
                this.expression = new Expression(component, this, template_scope, info.expression);
                this.uses_context = this.expression.uses_context;
                if (regex_contains_term_function_expression.test(info.expression.type) && info.expression.params.length === 0) // TODO make this detection more accurate — if `event.preventDefault` isn't called, and
                // `event` is passed to another function, we can make it passive
                this.can_make_passive = true;
                else if (info.expression.type === "Identifier") {
                    let node = component.node_for_declaration.get(info.expression.name);
                    if (node) {
                        if (node.type === "VariableDeclaration") {
                            // for `const handleClick = () => {...}`, we want the [arrow] function expression node
                            const declarator = node.declarations.find((d)=>/** @type {import('estree').Identifier} */ d.id.name === info.expression.name);
                            node = declarator && declarator.init;
                        }
                        if (node && (node.type === "FunctionExpression" || node.type === "FunctionDeclaration" || node.type === "ArrowFunctionExpression") && node.params.length === 0) this.can_make_passive = true;
                    }
                }
            } else this.handler_name = component.get_unique_name(`${sanitize(this.name)}_handler`);
        }
        /** @returns {boolean} */ get reassigned() {
            if (!this.expression) return false;
            const node = this.expression.node;
            if (regex_contains_term_function_expression.test(node.type)) return false;
            return this.expression.dynamic_dependencies().length > 0;
        }
    }
    /** @extends Node<'Action'> */ class Action extends Node {
        /** @type {string} */ name;
        /** @type {import('./shared/Expression.js').default} */ expression;
        /** @type {boolean} */ uses_context;
        /** @type {import('./shared/TemplateScope.js').default} */ template_scope;
        /**
	 * @param {import('../Component.js').default} component  *
	 * @param {import('./shared/Node.js').default} parent  *
	 * @param {import('./shared/TemplateScope.js').default} scope  *
	 * @param {import('../../interfaces.js').Directive} info  undefined
	 */ constructor(component, parent, scope, info){
            super(component, parent, scope, info);
            const object = info.name.split(".")[0];
            component.warn_if_undefined(object, info, scope);
            this.name = info.name;
            component.add_reference(/** @type {any} */ this, object);
            this.expression = info.expression ? new Expression(component, this, scope, info.expression) : null;
            this.template_scope = scope;
            this.uses_context = this.expression && this.expression.uses_context;
        }
    }
    /** @extends Node<'Body'> */ class Body extends Node {
        /** @type {import('./EventHandler.js').default[]} */ handlers = [];
        /** @type {import('./Action.js').default[]} */ actions = [];
        /**
	 * @param {import('../Component.js').default} component
	 * @param {import('./shared/Node.js').default} parent
	 * @param {import('./shared/TemplateScope.js').default} scope
	 * @param {import('../../interfaces.js').Element} info
	 */ constructor(component, parent, scope, info){
            super(component, parent, scope, info);
            info.attributes.forEach((node)=>{
                if (node.type === "EventHandler") this.handlers.push(new EventHandler(component, this, scope, node));
                else if (node.type === "Action") this.actions.push(new Action(component, this, scope, node));
            });
        }
    }
    /** @extends Node<'Comment'> */ let Comment$1 = class Comment extends Node {
        /** @type {string} */ data;
        /** @type {string[]} */ ignores;
        /**
	 * @param {import('../Component.js').default} component
	 * @param {import('./shared/Node.js').default} parent
	 * @param {import('./shared/TemplateScope.js').default} scope
	 * @param {import('../../interfaces.js').TemplateNode} info
	 */ constructor(component, parent, scope, info){
            super(component, parent, scope, info);
            this.data = info.data;
            this.ignores = info.ignores;
        }
    };
    /** @extends AbstractBlock<'ElseBlock'> */ class ElseBlock extends AbstractBlock {
        /** @type {import('./shared/TemplateScope.js').default} */ scope;
        /** @type {import('./ConstTag.js').default[]} */ const_tags;
        /**
	 * @param {import('../Component.js').default} component
	 * @param {import('./shared/Node.js').default} parent
	 * @param {import('./shared/TemplateScope.js').default} scope
	 * @param {import('../../interfaces.js').TemplateNode} info
	 */ constructor(component, parent, scope, info){
            super(component, parent, scope, info);
            this.scope = scope.child();
            [this.const_tags, this.children] = get_const_tags$1(info.children, component, this, this);
            this.warn_if_empty_block();
        }
    }
    /** @extends AbstractBlock<'EachBlock'> */ let EachBlock$1 = class EachBlock extends AbstractBlock {
        /** @type {import('./shared/Expression.js').default} */ expression;
        /** @type {import('estree').Node} */ context_node;
        /** @type {string} */ iterations;
        /** @type {string} */ index;
        /** @type {string} */ context;
        /** @type {import('./shared/Expression.js').default} */ key;
        /** @type {import('./shared/TemplateScope.js').default} */ scope;
        /** @type {import('./shared/Context.js').Context[]} */ contexts;
        /** @type {import('./ConstTag.js').default[]} */ const_tags;
        /** @type {boolean} */ has_animation;
        /** */ has_binding = false;
        /** */ has_index_binding = false;
        /** @type {Map<string, import('estree').Node>} */ context_rest_properties;
        /** @type {import('./ElseBlock.js').default} */ else;
        /**
	 * @param {import('../Component.js').default} component
	 * @param {import('estree').Node} parent
	 * @param {import('./shared/TemplateScope.js').default} scope
	 * @param {import('../../interfaces.js').TemplateNode} info
	 */ constructor(component, parent, scope, info){
            super(component, parent, scope, info);
            this.cannot_use_innerhtml();
            this.not_static_content();
            this.expression = new Expression(component, this, scope, info.expression);
            this.context = info.context.name || "each"; // TODO this is used to facilitate binding; currently fails with destructuring
            this.context_node = info.context;
            this.index = info.index;
            this.scope = scope.child();
            this.context_rest_properties = new Map();
            this.contexts = [];
            unpack_destructuring({
                contexts: this.contexts,
                node: info.context,
                scope: scope,
                component: component,
                context_rest_properties: this.context_rest_properties
            });
            this.contexts.forEach((context)=>{
                if (context.type !== "DestructuredVariable") return;
                this.scope.add(context.key.name, this.expression.dependencies, this);
            });
            if (this.index) {
                // index can only change if this is a keyed each block
                const dependencies = info.key ? this.expression.dependencies : new Set([]);
                this.scope.add(this.index, dependencies, this);
            }
            this.key = info.key ? new Expression(component, this, this.scope, info.key) : null;
            this.has_animation = false;
            [this.const_tags, this.children] = get_const_tags$1(info.children, component, this, this);
            if (this.has_animation) {
                this.children = this.children.filter((child)=>!is_empty_node(child) && !is_comment_node(child));
                if (this.children.length !== 1) {
                    const child = this.children.find((child)=>!!/** @type {import('./Element.js').default} */ child.animation);
                    component.error(/** @type {import('./Element.js').default} */ child.animation, compiler_errors.invalid_animation_sole);
                    return;
                }
            }
            this.warn_if_empty_block();
            this.else = info.else ? new ElseBlock(component, this, this.scope, info.else) : null;
        }
    };
    /** @param {import('./interfaces.js').INode} node */ function is_empty_node(node) {
        return node.type === "Text" && node.data.trim() === "";
    }
    /** @param {import('./interfaces.js').INode} node */ function is_comment_node(node) {
        return node.type === "Comment";
    }
    // TODO this should live in a specific binding
    const read_only_media_attributes = new Set([
        "duration",
        "buffered",
        "seekable",
        "played",
        "seeking",
        "ended",
        "videoHeight",
        "videoWidth",
        "naturalWidth",
        "naturalHeight",
        "readyState"
    ]);
    /** @extends Node<'Binding'> */ class Binding extends Node {
        /** @type {string} */ name;
        /** @type {import('./shared/Expression.js').default} */ expression;
        /** @type {import('estree').Node} */ raw_expression;
        /** @type {boolean} */ is_contextual;
        /** @type {boolean} */ is_readonly;
        /**
	 * @param {import('../Component.js').default} component
	 * @param {import('./Element.js').default | import('./InlineComponent.js').default | import('./Window.js').default | import('./Document.js').default} parent
	 * @param {import('./shared/TemplateScope.js').default} scope
	 * @param {import('../../interfaces.js').TemplateNode} info
	 */ constructor(component, parent, scope, info){
            super(component, parent, scope, info);
            if (info.expression.type !== "Identifier" && info.expression.type !== "MemberExpression") {
                component.error(info, compiler_errors.invalid_directive_value);
                return;
            }
            this.name = info.name;
            this.expression = new Expression(component, this, scope, info.expression);
            this.raw_expression = clone(info.expression);
            const { name: name } = get_object(this.expression.node);
            this.is_contextual = Array.from(this.expression.references).some((name)=>scope.names.has(name));
            if (this.is_contextual) this.validate_binding_rest_properties(scope);
            // make sure we track this as a mutable ref
            if (scope.is_let(name)) {
                component.error(this, compiler_errors.invalid_binding_let);
                return;
            } else if (scope.names.has(name)) {
                if (scope.is_await(name)) {
                    component.error(this, compiler_errors.invalid_binding_await);
                    return;
                }
                if (scope.is_const(name)) component.error(this, compiler_errors.invalid_binding_const);
                scope.dependencies_for_name.get(name).forEach((name)=>{
                    const variable = component.var_lookup.get(name);
                    if (variable) variable.mutated = true;
                });
            } else {
                const variable = component.var_lookup.get(name);
                if (!variable || variable.global) {
                    component.error(/** @type {any} */ this.expression.node, compiler_errors.binding_undeclared(name));
                    return;
                }
                variable[this.expression.node.type === "MemberExpression" ? "mutated" : "reassigned"] = true;
                if (info.expression.type === "Identifier" && !variable.writable) {
                    component.error(/** @type {any} */ this.expression.node, compiler_errors.invalid_binding_writable);
                    return;
                }
            }
            const type = parent.get_static_attribute_value("type");
            this.is_readonly = regex_dimensions.test(this.name) || regex_box_size.test(this.name) || is_element(parent) && (parent.is_media_node() && read_only_media_attributes.has(this.name) || parent.name === "input" && type === "file") /* TODO others? */ ;
        }
        is_readonly_media_attribute() {
            return read_only_media_attributes.has(this.name);
        }
        /** @param {import('./shared/TemplateScope.js').default} scope */ validate_binding_rest_properties(scope) {
            this.expression.references.forEach((name)=>{
                const each_block = scope.get_owner(name);
                if (each_block && each_block.type === "EachBlock") {
                    const rest_node = each_block.context_rest_properties.get(name);
                    if (rest_node) this.component.warn(/** @type {any} */ rest_node, compiler_warnings.invalid_rest_eachblock_binding(name));
                }
            });
        }
    }
    /**
 * @param {import('./shared/Node.js').default} node
 * @returns {node is import('./Element.js').default}
 */ function is_element(node) {
        return !!/** @type {any} */ node.is_media_node;
    }
    const valid_bindings$1 = [
        "fullscreenElement",
        "visibilityState"
    ];
    /** @extends Node<'Document'> */ class Document extends Node {
        /** @type {import('./EventHandler.js').default[]} */ handlers = [];
        /** @type {import('./Binding.js').default[]} */ bindings = [];
        /** @type {import('./Action.js').default[]} */ actions = [];
        /**
	 * @param {import('../Component.js').default} component
	 * @param {import('./shared/Node.js').default} parent
	 * @param {import('./shared/TemplateScope.js').default} scope
	 * @param {import('../../interfaces.js').Element} info
	 */ constructor(component, parent, scope, info){
            super(component, parent, scope, info);
            info.attributes.forEach((node)=>{
                if (node.type === "EventHandler") this.handlers.push(new EventHandler(component, this, scope, node));
                else if (node.type === "Binding") {
                    if (!~valid_bindings$1.indexOf(node.name)) {
                        const match = fuzzymatch(node.name, valid_bindings$1);
                        if (match) return component.error(node, compiler_errors.invalid_binding_on(node.name, "<svelte:document>", ` (did you mean '${match}'?)`));
                        else return component.error(node, compiler_errors.invalid_binding_on(node.name, "<svelte:document>", ` \u{2014} valid bindings are ${list(valid_bindings$1)}`));
                    }
                    this.bindings.push(new Binding(component, this, scope, node));
                } else if (node.type === "Action") this.actions.push(new Action(component, this, scope, node));
            });
            this.validate();
        }
        /** @private */ validate() {
            const handlers_map = new Set();
            this.handlers.forEach((handler)=>handlers_map.add(handler.name));
            if (handlers_map.has("mouseenter") || handlers_map.has("mouseleave")) this.component.warn(this, compiler_warnings.avoid_mouse_events_on_document);
        }
    }
    /**
 * @param {string} data
 * @returns {import('estree').Literal}
 */ function string_literal(data) {
        return {
            type: "Literal",
            value: data
        };
    }
    const escaped = {
        '"': "&quot;",
        "'": "&#39;",
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;"
    };
    const regex_html_characters_to_escape = /["'&<>]/g;
    function escape_html(html) {
        return String(html).replace(regex_html_characters_to_escape, (match)=>escaped[match]);
    }
    const regex_template_characters_to_escape = /(\${|`|\\)/g;
    function escape_template(str) {
        return str.replace(regex_template_characters_to_escape, "\\$1");
    }
    /**
 * @template T
 * @param {Set<T>} a
 * @param {Set<T> | T[]} b
 */ function add_to_set(a, b) {
        // @ts-ignore
        b.forEach((item)=>{
            a.add(item);
        });
    }
    /** @extends Node<'Attribute' | 'Spread', import('./Element.js').default> */ class Attribute extends Node {
        /** @type {import('./shared/TemplateScope.js').default} */ scope;
        /** @type {string} */ name;
        /** @type {boolean} */ is_spread;
        /** @type {boolean} */ is_true;
        /** @type {boolean} */ is_static;
        /** @type {import('./shared/Expression.js').default} */ expression;
        /** @type {Array<import('./Text.js').default | import('./shared/Expression.js').default>} */ chunks;
        /** @type {Set<string>} */ dependencies;
        /**
	 * @param {import('../Component.js').default} component
	 * @param {import('./shared/Node.js').default} parent
	 * @param {import('./shared/TemplateScope.js').default} scope
	 * @param {import('../../interfaces.js').TemplateNode} info
	 */ constructor(component, parent, scope, info){
            super(component, parent, scope, info);
            this.scope = scope;
            if (info.type === "Spread") {
                this.name = null;
                this.is_spread = true;
                this.is_true = false;
                this.expression = new Expression(component, this, scope, info.expression);
                this.dependencies = this.expression.dependencies;
                this.chunks = null;
                this.is_static = false;
            } else {
                this.name = info.name;
                this.is_true = info.value === true;
                this.is_static = true;
                this.dependencies = new Set();
                this.chunks = this.is_true ? [] : info.value.map((node)=>{
                    if (node.type === "Text") return node;
                    this.is_static = false;
                    const expression = new Expression(component, this, scope, node.expression);
                    add_to_set(this.dependencies, expression.dependencies);
                    return expression;
                });
            }
            if (this.dependencies.size > 0) {
                parent.cannot_use_innerhtml();
                parent.not_static_content();
            }
            // TODO Svelte 5: Think about moving this into the parser and make it an error
            if (this.name && this.name.includes(":") && !this.name.startsWith("xmlns:") && !this.name.startsWith("xlink:") && !this.name.startsWith("xml:")) component.warn(this, compiler_warnings.illegal_attribute_character);
        }
        get_dependencies() {
            if (this.is_spread) return this.expression.dynamic_dependencies();
            /** @type {Set<string>} */ const dependencies = new Set();
            this.chunks.forEach((chunk)=>{
                if (chunk.type === "Expression") add_to_set(dependencies, chunk.dynamic_dependencies());
            });
            return Array.from(dependencies);
        }
        /** @param {any} block */ get_value(block) {
            if (this.is_true) return x$1`true`;
            if (this.chunks.length === 0) return x$1`""`;
            if (this.chunks.length === 1) return this.chunks[0].type === "Text" ? string_literal(/** @type {import('./Text.js').default} */ this.chunks[0].data) : /** @type {import('./shared/Expression.js').default} */ this.chunks[0].manipulate(block);
            let expression = this.chunks.map(/** @param {any} chunk */ (chunk)=>chunk.type === "Text" ? string_literal(chunk.data) : chunk.manipulate(block)).reduce((lhs, rhs)=>x$1`${lhs} + ${rhs}`);
            if (this.chunks[0].type !== "Text") expression = x$1`"" + ${expression}`;
            return expression;
        }
        get_static_value() {
            if (!this.is_static) return null;
            return this.is_true ? true : this.chunks[0] ? /** @type {import('./Text.js').default} */ this.chunks[0].data : "";
        }
        should_cache() {
            return this.is_static ? false : this.chunks.length === 1 ? this.chunks[0].node.type !== "Identifier" || this.scope.names.has(this.chunks[0].node.name) : true;
        }
    }
    /** @extends Node<'Transition'> */ class Transition extends Node {
        /** @type {string} */ name;
        /** @type {string} */ directive;
        /** @type {import('./shared/Expression.js').default} */ expression;
        /** @type {boolean} */ is_local;
        /**
	 * @param {import('../Component.js').default} component
	 * @param {import('./Element.js').default} parent
	 * @param {import('./shared/TemplateScope.js').default} scope
	 * @param {import('../../interfaces.js').TemplateNode} info
	 */ constructor(component, parent, scope, info){
            super(component, parent, scope, info);
            component.warn_if_undefined(info.name, info, scope);
            this.name = info.name;
            component.add_reference(/** @type {any} */ this, info.name.split(".")[0]);
            this.directive = info.intro && info.outro ? "transition" : info.intro ? "in" : "out";
            this.is_local = !info.modifiers.includes("global");
            if (info.intro && parent.intro || info.outro && parent.outro) {
                const parent_transition = parent.intro || parent.outro;
                component.error(info, compiler_errors.duplicate_transition(this.directive, parent_transition.directive));
                return;
            }
            this.expression = info.expression ? new Expression(component, this, scope, info.expression) : null;
        }
    }
    /** @extends Node<'Animation'> */ class Animation extends Node {
        /** @type {string} */ name;
        /** @type {import('./shared/Expression.js').default} */ expression;
        /**
	 * @param {import('../Component.js').default} component  *
	 * @param {import('./Element.js').default} parent  *
	 * @param {import('./shared/TemplateScope.js').default} scope  *
	 * @param {import('../../interfaces.js').TemplateNode} info  undefined
	 */ constructor(component, parent, scope, info){
            super(component, parent, scope, info);
            component.warn_if_undefined(info.name, info, scope);
            this.name = info.name;
            component.add_reference(/** @type {any} */ this, info.name.split(".")[0]);
            if (parent.animation) {
                component.error(this, compiler_errors.duplicate_animation);
                return;
            }
            const block = parent.parent;
            if (!block || block.type !== "EachBlock") {
                // TODO can we relax the 'immediate child' rule?
                component.error(this, compiler_errors.invalid_animation_immediate);
                return;
            }
            if (!block.key) {
                component.error(this, compiler_errors.invalid_animation_key);
                return;
            }
            /** @type {import('./EachBlock.js').default} */ block.has_animation = true;
            this.expression = info.expression ? new Expression(component, this, scope, info.expression, true) : null;
        }
    }
    /** @extends Node<'Class'> */ class Class extends Node {
        /** @type {string} */ name;
        /** @type {import('./shared/Expression.js').default} */ expression;
        /**
	 * @param {import('../Component.js').default} component
	 * @param {import('./shared/Node.js').default} parent
	 * @param {import('./shared/TemplateScope.js').default} scope
	 * @param {import('../../interfaces.js').TemplateNode} info
	 */ constructor(component, parent, scope, info){
            super(component, parent, scope, info);
            this.name = info.name;
            this.expression = info.expression ? new Expression(component, this, scope, info.expression) : null;
        }
    }
    /**
 * Transforms a list of Text and MustacheTags into a TemplateLiteral expression.
 * Start/End positions on the elements of the expression are not set.
 * @param {Array<import('../../interfaces.js').Text | import('../../interfaces.js').MustacheTag>} value
 * @returns {import('estree').TemplateLiteral}
 */ function nodes_to_template_literal(value) {
        /**
	 * @type {import('estree').TemplateLiteral}
	 */ const literal = {
            type: "TemplateLiteral",
            expressions: [],
            quasis: []
        };
        /**
	 * @type {import('estree').TemplateElement}
	 */ let quasi = {
            type: "TemplateElement",
            value: {
                raw: "",
                cooked: null
            },
            tail: false
        };
        value.forEach((node)=>{
            if (node.type === "Text") quasi.value.raw += node.raw;
            else if (node.type === "MustacheTag") {
                literal.quasis.push(quasi);
                literal.expressions.push(/** @type {any} */ node.expression);
                quasi = {
                    type: "TemplateElement",
                    value: {
                        raw: "",
                        cooked: null
                    },
                    tail: false
                };
            }
        });
        quasi.tail = true;
        literal.quasis.push(quasi);
        return literal;
    }
    const valid_modifiers$1 = new Set([
        "important"
    ]);
    /** @extends Node<'StyleDirective'> */ class StyleDirective extends Node {
        /** @type {string} */ name;
        /** @type {Set<string>} */ modifiers;
        /** @type {import('./shared/Expression.js').default} */ expression;
        /** @type {boolean} */ should_cache;
        /**
	 * @param {import('../Component.js').default} component
	 * @param {import('./shared/Node.js').default} parent
	 * @param {import('./shared/TemplateScope.js').default} scope
	 * @param {import('../../interfaces.js').TemplateNode} info
	 */ constructor(component, parent, scope, info){
            super(component, parent, scope, info);
            this.name = info.name;
            this.modifiers = new Set(info.modifiers);
            for (const modifier of this.modifiers)if (!valid_modifiers$1.has(modifier)) component.error(this, compiler_errors.invalid_style_directive_modifier(list([
                ...valid_modifiers$1
            ])));
            // Convert the value array to an expression so it's easier to handle
            // the StyleDirective going forward.
            if (info.value === true || info.value.length === 1 && info.value[0].type === "MustacheTag") {
                const identifier = info.value === true ? {
                    type: "Identifier",
                    start: info.end - info.name.length,
                    end: info.end,
                    name: info.name
                } : info.value[0].expression;
                this.expression = new Expression(component, this, scope, identifier);
                this.should_cache = false;
            } else {
                const raw_expression = nodes_to_template_literal(info.value);
                this.expression = new Expression(component, this, scope, raw_expression);
                this.should_cache = raw_expression.expressions.length > 0;
            }
        }
        get important() {
            return this.modifiers.has("important");
        }
    }
    // Whitespace inside one of these elements will not result in
    // a whitespace node being created in any circumstances. (This
    // list is almost certainly very incomplete)
    const elements_without_text = new Set([
        "audio",
        "datalist",
        "dl",
        "optgroup",
        "select",
        "video"
    ]);
    const regex_ends_with_svg = /svg$/;
    const regex_non_whitespace_characters = /[\S\u00A0]/;
    /** @extends Node<'Text'> */ let Text$1 = class Text extends Node {
        /** @type {string} */ data;
        /** @type {boolean} */ synthetic;
        /**
	 * @param {import('../Component.js').default} component
	 * @param {import('./interfaces.js').INode} parent
	 * @param {import('./shared/TemplateScope.js').default} scope
	 * @param {import('../../interfaces.js').TemplateNode} info
	 */ constructor(component, parent, scope, info){
            super(component, parent, scope, info);
            this.data = info.data;
            this.synthetic = info.synthetic || false;
        }
        should_skip() {
            if (regex_non_whitespace_character.test(this.data)) return false;
            const parent_element = this.find_nearest(/(?:Element|InlineComponent|SlotTemplate|Head)/);
            if (!parent_element) return false;
            if (parent_element.type === "Head") return true;
            if (parent_element.type === "InlineComponent") return parent_element.children.length === 1 && this === parent_element.children[0];
            // svg namespace exclusions
            if (regex_ends_with_svg.test(parent_element.namespace)) {
                if (this.prev && this.prev.type === "Element" && this.prev.name === "tspan") return false;
            }
            return parent_element.namespace || elements_without_text.has(parent_element.name);
        }
        /** @returns {boolean} */ keep_space() {
            if (this.component.component_options.preserveWhitespace) return true;
            return this.within_pre();
        }
        /** @returns {boolean} */ within_pre() {
            let node = this.parent;
            while(node){
                if (node.type === "Element" && node.name === "pre") return true;
                node = node.parent;
            }
            return false;
        }
        /** @returns {boolean} */ use_space() {
            if (this.component.compile_options.preserveWhitespace) return false;
            if (regex_non_whitespace_characters.test(this.data)) return false;
            return !this.within_pre();
        }
    };
    // The `foreign` namespace covers all DOM implementations that aren't HTML5.
    // It opts out of HTML5-specific a11y checks and case-insensitive attribute names.
    const foreign = "https://svelte.dev/docs/special-elements#svelte-options";
    const html = "http://www.w3.org/1999/xhtml";
    const mathml = "http://www.w3.org/1998/Math/MathML";
    const svg = "http://www.w3.org/2000/svg";
    const xlink = "http://www.w3.org/1999/xlink";
    const xml = "http://www.w3.org/XML/1998/namespace";
    const xmlns = "http://www.w3.org/2000/xmlns";
    const valid_namespaces = [
        "foreign",
        "html",
        "mathml",
        "svg",
        "xlink",
        "xml",
        "xmlns",
        foreign,
        html,
        mathml,
        svg,
        xlink,
        xml,
        xmlns
    ];
    const namespaces = /** @type {const} */ {
        foreign: foreign,
        html: html,
        mathml: mathml,
        svg: svg,
        xlink: xlink,
        xml: xml,
        xmlns: xmlns
    };
    // Utilities for managing contenteditable nodes
    /** @typedef {import('../nodes/Attribute.js').default} Attribute */ /** @typedef {import('../nodes/Element.js').default} Element */ const CONTENTEDITABLE_BINDINGS = [
        "textContent",
        "innerHTML",
        "innerText"
    ];
    /**
 * Returns true if node is an 'input' or 'textarea'.
 * @param {Element} node The element to be checked
 */ function is_input_or_textarea(node) {
        return node.name === "textarea" || node.name === "input";
    }
    /**
 * Check if a given attribute is 'contenteditable'.
 * @param {Attribute} attribute A node.attribute
 */ function is_attr_contenteditable(attribute) {
        return attribute.name === "contenteditable";
    }
    /**
 * Check if any of a node's attributes are 'contentenditable'.
 * @param {Element} node The element to be checked
 */ function has_contenteditable_attr(node) {
        return node.attributes.some(is_attr_contenteditable);
    }
    /**
 * Returns true if node is not textarea or input, but has 'contenteditable' attribute.
 * @param {Element} node The element to be tested
 */ function is_contenteditable(node) {
        return !is_input_or_textarea(node) && has_contenteditable_attr(node);
    }
    /**
 * Returns true if a given binding/node is contenteditable.
 * @param {string} name A binding or node name to be checked
 */ function is_name_contenteditable(name) {
        return CONTENTEDITABLE_BINDINGS.includes(name);
    }
    /**
 * Returns the contenteditable attribute from the node (if it exists).
 * @param {Element} node The element to get the attribute from
 */ function get_contenteditable_attr(node) {
        return node.attributes.find(is_attr_contenteditable);
    }
    // https://github.com/darkskyapp/string-hash/blob/master/index.js
    const regex_return_characters = /\r/g;
    /**
 * @param {string} str
 * @returns {string}
 */ function hash(str) {
        str = str.replace(regex_return_characters, "");
        let hash = 5381;
        let i = str.length;
        while(i--)hash = (hash << 5) - hash ^ str.charCodeAt(i);
        return (hash >>> 0).toString(36);
    }
    const applicable = new Set([
        "Identifier",
        "ObjectExpression",
        "ArrayExpression",
        "Property"
    ]);
    /** @extends Node<'Let'> */ class Let extends Node {
        /** @type {import('estree').Identifier} */ name;
        /** @type {import('estree').Identifier} */ value;
        /** @type {string[]} */ names = [];
        /**
	 * @param {import('../Component.js').default} component
	 * @param {import('./shared/Node.js').default} parent
	 * @param {import('./shared/TemplateScope.js').default} scope
	 * @param {import('../../interfaces.js').TemplateNode} info
	 */ constructor(component, parent, scope, info){
            super(component, parent, scope, info);
            this.name = {
                type: "Identifier",
                name: info.name
            };
            const { names: names } = this;
            if (info.expression) {
                this.value = info.expression;
                walk(info.expression, {
                    /** @param {import('estree').Identifier | import('estree').BasePattern} node */ enter (node) {
                        if (!applicable.has(node.type)) return component.error(/** @type {any} */ node, compiler_errors.invalid_let);
                        if (node.type === "Identifier") names.push(/** @type {import('estree').Identifier} */ node.name);
                        // slightly unfortunate hack
                        if (node.type === "ArrayExpression") node.type = "ArrayPattern";
                        if (node.type === "ObjectExpression") node.type = "ObjectPattern";
                    }
                });
            } else names.push(this.name.name);
        }
    }
    var lib$1 = {};
    var ariaPropsMap$1 = {};
    var iterationDecorator$3 = {};
    var iteratorProxy$3 = {};
    Object.defineProperty(iteratorProxy$3, "__esModule", {
        value: true
    });
    iteratorProxy$3.default = void 0;
    // eslint-disable-next-line no-unused-vars
    function iteratorProxy$2() {
        var values = this;
        var index = 0;
        var iter = {
            "@@iterator": function iterator() {
                return iter;
            },
            next: function next() {
                if (index < values.length) {
                    var value = values[index];
                    index = index + 1;
                    return {
                        done: false,
                        value: value
                    };
                } else return {
                    done: true
                };
            }
        };
        return iter;
    }
    var _default$4j = iteratorProxy$2;
    iteratorProxy$3.default = _default$4j;
    Object.defineProperty(iterationDecorator$3, "__esModule", {
        value: true
    });
    iterationDecorator$3.default = iterationDecorator$2;
    var _iteratorProxy$1 = _interopRequireDefault$g(iteratorProxy$3);
    function _interopRequireDefault$g(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    function _typeof$1(obj) {
        "@babel/helpers - typeof";
        return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
            return typeof obj;
        } : function(obj) {
            return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        }, _typeof$1(obj);
    }
    function iterationDecorator$2(collection, entries) {
        if (typeof Symbol === "function" && _typeof$1(Symbol.iterator) === "symbol") Object.defineProperty(collection, Symbol.iterator, {
            value: _iteratorProxy$1.default.bind(entries)
        });
        return collection;
    }
    Object.defineProperty(ariaPropsMap$1, "__esModule", {
        value: true
    });
    ariaPropsMap$1.default = void 0;
    var _iterationDecorator$8 = _interopRequireDefault$f(iterationDecorator$3);
    function _interopRequireDefault$f(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    function _slicedToArray$8(arr, i) {
        return _arrayWithHoles$8(arr) || _iterableToArrayLimit$8(arr, i) || _unsupportedIterableToArray$8(arr, i) || _nonIterableRest$8();
    }
    function _nonIterableRest$8() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _iterableToArrayLimit$8(arr, i) {
        var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
        if (_i == null) return;
        var _arr = [];
        var _n = true;
        var _d = false;
        var _s, _e;
        try {
            for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){
                _arr.push(_s.value);
                if (i && _arr.length === i) break;
            }
        } catch (err) {
            _d = true;
            _e = err;
        } finally{
            try {
                if (!_n && _i["return"] != null) _i["return"]();
            } finally{
                if (_d) throw _e;
            }
        }
        return _arr;
    }
    function _arrayWithHoles$8(arr) {
        if (Array.isArray(arr)) return arr;
    }
    function _createForOfIteratorHelper$8(o, allowArrayLike) {
        var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
        if (!it) {
            if (Array.isArray(o) || (it = _unsupportedIterableToArray$8(o)) || allowArrayLike && o && typeof o.length === "number") {
                if (it) o = it;
                var i = 0;
                var F = function F() {};
                return {
                    s: F,
                    n: function n() {
                        if (i >= o.length) return {
                            done: true
                        };
                        return {
                            done: false,
                            value: o[i++]
                        };
                    },
                    e: function e(_e2) {
                        throw _e2;
                    },
                    f: F
                };
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var normalCompletion = true, didErr = false, err;
        return {
            s: function s() {
                it = it.call(o);
            },
            n: function n() {
                var step = it.next();
                normalCompletion = step.done;
                return step;
            },
            e: function e(_e3) {
                didErr = true;
                err = _e3;
            },
            f: function f() {
                try {
                    if (!normalCompletion && it.return != null) it.return();
                } finally{
                    if (didErr) throw err;
                }
            }
        };
    }
    function _unsupportedIterableToArray$8(o, minLen) {
        if (!o) return;
        if (typeof o === "string") return _arrayLikeToArray$8(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor) n = o.constructor.name;
        if (n === "Map" || n === "Set") return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$8(o, minLen);
    }
    function _arrayLikeToArray$8(arr, len) {
        if (len == null || len > arr.length) len = arr.length;
        for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
        return arr2;
    }
    var properties$1 = [
        [
            "aria-activedescendant",
            {
                "type": "id"
            }
        ],
        [
            "aria-atomic",
            {
                "type": "boolean"
            }
        ],
        [
            "aria-autocomplete",
            {
                "type": "token",
                "values": [
                    "inline",
                    "list",
                    "both",
                    "none"
                ]
            }
        ],
        [
            "aria-braillelabel",
            {
                "type": "string"
            }
        ],
        [
            "aria-brailleroledescription",
            {
                "type": "string"
            }
        ],
        [
            "aria-busy",
            {
                "type": "boolean"
            }
        ],
        [
            "aria-checked",
            {
                "type": "tristate"
            }
        ],
        [
            "aria-colcount",
            {
                type: "integer"
            }
        ],
        [
            "aria-colindex",
            {
                type: "integer"
            }
        ],
        [
            "aria-colspan",
            {
                type: "integer"
            }
        ],
        [
            "aria-controls",
            {
                "type": "idlist"
            }
        ],
        [
            "aria-current",
            {
                type: "token",
                values: [
                    "page",
                    "step",
                    "location",
                    "date",
                    "time",
                    true,
                    false
                ]
            }
        ],
        [
            "aria-describedby",
            {
                "type": "idlist"
            }
        ],
        [
            "aria-description",
            {
                "type": "string"
            }
        ],
        [
            "aria-details",
            {
                "type": "id"
            }
        ],
        [
            "aria-disabled",
            {
                "type": "boolean"
            }
        ],
        [
            "aria-dropeffect",
            {
                "type": "tokenlist",
                "values": [
                    "copy",
                    "execute",
                    "link",
                    "move",
                    "none",
                    "popup"
                ]
            }
        ],
        [
            "aria-errormessage",
            {
                "type": "id"
            }
        ],
        [
            "aria-expanded",
            {
                "type": "boolean",
                "allowundefined": true
            }
        ],
        [
            "aria-flowto",
            {
                "type": "idlist"
            }
        ],
        [
            "aria-grabbed",
            {
                "type": "boolean",
                "allowundefined": true
            }
        ],
        [
            "aria-haspopup",
            {
                "type": "token",
                "values": [
                    false,
                    true,
                    "menu",
                    "listbox",
                    "tree",
                    "grid",
                    "dialog"
                ]
            }
        ],
        [
            "aria-hidden",
            {
                "type": "boolean",
                "allowundefined": true
            }
        ],
        [
            "aria-invalid",
            {
                "type": "token",
                "values": [
                    "grammar",
                    false,
                    "spelling",
                    true
                ]
            }
        ],
        [
            "aria-keyshortcuts",
            {
                type: "string"
            }
        ],
        [
            "aria-label",
            {
                "type": "string"
            }
        ],
        [
            "aria-labelledby",
            {
                "type": "idlist"
            }
        ],
        [
            "aria-level",
            {
                "type": "integer"
            }
        ],
        [
            "aria-live",
            {
                "type": "token",
                "values": [
                    "assertive",
                    "off",
                    "polite"
                ]
            }
        ],
        [
            "aria-modal",
            {
                type: "boolean"
            }
        ],
        [
            "aria-multiline",
            {
                "type": "boolean"
            }
        ],
        [
            "aria-multiselectable",
            {
                "type": "boolean"
            }
        ],
        [
            "aria-orientation",
            {
                "type": "token",
                "values": [
                    "vertical",
                    "undefined",
                    "horizontal"
                ]
            }
        ],
        [
            "aria-owns",
            {
                "type": "idlist"
            }
        ],
        [
            "aria-placeholder",
            {
                type: "string"
            }
        ],
        [
            "aria-posinset",
            {
                "type": "integer"
            }
        ],
        [
            "aria-pressed",
            {
                "type": "tristate"
            }
        ],
        [
            "aria-readonly",
            {
                "type": "boolean"
            }
        ],
        [
            "aria-relevant",
            {
                "type": "tokenlist",
                "values": [
                    "additions",
                    "all",
                    "removals",
                    "text"
                ]
            }
        ],
        [
            "aria-required",
            {
                "type": "boolean"
            }
        ],
        [
            "aria-roledescription",
            {
                type: "string"
            }
        ],
        [
            "aria-rowcount",
            {
                type: "integer"
            }
        ],
        [
            "aria-rowindex",
            {
                type: "integer"
            }
        ],
        [
            "aria-rowspan",
            {
                type: "integer"
            }
        ],
        [
            "aria-selected",
            {
                "type": "boolean",
                "allowundefined": true
            }
        ],
        [
            "aria-setsize",
            {
                "type": "integer"
            }
        ],
        [
            "aria-sort",
            {
                "type": "token",
                "values": [
                    "ascending",
                    "descending",
                    "none",
                    "other"
                ]
            }
        ],
        [
            "aria-valuemax",
            {
                "type": "number"
            }
        ],
        [
            "aria-valuemin",
            {
                "type": "number"
            }
        ],
        [
            "aria-valuenow",
            {
                "type": "number"
            }
        ],
        [
            "aria-valuetext",
            {
                "type": "string"
            }
        ]
    ];
    var ariaPropsMap = {
        entries: function entries() {
            return properties$1;
        },
        forEach: function forEach(fn) {
            var thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
            var _iterator = _createForOfIteratorHelper$8(properties$1), _step;
            try {
                for(_iterator.s(); !(_step = _iterator.n()).done;){
                    var _step$value = _slicedToArray$8(_step.value, 2), key = _step$value[0], values = _step$value[1];
                    fn.call(thisArg, values, key, properties$1);
                }
            } catch (err) {
                _iterator.e(err);
            } finally{
                _iterator.f();
            }
        },
        get: function get(key) {
            var item = properties$1.find(function(tuple) {
                return tuple[0] === key ? true : false;
            });
            return item && item[1];
        },
        has: function has(key) {
            return !!ariaPropsMap.get(key);
        },
        keys: function keys() {
            return properties$1.map(function(_ref) {
                var _ref2 = _slicedToArray$8(_ref, 1), key = _ref2[0];
                return key;
            });
        },
        values: function values() {
            return properties$1.map(function(_ref3) {
                var _ref4 = _slicedToArray$8(_ref3, 2), values = _ref4[1];
                return values;
            });
        }
    };
    var _default$4i = (0, _iterationDecorator$8.default)(ariaPropsMap, ariaPropsMap.entries());
    ariaPropsMap$1.default = _default$4i;
    var domMap$1 = {};
    Object.defineProperty(domMap$1, "__esModule", {
        value: true
    });
    domMap$1.default = void 0;
    var _iterationDecorator$7 = _interopRequireDefault$e(iterationDecorator$3);
    function _interopRequireDefault$e(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    function _slicedToArray$7(arr, i) {
        return _arrayWithHoles$7(arr) || _iterableToArrayLimit$7(arr, i) || _unsupportedIterableToArray$7(arr, i) || _nonIterableRest$7();
    }
    function _nonIterableRest$7() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _iterableToArrayLimit$7(arr, i) {
        var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
        if (_i == null) return;
        var _arr = [];
        var _n = true;
        var _d = false;
        var _s, _e;
        try {
            for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){
                _arr.push(_s.value);
                if (i && _arr.length === i) break;
            }
        } catch (err) {
            _d = true;
            _e = err;
        } finally{
            try {
                if (!_n && _i["return"] != null) _i["return"]();
            } finally{
                if (_d) throw _e;
            }
        }
        return _arr;
    }
    function _arrayWithHoles$7(arr) {
        if (Array.isArray(arr)) return arr;
    }
    function _createForOfIteratorHelper$7(o, allowArrayLike) {
        var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
        if (!it) {
            if (Array.isArray(o) || (it = _unsupportedIterableToArray$7(o)) || allowArrayLike && o && typeof o.length === "number") {
                if (it) o = it;
                var i = 0;
                var F = function F() {};
                return {
                    s: F,
                    n: function n() {
                        if (i >= o.length) return {
                            done: true
                        };
                        return {
                            done: false,
                            value: o[i++]
                        };
                    },
                    e: function e(_e2) {
                        throw _e2;
                    },
                    f: F
                };
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var normalCompletion = true, didErr = false, err;
        return {
            s: function s() {
                it = it.call(o);
            },
            n: function n() {
                var step = it.next();
                normalCompletion = step.done;
                return step;
            },
            e: function e(_e3) {
                didErr = true;
                err = _e3;
            },
            f: function f() {
                try {
                    if (!normalCompletion && it.return != null) it.return();
                } finally{
                    if (didErr) throw err;
                }
            }
        };
    }
    function _unsupportedIterableToArray$7(o, minLen) {
        if (!o) return;
        if (typeof o === "string") return _arrayLikeToArray$7(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor) n = o.constructor.name;
        if (n === "Map" || n === "Set") return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$7(o, minLen);
    }
    function _arrayLikeToArray$7(arr, len) {
        if (len == null || len > arr.length) len = arr.length;
        for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
        return arr2;
    }
    var dom$2 = [
        [
            "a",
            {
                reserved: false
            }
        ],
        [
            "abbr",
            {
                reserved: false
            }
        ],
        [
            "acronym",
            {
                reserved: false
            }
        ],
        [
            "address",
            {
                reserved: false
            }
        ],
        [
            "applet",
            {
                reserved: false
            }
        ],
        [
            "area",
            {
                reserved: false
            }
        ],
        [
            "article",
            {
                reserved: false
            }
        ],
        [
            "aside",
            {
                reserved: false
            }
        ],
        [
            "audio",
            {
                reserved: false
            }
        ],
        [
            "b",
            {
                reserved: false
            }
        ],
        [
            "base",
            {
                reserved: true
            }
        ],
        [
            "bdi",
            {
                reserved: false
            }
        ],
        [
            "bdo",
            {
                reserved: false
            }
        ],
        [
            "big",
            {
                reserved: false
            }
        ],
        [
            "blink",
            {
                reserved: false
            }
        ],
        [
            "blockquote",
            {
                reserved: false
            }
        ],
        [
            "body",
            {
                reserved: false
            }
        ],
        [
            "br",
            {
                reserved: false
            }
        ],
        [
            "button",
            {
                reserved: false
            }
        ],
        [
            "canvas",
            {
                reserved: false
            }
        ],
        [
            "caption",
            {
                reserved: false
            }
        ],
        [
            "center",
            {
                reserved: false
            }
        ],
        [
            "cite",
            {
                reserved: false
            }
        ],
        [
            "code",
            {
                reserved: false
            }
        ],
        [
            "col",
            {
                reserved: true
            }
        ],
        [
            "colgroup",
            {
                reserved: true
            }
        ],
        [
            "content",
            {
                reserved: false
            }
        ],
        [
            "data",
            {
                reserved: false
            }
        ],
        [
            "datalist",
            {
                reserved: false
            }
        ],
        [
            "dd",
            {
                reserved: false
            }
        ],
        [
            "del",
            {
                reserved: false
            }
        ],
        [
            "details",
            {
                reserved: false
            }
        ],
        [
            "dfn",
            {
                reserved: false
            }
        ],
        [
            "dialog",
            {
                reserved: false
            }
        ],
        [
            "dir",
            {
                reserved: false
            }
        ],
        [
            "div",
            {
                reserved: false
            }
        ],
        [
            "dl",
            {
                reserved: false
            }
        ],
        [
            "dt",
            {
                reserved: false
            }
        ],
        [
            "em",
            {
                reserved: false
            }
        ],
        [
            "embed",
            {
                reserved: false
            }
        ],
        [
            "fieldset",
            {
                reserved: false
            }
        ],
        [
            "figcaption",
            {
                reserved: false
            }
        ],
        [
            "figure",
            {
                reserved: false
            }
        ],
        [
            "font",
            {
                reserved: false
            }
        ],
        [
            "footer",
            {
                reserved: false
            }
        ],
        [
            "form",
            {
                reserved: false
            }
        ],
        [
            "frame",
            {
                reserved: false
            }
        ],
        [
            "frameset",
            {
                reserved: false
            }
        ],
        [
            "h1",
            {
                reserved: false
            }
        ],
        [
            "h2",
            {
                reserved: false
            }
        ],
        [
            "h3",
            {
                reserved: false
            }
        ],
        [
            "h4",
            {
                reserved: false
            }
        ],
        [
            "h5",
            {
                reserved: false
            }
        ],
        [
            "h6",
            {
                reserved: false
            }
        ],
        [
            "head",
            {
                reserved: true
            }
        ],
        [
            "header",
            {
                reserved: false
            }
        ],
        [
            "hgroup",
            {
                reserved: false
            }
        ],
        [
            "hr",
            {
                reserved: false
            }
        ],
        [
            "html",
            {
                reserved: true
            }
        ],
        [
            "i",
            {
                reserved: false
            }
        ],
        [
            "iframe",
            {
                reserved: false
            }
        ],
        [
            "img",
            {
                reserved: false
            }
        ],
        [
            "input",
            {
                reserved: false
            }
        ],
        [
            "ins",
            {
                reserved: false
            }
        ],
        [
            "kbd",
            {
                reserved: false
            }
        ],
        [
            "keygen",
            {
                reserved: false
            }
        ],
        [
            "label",
            {
                reserved: false
            }
        ],
        [
            "legend",
            {
                reserved: false
            }
        ],
        [
            "li",
            {
                reserved: false
            }
        ],
        [
            "link",
            {
                reserved: true
            }
        ],
        [
            "main",
            {
                reserved: false
            }
        ],
        [
            "map",
            {
                reserved: false
            }
        ],
        [
            "mark",
            {
                reserved: false
            }
        ],
        [
            "marquee",
            {
                reserved: false
            }
        ],
        [
            "menu",
            {
                reserved: false
            }
        ],
        [
            "menuitem",
            {
                reserved: false
            }
        ],
        [
            "meta",
            {
                reserved: true
            }
        ],
        [
            "meter",
            {
                reserved: false
            }
        ],
        [
            "nav",
            {
                reserved: false
            }
        ],
        [
            "noembed",
            {
                reserved: true
            }
        ],
        [
            "noscript",
            {
                reserved: true
            }
        ],
        [
            "object",
            {
                reserved: false
            }
        ],
        [
            "ol",
            {
                reserved: false
            }
        ],
        [
            "optgroup",
            {
                reserved: false
            }
        ],
        [
            "option",
            {
                reserved: false
            }
        ],
        [
            "output",
            {
                reserved: false
            }
        ],
        [
            "p",
            {
                reserved: false
            }
        ],
        [
            "param",
            {
                reserved: true
            }
        ],
        [
            "picture",
            {
                reserved: true
            }
        ],
        [
            "pre",
            {
                reserved: false
            }
        ],
        [
            "progress",
            {
                reserved: false
            }
        ],
        [
            "q",
            {
                reserved: false
            }
        ],
        [
            "rp",
            {
                reserved: false
            }
        ],
        [
            "rt",
            {
                reserved: false
            }
        ],
        [
            "rtc",
            {
                reserved: false
            }
        ],
        [
            "ruby",
            {
                reserved: false
            }
        ],
        [
            "s",
            {
                reserved: false
            }
        ],
        [
            "samp",
            {
                reserved: false
            }
        ],
        [
            "script",
            {
                reserved: true
            }
        ],
        [
            "section",
            {
                reserved: false
            }
        ],
        [
            "select",
            {
                reserved: false
            }
        ],
        [
            "small",
            {
                reserved: false
            }
        ],
        [
            "source",
            {
                reserved: true
            }
        ],
        [
            "spacer",
            {
                reserved: false
            }
        ],
        [
            "span",
            {
                reserved: false
            }
        ],
        [
            "strike",
            {
                reserved: false
            }
        ],
        [
            "strong",
            {
                reserved: false
            }
        ],
        [
            "style",
            {
                reserved: true
            }
        ],
        [
            "sub",
            {
                reserved: false
            }
        ],
        [
            "summary",
            {
                reserved: false
            }
        ],
        [
            "sup",
            {
                reserved: false
            }
        ],
        [
            "table",
            {
                reserved: false
            }
        ],
        [
            "tbody",
            {
                reserved: false
            }
        ],
        [
            "td",
            {
                reserved: false
            }
        ],
        [
            "textarea",
            {
                reserved: false
            }
        ],
        [
            "tfoot",
            {
                reserved: false
            }
        ],
        [
            "th",
            {
                reserved: false
            }
        ],
        [
            "thead",
            {
                reserved: false
            }
        ],
        [
            "time",
            {
                reserved: false
            }
        ],
        [
            "title",
            {
                reserved: true
            }
        ],
        [
            "tr",
            {
                reserved: false
            }
        ],
        [
            "track",
            {
                reserved: true
            }
        ],
        [
            "tt",
            {
                reserved: false
            }
        ],
        [
            "u",
            {
                reserved: false
            }
        ],
        [
            "ul",
            {
                reserved: false
            }
        ],
        [
            "var",
            {
                reserved: false
            }
        ],
        [
            "video",
            {
                reserved: false
            }
        ],
        [
            "wbr",
            {
                reserved: false
            }
        ],
        [
            "xmp",
            {
                reserved: false
            }
        ]
    ];
    var domMap = {
        entries: function entries() {
            return dom$2;
        },
        forEach: function forEach(fn) {
            var thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
            var _iterator = _createForOfIteratorHelper$7(dom$2), _step;
            try {
                for(_iterator.s(); !(_step = _iterator.n()).done;){
                    var _step$value = _slicedToArray$7(_step.value, 2), key = _step$value[0], values = _step$value[1];
                    fn.call(thisArg, values, key, dom$2);
                }
            } catch (err) {
                _iterator.e(err);
            } finally{
                _iterator.f();
            }
        },
        get: function get(key) {
            var item = dom$2.find(function(tuple) {
                return tuple[0] === key ? true : false;
            });
            return item && item[1];
        },
        has: function has(key) {
            return !!domMap.get(key);
        },
        keys: function keys() {
            return dom$2.map(function(_ref) {
                var _ref2 = _slicedToArray$7(_ref, 1), key = _ref2[0];
                return key;
            });
        },
        values: function values() {
            return dom$2.map(function(_ref3) {
                var _ref4 = _slicedToArray$7(_ref3, 2), values = _ref4[1];
                return values;
            });
        }
    };
    var _default$4h = (0, _iterationDecorator$7.default)(domMap, domMap.entries());
    domMap$1.default = _default$4h;
    var rolesMap$1 = {};
    var ariaAbstractRoles$1 = {};
    var commandRole$1 = {};
    Object.defineProperty(commandRole$1, "__esModule", {
        value: true
    });
    commandRole$1.default = void 0;
    var commandRole = {
        abstract: true,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "widget"
            ]
        ]
    };
    var _default$4g = commandRole;
    commandRole$1.default = _default$4g;
    var compositeRole$1 = {};
    Object.defineProperty(compositeRole$1, "__esModule", {
        value: true
    });
    compositeRole$1.default = void 0;
    var compositeRole = {
        abstract: true,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {
            "aria-activedescendant": null,
            "aria-disabled": null
        },
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "widget"
            ]
        ]
    };
    var _default$4f = compositeRole;
    compositeRole$1.default = _default$4f;
    var inputRole$1 = {};
    Object.defineProperty(inputRole$1, "__esModule", {
        value: true
    });
    inputRole$1.default = void 0;
    var inputRole = {
        abstract: true,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {
            "aria-disabled": null
        },
        relatedConcepts: [
            {
                concept: {
                    name: "input"
                },
                module: "XForms"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "widget"
            ]
        ]
    };
    var _default$4e = inputRole;
    inputRole$1.default = _default$4e;
    var landmarkRole$1 = {};
    Object.defineProperty(landmarkRole$1, "__esModule", {
        value: true
    });
    landmarkRole$1.default = void 0;
    var landmarkRole = {
        abstract: true,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "section"
            ]
        ]
    };
    var _default$4d = landmarkRole;
    landmarkRole$1.default = _default$4d;
    var rangeRole$1 = {};
    Object.defineProperty(rangeRole$1, "__esModule", {
        value: true
    });
    rangeRole$1.default = void 0;
    var rangeRole = {
        abstract: true,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {
            "aria-valuemax": null,
            "aria-valuemin": null,
            "aria-valuenow": null
        },
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure"
            ]
        ]
    };
    var _default$4c = rangeRole;
    rangeRole$1.default = _default$4c;
    var roletypeRole$1 = {};
    Object.defineProperty(roletypeRole$1, "__esModule", {
        value: true
    });
    roletypeRole$1.default = void 0;
    var roletypeRole = {
        abstract: true,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [],
        prohibitedProps: [],
        props: {
            "aria-atomic": null,
            "aria-busy": null,
            "aria-controls": null,
            "aria-current": null,
            "aria-describedby": null,
            "aria-details": null,
            "aria-dropeffect": null,
            "aria-flowto": null,
            "aria-grabbed": null,
            "aria-hidden": null,
            "aria-keyshortcuts": null,
            "aria-label": null,
            "aria-labelledby": null,
            "aria-live": null,
            "aria-owns": null,
            "aria-relevant": null,
            "aria-roledescription": null
        },
        relatedConcepts: [
            {
                concept: {
                    name: "role"
                },
                module: "XHTML"
            },
            {
                concept: {
                    name: "type"
                },
                module: "Dublin Core"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: []
    };
    var _default$4b = roletypeRole;
    roletypeRole$1.default = _default$4b;
    var sectionRole$1 = {};
    Object.defineProperty(sectionRole$1, "__esModule", {
        value: true
    });
    sectionRole$1.default = void 0;
    var sectionRole = {
        abstract: true,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [
            {
                concept: {
                    name: "frontmatter"
                },
                module: "DTB"
            },
            {
                concept: {
                    name: "level"
                },
                module: "DTB"
            },
            {
                concept: {
                    name: "level"
                },
                module: "SMIL"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure"
            ]
        ]
    };
    var _default$4a = sectionRole;
    sectionRole$1.default = _default$4a;
    var sectionheadRole$1 = {};
    Object.defineProperty(sectionheadRole$1, "__esModule", {
        value: true
    });
    sectionheadRole$1.default = void 0;
    var sectionheadRole = {
        abstract: true,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author",
            "contents"
        ],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure"
            ]
        ]
    };
    var _default$49 = sectionheadRole;
    sectionheadRole$1.default = _default$49;
    var selectRole$1 = {};
    Object.defineProperty(selectRole$1, "__esModule", {
        value: true
    });
    selectRole$1.default = void 0;
    var selectRole = {
        abstract: true,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {
            "aria-orientation": null
        },
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "widget",
                "composite"
            ],
            [
                "roletype",
                "structure",
                "section",
                "group"
            ]
        ]
    };
    var _default$48 = selectRole;
    selectRole$1.default = _default$48;
    var structureRole$1 = {};
    Object.defineProperty(structureRole$1, "__esModule", {
        value: true
    });
    structureRole$1.default = void 0;
    var structureRole = {
        abstract: true,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype"
            ]
        ]
    };
    var _default$47 = structureRole;
    structureRole$1.default = _default$47;
    var widgetRole$1 = {};
    Object.defineProperty(widgetRole$1, "__esModule", {
        value: true
    });
    widgetRole$1.default = void 0;
    var widgetRole = {
        abstract: true,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype"
            ]
        ]
    };
    var _default$46 = widgetRole;
    widgetRole$1.default = _default$46;
    var windowRole$1 = {};
    Object.defineProperty(windowRole$1, "__esModule", {
        value: true
    });
    windowRole$1.default = void 0;
    var windowRole = {
        abstract: true,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {
            "aria-modal": null
        },
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype"
            ]
        ]
    };
    var _default$45 = windowRole;
    windowRole$1.default = _default$45;
    Object.defineProperty(ariaAbstractRoles$1, "__esModule", {
        value: true
    });
    ariaAbstractRoles$1.default = void 0;
    var _commandRole = _interopRequireDefault$d(commandRole$1);
    var _compositeRole = _interopRequireDefault$d(compositeRole$1);
    var _inputRole = _interopRequireDefault$d(inputRole$1);
    var _landmarkRole = _interopRequireDefault$d(landmarkRole$1);
    var _rangeRole = _interopRequireDefault$d(rangeRole$1);
    var _roletypeRole = _interopRequireDefault$d(roletypeRole$1);
    var _sectionRole = _interopRequireDefault$d(sectionRole$1);
    var _sectionheadRole = _interopRequireDefault$d(sectionheadRole$1);
    var _selectRole = _interopRequireDefault$d(selectRole$1);
    var _structureRole = _interopRequireDefault$d(structureRole$1);
    var _widgetRole = _interopRequireDefault$d(widgetRole$1);
    var _windowRole = _interopRequireDefault$d(windowRole$1);
    function _interopRequireDefault$d(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    var ariaAbstractRoles = [
        [
            "command",
            _commandRole.default
        ],
        [
            "composite",
            _compositeRole.default
        ],
        [
            "input",
            _inputRole.default
        ],
        [
            "landmark",
            _landmarkRole.default
        ],
        [
            "range",
            _rangeRole.default
        ],
        [
            "roletype",
            _roletypeRole.default
        ],
        [
            "section",
            _sectionRole.default
        ],
        [
            "sectionhead",
            _sectionheadRole.default
        ],
        [
            "select",
            _selectRole.default
        ],
        [
            "structure",
            _structureRole.default
        ],
        [
            "widget",
            _widgetRole.default
        ],
        [
            "window",
            _windowRole.default
        ]
    ];
    var _default$44 = ariaAbstractRoles;
    ariaAbstractRoles$1.default = _default$44;
    var ariaLiteralRoles$1 = {};
    var alertRole$1 = {};
    Object.defineProperty(alertRole$1, "__esModule", {
        value: true
    });
    alertRole$1.default = void 0;
    var alertRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {
            "aria-atomic": "true",
            "aria-live": "assertive"
        },
        relatedConcepts: [
            {
                concept: {
                    name: "alert"
                },
                module: "XForms"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "section"
            ]
        ]
    };
    var _default$43 = alertRole;
    alertRole$1.default = _default$43;
    var alertdialogRole$1 = {};
    Object.defineProperty(alertdialogRole$1, "__esModule", {
        value: true
    });
    alertdialogRole$1.default = void 0;
    var alertdialogRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [
            {
                concept: {
                    name: "alert"
                },
                module: "XForms"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "section",
                "alert"
            ],
            [
                "roletype",
                "window",
                "dialog"
            ]
        ]
    };
    var _default$42 = alertdialogRole;
    alertdialogRole$1.default = _default$42;
    var applicationRole$1 = {};
    Object.defineProperty(applicationRole$1, "__esModule", {
        value: true
    });
    applicationRole$1.default = void 0;
    var applicationRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {
            "aria-activedescendant": null,
            "aria-disabled": null,
            "aria-errormessage": null,
            "aria-expanded": null,
            "aria-haspopup": null,
            "aria-invalid": null
        },
        relatedConcepts: [
            {
                concept: {
                    name: "Device Independence Delivery Unit"
                }
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure"
            ]
        ]
    };
    var _default$41 = applicationRole;
    applicationRole$1.default = _default$41;
    var articleRole$1 = {};
    Object.defineProperty(articleRole$1, "__esModule", {
        value: true
    });
    articleRole$1.default = void 0;
    var articleRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {
            "aria-posinset": null,
            "aria-setsize": null
        },
        relatedConcepts: [
            {
                concept: {
                    name: "article"
                },
                module: "HTML"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "document"
            ]
        ]
    };
    var _default$40 = articleRole;
    articleRole$1.default = _default$40;
    var bannerRole$1 = {};
    Object.defineProperty(bannerRole$1, "__esModule", {
        value: true
    });
    bannerRole$1.default = void 0;
    var bannerRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [
            {
                concept: {
                    constraints: [
                        "scoped to the body element"
                    ],
                    name: "header"
                },
                module: "HTML"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "section",
                "landmark"
            ]
        ]
    };
    var _default$3$ = bannerRole;
    bannerRole$1.default = _default$3$;
    var blockquoteRole$1 = {};
    Object.defineProperty(blockquoteRole$1, "__esModule", {
        value: true
    });
    blockquoteRole$1.default = void 0;
    var blockquoteRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [
            {
                concept: {
                    name: "blockquote"
                },
                module: "HTML"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "section"
            ]
        ]
    };
    var _default$3_ = blockquoteRole;
    blockquoteRole$1.default = _default$3_;
    var buttonRole$1 = {};
    Object.defineProperty(buttonRole$1, "__esModule", {
        value: true
    });
    buttonRole$1.default = void 0;
    var buttonRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: true,
        nameFrom: [
            "author",
            "contents"
        ],
        prohibitedProps: [],
        props: {
            "aria-disabled": null,
            "aria-expanded": null,
            "aria-haspopup": null,
            "aria-pressed": null
        },
        relatedConcepts: [
            {
                concept: {
                    attributes: [
                        {
                            name: "type",
                            value: "button"
                        }
                    ],
                    name: "input"
                },
                module: "HTML"
            },
            {
                concept: {
                    attributes: [
                        {
                            name: "type",
                            value: "image"
                        }
                    ],
                    name: "input"
                },
                module: "HTML"
            },
            {
                concept: {
                    attributes: [
                        {
                            name: "type",
                            value: "reset"
                        }
                    ],
                    name: "input"
                },
                module: "HTML"
            },
            {
                concept: {
                    attributes: [
                        {
                            name: "type",
                            value: "submit"
                        }
                    ],
                    name: "input"
                },
                module: "HTML"
            },
            {
                concept: {
                    name: "button"
                },
                module: "HTML"
            },
            {
                concept: {
                    name: "trigger"
                },
                module: "XForms"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "widget",
                "command"
            ]
        ]
    };
    var _default$3Z = buttonRole;
    buttonRole$1.default = _default$3Z;
    var captionRole$1 = {};
    Object.defineProperty(captionRole$1, "__esModule", {
        value: true
    });
    captionRole$1.default = void 0;
    var captionRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "prohibited"
        ],
        prohibitedProps: [
            "aria-label",
            "aria-labelledby"
        ],
        props: {},
        relatedConcepts: [
            {
                concept: {
                    name: "caption"
                },
                module: "HTML"
            }
        ],
        requireContextRole: [
            "figure",
            "grid",
            "table"
        ],
        requiredContextRole: [
            "figure",
            "grid",
            "table"
        ],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "section"
            ]
        ]
    };
    var _default$3Y = captionRole;
    captionRole$1.default = _default$3Y;
    var cellRole$1 = {};
    Object.defineProperty(cellRole$1, "__esModule", {
        value: true
    });
    cellRole$1.default = void 0;
    var cellRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author",
            "contents"
        ],
        prohibitedProps: [],
        props: {
            "aria-colindex": null,
            "aria-colspan": null,
            "aria-rowindex": null,
            "aria-rowspan": null
        },
        relatedConcepts: [
            {
                concept: {
                    constraints: [
                        "ancestor table element has table role"
                    ],
                    name: "td"
                },
                module: "HTML"
            }
        ],
        requireContextRole: [
            "row"
        ],
        requiredContextRole: [
            "row"
        ],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "section"
            ]
        ]
    };
    var _default$3X = cellRole;
    cellRole$1.default = _default$3X;
    var checkboxRole$1 = {};
    Object.defineProperty(checkboxRole$1, "__esModule", {
        value: true
    });
    checkboxRole$1.default = void 0;
    var checkboxRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: true,
        nameFrom: [
            "author",
            "contents"
        ],
        prohibitedProps: [],
        props: {
            "aria-checked": null,
            "aria-errormessage": null,
            "aria-expanded": null,
            "aria-invalid": null,
            "aria-readonly": null,
            "aria-required": null
        },
        relatedConcepts: [
            {
                concept: {
                    attributes: [
                        {
                            name: "type",
                            value: "checkbox"
                        }
                    ],
                    name: "input"
                },
                module: "HTML"
            },
            {
                concept: {
                    name: "option"
                },
                module: "ARIA"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {
            "aria-checked": null
        },
        superClass: [
            [
                "roletype",
                "widget",
                "input"
            ]
        ]
    };
    var _default$3W = checkboxRole;
    checkboxRole$1.default = _default$3W;
    var codeRole$1 = {};
    Object.defineProperty(codeRole$1, "__esModule", {
        value: true
    });
    codeRole$1.default = void 0;
    var codeRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "prohibited"
        ],
        prohibitedProps: [
            "aria-label",
            "aria-labelledby"
        ],
        props: {},
        relatedConcepts: [
            {
                concept: {
                    name: "code"
                },
                module: "HTML"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "section"
            ]
        ]
    };
    var _default$3V = codeRole;
    codeRole$1.default = _default$3V;
    var columnheaderRole$1 = {};
    Object.defineProperty(columnheaderRole$1, "__esModule", {
        value: true
    });
    columnheaderRole$1.default = void 0;
    var columnheaderRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author",
            "contents"
        ],
        prohibitedProps: [],
        props: {
            "aria-sort": null
        },
        relatedConcepts: [
            {
                concept: {
                    name: "th"
                },
                module: "HTML"
            },
            {
                concept: {
                    attributes: [
                        {
                            name: "scope",
                            value: "col"
                        }
                    ],
                    name: "th"
                },
                module: "HTML"
            },
            {
                concept: {
                    attributes: [
                        {
                            name: "scope",
                            value: "colgroup"
                        }
                    ],
                    name: "th"
                },
                module: "HTML"
            }
        ],
        requireContextRole: [
            "row"
        ],
        requiredContextRole: [
            "row"
        ],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "section",
                "cell"
            ],
            [
                "roletype",
                "structure",
                "section",
                "cell",
                "gridcell"
            ],
            [
                "roletype",
                "widget",
                "gridcell"
            ],
            [
                "roletype",
                "structure",
                "sectionhead"
            ]
        ]
    };
    var _default$3U = columnheaderRole;
    columnheaderRole$1.default = _default$3U;
    var comboboxRole$1 = {};
    Object.defineProperty(comboboxRole$1, "__esModule", {
        value: true
    });
    comboboxRole$1.default = void 0;
    var comboboxRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {
            "aria-activedescendant": null,
            "aria-autocomplete": null,
            "aria-errormessage": null,
            "aria-invalid": null,
            "aria-readonly": null,
            "aria-required": null,
            "aria-expanded": "false",
            "aria-haspopup": "listbox"
        },
        relatedConcepts: [
            {
                concept: {
                    attributes: [
                        {
                            constraints: [
                                "set"
                            ],
                            name: "list"
                        },
                        {
                            name: "type",
                            value: "email"
                        }
                    ],
                    name: "input"
                },
                module: "HTML"
            },
            {
                concept: {
                    attributes: [
                        {
                            constraints: [
                                "set"
                            ],
                            name: "list"
                        },
                        {
                            name: "type",
                            value: "search"
                        }
                    ],
                    name: "input"
                },
                module: "HTML"
            },
            {
                concept: {
                    attributes: [
                        {
                            constraints: [
                                "set"
                            ],
                            name: "list"
                        },
                        {
                            name: "type",
                            value: "tel"
                        }
                    ],
                    name: "input"
                },
                module: "HTML"
            },
            {
                concept: {
                    attributes: [
                        {
                            constraints: [
                                "set"
                            ],
                            name: "list"
                        },
                        {
                            name: "type",
                            value: "text"
                        }
                    ],
                    name: "input"
                },
                module: "HTML"
            },
            {
                concept: {
                    attributes: [
                        {
                            constraints: [
                                "set"
                            ],
                            name: "list"
                        },
                        {
                            name: "type",
                            value: "url"
                        }
                    ],
                    name: "input"
                },
                module: "HTML"
            },
            {
                concept: {
                    attributes: [
                        {
                            constraints: [
                                "set"
                            ],
                            name: "list"
                        },
                        {
                            name: "type",
                            value: "url"
                        }
                    ],
                    name: "input"
                },
                module: "HTML"
            },
            {
                concept: {
                    attributes: [
                        {
                            constraints: [
                                "undefined"
                            ],
                            name: "multiple"
                        },
                        {
                            constraints: [
                                "undefined"
                            ],
                            name: "size"
                        }
                    ],
                    constraints: [
                        "the multiple attribute is not set and the size attribute does not have a value greater than 1"
                    ],
                    name: "select"
                },
                module: "HTML"
            },
            {
                concept: {
                    name: "select"
                },
                module: "XForms"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {
            "aria-controls": null,
            "aria-expanded": "false"
        },
        superClass: [
            [
                "roletype",
                "widget",
                "input"
            ]
        ]
    };
    var _default$3T = comboboxRole;
    comboboxRole$1.default = _default$3T;
    var complementaryRole$1 = {};
    Object.defineProperty(complementaryRole$1, "__esModule", {
        value: true
    });
    complementaryRole$1.default = void 0;
    var complementaryRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [
            {
                concept: {
                    name: "aside"
                },
                module: "HTML"
            },
            {
                concept: {
                    attributes: [
                        {
                            constraints: [
                                "set"
                            ],
                            name: "aria-label"
                        }
                    ],
                    constraints: [
                        "scoped to a sectioning content element",
                        "scoped to a sectioning root element other than body"
                    ],
                    name: "aside"
                },
                module: "HTML"
            },
            {
                concept: {
                    attributes: [
                        {
                            constraints: [
                                "set"
                            ],
                            name: "aria-labelledby"
                        }
                    ],
                    constraints: [
                        "scoped to a sectioning content element",
                        "scoped to a sectioning root element other than body"
                    ],
                    name: "aside"
                },
                module: "HTML"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "section",
                "landmark"
            ]
        ]
    };
    var _default$3S = complementaryRole;
    complementaryRole$1.default = _default$3S;
    var contentinfoRole$1 = {};
    Object.defineProperty(contentinfoRole$1, "__esModule", {
        value: true
    });
    contentinfoRole$1.default = void 0;
    var contentinfoRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [
            {
                concept: {
                    constraints: [
                        "scoped to the body element"
                    ],
                    name: "footer"
                },
                module: "HTML"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "section",
                "landmark"
            ]
        ]
    };
    var _default$3R = contentinfoRole;
    contentinfoRole$1.default = _default$3R;
    var definitionRole$1 = {};
    Object.defineProperty(definitionRole$1, "__esModule", {
        value: true
    });
    definitionRole$1.default = void 0;
    var definitionRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [
            {
                concept: {
                    name: "dd"
                },
                module: "HTML"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "section"
            ]
        ]
    };
    var _default$3Q = definitionRole;
    definitionRole$1.default = _default$3Q;
    var deletionRole$1 = {};
    Object.defineProperty(deletionRole$1, "__esModule", {
        value: true
    });
    deletionRole$1.default = void 0;
    var deletionRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "prohibited"
        ],
        prohibitedProps: [
            "aria-label",
            "aria-labelledby"
        ],
        props: {},
        relatedConcepts: [
            {
                concept: {
                    name: "del"
                },
                module: "HTML"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "section"
            ]
        ]
    };
    var _default$3P = deletionRole;
    deletionRole$1.default = _default$3P;
    var dialogRole$1 = {};
    Object.defineProperty(dialogRole$1, "__esModule", {
        value: true
    });
    dialogRole$1.default = void 0;
    var dialogRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [
            {
                concept: {
                    name: "dialog"
                },
                module: "HTML"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "window"
            ]
        ]
    };
    var _default$3O = dialogRole;
    dialogRole$1.default = _default$3O;
    var directoryRole$1 = {};
    Object.defineProperty(directoryRole$1, "__esModule", {
        value: true
    });
    directoryRole$1.default = void 0;
    var directoryRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [
            {
                module: "DAISY Guide"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "section",
                "list"
            ]
        ]
    };
    var _default$3N = directoryRole;
    directoryRole$1.default = _default$3N;
    var documentRole$1 = {};
    Object.defineProperty(documentRole$1, "__esModule", {
        value: true
    });
    documentRole$1.default = void 0;
    var documentRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [
            {
                concept: {
                    name: "Device Independence Delivery Unit"
                }
            },
            {
                concept: {
                    name: "html"
                },
                module: "HTML"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure"
            ]
        ]
    };
    var _default$3M = documentRole;
    documentRole$1.default = _default$3M;
    var emphasisRole$1 = {};
    Object.defineProperty(emphasisRole$1, "__esModule", {
        value: true
    });
    emphasisRole$1.default = void 0;
    var emphasisRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "prohibited"
        ],
        prohibitedProps: [
            "aria-label",
            "aria-labelledby"
        ],
        props: {},
        relatedConcepts: [
            {
                concept: {
                    name: "em"
                },
                module: "HTML"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "section"
            ]
        ]
    };
    var _default$3L = emphasisRole;
    emphasisRole$1.default = _default$3L;
    var feedRole$1 = {};
    Object.defineProperty(feedRole$1, "__esModule", {
        value: true
    });
    feedRole$1.default = void 0;
    var feedRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [
            [
                "article"
            ]
        ],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "section",
                "list"
            ]
        ]
    };
    var _default$3K = feedRole;
    feedRole$1.default = _default$3K;
    var figureRole$1 = {};
    Object.defineProperty(figureRole$1, "__esModule", {
        value: true
    });
    figureRole$1.default = void 0;
    var figureRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [
            {
                concept: {
                    name: "figure"
                },
                module: "HTML"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "section"
            ]
        ]
    };
    var _default$3J = figureRole;
    figureRole$1.default = _default$3J;
    var formRole$1 = {};
    Object.defineProperty(formRole$1, "__esModule", {
        value: true
    });
    formRole$1.default = void 0;
    var formRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [
            {
                concept: {
                    attributes: [
                        {
                            constraints: [
                                "set"
                            ],
                            name: "aria-label"
                        }
                    ],
                    name: "form"
                },
                module: "HTML"
            },
            {
                concept: {
                    attributes: [
                        {
                            constraints: [
                                "set"
                            ],
                            name: "aria-labelledby"
                        }
                    ],
                    name: "form"
                },
                module: "HTML"
            },
            {
                concept: {
                    attributes: [
                        {
                            constraints: [
                                "set"
                            ],
                            name: "name"
                        }
                    ],
                    name: "form"
                },
                module: "HTML"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "section",
                "landmark"
            ]
        ]
    };
    var _default$3I = formRole;
    formRole$1.default = _default$3I;
    var genericRole$1 = {};
    Object.defineProperty(genericRole$1, "__esModule", {
        value: true
    });
    genericRole$1.default = void 0;
    var genericRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "prohibited"
        ],
        prohibitedProps: [
            "aria-label",
            "aria-labelledby"
        ],
        props: {},
        relatedConcepts: [
            {
                concept: {
                    name: "a"
                },
                module: "HTML"
            },
            {
                concept: {
                    name: "area"
                },
                module: "HTML"
            },
            {
                concept: {
                    name: "aside"
                },
                module: "HTML"
            },
            {
                concept: {
                    name: "b"
                },
                module: "HTML"
            },
            {
                concept: {
                    name: "bdo"
                },
                module: "HTML"
            },
            {
                concept: {
                    name: "body"
                },
                module: "HTML"
            },
            {
                concept: {
                    name: "data"
                },
                module: "HTML"
            },
            {
                concept: {
                    name: "div"
                },
                module: "HTML"
            },
            {
                concept: {
                    constraints: [
                        "scoped to the main element",
                        "scoped to a sectioning content element",
                        "scoped to a sectioning root element other than body"
                    ],
                    name: "footer"
                },
                module: "HTML"
            },
            {
                concept: {
                    constraints: [
                        "scoped to the main element",
                        "scoped to a sectioning content element",
                        "scoped to a sectioning root element other than body"
                    ],
                    name: "header"
                },
                module: "HTML"
            },
            {
                concept: {
                    name: "hgroup"
                },
                module: "HTML"
            },
            {
                concept: {
                    name: "i"
                },
                module: "HTML"
            },
            {
                concept: {
                    name: "pre"
                },
                module: "HTML"
            },
            {
                concept: {
                    name: "q"
                },
                module: "HTML"
            },
            {
                concept: {
                    name: "samp"
                },
                module: "HTML"
            },
            {
                concept: {
                    name: "section"
                },
                module: "HTML"
            },
            {
                concept: {
                    name: "small"
                },
                module: "HTML"
            },
            {
                concept: {
                    name: "span"
                },
                module: "HTML"
            },
            {
                concept: {
                    name: "u"
                },
                module: "HTML"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure"
            ]
        ]
    };
    var _default$3H = genericRole;
    genericRole$1.default = _default$3H;
    var gridRole$1 = {};
    Object.defineProperty(gridRole$1, "__esModule", {
        value: true
    });
    gridRole$1.default = void 0;
    var gridRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {
            "aria-multiselectable": null,
            "aria-readonly": null
        },
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [
            [
                "row"
            ],
            [
                "row",
                "rowgroup"
            ]
        ],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "widget",
                "composite"
            ],
            [
                "roletype",
                "structure",
                "section",
                "table"
            ]
        ]
    };
    var _default$3G = gridRole;
    gridRole$1.default = _default$3G;
    var gridcellRole$1 = {};
    Object.defineProperty(gridcellRole$1, "__esModule", {
        value: true
    });
    gridcellRole$1.default = void 0;
    var gridcellRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author",
            "contents"
        ],
        prohibitedProps: [],
        props: {
            "aria-disabled": null,
            "aria-errormessage": null,
            "aria-expanded": null,
            "aria-haspopup": null,
            "aria-invalid": null,
            "aria-readonly": null,
            "aria-required": null,
            "aria-selected": null
        },
        relatedConcepts: [
            {
                concept: {
                    constraints: [
                        "ancestor table element has grid role",
                        "ancestor table element has treegrid role"
                    ],
                    name: "td"
                },
                module: "HTML"
            }
        ],
        requireContextRole: [
            "row"
        ],
        requiredContextRole: [
            "row"
        ],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "section",
                "cell"
            ],
            [
                "roletype",
                "widget"
            ]
        ]
    };
    var _default$3F = gridcellRole;
    gridcellRole$1.default = _default$3F;
    var groupRole$1 = {};
    Object.defineProperty(groupRole$1, "__esModule", {
        value: true
    });
    groupRole$1.default = void 0;
    var groupRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {
            "aria-activedescendant": null,
            "aria-disabled": null
        },
        relatedConcepts: [
            {
                concept: {
                    name: "details"
                },
                module: "HTML"
            },
            {
                concept: {
                    name: "fieldset"
                },
                module: "HTML"
            },
            {
                concept: {
                    name: "optgroup"
                },
                module: "HTML"
            },
            {
                concept: {
                    name: "address"
                },
                module: "HTML"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "section"
            ]
        ]
    };
    var _default$3E = groupRole;
    groupRole$1.default = _default$3E;
    var headingRole$1 = {};
    Object.defineProperty(headingRole$1, "__esModule", {
        value: true
    });
    headingRole$1.default = void 0;
    var headingRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author",
            "contents"
        ],
        prohibitedProps: [],
        props: {
            "aria-level": "2"
        },
        relatedConcepts: [
            {
                concept: {
                    name: "h1"
                },
                module: "HTML"
            },
            {
                concept: {
                    name: "h2"
                },
                module: "HTML"
            },
            {
                concept: {
                    name: "h3"
                },
                module: "HTML"
            },
            {
                concept: {
                    name: "h4"
                },
                module: "HTML"
            },
            {
                concept: {
                    name: "h5"
                },
                module: "HTML"
            },
            {
                concept: {
                    name: "h6"
                },
                module: "HTML"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {
            "aria-level": "2"
        },
        superClass: [
            [
                "roletype",
                "structure",
                "sectionhead"
            ]
        ]
    };
    var _default$3D = headingRole;
    headingRole$1.default = _default$3D;
    var imgRole$1 = {};
    Object.defineProperty(imgRole$1, "__esModule", {
        value: true
    });
    imgRole$1.default = void 0;
    var imgRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: true,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [
            {
                concept: {
                    attributes: [
                        {
                            constraints: [
                                "set"
                            ],
                            name: "alt"
                        }
                    ],
                    name: "img"
                },
                module: "HTML"
            },
            {
                concept: {
                    attributes: [
                        {
                            constraints: [
                                "undefined"
                            ],
                            name: "alt"
                        }
                    ],
                    name: "img"
                },
                module: "HTML"
            },
            {
                concept: {
                    name: "imggroup"
                },
                module: "DTB"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "section"
            ]
        ]
    };
    var _default$3C = imgRole;
    imgRole$1.default = _default$3C;
    var insertionRole$1 = {};
    Object.defineProperty(insertionRole$1, "__esModule", {
        value: true
    });
    insertionRole$1.default = void 0;
    var insertionRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "prohibited"
        ],
        prohibitedProps: [
            "aria-label",
            "aria-labelledby"
        ],
        props: {},
        relatedConcepts: [
            {
                concept: {
                    name: "ins"
                },
                module: "HTML"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "section"
            ]
        ]
    };
    var _default$3B = insertionRole;
    insertionRole$1.default = _default$3B;
    var linkRole$1 = {};
    Object.defineProperty(linkRole$1, "__esModule", {
        value: true
    });
    linkRole$1.default = void 0;
    var linkRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author",
            "contents"
        ],
        prohibitedProps: [],
        props: {
            "aria-disabled": null,
            "aria-expanded": null,
            "aria-haspopup": null
        },
        relatedConcepts: [
            {
                concept: {
                    attributes: [
                        {
                            constraints: [
                                "set"
                            ],
                            name: "href"
                        }
                    ],
                    name: "a"
                },
                module: "HTML"
            },
            {
                concept: {
                    attributes: [
                        {
                            constraints: [
                                "set"
                            ],
                            name: "href"
                        }
                    ],
                    name: "area"
                },
                module: "HTML"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "widget",
                "command"
            ]
        ]
    };
    var _default$3A = linkRole;
    linkRole$1.default = _default$3A;
    var listRole$1 = {};
    Object.defineProperty(listRole$1, "__esModule", {
        value: true
    });
    listRole$1.default = void 0;
    var listRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [
            {
                concept: {
                    name: "menu"
                },
                module: "HTML"
            },
            {
                concept: {
                    name: "ol"
                },
                module: "HTML"
            },
            {
                concept: {
                    name: "ul"
                },
                module: "HTML"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [
            [
                "listitem"
            ]
        ],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "section"
            ]
        ]
    };
    var _default$3z = listRole;
    listRole$1.default = _default$3z;
    var listboxRole$1 = {};
    Object.defineProperty(listboxRole$1, "__esModule", {
        value: true
    });
    listboxRole$1.default = void 0;
    var listboxRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {
            "aria-errormessage": null,
            "aria-expanded": null,
            "aria-invalid": null,
            "aria-multiselectable": null,
            "aria-readonly": null,
            "aria-required": null,
            "aria-orientation": "vertical"
        },
        relatedConcepts: [
            {
                concept: {
                    attributes: [
                        {
                            constraints: [
                                ">1"
                            ],
                            name: "size"
                        }
                    ],
                    constraints: [
                        "the size attribute value is greater than 1"
                    ],
                    name: "select"
                },
                module: "HTML"
            },
            {
                concept: {
                    attributes: [
                        {
                            name: "multiple"
                        }
                    ],
                    name: "select"
                },
                module: "HTML"
            },
            {
                concept: {
                    name: "datalist"
                },
                module: "HTML"
            },
            {
                concept: {
                    name: "list"
                },
                module: "ARIA"
            },
            {
                concept: {
                    name: "select"
                },
                module: "XForms"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [
            [
                "option",
                "group"
            ],
            [
                "option"
            ]
        ],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "widget",
                "composite",
                "select"
            ],
            [
                "roletype",
                "structure",
                "section",
                "group",
                "select"
            ]
        ]
    };
    var _default$3y = listboxRole;
    listboxRole$1.default = _default$3y;
    var listitemRole$1 = {};
    Object.defineProperty(listitemRole$1, "__esModule", {
        value: true
    });
    listitemRole$1.default = void 0;
    var listitemRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {
            "aria-level": null,
            "aria-posinset": null,
            "aria-setsize": null
        },
        relatedConcepts: [
            {
                concept: {
                    constraints: [
                        "direct descendant of ol",
                        "direct descendant of ul",
                        "direct descendant of menu"
                    ],
                    name: "li"
                },
                module: "HTML"
            },
            {
                concept: {
                    name: "item"
                },
                module: "XForms"
            }
        ],
        requireContextRole: [
            "directory",
            "list"
        ],
        requiredContextRole: [
            "directory",
            "list"
        ],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "section"
            ]
        ]
    };
    var _default$3x = listitemRole;
    listitemRole$1.default = _default$3x;
    var logRole$1 = {};
    Object.defineProperty(logRole$1, "__esModule", {
        value: true
    });
    logRole$1.default = void 0;
    var logRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {
            "aria-live": "polite"
        },
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "section"
            ]
        ]
    };
    var _default$3w = logRole;
    logRole$1.default = _default$3w;
    var mainRole$1 = {};
    Object.defineProperty(mainRole$1, "__esModule", {
        value: true
    });
    mainRole$1.default = void 0;
    var mainRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [
            {
                concept: {
                    name: "main"
                },
                module: "HTML"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "section",
                "landmark"
            ]
        ]
    };
    var _default$3v = mainRole;
    mainRole$1.default = _default$3v;
    var markRole$1 = {};
    Object.defineProperty(markRole$1, "__esModule", {
        value: true
    });
    markRole$1.default = void 0;
    var markRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "prohibited"
        ],
        prohibitedProps: [],
        props: {
            "aria-braillelabel": null,
            "aria-brailleroledescription": null,
            "aria-description": null
        },
        relatedConcepts: [
            {
                concept: {
                    name: "mark"
                },
                module: "HTML"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "section"
            ]
        ]
    };
    var _default$3u = markRole;
    markRole$1.default = _default$3u;
    var marqueeRole$1 = {};
    Object.defineProperty(marqueeRole$1, "__esModule", {
        value: true
    });
    marqueeRole$1.default = void 0;
    var marqueeRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "section"
            ]
        ]
    };
    var _default$3t = marqueeRole;
    marqueeRole$1.default = _default$3t;
    var mathRole$1 = {};
    Object.defineProperty(mathRole$1, "__esModule", {
        value: true
    });
    mathRole$1.default = void 0;
    var mathRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [
            {
                concept: {
                    name: "math"
                },
                module: "HTML"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "section"
            ]
        ]
    };
    var _default$3s = mathRole;
    mathRole$1.default = _default$3s;
    var menuRole$1 = {};
    Object.defineProperty(menuRole$1, "__esModule", {
        value: true
    });
    menuRole$1.default = void 0;
    var menuRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {
            "aria-orientation": "vertical"
        },
        relatedConcepts: [
            {
                concept: {
                    name: "MENU"
                },
                module: "JAPI"
            },
            {
                concept: {
                    name: "list"
                },
                module: "ARIA"
            },
            {
                concept: {
                    name: "select"
                },
                module: "XForms"
            },
            {
                concept: {
                    name: "sidebar"
                },
                module: "DTB"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [
            [
                "menuitem",
                "group"
            ],
            [
                "menuitemradio",
                "group"
            ],
            [
                "menuitemcheckbox",
                "group"
            ],
            [
                "menuitem"
            ],
            [
                "menuitemcheckbox"
            ],
            [
                "menuitemradio"
            ]
        ],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "widget",
                "composite",
                "select"
            ],
            [
                "roletype",
                "structure",
                "section",
                "group",
                "select"
            ]
        ]
    };
    var _default$3r = menuRole;
    menuRole$1.default = _default$3r;
    var menubarRole$1 = {};
    Object.defineProperty(menubarRole$1, "__esModule", {
        value: true
    });
    menubarRole$1.default = void 0;
    var menubarRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {
            "aria-orientation": "horizontal"
        },
        relatedConcepts: [
            {
                concept: {
                    name: "toolbar"
                },
                module: "ARIA"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [
            [
                "menuitem",
                "group"
            ],
            [
                "menuitemradio",
                "group"
            ],
            [
                "menuitemcheckbox",
                "group"
            ],
            [
                "menuitem"
            ],
            [
                "menuitemcheckbox"
            ],
            [
                "menuitemradio"
            ]
        ],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "widget",
                "composite",
                "select",
                "menu"
            ],
            [
                "roletype",
                "structure",
                "section",
                "group",
                "select",
                "menu"
            ]
        ]
    };
    var _default$3q = menubarRole;
    menubarRole$1.default = _default$3q;
    var menuitemRole$1 = {};
    Object.defineProperty(menuitemRole$1, "__esModule", {
        value: true
    });
    menuitemRole$1.default = void 0;
    var menuitemRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author",
            "contents"
        ],
        prohibitedProps: [],
        props: {
            "aria-disabled": null,
            "aria-expanded": null,
            "aria-haspopup": null,
            "aria-posinset": null,
            "aria-setsize": null
        },
        relatedConcepts: [
            {
                concept: {
                    name: "MENU_ITEM"
                },
                module: "JAPI"
            },
            {
                concept: {
                    name: "listitem"
                },
                module: "ARIA"
            },
            {
                concept: {
                    name: "option"
                },
                module: "ARIA"
            }
        ],
        requireContextRole: [
            "group",
            "menu",
            "menubar"
        ],
        requiredContextRole: [
            "group",
            "menu",
            "menubar"
        ],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "widget",
                "command"
            ]
        ]
    };
    var _default$3p = menuitemRole;
    menuitemRole$1.default = _default$3p;
    var menuitemcheckboxRole$1 = {};
    Object.defineProperty(menuitemcheckboxRole$1, "__esModule", {
        value: true
    });
    menuitemcheckboxRole$1.default = void 0;
    var menuitemcheckboxRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: true,
        nameFrom: [
            "author",
            "contents"
        ],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [
            {
                concept: {
                    name: "menuitem"
                },
                module: "ARIA"
            }
        ],
        requireContextRole: [
            "group",
            "menu",
            "menubar"
        ],
        requiredContextRole: [
            "group",
            "menu",
            "menubar"
        ],
        requiredOwnedElements: [],
        requiredProps: {
            "aria-checked": null
        },
        superClass: [
            [
                "roletype",
                "widget",
                "input",
                "checkbox"
            ],
            [
                "roletype",
                "widget",
                "command",
                "menuitem"
            ]
        ]
    };
    var _default$3o = menuitemcheckboxRole;
    menuitemcheckboxRole$1.default = _default$3o;
    var menuitemradioRole$1 = {};
    Object.defineProperty(menuitemradioRole$1, "__esModule", {
        value: true
    });
    menuitemradioRole$1.default = void 0;
    var menuitemradioRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: true,
        nameFrom: [
            "author",
            "contents"
        ],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [
            {
                concept: {
                    name: "menuitem"
                },
                module: "ARIA"
            }
        ],
        requireContextRole: [
            "group",
            "menu",
            "menubar"
        ],
        requiredContextRole: [
            "group",
            "menu",
            "menubar"
        ],
        requiredOwnedElements: [],
        requiredProps: {
            "aria-checked": null
        },
        superClass: [
            [
                "roletype",
                "widget",
                "input",
                "checkbox",
                "menuitemcheckbox"
            ],
            [
                "roletype",
                "widget",
                "command",
                "menuitem",
                "menuitemcheckbox"
            ],
            [
                "roletype",
                "widget",
                "input",
                "radio"
            ]
        ]
    };
    var _default$3n = menuitemradioRole;
    menuitemradioRole$1.default = _default$3n;
    var meterRole$1 = {};
    Object.defineProperty(meterRole$1, "__esModule", {
        value: true
    });
    meterRole$1.default = void 0;
    var meterRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: true,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {
            "aria-valuetext": null,
            "aria-valuemax": "100",
            "aria-valuemin": "0"
        },
        relatedConcepts: [
            {
                concept: {
                    name: "meter"
                },
                module: "HTML"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {
            "aria-valuenow": null
        },
        superClass: [
            [
                "roletype",
                "structure",
                "range"
            ]
        ]
    };
    var _default$3m = meterRole;
    meterRole$1.default = _default$3m;
    var navigationRole$1 = {};
    Object.defineProperty(navigationRole$1, "__esModule", {
        value: true
    });
    navigationRole$1.default = void 0;
    var navigationRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [
            {
                concept: {
                    name: "nav"
                },
                module: "HTML"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "section",
                "landmark"
            ]
        ]
    };
    var _default$3l = navigationRole;
    navigationRole$1.default = _default$3l;
    var noneRole$1 = {};
    Object.defineProperty(noneRole$1, "__esModule", {
        value: true
    });
    noneRole$1.default = void 0;
    var noneRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: []
    };
    var _default$3k = noneRole;
    noneRole$1.default = _default$3k;
    var noteRole$1 = {};
    Object.defineProperty(noteRole$1, "__esModule", {
        value: true
    });
    noteRole$1.default = void 0;
    var noteRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "section"
            ]
        ]
    };
    var _default$3j = noteRole;
    noteRole$1.default = _default$3j;
    var optionRole$1 = {};
    Object.defineProperty(optionRole$1, "__esModule", {
        value: true
    });
    optionRole$1.default = void 0;
    var optionRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: true,
        nameFrom: [
            "author",
            "contents"
        ],
        prohibitedProps: [],
        props: {
            "aria-checked": null,
            "aria-posinset": null,
            "aria-setsize": null,
            "aria-selected": "false"
        },
        relatedConcepts: [
            {
                concept: {
                    name: "item"
                },
                module: "XForms"
            },
            {
                concept: {
                    name: "listitem"
                },
                module: "ARIA"
            },
            {
                concept: {
                    name: "option"
                },
                module: "HTML"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {
            "aria-selected": "false"
        },
        superClass: [
            [
                "roletype",
                "widget",
                "input"
            ]
        ]
    };
    var _default$3i = optionRole;
    optionRole$1.default = _default$3i;
    var paragraphRole$1 = {};
    Object.defineProperty(paragraphRole$1, "__esModule", {
        value: true
    });
    paragraphRole$1.default = void 0;
    var paragraphRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "prohibited"
        ],
        prohibitedProps: [
            "aria-label",
            "aria-labelledby"
        ],
        props: {},
        relatedConcepts: [
            {
                concept: {
                    name: "p"
                },
                module: "HTML"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "section"
            ]
        ]
    };
    var _default$3h = paragraphRole;
    paragraphRole$1.default = _default$3h;
    var presentationRole$1 = {};
    Object.defineProperty(presentationRole$1, "__esModule", {
        value: true
    });
    presentationRole$1.default = void 0;
    var presentationRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "prohibited"
        ],
        prohibitedProps: [
            "aria-label",
            "aria-labelledby"
        ],
        props: {},
        relatedConcepts: [
            {
                concept: {
                    attributes: [
                        {
                            name: "alt",
                            value: ""
                        }
                    ],
                    name: "img"
                },
                module: "HTML"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure"
            ]
        ]
    };
    var _default$3g = presentationRole;
    presentationRole$1.default = _default$3g;
    var progressbarRole$1 = {};
    Object.defineProperty(progressbarRole$1, "__esModule", {
        value: true
    });
    progressbarRole$1.default = void 0;
    var progressbarRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: true,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {
            "aria-valuetext": null
        },
        relatedConcepts: [
            {
                concept: {
                    name: "progress"
                },
                module: "HTML"
            },
            {
                concept: {
                    name: "status"
                },
                module: "ARIA"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "range"
            ],
            [
                "roletype",
                "widget"
            ]
        ]
    };
    var _default$3f = progressbarRole;
    progressbarRole$1.default = _default$3f;
    var radioRole$1 = {};
    Object.defineProperty(radioRole$1, "__esModule", {
        value: true
    });
    radioRole$1.default = void 0;
    var radioRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: true,
        nameFrom: [
            "author",
            "contents"
        ],
        prohibitedProps: [],
        props: {
            "aria-checked": null,
            "aria-posinset": null,
            "aria-setsize": null
        },
        relatedConcepts: [
            {
                concept: {
                    attributes: [
                        {
                            name: "type",
                            value: "radio"
                        }
                    ],
                    name: "input"
                },
                module: "HTML"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {
            "aria-checked": null
        },
        superClass: [
            [
                "roletype",
                "widget",
                "input"
            ]
        ]
    };
    var _default$3e = radioRole;
    radioRole$1.default = _default$3e;
    var radiogroupRole$1 = {};
    Object.defineProperty(radiogroupRole$1, "__esModule", {
        value: true
    });
    radiogroupRole$1.default = void 0;
    var radiogroupRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {
            "aria-errormessage": null,
            "aria-invalid": null,
            "aria-readonly": null,
            "aria-required": null
        },
        relatedConcepts: [
            {
                concept: {
                    name: "list"
                },
                module: "ARIA"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [
            [
                "radio"
            ]
        ],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "widget",
                "composite",
                "select"
            ],
            [
                "roletype",
                "structure",
                "section",
                "group",
                "select"
            ]
        ]
    };
    var _default$3d = radiogroupRole;
    radiogroupRole$1.default = _default$3d;
    var regionRole$1 = {};
    Object.defineProperty(regionRole$1, "__esModule", {
        value: true
    });
    regionRole$1.default = void 0;
    var regionRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [
            {
                concept: {
                    attributes: [
                        {
                            constraints: [
                                "set"
                            ],
                            name: "aria-label"
                        }
                    ],
                    name: "section"
                },
                module: "HTML"
            },
            {
                concept: {
                    attributes: [
                        {
                            constraints: [
                                "set"
                            ],
                            name: "aria-labelledby"
                        }
                    ],
                    name: "section"
                },
                module: "HTML"
            },
            {
                concept: {
                    name: "Device Independence Glossart perceivable unit"
                }
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "section",
                "landmark"
            ]
        ]
    };
    var _default$3c = regionRole;
    regionRole$1.default = _default$3c;
    var rowRole$1 = {};
    Object.defineProperty(rowRole$1, "__esModule", {
        value: true
    });
    rowRole$1.default = void 0;
    var rowRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author",
            "contents"
        ],
        prohibitedProps: [],
        props: {
            "aria-colindex": null,
            "aria-expanded": null,
            "aria-level": null,
            "aria-posinset": null,
            "aria-rowindex": null,
            "aria-selected": null,
            "aria-setsize": null
        },
        relatedConcepts: [
            {
                concept: {
                    name: "tr"
                },
                module: "HTML"
            }
        ],
        requireContextRole: [
            "grid",
            "rowgroup",
            "table",
            "treegrid"
        ],
        requiredContextRole: [
            "grid",
            "rowgroup",
            "table",
            "treegrid"
        ],
        requiredOwnedElements: [
            [
                "cell"
            ],
            [
                "columnheader"
            ],
            [
                "gridcell"
            ],
            [
                "rowheader"
            ]
        ],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "section",
                "group"
            ],
            [
                "roletype",
                "widget"
            ]
        ]
    };
    var _default$3b = rowRole;
    rowRole$1.default = _default$3b;
    var rowgroupRole$1 = {};
    Object.defineProperty(rowgroupRole$1, "__esModule", {
        value: true
    });
    rowgroupRole$1.default = void 0;
    var rowgroupRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author",
            "contents"
        ],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [
            {
                concept: {
                    name: "tbody"
                },
                module: "HTML"
            },
            {
                concept: {
                    name: "tfoot"
                },
                module: "HTML"
            },
            {
                concept: {
                    name: "thead"
                },
                module: "HTML"
            }
        ],
        requireContextRole: [
            "grid",
            "table",
            "treegrid"
        ],
        requiredContextRole: [
            "grid",
            "table",
            "treegrid"
        ],
        requiredOwnedElements: [
            [
                "row"
            ]
        ],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure"
            ]
        ]
    };
    var _default$3a = rowgroupRole;
    rowgroupRole$1.default = _default$3a;
    var rowheaderRole$1 = {};
    Object.defineProperty(rowheaderRole$1, "__esModule", {
        value: true
    });
    rowheaderRole$1.default = void 0;
    var rowheaderRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author",
            "contents"
        ],
        prohibitedProps: [],
        props: {
            "aria-sort": null
        },
        relatedConcepts: [
            {
                concept: {
                    attributes: [
                        {
                            name: "scope",
                            value: "row"
                        }
                    ],
                    name: "th"
                },
                module: "HTML"
            },
            {
                concept: {
                    attributes: [
                        {
                            name: "scope",
                            value: "rowgroup"
                        }
                    ],
                    name: "th"
                },
                module: "HTML"
            }
        ],
        requireContextRole: [
            "row",
            "rowgroup"
        ],
        requiredContextRole: [
            "row",
            "rowgroup"
        ],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "section",
                "cell"
            ],
            [
                "roletype",
                "structure",
                "section",
                "cell",
                "gridcell"
            ],
            [
                "roletype",
                "widget",
                "gridcell"
            ],
            [
                "roletype",
                "structure",
                "sectionhead"
            ]
        ]
    };
    var _default$39 = rowheaderRole;
    rowheaderRole$1.default = _default$39;
    var scrollbarRole$1 = {};
    Object.defineProperty(scrollbarRole$1, "__esModule", {
        value: true
    });
    scrollbarRole$1.default = void 0;
    var scrollbarRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: true,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {
            "aria-disabled": null,
            "aria-valuetext": null,
            "aria-orientation": "vertical",
            "aria-valuemax": "100",
            "aria-valuemin": "0"
        },
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {
            "aria-controls": null,
            "aria-valuenow": null
        },
        superClass: [
            [
                "roletype",
                "structure",
                "range"
            ],
            [
                "roletype",
                "widget"
            ]
        ]
    };
    var _default$38 = scrollbarRole;
    scrollbarRole$1.default = _default$38;
    var searchRole$1 = {};
    Object.defineProperty(searchRole$1, "__esModule", {
        value: true
    });
    searchRole$1.default = void 0;
    var searchRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "section",
                "landmark"
            ]
        ]
    };
    var _default$37 = searchRole;
    searchRole$1.default = _default$37;
    var searchboxRole$1 = {};
    Object.defineProperty(searchboxRole$1, "__esModule", {
        value: true
    });
    searchboxRole$1.default = void 0;
    var searchboxRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [
            {
                concept: {
                    attributes: [
                        {
                            constraints: [
                                "undefined"
                            ],
                            name: "list"
                        },
                        {
                            name: "type",
                            value: "search"
                        }
                    ],
                    constraints: [
                        "the list attribute is not set"
                    ],
                    name: "input"
                },
                module: "HTML"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "widget",
                "input",
                "textbox"
            ]
        ]
    };
    var _default$36 = searchboxRole;
    searchboxRole$1.default = _default$36;
    var separatorRole$1 = {};
    Object.defineProperty(separatorRole$1, "__esModule", {
        value: true
    });
    separatorRole$1.default = void 0;
    var separatorRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: true,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {
            "aria-disabled": null,
            "aria-orientation": "horizontal",
            "aria-valuemax": "100",
            "aria-valuemin": "0",
            "aria-valuenow": null,
            "aria-valuetext": null
        },
        relatedConcepts: [
            {
                concept: {
                    name: "hr"
                },
                module: "HTML"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure"
            ]
        ]
    };
    var _default$35 = separatorRole;
    separatorRole$1.default = _default$35;
    var sliderRole$1 = {};
    Object.defineProperty(sliderRole$1, "__esModule", {
        value: true
    });
    sliderRole$1.default = void 0;
    var sliderRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: true,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {
            "aria-errormessage": null,
            "aria-haspopup": null,
            "aria-invalid": null,
            "aria-readonly": null,
            "aria-valuetext": null,
            "aria-orientation": "horizontal",
            "aria-valuemax": "100",
            "aria-valuemin": "0"
        },
        relatedConcepts: [
            {
                concept: {
                    attributes: [
                        {
                            name: "type",
                            value: "range"
                        }
                    ],
                    name: "input"
                },
                module: "HTML"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {
            "aria-valuenow": null
        },
        superClass: [
            [
                "roletype",
                "widget",
                "input"
            ],
            [
                "roletype",
                "structure",
                "range"
            ]
        ]
    };
    var _default$34 = sliderRole;
    sliderRole$1.default = _default$34;
    var spinbuttonRole$1 = {};
    Object.defineProperty(spinbuttonRole$1, "__esModule", {
        value: true
    });
    spinbuttonRole$1.default = void 0;
    var spinbuttonRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {
            "aria-errormessage": null,
            "aria-invalid": null,
            "aria-readonly": null,
            "aria-required": null,
            "aria-valuetext": null,
            "aria-valuenow": "0"
        },
        relatedConcepts: [
            {
                concept: {
                    attributes: [
                        {
                            name: "type",
                            value: "number"
                        }
                    ],
                    name: "input"
                },
                module: "HTML"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "widget",
                "composite"
            ],
            [
                "roletype",
                "widget",
                "input"
            ],
            [
                "roletype",
                "structure",
                "range"
            ]
        ]
    };
    var _default$33 = spinbuttonRole;
    spinbuttonRole$1.default = _default$33;
    var statusRole$1 = {};
    Object.defineProperty(statusRole$1, "__esModule", {
        value: true
    });
    statusRole$1.default = void 0;
    var statusRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {
            "aria-atomic": "true",
            "aria-live": "polite"
        },
        relatedConcepts: [
            {
                concept: {
                    name: "output"
                },
                module: "HTML"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "section"
            ]
        ]
    };
    var _default$32 = statusRole;
    statusRole$1.default = _default$32;
    var strongRole$1 = {};
    Object.defineProperty(strongRole$1, "__esModule", {
        value: true
    });
    strongRole$1.default = void 0;
    var strongRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "prohibited"
        ],
        prohibitedProps: [
            "aria-label",
            "aria-labelledby"
        ],
        props: {},
        relatedConcepts: [
            {
                concept: {
                    name: "strong"
                },
                module: "HTML"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "section"
            ]
        ]
    };
    var _default$31 = strongRole;
    strongRole$1.default = _default$31;
    var subscriptRole$1 = {};
    Object.defineProperty(subscriptRole$1, "__esModule", {
        value: true
    });
    subscriptRole$1.default = void 0;
    var subscriptRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "prohibited"
        ],
        prohibitedProps: [
            "aria-label",
            "aria-labelledby"
        ],
        props: {},
        relatedConcepts: [
            {
                concept: {
                    name: "sub"
                },
                module: "HTML"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "section"
            ]
        ]
    };
    var _default$30 = subscriptRole;
    subscriptRole$1.default = _default$30;
    var superscriptRole$1 = {};
    Object.defineProperty(superscriptRole$1, "__esModule", {
        value: true
    });
    superscriptRole$1.default = void 0;
    var superscriptRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "prohibited"
        ],
        prohibitedProps: [
            "aria-label",
            "aria-labelledby"
        ],
        props: {},
        relatedConcepts: [
            {
                concept: {
                    name: "sup"
                },
                module: "HTML"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "section"
            ]
        ]
    };
    var _default$2$ = superscriptRole;
    superscriptRole$1.default = _default$2$;
    var switchRole$1 = {};
    Object.defineProperty(switchRole$1, "__esModule", {
        value: true
    });
    switchRole$1.default = void 0;
    var switchRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: true,
        nameFrom: [
            "author",
            "contents"
        ],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [
            {
                concept: {
                    name: "button"
                },
                module: "ARIA"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {
            "aria-checked": null
        },
        superClass: [
            [
                "roletype",
                "widget",
                "input",
                "checkbox"
            ]
        ]
    };
    var _default$2_ = switchRole;
    switchRole$1.default = _default$2_;
    var tabRole$1 = {};
    Object.defineProperty(tabRole$1, "__esModule", {
        value: true
    });
    tabRole$1.default = void 0;
    var tabRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: true,
        nameFrom: [
            "author",
            "contents"
        ],
        prohibitedProps: [],
        props: {
            "aria-disabled": null,
            "aria-expanded": null,
            "aria-haspopup": null,
            "aria-posinset": null,
            "aria-setsize": null,
            "aria-selected": "false"
        },
        relatedConcepts: [],
        requireContextRole: [
            "tablist"
        ],
        requiredContextRole: [
            "tablist"
        ],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "sectionhead"
            ],
            [
                "roletype",
                "widget"
            ]
        ]
    };
    var _default$2Z = tabRole;
    tabRole$1.default = _default$2Z;
    var tableRole$1 = {};
    Object.defineProperty(tableRole$1, "__esModule", {
        value: true
    });
    tableRole$1.default = void 0;
    var tableRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {
            "aria-colcount": null,
            "aria-rowcount": null
        },
        relatedConcepts: [
            {
                concept: {
                    name: "table"
                },
                module: "HTML"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [
            [
                "row"
            ],
            [
                "row",
                "rowgroup"
            ]
        ],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "section"
            ]
        ]
    };
    var _default$2Y = tableRole;
    tableRole$1.default = _default$2Y;
    var tablistRole$1 = {};
    Object.defineProperty(tablistRole$1, "__esModule", {
        value: true
    });
    tablistRole$1.default = void 0;
    var tablistRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {
            "aria-level": null,
            "aria-multiselectable": null,
            "aria-orientation": "horizontal"
        },
        relatedConcepts: [
            {
                module: "DAISY",
                concept: {
                    name: "guide"
                }
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [
            [
                "tab"
            ]
        ],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "widget",
                "composite"
            ]
        ]
    };
    var _default$2X = tablistRole;
    tablistRole$1.default = _default$2X;
    var tabpanelRole$1 = {};
    Object.defineProperty(tabpanelRole$1, "__esModule", {
        value: true
    });
    tabpanelRole$1.default = void 0;
    var tabpanelRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "section"
            ]
        ]
    };
    var _default$2W = tabpanelRole;
    tabpanelRole$1.default = _default$2W;
    var termRole$1 = {};
    Object.defineProperty(termRole$1, "__esModule", {
        value: true
    });
    termRole$1.default = void 0;
    var termRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [
            {
                concept: {
                    name: "dfn"
                },
                module: "HTML"
            },
            {
                concept: {
                    name: "dt"
                },
                module: "HTML"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "section"
            ]
        ]
    };
    var _default$2V = termRole;
    termRole$1.default = _default$2V;
    var textboxRole$1 = {};
    Object.defineProperty(textboxRole$1, "__esModule", {
        value: true
    });
    textboxRole$1.default = void 0;
    var textboxRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {
            "aria-activedescendant": null,
            "aria-autocomplete": null,
            "aria-errormessage": null,
            "aria-haspopup": null,
            "aria-invalid": null,
            "aria-multiline": null,
            "aria-placeholder": null,
            "aria-readonly": null,
            "aria-required": null
        },
        relatedConcepts: [
            {
                concept: {
                    attributes: [
                        {
                            constraints: [
                                "undefined"
                            ],
                            name: "type"
                        },
                        {
                            constraints: [
                                "undefined"
                            ],
                            name: "list"
                        }
                    ],
                    constraints: [
                        "the list attribute is not set"
                    ],
                    name: "input"
                },
                module: "HTML"
            },
            {
                concept: {
                    attributes: [
                        {
                            constraints: [
                                "undefined"
                            ],
                            name: "list"
                        },
                        {
                            name: "type",
                            value: "email"
                        }
                    ],
                    constraints: [
                        "the list attribute is not set"
                    ],
                    name: "input"
                },
                module: "HTML"
            },
            {
                concept: {
                    attributes: [
                        {
                            constraints: [
                                "undefined"
                            ],
                            name: "list"
                        },
                        {
                            name: "type",
                            value: "tel"
                        }
                    ],
                    constraints: [
                        "the list attribute is not set"
                    ],
                    name: "input"
                },
                module: "HTML"
            },
            {
                concept: {
                    attributes: [
                        {
                            constraints: [
                                "undefined"
                            ],
                            name: "list"
                        },
                        {
                            name: "type",
                            value: "text"
                        }
                    ],
                    constraints: [
                        "the list attribute is not set"
                    ],
                    name: "input"
                },
                module: "HTML"
            },
            {
                concept: {
                    attributes: [
                        {
                            constraints: [
                                "undefined"
                            ],
                            name: "list"
                        },
                        {
                            name: "type",
                            value: "url"
                        }
                    ],
                    constraints: [
                        "the list attribute is not set"
                    ],
                    name: "input"
                },
                module: "HTML"
            },
            {
                concept: {
                    name: "input"
                },
                module: "XForms"
            },
            {
                concept: {
                    name: "textarea"
                },
                module: "HTML"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "widget",
                "input"
            ]
        ]
    };
    var _default$2U = textboxRole;
    textboxRole$1.default = _default$2U;
    var timeRole$1 = {};
    Object.defineProperty(timeRole$1, "__esModule", {
        value: true
    });
    timeRole$1.default = void 0;
    var timeRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [
            {
                concept: {
                    name: "time"
                },
                module: "HTML"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "section"
            ]
        ]
    };
    var _default$2T = timeRole;
    timeRole$1.default = _default$2T;
    var timerRole$1 = {};
    Object.defineProperty(timerRole$1, "__esModule", {
        value: true
    });
    timerRole$1.default = void 0;
    var timerRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "section",
                "status"
            ]
        ]
    };
    var _default$2S = timerRole;
    timerRole$1.default = _default$2S;
    var toolbarRole$1 = {};
    Object.defineProperty(toolbarRole$1, "__esModule", {
        value: true
    });
    toolbarRole$1.default = void 0;
    var toolbarRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {
            "aria-orientation": "horizontal"
        },
        relatedConcepts: [
            {
                concept: {
                    name: "menubar"
                },
                module: "ARIA"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "section",
                "group"
            ]
        ]
    };
    var _default$2R = toolbarRole;
    toolbarRole$1.default = _default$2R;
    var tooltipRole$1 = {};
    Object.defineProperty(tooltipRole$1, "__esModule", {
        value: true
    });
    tooltipRole$1.default = void 0;
    var tooltipRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author",
            "contents"
        ],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "section"
            ]
        ]
    };
    var _default$2Q = tooltipRole;
    tooltipRole$1.default = _default$2Q;
    var treeRole$1 = {};
    Object.defineProperty(treeRole$1, "__esModule", {
        value: true
    });
    treeRole$1.default = void 0;
    var treeRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {
            "aria-errormessage": null,
            "aria-invalid": null,
            "aria-multiselectable": null,
            "aria-required": null,
            "aria-orientation": "vertical"
        },
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [
            [
                "treeitem",
                "group"
            ],
            [
                "treeitem"
            ]
        ],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "widget",
                "composite",
                "select"
            ],
            [
                "roletype",
                "structure",
                "section",
                "group",
                "select"
            ]
        ]
    };
    var _default$2P = treeRole;
    treeRole$1.default = _default$2P;
    var treegridRole$1 = {};
    Object.defineProperty(treegridRole$1, "__esModule", {
        value: true
    });
    treegridRole$1.default = void 0;
    var treegridRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [
            [
                "row"
            ],
            [
                "row",
                "rowgroup"
            ]
        ],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "widget",
                "composite",
                "grid"
            ],
            [
                "roletype",
                "structure",
                "section",
                "table",
                "grid"
            ],
            [
                "roletype",
                "widget",
                "composite",
                "select",
                "tree"
            ],
            [
                "roletype",
                "structure",
                "section",
                "group",
                "select",
                "tree"
            ]
        ]
    };
    var _default$2O = treegridRole;
    treegridRole$1.default = _default$2O;
    var treeitemRole$1 = {};
    Object.defineProperty(treeitemRole$1, "__esModule", {
        value: true
    });
    treeitemRole$1.default = void 0;
    var treeitemRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author",
            "contents"
        ],
        prohibitedProps: [],
        props: {
            "aria-expanded": null,
            "aria-haspopup": null
        },
        relatedConcepts: [],
        requireContextRole: [
            "group",
            "tree"
        ],
        requiredContextRole: [
            "group",
            "tree"
        ],
        requiredOwnedElements: [],
        requiredProps: {
            "aria-selected": null
        },
        superClass: [
            [
                "roletype",
                "structure",
                "section",
                "listitem"
            ],
            [
                "roletype",
                "widget",
                "input",
                "option"
            ]
        ]
    };
    var _default$2N = treeitemRole;
    treeitemRole$1.default = _default$2N;
    Object.defineProperty(ariaLiteralRoles$1, "__esModule", {
        value: true
    });
    ariaLiteralRoles$1.default = void 0;
    var _alertRole = _interopRequireDefault$c(alertRole$1);
    var _alertdialogRole = _interopRequireDefault$c(alertdialogRole$1);
    var _applicationRole = _interopRequireDefault$c(applicationRole$1);
    var _articleRole = _interopRequireDefault$c(articleRole$1);
    var _bannerRole = _interopRequireDefault$c(bannerRole$1);
    var _blockquoteRole = _interopRequireDefault$c(blockquoteRole$1);
    var _buttonRole = _interopRequireDefault$c(buttonRole$1);
    var _captionRole = _interopRequireDefault$c(captionRole$1);
    var _cellRole = _interopRequireDefault$c(cellRole$1);
    var _checkboxRole = _interopRequireDefault$c(checkboxRole$1);
    var _codeRole = _interopRequireDefault$c(codeRole$1);
    var _columnheaderRole = _interopRequireDefault$c(columnheaderRole$1);
    var _comboboxRole = _interopRequireDefault$c(comboboxRole$1);
    var _complementaryRole = _interopRequireDefault$c(complementaryRole$1);
    var _contentinfoRole = _interopRequireDefault$c(contentinfoRole$1);
    var _definitionRole = _interopRequireDefault$c(definitionRole$1);
    var _deletionRole = _interopRequireDefault$c(deletionRole$1);
    var _dialogRole = _interopRequireDefault$c(dialogRole$1);
    var _directoryRole = _interopRequireDefault$c(directoryRole$1);
    var _documentRole = _interopRequireDefault$c(documentRole$1);
    var _emphasisRole = _interopRequireDefault$c(emphasisRole$1);
    var _feedRole = _interopRequireDefault$c(feedRole$1);
    var _figureRole = _interopRequireDefault$c(figureRole$1);
    var _formRole = _interopRequireDefault$c(formRole$1);
    var _genericRole = _interopRequireDefault$c(genericRole$1);
    var _gridRole = _interopRequireDefault$c(gridRole$1);
    var _gridcellRole = _interopRequireDefault$c(gridcellRole$1);
    var _groupRole = _interopRequireDefault$c(groupRole$1);
    var _headingRole = _interopRequireDefault$c(headingRole$1);
    var _imgRole = _interopRequireDefault$c(imgRole$1);
    var _insertionRole = _interopRequireDefault$c(insertionRole$1);
    var _linkRole = _interopRequireDefault$c(linkRole$1);
    var _listRole = _interopRequireDefault$c(listRole$1);
    var _listboxRole = _interopRequireDefault$c(listboxRole$1);
    var _listitemRole = _interopRequireDefault$c(listitemRole$1);
    var _logRole = _interopRequireDefault$c(logRole$1);
    var _mainRole = _interopRequireDefault$c(mainRole$1);
    var _markRole = _interopRequireDefault$c(markRole$1);
    var _marqueeRole = _interopRequireDefault$c(marqueeRole$1);
    var _mathRole = _interopRequireDefault$c(mathRole$1);
    var _menuRole = _interopRequireDefault$c(menuRole$1);
    var _menubarRole = _interopRequireDefault$c(menubarRole$1);
    var _menuitemRole = _interopRequireDefault$c(menuitemRole$1);
    var _menuitemcheckboxRole = _interopRequireDefault$c(menuitemcheckboxRole$1);
    var _menuitemradioRole = _interopRequireDefault$c(menuitemradioRole$1);
    var _meterRole = _interopRequireDefault$c(meterRole$1);
    var _navigationRole = _interopRequireDefault$c(navigationRole$1);
    var _noneRole = _interopRequireDefault$c(noneRole$1);
    var _noteRole = _interopRequireDefault$c(noteRole$1);
    var _optionRole = _interopRequireDefault$c(optionRole$1);
    var _paragraphRole = _interopRequireDefault$c(paragraphRole$1);
    var _presentationRole = _interopRequireDefault$c(presentationRole$1);
    var _progressbarRole = _interopRequireDefault$c(progressbarRole$1);
    var _radioRole = _interopRequireDefault$c(radioRole$1);
    var _radiogroupRole = _interopRequireDefault$c(radiogroupRole$1);
    var _regionRole = _interopRequireDefault$c(regionRole$1);
    var _rowRole = _interopRequireDefault$c(rowRole$1);
    var _rowgroupRole = _interopRequireDefault$c(rowgroupRole$1);
    var _rowheaderRole = _interopRequireDefault$c(rowheaderRole$1);
    var _scrollbarRole = _interopRequireDefault$c(scrollbarRole$1);
    var _searchRole = _interopRequireDefault$c(searchRole$1);
    var _searchboxRole = _interopRequireDefault$c(searchboxRole$1);
    var _separatorRole = _interopRequireDefault$c(separatorRole$1);
    var _sliderRole = _interopRequireDefault$c(sliderRole$1);
    var _spinbuttonRole = _interopRequireDefault$c(spinbuttonRole$1);
    var _statusRole = _interopRequireDefault$c(statusRole$1);
    var _strongRole = _interopRequireDefault$c(strongRole$1);
    var _subscriptRole = _interopRequireDefault$c(subscriptRole$1);
    var _superscriptRole = _interopRequireDefault$c(superscriptRole$1);
    var _switchRole = _interopRequireDefault$c(switchRole$1);
    var _tabRole = _interopRequireDefault$c(tabRole$1);
    var _tableRole = _interopRequireDefault$c(tableRole$1);
    var _tablistRole = _interopRequireDefault$c(tablistRole$1);
    var _tabpanelRole = _interopRequireDefault$c(tabpanelRole$1);
    var _termRole = _interopRequireDefault$c(termRole$1);
    var _textboxRole = _interopRequireDefault$c(textboxRole$1);
    var _timeRole = _interopRequireDefault$c(timeRole$1);
    var _timerRole = _interopRequireDefault$c(timerRole$1);
    var _toolbarRole = _interopRequireDefault$c(toolbarRole$1);
    var _tooltipRole = _interopRequireDefault$c(tooltipRole$1);
    var _treeRole = _interopRequireDefault$c(treeRole$1);
    var _treegridRole = _interopRequireDefault$c(treegridRole$1);
    var _treeitemRole = _interopRequireDefault$c(treeitemRole$1);
    function _interopRequireDefault$c(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    var ariaLiteralRoles = [
        [
            "alert",
            _alertRole.default
        ],
        [
            "alertdialog",
            _alertdialogRole.default
        ],
        [
            "application",
            _applicationRole.default
        ],
        [
            "article",
            _articleRole.default
        ],
        [
            "banner",
            _bannerRole.default
        ],
        [
            "blockquote",
            _blockquoteRole.default
        ],
        [
            "button",
            _buttonRole.default
        ],
        [
            "caption",
            _captionRole.default
        ],
        [
            "cell",
            _cellRole.default
        ],
        [
            "checkbox",
            _checkboxRole.default
        ],
        [
            "code",
            _codeRole.default
        ],
        [
            "columnheader",
            _columnheaderRole.default
        ],
        [
            "combobox",
            _comboboxRole.default
        ],
        [
            "complementary",
            _complementaryRole.default
        ],
        [
            "contentinfo",
            _contentinfoRole.default
        ],
        [
            "definition",
            _definitionRole.default
        ],
        [
            "deletion",
            _deletionRole.default
        ],
        [
            "dialog",
            _dialogRole.default
        ],
        [
            "directory",
            _directoryRole.default
        ],
        [
            "document",
            _documentRole.default
        ],
        [
            "emphasis",
            _emphasisRole.default
        ],
        [
            "feed",
            _feedRole.default
        ],
        [
            "figure",
            _figureRole.default
        ],
        [
            "form",
            _formRole.default
        ],
        [
            "generic",
            _genericRole.default
        ],
        [
            "grid",
            _gridRole.default
        ],
        [
            "gridcell",
            _gridcellRole.default
        ],
        [
            "group",
            _groupRole.default
        ],
        [
            "heading",
            _headingRole.default
        ],
        [
            "img",
            _imgRole.default
        ],
        [
            "insertion",
            _insertionRole.default
        ],
        [
            "link",
            _linkRole.default
        ],
        [
            "list",
            _listRole.default
        ],
        [
            "listbox",
            _listboxRole.default
        ],
        [
            "listitem",
            _listitemRole.default
        ],
        [
            "log",
            _logRole.default
        ],
        [
            "main",
            _mainRole.default
        ],
        [
            "mark",
            _markRole.default
        ],
        [
            "marquee",
            _marqueeRole.default
        ],
        [
            "math",
            _mathRole.default
        ],
        [
            "menu",
            _menuRole.default
        ],
        [
            "menubar",
            _menubarRole.default
        ],
        [
            "menuitem",
            _menuitemRole.default
        ],
        [
            "menuitemcheckbox",
            _menuitemcheckboxRole.default
        ],
        [
            "menuitemradio",
            _menuitemradioRole.default
        ],
        [
            "meter",
            _meterRole.default
        ],
        [
            "navigation",
            _navigationRole.default
        ],
        [
            "none",
            _noneRole.default
        ],
        [
            "note",
            _noteRole.default
        ],
        [
            "option",
            _optionRole.default
        ],
        [
            "paragraph",
            _paragraphRole.default
        ],
        [
            "presentation",
            _presentationRole.default
        ],
        [
            "progressbar",
            _progressbarRole.default
        ],
        [
            "radio",
            _radioRole.default
        ],
        [
            "radiogroup",
            _radiogroupRole.default
        ],
        [
            "region",
            _regionRole.default
        ],
        [
            "row",
            _rowRole.default
        ],
        [
            "rowgroup",
            _rowgroupRole.default
        ],
        [
            "rowheader",
            _rowheaderRole.default
        ],
        [
            "scrollbar",
            _scrollbarRole.default
        ],
        [
            "search",
            _searchRole.default
        ],
        [
            "searchbox",
            _searchboxRole.default
        ],
        [
            "separator",
            _separatorRole.default
        ],
        [
            "slider",
            _sliderRole.default
        ],
        [
            "spinbutton",
            _spinbuttonRole.default
        ],
        [
            "status",
            _statusRole.default
        ],
        [
            "strong",
            _strongRole.default
        ],
        [
            "subscript",
            _subscriptRole.default
        ],
        [
            "superscript",
            _superscriptRole.default
        ],
        [
            "switch",
            _switchRole.default
        ],
        [
            "tab",
            _tabRole.default
        ],
        [
            "table",
            _tableRole.default
        ],
        [
            "tablist",
            _tablistRole.default
        ],
        [
            "tabpanel",
            _tabpanelRole.default
        ],
        [
            "term",
            _termRole.default
        ],
        [
            "textbox",
            _textboxRole.default
        ],
        [
            "time",
            _timeRole.default
        ],
        [
            "timer",
            _timerRole.default
        ],
        [
            "toolbar",
            _toolbarRole.default
        ],
        [
            "tooltip",
            _tooltipRole.default
        ],
        [
            "tree",
            _treeRole.default
        ],
        [
            "treegrid",
            _treegridRole.default
        ],
        [
            "treeitem",
            _treeitemRole.default
        ]
    ];
    var _default$2M = ariaLiteralRoles;
    ariaLiteralRoles$1.default = _default$2M;
    var ariaDpubRoles$1 = {};
    var docAbstractRole$1 = {};
    Object.defineProperty(docAbstractRole$1, "__esModule", {
        value: true
    });
    docAbstractRole$1.default = void 0;
    var docAbstractRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {
            "aria-disabled": null,
            "aria-errormessage": null,
            "aria-expanded": null,
            "aria-haspopup": null,
            "aria-invalid": null
        },
        relatedConcepts: [
            {
                concept: {
                    name: "abstract [EPUB-SSV]"
                },
                module: "EPUB"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "section"
            ]
        ]
    };
    var _default$2L = docAbstractRole;
    docAbstractRole$1.default = _default$2L;
    var docAcknowledgmentsRole$1 = {};
    Object.defineProperty(docAcknowledgmentsRole$1, "__esModule", {
        value: true
    });
    docAcknowledgmentsRole$1.default = void 0;
    var docAcknowledgmentsRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {
            "aria-disabled": null,
            "aria-errormessage": null,
            "aria-expanded": null,
            "aria-haspopup": null,
            "aria-invalid": null
        },
        relatedConcepts: [
            {
                concept: {
                    name: "acknowledgments [EPUB-SSV]"
                },
                module: "EPUB"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "section",
                "landmark"
            ]
        ]
    };
    var _default$2K = docAcknowledgmentsRole;
    docAcknowledgmentsRole$1.default = _default$2K;
    var docAfterwordRole$1 = {};
    Object.defineProperty(docAfterwordRole$1, "__esModule", {
        value: true
    });
    docAfterwordRole$1.default = void 0;
    var docAfterwordRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {
            "aria-disabled": null,
            "aria-errormessage": null,
            "aria-expanded": null,
            "aria-haspopup": null,
            "aria-invalid": null
        },
        relatedConcepts: [
            {
                concept: {
                    name: "afterword [EPUB-SSV]"
                },
                module: "EPUB"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "section",
                "landmark"
            ]
        ]
    };
    var _default$2J = docAfterwordRole;
    docAfterwordRole$1.default = _default$2J;
    var docAppendixRole$1 = {};
    Object.defineProperty(docAppendixRole$1, "__esModule", {
        value: true
    });
    docAppendixRole$1.default = void 0;
    var docAppendixRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {
            "aria-disabled": null,
            "aria-errormessage": null,
            "aria-expanded": null,
            "aria-haspopup": null,
            "aria-invalid": null
        },
        relatedConcepts: [
            {
                concept: {
                    name: "appendix [EPUB-SSV]"
                },
                module: "EPUB"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "section",
                "landmark"
            ]
        ]
    };
    var _default$2I = docAppendixRole;
    docAppendixRole$1.default = _default$2I;
    var docBacklinkRole$1 = {};
    Object.defineProperty(docBacklinkRole$1, "__esModule", {
        value: true
    });
    docBacklinkRole$1.default = void 0;
    var docBacklinkRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author",
            "contents"
        ],
        prohibitedProps: [],
        props: {
            "aria-errormessage": null,
            "aria-invalid": null
        },
        relatedConcepts: [
            {
                concept: {
                    name: "referrer [EPUB-SSV]"
                },
                module: "EPUB"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "widget",
                "command",
                "link"
            ]
        ]
    };
    var _default$2H = docBacklinkRole;
    docBacklinkRole$1.default = _default$2H;
    var docBiblioentryRole$1 = {};
    Object.defineProperty(docBiblioentryRole$1, "__esModule", {
        value: true
    });
    docBiblioentryRole$1.default = void 0;
    var docBiblioentryRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {
            "aria-disabled": null,
            "aria-errormessage": null,
            "aria-expanded": null,
            "aria-haspopup": null,
            "aria-invalid": null
        },
        relatedConcepts: [
            {
                concept: {
                    name: "EPUB biblioentry [EPUB-SSV]"
                },
                module: "EPUB"
            }
        ],
        requireContextRole: [
            "doc-bibliography"
        ],
        requiredContextRole: [
            "doc-bibliography"
        ],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "section",
                "listitem"
            ]
        ]
    };
    var _default$2G = docBiblioentryRole;
    docBiblioentryRole$1.default = _default$2G;
    var docBibliographyRole$1 = {};
    Object.defineProperty(docBibliographyRole$1, "__esModule", {
        value: true
    });
    docBibliographyRole$1.default = void 0;
    var docBibliographyRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {
            "aria-disabled": null,
            "aria-errormessage": null,
            "aria-expanded": null,
            "aria-haspopup": null,
            "aria-invalid": null
        },
        relatedConcepts: [
            {
                concept: {
                    name: "bibliography [EPUB-SSV]"
                },
                module: "EPUB"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [
            [
                "doc-biblioentry"
            ]
        ],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "section",
                "landmark"
            ]
        ]
    };
    var _default$2F = docBibliographyRole;
    docBibliographyRole$1.default = _default$2F;
    var docBibliorefRole$1 = {};
    Object.defineProperty(docBibliorefRole$1, "__esModule", {
        value: true
    });
    docBibliorefRole$1.default = void 0;
    var docBibliorefRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author",
            "contents"
        ],
        prohibitedProps: [],
        props: {
            "aria-errormessage": null,
            "aria-invalid": null
        },
        relatedConcepts: [
            {
                concept: {
                    name: "biblioref [EPUB-SSV]"
                },
                module: "EPUB"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "widget",
                "command",
                "link"
            ]
        ]
    };
    var _default$2E = docBibliorefRole;
    docBibliorefRole$1.default = _default$2E;
    var docChapterRole$1 = {};
    Object.defineProperty(docChapterRole$1, "__esModule", {
        value: true
    });
    docChapterRole$1.default = void 0;
    var docChapterRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {
            "aria-disabled": null,
            "aria-errormessage": null,
            "aria-expanded": null,
            "aria-haspopup": null,
            "aria-invalid": null
        },
        relatedConcepts: [
            {
                concept: {
                    name: "chapter [EPUB-SSV]"
                },
                module: "EPUB"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "section",
                "landmark"
            ]
        ]
    };
    var _default$2D = docChapterRole;
    docChapterRole$1.default = _default$2D;
    var docColophonRole$1 = {};
    Object.defineProperty(docColophonRole$1, "__esModule", {
        value: true
    });
    docColophonRole$1.default = void 0;
    var docColophonRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {
            "aria-disabled": null,
            "aria-errormessage": null,
            "aria-expanded": null,
            "aria-haspopup": null,
            "aria-invalid": null
        },
        relatedConcepts: [
            {
                concept: {
                    name: "colophon [EPUB-SSV]"
                },
                module: "EPUB"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "section"
            ]
        ]
    };
    var _default$2C = docColophonRole;
    docColophonRole$1.default = _default$2C;
    var docConclusionRole$1 = {};
    Object.defineProperty(docConclusionRole$1, "__esModule", {
        value: true
    });
    docConclusionRole$1.default = void 0;
    var docConclusionRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {
            "aria-disabled": null,
            "aria-errormessage": null,
            "aria-expanded": null,
            "aria-haspopup": null,
            "aria-invalid": null
        },
        relatedConcepts: [
            {
                concept: {
                    name: "conclusion [EPUB-SSV]"
                },
                module: "EPUB"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "section",
                "landmark"
            ]
        ]
    };
    var _default$2B = docConclusionRole;
    docConclusionRole$1.default = _default$2B;
    var docCoverRole$1 = {};
    Object.defineProperty(docCoverRole$1, "__esModule", {
        value: true
    });
    docCoverRole$1.default = void 0;
    var docCoverRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {
            "aria-disabled": null,
            "aria-errormessage": null,
            "aria-expanded": null,
            "aria-haspopup": null,
            "aria-invalid": null
        },
        relatedConcepts: [
            {
                concept: {
                    name: "cover [EPUB-SSV]"
                },
                module: "EPUB"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "section",
                "img"
            ]
        ]
    };
    var _default$2A = docCoverRole;
    docCoverRole$1.default = _default$2A;
    var docCreditRole$1 = {};
    Object.defineProperty(docCreditRole$1, "__esModule", {
        value: true
    });
    docCreditRole$1.default = void 0;
    var docCreditRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {
            "aria-disabled": null,
            "aria-errormessage": null,
            "aria-expanded": null,
            "aria-haspopup": null,
            "aria-invalid": null
        },
        relatedConcepts: [
            {
                concept: {
                    name: "credit [EPUB-SSV]"
                },
                module: "EPUB"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "section"
            ]
        ]
    };
    var _default$2z = docCreditRole;
    docCreditRole$1.default = _default$2z;
    var docCreditsRole$1 = {};
    Object.defineProperty(docCreditsRole$1, "__esModule", {
        value: true
    });
    docCreditsRole$1.default = void 0;
    var docCreditsRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {
            "aria-disabled": null,
            "aria-errormessage": null,
            "aria-expanded": null,
            "aria-haspopup": null,
            "aria-invalid": null
        },
        relatedConcepts: [
            {
                concept: {
                    name: "credits [EPUB-SSV]"
                },
                module: "EPUB"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "section",
                "landmark"
            ]
        ]
    };
    var _default$2y = docCreditsRole;
    docCreditsRole$1.default = _default$2y;
    var docDedicationRole$1 = {};
    Object.defineProperty(docDedicationRole$1, "__esModule", {
        value: true
    });
    docDedicationRole$1.default = void 0;
    var docDedicationRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {
            "aria-disabled": null,
            "aria-errormessage": null,
            "aria-expanded": null,
            "aria-haspopup": null,
            "aria-invalid": null
        },
        relatedConcepts: [
            {
                concept: {
                    name: "dedication [EPUB-SSV]"
                },
                module: "EPUB"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "section"
            ]
        ]
    };
    var _default$2x = docDedicationRole;
    docDedicationRole$1.default = _default$2x;
    var docEndnoteRole$1 = {};
    Object.defineProperty(docEndnoteRole$1, "__esModule", {
        value: true
    });
    docEndnoteRole$1.default = void 0;
    var docEndnoteRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {
            "aria-disabled": null,
            "aria-errormessage": null,
            "aria-expanded": null,
            "aria-haspopup": null,
            "aria-invalid": null
        },
        relatedConcepts: [
            {
                concept: {
                    name: "rearnote [EPUB-SSV]"
                },
                module: "EPUB"
            }
        ],
        requireContextRole: [
            "doc-endnotes"
        ],
        requiredContextRole: [
            "doc-endnotes"
        ],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "section",
                "listitem"
            ]
        ]
    };
    var _default$2w = docEndnoteRole;
    docEndnoteRole$1.default = _default$2w;
    var docEndnotesRole$1 = {};
    Object.defineProperty(docEndnotesRole$1, "__esModule", {
        value: true
    });
    docEndnotesRole$1.default = void 0;
    var docEndnotesRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {
            "aria-disabled": null,
            "aria-errormessage": null,
            "aria-expanded": null,
            "aria-haspopup": null,
            "aria-invalid": null
        },
        relatedConcepts: [
            {
                concept: {
                    name: "rearnotes [EPUB-SSV]"
                },
                module: "EPUB"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [
            [
                "doc-endnote"
            ]
        ],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "section",
                "landmark"
            ]
        ]
    };
    var _default$2v = docEndnotesRole;
    docEndnotesRole$1.default = _default$2v;
    var docEpigraphRole$1 = {};
    Object.defineProperty(docEpigraphRole$1, "__esModule", {
        value: true
    });
    docEpigraphRole$1.default = void 0;
    var docEpigraphRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {
            "aria-disabled": null,
            "aria-errormessage": null,
            "aria-expanded": null,
            "aria-haspopup": null,
            "aria-invalid": null
        },
        relatedConcepts: [
            {
                concept: {
                    name: "epigraph [EPUB-SSV]"
                },
                module: "EPUB"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "section"
            ]
        ]
    };
    var _default$2u = docEpigraphRole;
    docEpigraphRole$1.default = _default$2u;
    var docEpilogueRole$1 = {};
    Object.defineProperty(docEpilogueRole$1, "__esModule", {
        value: true
    });
    docEpilogueRole$1.default = void 0;
    var docEpilogueRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {
            "aria-disabled": null,
            "aria-errormessage": null,
            "aria-expanded": null,
            "aria-haspopup": null,
            "aria-invalid": null
        },
        relatedConcepts: [
            {
                concept: {
                    name: "epilogue [EPUB-SSV]"
                },
                module: "EPUB"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "section",
                "landmark"
            ]
        ]
    };
    var _default$2t = docEpilogueRole;
    docEpilogueRole$1.default = _default$2t;
    var docErrataRole$1 = {};
    Object.defineProperty(docErrataRole$1, "__esModule", {
        value: true
    });
    docErrataRole$1.default = void 0;
    var docErrataRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {
            "aria-disabled": null,
            "aria-errormessage": null,
            "aria-expanded": null,
            "aria-haspopup": null,
            "aria-invalid": null
        },
        relatedConcepts: [
            {
                concept: {
                    name: "errata [EPUB-SSV]"
                },
                module: "EPUB"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "section",
                "landmark"
            ]
        ]
    };
    var _default$2s = docErrataRole;
    docErrataRole$1.default = _default$2s;
    var docExampleRole$1 = {};
    Object.defineProperty(docExampleRole$1, "__esModule", {
        value: true
    });
    docExampleRole$1.default = void 0;
    var docExampleRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {
            "aria-disabled": null,
            "aria-errormessage": null,
            "aria-expanded": null,
            "aria-haspopup": null,
            "aria-invalid": null
        },
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "section"
            ]
        ]
    };
    var _default$2r = docExampleRole;
    docExampleRole$1.default = _default$2r;
    var docFootnoteRole$1 = {};
    Object.defineProperty(docFootnoteRole$1, "__esModule", {
        value: true
    });
    docFootnoteRole$1.default = void 0;
    var docFootnoteRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {
            "aria-disabled": null,
            "aria-errormessage": null,
            "aria-expanded": null,
            "aria-haspopup": null,
            "aria-invalid": null
        },
        relatedConcepts: [
            {
                concept: {
                    name: "footnote [EPUB-SSV]"
                },
                module: "EPUB"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "section"
            ]
        ]
    };
    var _default$2q = docFootnoteRole;
    docFootnoteRole$1.default = _default$2q;
    var docForewordRole$1 = {};
    Object.defineProperty(docForewordRole$1, "__esModule", {
        value: true
    });
    docForewordRole$1.default = void 0;
    var docForewordRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {
            "aria-disabled": null,
            "aria-errormessage": null,
            "aria-expanded": null,
            "aria-haspopup": null,
            "aria-invalid": null
        },
        relatedConcepts: [
            {
                concept: {
                    name: "foreword [EPUB-SSV]"
                },
                module: "EPUB"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "section",
                "landmark"
            ]
        ]
    };
    var _default$2p = docForewordRole;
    docForewordRole$1.default = _default$2p;
    var docGlossaryRole$1 = {};
    Object.defineProperty(docGlossaryRole$1, "__esModule", {
        value: true
    });
    docGlossaryRole$1.default = void 0;
    var docGlossaryRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {
            "aria-disabled": null,
            "aria-errormessage": null,
            "aria-expanded": null,
            "aria-haspopup": null,
            "aria-invalid": null
        },
        relatedConcepts: [
            {
                concept: {
                    name: "glossary [EPUB-SSV]"
                },
                module: "EPUB"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [
            [
                "definition"
            ],
            [
                "term"
            ]
        ],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "section",
                "landmark"
            ]
        ]
    };
    var _default$2o = docGlossaryRole;
    docGlossaryRole$1.default = _default$2o;
    var docGlossrefRole$1 = {};
    Object.defineProperty(docGlossrefRole$1, "__esModule", {
        value: true
    });
    docGlossrefRole$1.default = void 0;
    var docGlossrefRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author",
            "contents"
        ],
        prohibitedProps: [],
        props: {
            "aria-errormessage": null,
            "aria-invalid": null
        },
        relatedConcepts: [
            {
                concept: {
                    name: "glossref [EPUB-SSV]"
                },
                module: "EPUB"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "widget",
                "command",
                "link"
            ]
        ]
    };
    var _default$2n = docGlossrefRole;
    docGlossrefRole$1.default = _default$2n;
    var docIndexRole$1 = {};
    Object.defineProperty(docIndexRole$1, "__esModule", {
        value: true
    });
    docIndexRole$1.default = void 0;
    var docIndexRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {
            "aria-disabled": null,
            "aria-errormessage": null,
            "aria-expanded": null,
            "aria-haspopup": null,
            "aria-invalid": null
        },
        relatedConcepts: [
            {
                concept: {
                    name: "index [EPUB-SSV]"
                },
                module: "EPUB"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "section",
                "landmark",
                "navigation"
            ]
        ]
    };
    var _default$2m = docIndexRole;
    docIndexRole$1.default = _default$2m;
    var docIntroductionRole$1 = {};
    Object.defineProperty(docIntroductionRole$1, "__esModule", {
        value: true
    });
    docIntroductionRole$1.default = void 0;
    var docIntroductionRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {
            "aria-disabled": null,
            "aria-errormessage": null,
            "aria-expanded": null,
            "aria-haspopup": null,
            "aria-invalid": null
        },
        relatedConcepts: [
            {
                concept: {
                    name: "introduction [EPUB-SSV]"
                },
                module: "EPUB"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "section",
                "landmark"
            ]
        ]
    };
    var _default$2l = docIntroductionRole;
    docIntroductionRole$1.default = _default$2l;
    var docNoterefRole$1 = {};
    Object.defineProperty(docNoterefRole$1, "__esModule", {
        value: true
    });
    docNoterefRole$1.default = void 0;
    var docNoterefRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author",
            "contents"
        ],
        prohibitedProps: [],
        props: {
            "aria-errormessage": null,
            "aria-invalid": null
        },
        relatedConcepts: [
            {
                concept: {
                    name: "noteref [EPUB-SSV]"
                },
                module: "EPUB"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "widget",
                "command",
                "link"
            ]
        ]
    };
    var _default$2k = docNoterefRole;
    docNoterefRole$1.default = _default$2k;
    var docNoticeRole$1 = {};
    Object.defineProperty(docNoticeRole$1, "__esModule", {
        value: true
    });
    docNoticeRole$1.default = void 0;
    var docNoticeRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {
            "aria-disabled": null,
            "aria-errormessage": null,
            "aria-expanded": null,
            "aria-haspopup": null,
            "aria-invalid": null
        },
        relatedConcepts: [
            {
                concept: {
                    name: "notice [EPUB-SSV]"
                },
                module: "EPUB"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "section",
                "note"
            ]
        ]
    };
    var _default$2j = docNoticeRole;
    docNoticeRole$1.default = _default$2j;
    var docPagebreakRole$1 = {};
    Object.defineProperty(docPagebreakRole$1, "__esModule", {
        value: true
    });
    docPagebreakRole$1.default = void 0;
    var docPagebreakRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: true,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {
            "aria-errormessage": null,
            "aria-expanded": null,
            "aria-haspopup": null,
            "aria-invalid": null
        },
        relatedConcepts: [
            {
                concept: {
                    name: "pagebreak [EPUB-SSV]"
                },
                module: "EPUB"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "separator"
            ]
        ]
    };
    var _default$2i = docPagebreakRole;
    docPagebreakRole$1.default = _default$2i;
    var docPagelistRole$1 = {};
    Object.defineProperty(docPagelistRole$1, "__esModule", {
        value: true
    });
    docPagelistRole$1.default = void 0;
    var docPagelistRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {
            "aria-disabled": null,
            "aria-errormessage": null,
            "aria-expanded": null,
            "aria-haspopup": null,
            "aria-invalid": null
        },
        relatedConcepts: [
            {
                concept: {
                    name: "page-list [EPUB-SSV]"
                },
                module: "EPUB"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "section",
                "landmark",
                "navigation"
            ]
        ]
    };
    var _default$2h = docPagelistRole;
    docPagelistRole$1.default = _default$2h;
    var docPartRole$1 = {};
    Object.defineProperty(docPartRole$1, "__esModule", {
        value: true
    });
    docPartRole$1.default = void 0;
    var docPartRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {
            "aria-disabled": null,
            "aria-errormessage": null,
            "aria-expanded": null,
            "aria-haspopup": null,
            "aria-invalid": null
        },
        relatedConcepts: [
            {
                concept: {
                    name: "part [EPUB-SSV]"
                },
                module: "EPUB"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "section",
                "landmark"
            ]
        ]
    };
    var _default$2g = docPartRole;
    docPartRole$1.default = _default$2g;
    var docPrefaceRole$1 = {};
    Object.defineProperty(docPrefaceRole$1, "__esModule", {
        value: true
    });
    docPrefaceRole$1.default = void 0;
    var docPrefaceRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {
            "aria-disabled": null,
            "aria-errormessage": null,
            "aria-expanded": null,
            "aria-haspopup": null,
            "aria-invalid": null
        },
        relatedConcepts: [
            {
                concept: {
                    name: "preface [EPUB-SSV]"
                },
                module: "EPUB"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "section",
                "landmark"
            ]
        ]
    };
    var _default$2f = docPrefaceRole;
    docPrefaceRole$1.default = _default$2f;
    var docPrologueRole$1 = {};
    Object.defineProperty(docPrologueRole$1, "__esModule", {
        value: true
    });
    docPrologueRole$1.default = void 0;
    var docPrologueRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {
            "aria-disabled": null,
            "aria-errormessage": null,
            "aria-expanded": null,
            "aria-haspopup": null,
            "aria-invalid": null
        },
        relatedConcepts: [
            {
                concept: {
                    name: "prologue [EPUB-SSV]"
                },
                module: "EPUB"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "section",
                "landmark"
            ]
        ]
    };
    var _default$2e = docPrologueRole;
    docPrologueRole$1.default = _default$2e;
    var docPullquoteRole$1 = {};
    Object.defineProperty(docPullquoteRole$1, "__esModule", {
        value: true
    });
    docPullquoteRole$1.default = void 0;
    var docPullquoteRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {},
        relatedConcepts: [
            {
                concept: {
                    name: "pullquote [EPUB-SSV]"
                },
                module: "EPUB"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "none"
            ]
        ]
    };
    var _default$2d = docPullquoteRole;
    docPullquoteRole$1.default = _default$2d;
    var docQnaRole$1 = {};
    Object.defineProperty(docQnaRole$1, "__esModule", {
        value: true
    });
    docQnaRole$1.default = void 0;
    var docQnaRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {
            "aria-disabled": null,
            "aria-errormessage": null,
            "aria-expanded": null,
            "aria-haspopup": null,
            "aria-invalid": null
        },
        relatedConcepts: [
            {
                concept: {
                    name: "qna [EPUB-SSV]"
                },
                module: "EPUB"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "section"
            ]
        ]
    };
    var _default$2c = docQnaRole;
    docQnaRole$1.default = _default$2c;
    var docSubtitleRole$1 = {};
    Object.defineProperty(docSubtitleRole$1, "__esModule", {
        value: true
    });
    docSubtitleRole$1.default = void 0;
    var docSubtitleRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {
            "aria-disabled": null,
            "aria-errormessage": null,
            "aria-expanded": null,
            "aria-haspopup": null,
            "aria-invalid": null
        },
        relatedConcepts: [
            {
                concept: {
                    name: "subtitle [EPUB-SSV]"
                },
                module: "EPUB"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "sectionhead"
            ]
        ]
    };
    var _default$2b = docSubtitleRole;
    docSubtitleRole$1.default = _default$2b;
    var docTipRole$1 = {};
    Object.defineProperty(docTipRole$1, "__esModule", {
        value: true
    });
    docTipRole$1.default = void 0;
    var docTipRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {
            "aria-disabled": null,
            "aria-errormessage": null,
            "aria-expanded": null,
            "aria-haspopup": null,
            "aria-invalid": null
        },
        relatedConcepts: [
            {
                concept: {
                    name: "help [EPUB-SSV]"
                },
                module: "EPUB"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "section",
                "note"
            ]
        ]
    };
    var _default$2a = docTipRole;
    docTipRole$1.default = _default$2a;
    var docTocRole$1 = {};
    Object.defineProperty(docTocRole$1, "__esModule", {
        value: true
    });
    docTocRole$1.default = void 0;
    var docTocRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {
            "aria-disabled": null,
            "aria-errormessage": null,
            "aria-expanded": null,
            "aria-haspopup": null,
            "aria-invalid": null
        },
        relatedConcepts: [
            {
                concept: {
                    name: "toc [EPUB-SSV]"
                },
                module: "EPUB"
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "section",
                "landmark",
                "navigation"
            ]
        ]
    };
    var _default$29 = docTocRole;
    docTocRole$1.default = _default$29;
    Object.defineProperty(ariaDpubRoles$1, "__esModule", {
        value: true
    });
    ariaDpubRoles$1.default = void 0;
    var _docAbstractRole = _interopRequireDefault$b(docAbstractRole$1);
    var _docAcknowledgmentsRole = _interopRequireDefault$b(docAcknowledgmentsRole$1);
    var _docAfterwordRole = _interopRequireDefault$b(docAfterwordRole$1);
    var _docAppendixRole = _interopRequireDefault$b(docAppendixRole$1);
    var _docBacklinkRole = _interopRequireDefault$b(docBacklinkRole$1);
    var _docBiblioentryRole = _interopRequireDefault$b(docBiblioentryRole$1);
    var _docBibliographyRole = _interopRequireDefault$b(docBibliographyRole$1);
    var _docBibliorefRole = _interopRequireDefault$b(docBibliorefRole$1);
    var _docChapterRole = _interopRequireDefault$b(docChapterRole$1);
    var _docColophonRole = _interopRequireDefault$b(docColophonRole$1);
    var _docConclusionRole = _interopRequireDefault$b(docConclusionRole$1);
    var _docCoverRole = _interopRequireDefault$b(docCoverRole$1);
    var _docCreditRole = _interopRequireDefault$b(docCreditRole$1);
    var _docCreditsRole = _interopRequireDefault$b(docCreditsRole$1);
    var _docDedicationRole = _interopRequireDefault$b(docDedicationRole$1);
    var _docEndnoteRole = _interopRequireDefault$b(docEndnoteRole$1);
    var _docEndnotesRole = _interopRequireDefault$b(docEndnotesRole$1);
    var _docEpigraphRole = _interopRequireDefault$b(docEpigraphRole$1);
    var _docEpilogueRole = _interopRequireDefault$b(docEpilogueRole$1);
    var _docErrataRole = _interopRequireDefault$b(docErrataRole$1);
    var _docExampleRole = _interopRequireDefault$b(docExampleRole$1);
    var _docFootnoteRole = _interopRequireDefault$b(docFootnoteRole$1);
    var _docForewordRole = _interopRequireDefault$b(docForewordRole$1);
    var _docGlossaryRole = _interopRequireDefault$b(docGlossaryRole$1);
    var _docGlossrefRole = _interopRequireDefault$b(docGlossrefRole$1);
    var _docIndexRole = _interopRequireDefault$b(docIndexRole$1);
    var _docIntroductionRole = _interopRequireDefault$b(docIntroductionRole$1);
    var _docNoterefRole = _interopRequireDefault$b(docNoterefRole$1);
    var _docNoticeRole = _interopRequireDefault$b(docNoticeRole$1);
    var _docPagebreakRole = _interopRequireDefault$b(docPagebreakRole$1);
    var _docPagelistRole = _interopRequireDefault$b(docPagelistRole$1);
    var _docPartRole = _interopRequireDefault$b(docPartRole$1);
    var _docPrefaceRole = _interopRequireDefault$b(docPrefaceRole$1);
    var _docPrologueRole = _interopRequireDefault$b(docPrologueRole$1);
    var _docPullquoteRole = _interopRequireDefault$b(docPullquoteRole$1);
    var _docQnaRole = _interopRequireDefault$b(docQnaRole$1);
    var _docSubtitleRole = _interopRequireDefault$b(docSubtitleRole$1);
    var _docTipRole = _interopRequireDefault$b(docTipRole$1);
    var _docTocRole = _interopRequireDefault$b(docTocRole$1);
    function _interopRequireDefault$b(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    var ariaDpubRoles = [
        [
            "doc-abstract",
            _docAbstractRole.default
        ],
        [
            "doc-acknowledgments",
            _docAcknowledgmentsRole.default
        ],
        [
            "doc-afterword",
            _docAfterwordRole.default
        ],
        [
            "doc-appendix",
            _docAppendixRole.default
        ],
        [
            "doc-backlink",
            _docBacklinkRole.default
        ],
        [
            "doc-biblioentry",
            _docBiblioentryRole.default
        ],
        [
            "doc-bibliography",
            _docBibliographyRole.default
        ],
        [
            "doc-biblioref",
            _docBibliorefRole.default
        ],
        [
            "doc-chapter",
            _docChapterRole.default
        ],
        [
            "doc-colophon",
            _docColophonRole.default
        ],
        [
            "doc-conclusion",
            _docConclusionRole.default
        ],
        [
            "doc-cover",
            _docCoverRole.default
        ],
        [
            "doc-credit",
            _docCreditRole.default
        ],
        [
            "doc-credits",
            _docCreditsRole.default
        ],
        [
            "doc-dedication",
            _docDedicationRole.default
        ],
        [
            "doc-endnote",
            _docEndnoteRole.default
        ],
        [
            "doc-endnotes",
            _docEndnotesRole.default
        ],
        [
            "doc-epigraph",
            _docEpigraphRole.default
        ],
        [
            "doc-epilogue",
            _docEpilogueRole.default
        ],
        [
            "doc-errata",
            _docErrataRole.default
        ],
        [
            "doc-example",
            _docExampleRole.default
        ],
        [
            "doc-footnote",
            _docFootnoteRole.default
        ],
        [
            "doc-foreword",
            _docForewordRole.default
        ],
        [
            "doc-glossary",
            _docGlossaryRole.default
        ],
        [
            "doc-glossref",
            _docGlossrefRole.default
        ],
        [
            "doc-index",
            _docIndexRole.default
        ],
        [
            "doc-introduction",
            _docIntroductionRole.default
        ],
        [
            "doc-noteref",
            _docNoterefRole.default
        ],
        [
            "doc-notice",
            _docNoticeRole.default
        ],
        [
            "doc-pagebreak",
            _docPagebreakRole.default
        ],
        [
            "doc-pagelist",
            _docPagelistRole.default
        ],
        [
            "doc-part",
            _docPartRole.default
        ],
        [
            "doc-preface",
            _docPrefaceRole.default
        ],
        [
            "doc-prologue",
            _docPrologueRole.default
        ],
        [
            "doc-pullquote",
            _docPullquoteRole.default
        ],
        [
            "doc-qna",
            _docQnaRole.default
        ],
        [
            "doc-subtitle",
            _docSubtitleRole.default
        ],
        [
            "doc-tip",
            _docTipRole.default
        ],
        [
            "doc-toc",
            _docTocRole.default
        ]
    ];
    var _default$28 = ariaDpubRoles;
    ariaDpubRoles$1.default = _default$28;
    var ariaGraphicsRoles$1 = {};
    var graphicsDocumentRole$1 = {};
    Object.defineProperty(graphicsDocumentRole$1, "__esModule", {
        value: true
    });
    graphicsDocumentRole$1.default = void 0;
    var graphicsDocumentRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {
            "aria-disabled": null,
            "aria-errormessage": null,
            "aria-expanded": null,
            "aria-haspopup": null,
            "aria-invalid": null
        },
        relatedConcepts: [
            {
                module: "GRAPHICS",
                concept: {
                    name: "graphics-object"
                }
            },
            {
                module: "ARIA",
                concept: {
                    name: "img"
                }
            },
            {
                module: "ARIA",
                concept: {
                    name: "article"
                }
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "document"
            ]
        ]
    };
    var _default$27 = graphicsDocumentRole;
    graphicsDocumentRole$1.default = _default$27;
    var graphicsObjectRole$1 = {};
    Object.defineProperty(graphicsObjectRole$1, "__esModule", {
        value: true
    });
    graphicsObjectRole$1.default = void 0;
    var graphicsObjectRole = {
        abstract: false,
        accessibleNameRequired: false,
        baseConcepts: [],
        childrenPresentational: false,
        nameFrom: [
            "author",
            "contents"
        ],
        prohibitedProps: [],
        props: {
            "aria-errormessage": null,
            "aria-expanded": null,
            "aria-haspopup": null,
            "aria-invalid": null
        },
        relatedConcepts: [
            {
                module: "GRAPHICS",
                concept: {
                    name: "graphics-document"
                }
            },
            {
                module: "ARIA",
                concept: {
                    name: "group"
                }
            },
            {
                module: "ARIA",
                concept: {
                    name: "img"
                }
            },
            {
                module: "GRAPHICS",
                concept: {
                    name: "graphics-symbol"
                }
            }
        ],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "section",
                "group"
            ]
        ]
    };
    var _default$26 = graphicsObjectRole;
    graphicsObjectRole$1.default = _default$26;
    var graphicsSymbolRole$1 = {};
    Object.defineProperty(graphicsSymbolRole$1, "__esModule", {
        value: true
    });
    graphicsSymbolRole$1.default = void 0;
    var graphicsSymbolRole = {
        abstract: false,
        accessibleNameRequired: true,
        baseConcepts: [],
        childrenPresentational: true,
        nameFrom: [
            "author"
        ],
        prohibitedProps: [],
        props: {
            "aria-disabled": null,
            "aria-errormessage": null,
            "aria-expanded": null,
            "aria-haspopup": null,
            "aria-invalid": null
        },
        relatedConcepts: [],
        requireContextRole: [],
        requiredContextRole: [],
        requiredOwnedElements: [],
        requiredProps: {},
        superClass: [
            [
                "roletype",
                "structure",
                "section",
                "img"
            ]
        ]
    };
    var _default$25 = graphicsSymbolRole;
    graphicsSymbolRole$1.default = _default$25;
    Object.defineProperty(ariaGraphicsRoles$1, "__esModule", {
        value: true
    });
    ariaGraphicsRoles$1.default = void 0;
    var _graphicsDocumentRole = _interopRequireDefault$a(graphicsDocumentRole$1);
    var _graphicsObjectRole = _interopRequireDefault$a(graphicsObjectRole$1);
    var _graphicsSymbolRole = _interopRequireDefault$a(graphicsSymbolRole$1);
    function _interopRequireDefault$a(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    var ariaGraphicsRoles = [
        [
            "graphics-document",
            _graphicsDocumentRole.default
        ],
        [
            "graphics-object",
            _graphicsObjectRole.default
        ],
        [
            "graphics-symbol",
            _graphicsSymbolRole.default
        ]
    ];
    var _default$24 = ariaGraphicsRoles;
    ariaGraphicsRoles$1.default = _default$24;
    Object.defineProperty(rolesMap$1, "__esModule", {
        value: true
    });
    rolesMap$1.default = void 0;
    var _ariaAbstractRoles = _interopRequireDefault$9(ariaAbstractRoles$1);
    var _ariaLiteralRoles = _interopRequireDefault$9(ariaLiteralRoles$1);
    var _ariaDpubRoles = _interopRequireDefault$9(ariaDpubRoles$1);
    var _ariaGraphicsRoles = _interopRequireDefault$9(ariaGraphicsRoles$1);
    var _iterationDecorator$6 = _interopRequireDefault$9(iterationDecorator$3);
    function _interopRequireDefault$9(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    function _defineProperty(obj, key, value) {
        if (key in obj) Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
        else obj[key] = value;
        return obj;
    }
    function _createForOfIteratorHelper$6(o, allowArrayLike) {
        var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
        if (!it) {
            if (Array.isArray(o) || (it = _unsupportedIterableToArray$6(o)) || allowArrayLike && o && typeof o.length === "number") {
                if (it) o = it;
                var i = 0;
                var F = function F() {};
                return {
                    s: F,
                    n: function n() {
                        if (i >= o.length) return {
                            done: true
                        };
                        return {
                            done: false,
                            value: o[i++]
                        };
                    },
                    e: function e(_e2) {
                        throw _e2;
                    },
                    f: F
                };
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var normalCompletion = true, didErr = false, err;
        return {
            s: function s() {
                it = it.call(o);
            },
            n: function n() {
                var step = it.next();
                normalCompletion = step.done;
                return step;
            },
            e: function e(_e3) {
                didErr = true;
                err = _e3;
            },
            f: function f() {
                try {
                    if (!normalCompletion && it.return != null) it.return();
                } finally{
                    if (didErr) throw err;
                }
            }
        };
    }
    function _slicedToArray$6(arr, i) {
        return _arrayWithHoles$6(arr) || _iterableToArrayLimit$6(arr, i) || _unsupportedIterableToArray$6(arr, i) || _nonIterableRest$6();
    }
    function _nonIterableRest$6() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray$6(o, minLen) {
        if (!o) return;
        if (typeof o === "string") return _arrayLikeToArray$6(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor) n = o.constructor.name;
        if (n === "Map" || n === "Set") return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$6(o, minLen);
    }
    function _arrayLikeToArray$6(arr, len) {
        if (len == null || len > arr.length) len = arr.length;
        for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
        return arr2;
    }
    function _iterableToArrayLimit$6(arr, i) {
        var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
        if (_i == null) return;
        var _arr = [];
        var _n = true;
        var _d = false;
        var _s, _e;
        try {
            for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){
                _arr.push(_s.value);
                if (i && _arr.length === i) break;
            }
        } catch (err) {
            _d = true;
            _e = err;
        } finally{
            try {
                if (!_n && _i["return"] != null) _i["return"]();
            } finally{
                if (_d) throw _e;
            }
        }
        return _arr;
    }
    function _arrayWithHoles$6(arr) {
        if (Array.isArray(arr)) return arr;
    }
    var roles$1 = [].concat(_ariaAbstractRoles.default, _ariaLiteralRoles.default, _ariaDpubRoles.default, _ariaGraphicsRoles.default);
    roles$1.forEach(function(_ref) {
        var _ref2 = _slicedToArray$6(_ref, 2), roleDefinition = _ref2[1];
        // Conglomerate the properties
        var _iterator = _createForOfIteratorHelper$6(roleDefinition.superClass), _step;
        try {
            for(_iterator.s(); !(_step = _iterator.n()).done;){
                var superClassIter = _step.value;
                var _iterator2 = _createForOfIteratorHelper$6(superClassIter), _step2;
                try {
                    var _loop = function _loop() {
                        var superClassName = _step2.value;
                        var superClassRoleTuple = roles$1.find(function(_ref3) {
                            var _ref4 = _slicedToArray$6(_ref3, 1), name = _ref4[0];
                            return name === superClassName;
                        });
                        if (superClassRoleTuple) {
                            var superClassDefinition = superClassRoleTuple[1];
                            for(var _i2 = 0, _Object$keys = Object.keys(superClassDefinition.props); _i2 < _Object$keys.length; _i2++){
                                var prop = _Object$keys[_i2];
                                if (// $FlowIssue Accessing the hasOwnProperty on the Object prototype is fine.
                                !Object.prototype.hasOwnProperty.call(roleDefinition.props, prop)) Object.assign(roleDefinition.props, _defineProperty({}, prop, superClassDefinition.props[prop]));
                            }
                        }
                    };
                    for(_iterator2.s(); !(_step2 = _iterator2.n()).done;)_loop();
                } catch (err) {
                    _iterator2.e(err);
                } finally{
                    _iterator2.f();
                }
            }
        } catch (err) {
            _iterator.e(err);
        } finally{
            _iterator.f();
        }
    });
    var rolesMap = {
        entries: function entries() {
            return roles$1;
        },
        forEach: function forEach(fn) {
            var thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
            var _iterator3 = _createForOfIteratorHelper$6(roles$1), _step3;
            try {
                for(_iterator3.s(); !(_step3 = _iterator3.n()).done;){
                    var _step3$value = _slicedToArray$6(_step3.value, 2), key = _step3$value[0], values = _step3$value[1];
                    fn.call(thisArg, values, key, roles$1);
                }
            } catch (err) {
                _iterator3.e(err);
            } finally{
                _iterator3.f();
            }
        },
        get: function get(key) {
            var item = roles$1.find(function(tuple) {
                return tuple[0] === key ? true : false;
            });
            return item && item[1];
        },
        has: function has(key) {
            return !!rolesMap.get(key);
        },
        keys: function keys() {
            return roles$1.map(function(_ref5) {
                var _ref6 = _slicedToArray$6(_ref5, 1), key = _ref6[0];
                return key;
            });
        },
        values: function values() {
            return roles$1.map(function(_ref7) {
                var _ref8 = _slicedToArray$6(_ref7, 2), values = _ref8[1];
                return values;
            });
        }
    };
    var _default$23 = (0, _iterationDecorator$6.default)(rolesMap, rolesMap.entries());
    rolesMap$1.default = _default$23;
    var elementRoleMap$1 = {};
    var lite = {};
    var has = Object.prototype.hasOwnProperty;
    function dequal(foo, bar) {
        var ctor, len;
        if (foo === bar) return true;
        if (foo && bar && (ctor = foo.constructor) === bar.constructor) {
            if (ctor === Date) return foo.getTime() === bar.getTime();
            if (ctor === RegExp) return foo.toString() === bar.toString();
            if (ctor === Array) {
                if ((len = foo.length) === bar.length) {
                    while(len-- && dequal(foo[len], bar[len]));
                }
                return len === -1;
            }
            if (!ctor || typeof foo === "object") {
                len = 0;
                for(ctor in foo){
                    if (has.call(foo, ctor) && ++len && !has.call(bar, ctor)) return false;
                    if (!(ctor in bar) || !dequal(foo[ctor], bar[ctor])) return false;
                }
                return Object.keys(bar).length === len;
            }
        }
        return foo !== foo && bar !== bar;
    }
    lite.dequal = dequal;
    Object.defineProperty(elementRoleMap$1, "__esModule", {
        value: true
    });
    elementRoleMap$1.default = void 0;
    var _lite$1 = lite;
    var _iterationDecorator$5 = _interopRequireDefault$8(iterationDecorator$3);
    var _rolesMap$2 = _interopRequireDefault$8(rolesMap$1);
    function _interopRequireDefault$8(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    function _slicedToArray$5(arr, i) {
        return _arrayWithHoles$5(arr) || _iterableToArrayLimit$5(arr, i) || _unsupportedIterableToArray$5(arr, i) || _nonIterableRest$5();
    }
    function _nonIterableRest$5() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _iterableToArrayLimit$5(arr, i) {
        var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
        if (_i == null) return;
        var _arr = [];
        var _n = true;
        var _d = false;
        var _s, _e;
        try {
            for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){
                _arr.push(_s.value);
                if (i && _arr.length === i) break;
            }
        } catch (err) {
            _d = true;
            _e = err;
        } finally{
            try {
                if (!_n && _i["return"] != null) _i["return"]();
            } finally{
                if (_d) throw _e;
            }
        }
        return _arr;
    }
    function _arrayWithHoles$5(arr) {
        if (Array.isArray(arr)) return arr;
    }
    function _createForOfIteratorHelper$5(o, allowArrayLike) {
        var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
        if (!it) {
            if (Array.isArray(o) || (it = _unsupportedIterableToArray$5(o)) || allowArrayLike && o && typeof o.length === "number") {
                if (it) o = it;
                var i = 0;
                var F = function F() {};
                return {
                    s: F,
                    n: function n() {
                        if (i >= o.length) return {
                            done: true
                        };
                        return {
                            done: false,
                            value: o[i++]
                        };
                    },
                    e: function e(_e2) {
                        throw _e2;
                    },
                    f: F
                };
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var normalCompletion = true, didErr = false, err;
        return {
            s: function s() {
                it = it.call(o);
            },
            n: function n() {
                var step = it.next();
                normalCompletion = step.done;
                return step;
            },
            e: function e(_e3) {
                didErr = true;
                err = _e3;
            },
            f: function f() {
                try {
                    if (!normalCompletion && it.return != null) it.return();
                } finally{
                    if (didErr) throw err;
                }
            }
        };
    }
    function _unsupportedIterableToArray$5(o, minLen) {
        if (!o) return;
        if (typeof o === "string") return _arrayLikeToArray$5(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor) n = o.constructor.name;
        if (n === "Map" || n === "Set") return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$5(o, minLen);
    }
    function _arrayLikeToArray$5(arr, len) {
        if (len == null || len > arr.length) len = arr.length;
        for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
        return arr2;
    }
    var elementRoles$1 = [];
    var keys$1 = _rolesMap$2.default.keys();
    for(var i$1 = 0; i$1 < keys$1.length; i$1++){
        var key$1 = keys$1[i$1];
        var role$1 = _rolesMap$2.default.get(key$1);
        if (role$1) {
            var concepts$1 = [].concat(role$1.baseConcepts, role$1.relatedConcepts);
            for(var k$1 = 0; k$1 < concepts$1.length; k$1++){
                var relation$1 = concepts$1[k$1];
                if (relation$1.module === "HTML") (function() {
                    var concept = relation$1.concept;
                    if (concept) {
                        var elementRoleRelation = elementRoles$1.find(function(relation) {
                            return (0, _lite$1.dequal)(relation, concept);
                        });
                        var roles;
                        if (elementRoleRelation) roles = elementRoleRelation[1];
                        else roles = [];
                        var isUnique = true;
                        for(var _i = 0; _i < roles.length; _i++)if (roles[_i] === key$1) {
                            isUnique = false;
                            break;
                        }
                        if (isUnique) roles.push(key$1);
                        elementRoles$1.push([
                            concept,
                            roles
                        ]);
                    }
                })();
            }
        }
    }
    var elementRoleMap = {
        entries: function entries() {
            return elementRoles$1;
        },
        forEach: function forEach(fn) {
            var thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
            var _iterator = _createForOfIteratorHelper$5(elementRoles$1), _step;
            try {
                for(_iterator.s(); !(_step = _iterator.n()).done;){
                    var _step$value = _slicedToArray$5(_step.value, 2), _key = _step$value[0], values = _step$value[1];
                    fn.call(thisArg, values, _key, elementRoles$1);
                }
            } catch (err) {
                _iterator.e(err);
            } finally{
                _iterator.f();
            }
        },
        get: function get(key) {
            var item = elementRoles$1.find(function(tuple) {
                return key.name === tuple[0].name && (0, _lite$1.dequal)(key.attributes, tuple[0].attributes);
            });
            return item && item[1];
        },
        has: function has(key) {
            return !!elementRoleMap.get(key);
        },
        keys: function keys() {
            return elementRoles$1.map(function(_ref) {
                var _ref2 = _slicedToArray$5(_ref, 1), key = _ref2[0];
                return key;
            });
        },
        values: function values() {
            return elementRoles$1.map(function(_ref3) {
                var _ref4 = _slicedToArray$5(_ref3, 2), values = _ref4[1];
                return values;
            });
        }
    };
    var _default$22 = (0, _iterationDecorator$5.default)(elementRoleMap, elementRoleMap.entries());
    elementRoleMap$1.default = _default$22;
    var roleElementMap$1 = {};
    Object.defineProperty(roleElementMap$1, "__esModule", {
        value: true
    });
    roleElementMap$1.default = void 0;
    var _iterationDecorator$4 = _interopRequireDefault$7(iterationDecorator$3);
    var _rolesMap$1 = _interopRequireDefault$7(rolesMap$1);
    function _interopRequireDefault$7(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    function _slicedToArray$4(arr, i) {
        return _arrayWithHoles$4(arr) || _iterableToArrayLimit$4(arr, i) || _unsupportedIterableToArray$4(arr, i) || _nonIterableRest$4();
    }
    function _nonIterableRest$4() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _iterableToArrayLimit$4(arr, i) {
        var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
        if (_i == null) return;
        var _arr = [];
        var _n = true;
        var _d = false;
        var _s, _e;
        try {
            for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){
                _arr.push(_s.value);
                if (i && _arr.length === i) break;
            }
        } catch (err) {
            _d = true;
            _e = err;
        } finally{
            try {
                if (!_n && _i["return"] != null) _i["return"]();
            } finally{
                if (_d) throw _e;
            }
        }
        return _arr;
    }
    function _arrayWithHoles$4(arr) {
        if (Array.isArray(arr)) return arr;
    }
    function _createForOfIteratorHelper$4(o, allowArrayLike) {
        var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
        if (!it) {
            if (Array.isArray(o) || (it = _unsupportedIterableToArray$4(o)) || allowArrayLike && o && typeof o.length === "number") {
                if (it) o = it;
                var i = 0;
                var F = function F() {};
                return {
                    s: F,
                    n: function n() {
                        if (i >= o.length) return {
                            done: true
                        };
                        return {
                            done: false,
                            value: o[i++]
                        };
                    },
                    e: function e(_e2) {
                        throw _e2;
                    },
                    f: F
                };
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var normalCompletion = true, didErr = false, err;
        return {
            s: function s() {
                it = it.call(o);
            },
            n: function n() {
                var step = it.next();
                normalCompletion = step.done;
                return step;
            },
            e: function e(_e3) {
                didErr = true;
                err = _e3;
            },
            f: function f() {
                try {
                    if (!normalCompletion && it.return != null) it.return();
                } finally{
                    if (didErr) throw err;
                }
            }
        };
    }
    function _unsupportedIterableToArray$4(o, minLen) {
        if (!o) return;
        if (typeof o === "string") return _arrayLikeToArray$4(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor) n = o.constructor.name;
        if (n === "Map" || n === "Set") return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$4(o, minLen);
    }
    function _arrayLikeToArray$4(arr, len) {
        if (len == null || len > arr.length) len = arr.length;
        for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
        return arr2;
    }
    var roleElement = [];
    var keys = _rolesMap$1.default.keys();
    for(var i = 0; i < keys.length; i++){
        var key = keys[i];
        var role = _rolesMap$1.default.get(key);
        var relationConcepts = [];
        if (role) {
            var concepts = [].concat(role.baseConcepts, role.relatedConcepts);
            for(var k = 0; k < concepts.length; k++){
                var relation = concepts[k];
                if (relation.module === "HTML") {
                    var concept = relation.concept;
                    if (concept != null) relationConcepts.push(concept);
                }
            }
            if (relationConcepts.length > 0) roleElement.push([
                key,
                relationConcepts
            ]);
        }
    }
    var roleElementMap = {
        entries: function entries() {
            return roleElement;
        },
        forEach: function forEach(fn) {
            var thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
            var _iterator = _createForOfIteratorHelper$4(roleElement), _step;
            try {
                for(_iterator.s(); !(_step = _iterator.n()).done;){
                    var _step$value = _slicedToArray$4(_step.value, 2), _key = _step$value[0], values = _step$value[1];
                    fn.call(thisArg, values, _key, roleElement);
                }
            } catch (err) {
                _iterator.e(err);
            } finally{
                _iterator.f();
            }
        },
        get: function get(key) {
            var item = roleElement.find(function(tuple) {
                return tuple[0] === key ? true : false;
            });
            return item && item[1];
        },
        has: function has(key) {
            return !!roleElementMap.get(key);
        },
        keys: function keys() {
            return roleElement.map(function(_ref) {
                var _ref2 = _slicedToArray$4(_ref, 1), key = _ref2[0];
                return key;
            });
        },
        values: function values() {
            return roleElement.map(function(_ref3) {
                var _ref4 = _slicedToArray$4(_ref3, 2), values = _ref4[1];
                return values;
            });
        }
    };
    var _default$21 = (0, _iterationDecorator$4.default)(roleElementMap, roleElementMap.entries());
    roleElementMap$1.default = _default$21;
    Object.defineProperty(lib$1, "__esModule", {
        value: true
    });
    var roles_1 = lib$1.roles = lib$1.roleElements = elementRoles_1 = lib$1.elementRoles = lib$1.dom = aria_1 = lib$1.aria = void 0;
    var _ariaPropsMap = _interopRequireDefault$6(ariaPropsMap$1);
    var _domMap = _interopRequireDefault$6(domMap$1);
    var _rolesMap = _interopRequireDefault$6(rolesMap$1);
    var _elementRoleMap = _interopRequireDefault$6(elementRoleMap$1);
    var _roleElementMap = _interopRequireDefault$6(roleElementMap$1);
    function _interopRequireDefault$6(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    var aria = _ariaPropsMap.default;
    var aria_1 = lib$1.aria = aria;
    var dom$1 = _domMap.default;
    lib$1.dom = dom$1;
    var roles = _rolesMap.default;
    roles_1 = lib$1.roles = roles;
    var elementRoles = _elementRoleMap.default;
    var elementRoles_1 = lib$1.elementRoles = elementRoles;
    var roleElements = _roleElementMap.default;
    lib$1.roleElements = roleElements;
    var lib = {};
    var AXObjectElementMap$1 = {};
    var iterationDecorator$1 = {};
    var iteratorProxy$1 = {};
    Object.defineProperty(iteratorProxy$1, "__esModule", {
        value: true
    });
    iteratorProxy$1.default = void 0;
    // eslint-disable-next-line no-unused-vars
    function iteratorProxy() {
        var values = this;
        var index = 0;
        var iter = {
            "@@iterator": function iterator() {
                return iter;
            },
            next: function next() {
                if (index < values.length) {
                    var value = values[index];
                    index = index + 1;
                    return {
                        done: false,
                        value: value
                    };
                } else return {
                    done: true
                };
            }
        };
        return iter;
    }
    var _default$20 = iteratorProxy;
    iteratorProxy$1.default = _default$20;
    Object.defineProperty(iterationDecorator$1, "__esModule", {
        value: true
    });
    iterationDecorator$1.default = iterationDecorator;
    var _iteratorProxy = _interopRequireDefault$5(iteratorProxy$1);
    function _interopRequireDefault$5(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    function _typeof(obj) {
        "@babel/helpers - typeof";
        return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
            return typeof obj;
        } : function(obj) {
            return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        }, _typeof(obj);
    }
    function iterationDecorator(collection, entries) {
        if (typeof Symbol === "function" && _typeof(Symbol.iterator) === "symbol") Object.defineProperty(collection, Symbol.iterator, {
            value: _iteratorProxy.default.bind(entries)
        });
        return collection;
    }
    var AXObjectsMap$1 = {};
    var AbbrRole$1 = {};
    Object.defineProperty(AbbrRole$1, "__esModule", {
        value: true
    });
    AbbrRole$1.default = void 0;
    var AbbrRole = {
        relatedConcepts: [
            {
                module: "HTML",
                concept: {
                    name: "abbr"
                }
            }
        ],
        type: "structure"
    };
    var _default$1$ = AbbrRole;
    AbbrRole$1.default = _default$1$;
    var AlertDialogRole$1 = {};
    Object.defineProperty(AlertDialogRole$1, "__esModule", {
        value: true
    });
    AlertDialogRole$1.default = void 0;
    var AlertDialogRole = {
        relatedConcepts: [
            {
                module: "ARIA",
                concept: {
                    name: "alertdialog"
                }
            }
        ],
        type: "window"
    };
    var _default$1_ = AlertDialogRole;
    AlertDialogRole$1.default = _default$1_;
    var AlertRole$1 = {};
    Object.defineProperty(AlertRole$1, "__esModule", {
        value: true
    });
    AlertRole$1.default = void 0;
    var AlertRole = {
        relatedConcepts: [
            {
                module: "ARIA",
                concept: {
                    name: "alert"
                }
            }
        ],
        type: "structure"
    };
    var _default$1Z = AlertRole;
    AlertRole$1.default = _default$1Z;
    var AnnotationRole$1 = {};
    Object.defineProperty(AnnotationRole$1, "__esModule", {
        value: true
    });
    AnnotationRole$1.default = void 0;
    var AnnotationRole = {
        relatedConcepts: [],
        type: "structure"
    };
    var _default$1Y = AnnotationRole;
    AnnotationRole$1.default = _default$1Y;
    var ApplicationRole$1 = {};
    Object.defineProperty(ApplicationRole$1, "__esModule", {
        value: true
    });
    ApplicationRole$1.default = void 0;
    var ApplicationRole = {
        relatedConcepts: [
            {
                module: "ARIA",
                concept: {
                    name: "application"
                }
            }
        ],
        type: "window"
    };
    var _default$1X = ApplicationRole;
    ApplicationRole$1.default = _default$1X;
    var ArticleRole$1 = {};
    Object.defineProperty(ArticleRole$1, "__esModule", {
        value: true
    });
    ArticleRole$1.default = void 0;
    var ArticleRole = {
        relatedConcepts: [
            {
                module: "ARIA",
                concept: {
                    name: "article"
                }
            },
            {
                module: "HTML",
                concept: {
                    name: "article"
                }
            }
        ],
        type: "structure"
    };
    var _default$1W = ArticleRole;
    ArticleRole$1.default = _default$1W;
    var AudioRole$1 = {};
    Object.defineProperty(AudioRole$1, "__esModule", {
        value: true
    });
    AudioRole$1.default = void 0;
    var AudioRole = {
        relatedConcepts: [
            {
                module: "HTML",
                concept: {
                    name: "audio"
                }
            }
        ],
        type: "widget"
    };
    var _default$1V = AudioRole;
    AudioRole$1.default = _default$1V;
    var BannerRole$1 = {};
    Object.defineProperty(BannerRole$1, "__esModule", {
        value: true
    });
    BannerRole$1.default = void 0;
    var BannerRole = {
        relatedConcepts: [
            {
                module: "ARIA",
                concept: {
                    name: "banner"
                }
            }
        ],
        type: "structure"
    };
    var _default$1U = BannerRole;
    BannerRole$1.default = _default$1U;
    var BlockquoteRole$1 = {};
    Object.defineProperty(BlockquoteRole$1, "__esModule", {
        value: true
    });
    BlockquoteRole$1.default = void 0;
    var BlockquoteRole = {
        relatedConcepts: [
            {
                module: "HTML",
                concept: {
                    name: "blockquote"
                }
            }
        ],
        type: "structure"
    };
    var _default$1T = BlockquoteRole;
    BlockquoteRole$1.default = _default$1T;
    var BusyIndicatorRole$1 = {};
    Object.defineProperty(BusyIndicatorRole$1, "__esModule", {
        value: true
    });
    BusyIndicatorRole$1.default = void 0;
    var BusyIndicatorRole = {
        relatedConcepts: [
            {
                module: "ARIA",
                concept: {
                    attributes: [
                        {
                            name: "aria-busy",
                            value: "true"
                        }
                    ]
                }
            }
        ],
        type: "widget"
    };
    var _default$1S = BusyIndicatorRole;
    BusyIndicatorRole$1.default = _default$1S;
    var ButtonRole$1 = {};
    Object.defineProperty(ButtonRole$1, "__esModule", {
        value: true
    });
    ButtonRole$1.default = void 0;
    var ButtonRole = {
        relatedConcepts: [
            {
                module: "ARIA",
                concept: {
                    name: "button"
                }
            },
            {
                module: "HTML",
                concept: {
                    name: "button"
                }
            }
        ],
        type: "widget"
    };
    var _default$1R = ButtonRole;
    ButtonRole$1.default = _default$1R;
    var CanvasRole$1 = {};
    Object.defineProperty(CanvasRole$1, "__esModule", {
        value: true
    });
    CanvasRole$1.default = void 0;
    var CanvasRole = {
        relatedConcepts: [
            {
                module: "HTML",
                concept: {
                    name: "canvas"
                }
            }
        ],
        type: "widget"
    };
    var _default$1Q = CanvasRole;
    CanvasRole$1.default = _default$1Q;
    var CaptionRole$1 = {};
    Object.defineProperty(CaptionRole$1, "__esModule", {
        value: true
    });
    CaptionRole$1.default = void 0;
    var CaptionRole = {
        relatedConcepts: [
            {
                module: "HTML",
                concept: {
                    name: "caption"
                }
            }
        ],
        type: "structure"
    };
    var _default$1P = CaptionRole;
    CaptionRole$1.default = _default$1P;
    var CellRole$1 = {};
    Object.defineProperty(CellRole$1, "__esModule", {
        value: true
    });
    CellRole$1.default = void 0;
    var CellRole = {
        relatedConcepts: [
            {
                module: "ARIA",
                concept: {
                    name: "cell"
                }
            },
            {
                module: "ARIA",
                concept: {
                    name: "gridcell"
                }
            },
            {
                module: "HTML",
                concept: {
                    name: "td"
                }
            }
        ],
        type: "widget"
    };
    var _default$1O = CellRole;
    CellRole$1.default = _default$1O;
    var CheckBoxRole$1 = {};
    Object.defineProperty(CheckBoxRole$1, "__esModule", {
        value: true
    });
    CheckBoxRole$1.default = void 0;
    var CheckBoxRole = {
        relatedConcepts: [
            {
                module: "ARIA",
                concept: {
                    name: "checkbox"
                }
            },
            {
                module: "HTML",
                concept: {
                    name: "input",
                    attributes: [
                        {
                            name: "type",
                            value: "checkbox"
                        }
                    ]
                }
            }
        ],
        type: "widget"
    };
    var _default$1N = CheckBoxRole;
    CheckBoxRole$1.default = _default$1N;
    var ColorWellRole$1 = {};
    Object.defineProperty(ColorWellRole$1, "__esModule", {
        value: true
    });
    ColorWellRole$1.default = void 0;
    var ColorWellRole = {
        relatedConcepts: [
            {
                module: "HTML",
                concept: {
                    name: "input",
                    attributes: [
                        {
                            name: "type",
                            value: "color"
                        }
                    ]
                }
            }
        ],
        type: "widget"
    };
    var _default$1M = ColorWellRole;
    ColorWellRole$1.default = _default$1M;
    var ColumnHeaderRole$1 = {};
    Object.defineProperty(ColumnHeaderRole$1, "__esModule", {
        value: true
    });
    ColumnHeaderRole$1.default = void 0;
    var ColumnHeaderRole = {
        relatedConcepts: [
            {
                module: "ARIA",
                concept: {
                    name: "columnheader"
                }
            },
            {
                module: "HTML",
                concept: {
                    name: "th"
                }
            }
        ],
        type: "widget"
    };
    var _default$1L = ColumnHeaderRole;
    ColumnHeaderRole$1.default = _default$1L;
    var ColumnRole$1 = {};
    Object.defineProperty(ColumnRole$1, "__esModule", {
        value: true
    });
    ColumnRole$1.default = void 0;
    var ColumnRole = {
        relatedConcepts: [],
        type: "structure"
    };
    var _default$1K = ColumnRole;
    ColumnRole$1.default = _default$1K;
    var ComboBoxRole$1 = {};
    Object.defineProperty(ComboBoxRole$1, "__esModule", {
        value: true
    });
    ComboBoxRole$1.default = void 0;
    var ComboBoxRole = {
        relatedConcepts: [
            {
                module: "ARIA",
                concept: {
                    name: "combobox"
                }
            },
            {
                module: "HTML",
                concept: {
                    name: "select"
                }
            }
        ],
        type: "widget"
    };
    var _default$1J = ComboBoxRole;
    ComboBoxRole$1.default = _default$1J;
    var ComplementaryRole$1 = {};
    Object.defineProperty(ComplementaryRole$1, "__esModule", {
        value: true
    });
    ComplementaryRole$1.default = void 0;
    var ComplementaryRole = {
        relatedConcepts: [
            {
                module: "ARIA",
                concept: {
                    name: "complementary"
                }
            }
        ],
        type: "structure"
    };
    var _default$1I = ComplementaryRole;
    ComplementaryRole$1.default = _default$1I;
    var ContentInfoRole$1 = {};
    Object.defineProperty(ContentInfoRole$1, "__esModule", {
        value: true
    });
    ContentInfoRole$1.default = void 0;
    var ContentInfoRole = {
        relatedConcepts: [
            {
                module: "ARIA",
                concept: {
                    name: "structureinfo"
                }
            }
        ],
        type: "structure"
    };
    var _default$1H = ContentInfoRole;
    ContentInfoRole$1.default = _default$1H;
    var DateRole$1 = {};
    Object.defineProperty(DateRole$1, "__esModule", {
        value: true
    });
    DateRole$1.default = void 0;
    var DateRole = {
        relatedConcepts: [
            {
                module: "HTML",
                concept: {
                    name: "input",
                    attributes: [
                        {
                            name: "type",
                            value: "date"
                        }
                    ]
                }
            }
        ],
        type: "widget"
    };
    var _default$1G = DateRole;
    DateRole$1.default = _default$1G;
    var DateTimeRole$1 = {};
    Object.defineProperty(DateTimeRole$1, "__esModule", {
        value: true
    });
    DateTimeRole$1.default = void 0;
    var DateTimeRole = {
        relatedConcepts: [
            {
                module: "HTML",
                concept: {
                    name: "input",
                    attributes: [
                        {
                            name: "type",
                            value: "datetime"
                        }
                    ]
                }
            }
        ],
        type: "widget"
    };
    var _default$1F = DateTimeRole;
    DateTimeRole$1.default = _default$1F;
    var DefinitionRole$1 = {};
    Object.defineProperty(DefinitionRole$1, "__esModule", {
        value: true
    });
    DefinitionRole$1.default = void 0;
    var DefinitionRole = {
        relatedConcepts: [
            {
                module: "HTML",
                concept: {
                    name: "dfn"
                }
            }
        ],
        type: "structure"
    };
    var _default$1E = DefinitionRole;
    DefinitionRole$1.default = _default$1E;
    var DescriptionListDetailRole$1 = {};
    Object.defineProperty(DescriptionListDetailRole$1, "__esModule", {
        value: true
    });
    DescriptionListDetailRole$1.default = void 0;
    var DescriptionListDetailRole = {
        relatedConcepts: [
            {
                module: "HTML",
                concept: {
                    name: "dd"
                }
            }
        ],
        type: "structure"
    };
    var _default$1D = DescriptionListDetailRole;
    DescriptionListDetailRole$1.default = _default$1D;
    var DescriptionListRole$1 = {};
    Object.defineProperty(DescriptionListRole$1, "__esModule", {
        value: true
    });
    DescriptionListRole$1.default = void 0;
    var DescriptionListRole = {
        relatedConcepts: [
            {
                module: "HTML",
                concept: {
                    name: "dl"
                }
            }
        ],
        type: "structure"
    };
    var _default$1C = DescriptionListRole;
    DescriptionListRole$1.default = _default$1C;
    var DescriptionListTermRole$1 = {};
    Object.defineProperty(DescriptionListTermRole$1, "__esModule", {
        value: true
    });
    DescriptionListTermRole$1.default = void 0;
    var DescriptionListTermRole = {
        relatedConcepts: [
            {
                module: "HTML",
                concept: {
                    name: "dt"
                }
            }
        ],
        type: "structure"
    };
    var _default$1B = DescriptionListTermRole;
    DescriptionListTermRole$1.default = _default$1B;
    var DetailsRole$1 = {};
    Object.defineProperty(DetailsRole$1, "__esModule", {
        value: true
    });
    DetailsRole$1.default = void 0;
    var DetailsRole = {
        relatedConcepts: [
            {
                module: "HTML",
                concept: {
                    name: "details"
                }
            }
        ],
        type: "structure"
    };
    var _default$1A = DetailsRole;
    DetailsRole$1.default = _default$1A;
    var DialogRole$1 = {};
    Object.defineProperty(DialogRole$1, "__esModule", {
        value: true
    });
    DialogRole$1.default = void 0;
    var DialogRole = {
        relatedConcepts: [
            {
                module: "ARIA",
                concept: {
                    name: "dialog"
                }
            },
            {
                module: "HTML",
                concept: {
                    name: "dialog"
                }
            }
        ],
        type: "window"
    };
    var _default$1z = DialogRole;
    DialogRole$1.default = _default$1z;
    var DirectoryRole$1 = {};
    Object.defineProperty(DirectoryRole$1, "__esModule", {
        value: true
    });
    DirectoryRole$1.default = void 0;
    var DirectoryRole = {
        relatedConcepts: [
            {
                module: "ARIA",
                concept: {
                    name: "directory"
                }
            },
            {
                module: "HTML",
                concept: {
                    name: "dir"
                }
            }
        ],
        type: "structure"
    };
    var _default$1y = DirectoryRole;
    DirectoryRole$1.default = _default$1y;
    var DisclosureTriangleRole$1 = {};
    Object.defineProperty(DisclosureTriangleRole$1, "__esModule", {
        value: true
    });
    DisclosureTriangleRole$1.default = void 0;
    var DisclosureTriangleRole = {
        relatedConcepts: [
            {
                module: "HTML",
                concept: {
                    constraints: [
                        "scoped to a details element"
                    ],
                    name: "summary"
                }
            }
        ],
        type: "widget"
    };
    var _default$1x = DisclosureTriangleRole;
    DisclosureTriangleRole$1.default = _default$1x;
    var DivRole$1 = {};
    Object.defineProperty(DivRole$1, "__esModule", {
        value: true
    });
    DivRole$1.default = void 0;
    var DivRole = {
        relatedConcepts: [
            {
                module: "HTML",
                concept: {
                    name: "div"
                }
            }
        ],
        type: "generic"
    };
    var _default$1w = DivRole;
    DivRole$1.default = _default$1w;
    var DocumentRole$1 = {};
    Object.defineProperty(DocumentRole$1, "__esModule", {
        value: true
    });
    DocumentRole$1.default = void 0;
    var DocumentRole = {
        relatedConcepts: [
            {
                module: "ARIA",
                concept: {
                    name: "document"
                }
            }
        ],
        type: "structure"
    };
    var _default$1v = DocumentRole;
    DocumentRole$1.default = _default$1v;
    var EmbeddedObjectRole$1 = {};
    Object.defineProperty(EmbeddedObjectRole$1, "__esModule", {
        value: true
    });
    EmbeddedObjectRole$1.default = void 0;
    var EmbeddedObjectRole = {
        relatedConcepts: [
            {
                module: "HTML",
                concept: {
                    name: "embed"
                }
            }
        ],
        type: "widget"
    };
    var _default$1u = EmbeddedObjectRole;
    EmbeddedObjectRole$1.default = _default$1u;
    var FeedRole$1 = {};
    Object.defineProperty(FeedRole$1, "__esModule", {
        value: true
    });
    FeedRole$1.default = void 0;
    var FeedRole = {
        relatedConcepts: [
            {
                module: "ARIA",
                concept: {
                    name: "feed"
                }
            }
        ],
        type: "structure"
    };
    var _default$1t = FeedRole;
    FeedRole$1.default = _default$1t;
    var FigcaptionRole$1 = {};
    Object.defineProperty(FigcaptionRole$1, "__esModule", {
        value: true
    });
    FigcaptionRole$1.default = void 0;
    var FigcaptionRole = {
        relatedConcepts: [
            {
                module: "HTML",
                concept: {
                    name: "figcaption"
                }
            }
        ],
        type: "structure"
    };
    var _default$1s = FigcaptionRole;
    FigcaptionRole$1.default = _default$1s;
    var FigureRole$1 = {};
    Object.defineProperty(FigureRole$1, "__esModule", {
        value: true
    });
    FigureRole$1.default = void 0;
    var FigureRole = {
        relatedConcepts: [
            {
                module: "ARIA",
                concept: {
                    name: "figure"
                }
            },
            {
                module: "HTML",
                concept: {
                    name: "figure"
                }
            }
        ],
        type: "structure"
    };
    var _default$1r = FigureRole;
    FigureRole$1.default = _default$1r;
    var FooterRole$1 = {};
    Object.defineProperty(FooterRole$1, "__esModule", {
        value: true
    });
    FooterRole$1.default = void 0;
    var FooterRole = {
        relatedConcepts: [
            {
                module: "HTML",
                concept: {
                    name: "footer"
                }
            }
        ],
        type: "structure"
    };
    var _default$1q = FooterRole;
    FooterRole$1.default = _default$1q;
    var FormRole$1 = {};
    Object.defineProperty(FormRole$1, "__esModule", {
        value: true
    });
    FormRole$1.default = void 0;
    var FormRole = {
        relatedConcepts: [
            {
                module: "ARIA",
                concept: {
                    name: "form"
                }
            },
            {
                module: "HTML",
                concept: {
                    name: "form"
                }
            }
        ],
        type: "structure"
    };
    var _default$1p = FormRole;
    FormRole$1.default = _default$1p;
    var GridRole$1 = {};
    Object.defineProperty(GridRole$1, "__esModule", {
        value: true
    });
    GridRole$1.default = void 0;
    var GridRole = {
        relatedConcepts: [
            {
                module: "ARIA",
                concept: {
                    name: "grid"
                }
            }
        ],
        type: "widget"
    };
    var _default$1o = GridRole;
    GridRole$1.default = _default$1o;
    var GroupRole$1 = {};
    Object.defineProperty(GroupRole$1, "__esModule", {
        value: true
    });
    GroupRole$1.default = void 0;
    var GroupRole = {
        relatedConcepts: [
            {
                module: "ARIA",
                concept: {
                    name: "group"
                }
            }
        ],
        type: "structure"
    };
    var _default$1n = GroupRole;
    GroupRole$1.default = _default$1n;
    var HeadingRole$1 = {};
    Object.defineProperty(HeadingRole$1, "__esModule", {
        value: true
    });
    HeadingRole$1.default = void 0;
    var HeadingRole = {
        relatedConcepts: [
            {
                module: "ARIA",
                concept: {
                    name: "heading"
                }
            },
            {
                module: "HTML",
                concept: {
                    name: "h1"
                }
            },
            {
                module: "HTML",
                concept: {
                    name: "h2"
                }
            },
            {
                module: "HTML",
                concept: {
                    name: "h3"
                }
            },
            {
                module: "HTML",
                concept: {
                    name: "h4"
                }
            },
            {
                module: "HTML",
                concept: {
                    name: "h5"
                }
            },
            {
                module: "HTML",
                concept: {
                    name: "h6"
                }
            }
        ],
        type: "structure"
    };
    var _default$1m = HeadingRole;
    HeadingRole$1.default = _default$1m;
    var IframePresentationalRole$1 = {};
    Object.defineProperty(IframePresentationalRole$1, "__esModule", {
        value: true
    });
    IframePresentationalRole$1.default = void 0;
    var IframePresentationalRole = {
        relatedConcepts: [],
        type: "window"
    };
    var _default$1l = IframePresentationalRole;
    IframePresentationalRole$1.default = _default$1l;
    var IframeRole$1 = {};
    Object.defineProperty(IframeRole$1, "__esModule", {
        value: true
    });
    IframeRole$1.default = void 0;
    var IframeRole = {
        relatedConcepts: [
            {
                module: "HTML",
                concept: {
                    name: "iframe"
                }
            }
        ],
        type: "window"
    };
    var _default$1k = IframeRole;
    IframeRole$1.default = _default$1k;
    var IgnoredRole$1 = {};
    Object.defineProperty(IgnoredRole$1, "__esModule", {
        value: true
    });
    IgnoredRole$1.default = void 0;
    var IgnoredRole = {
        relatedConcepts: [],
        type: "structure"
    };
    var _default$1j = IgnoredRole;
    IgnoredRole$1.default = _default$1j;
    var ImageMapLinkRole$1 = {};
    Object.defineProperty(ImageMapLinkRole$1, "__esModule", {
        value: true
    });
    ImageMapLinkRole$1.default = void 0;
    var ImageMapLinkRole = {
        relatedConcepts: [],
        type: "widget"
    };
    var _default$1i = ImageMapLinkRole;
    ImageMapLinkRole$1.default = _default$1i;
    var ImageMapRole$1 = {};
    Object.defineProperty(ImageMapRole$1, "__esModule", {
        value: true
    });
    ImageMapRole$1.default = void 0;
    var ImageMapRole = {
        relatedConcepts: [
            {
                module: "HTML",
                concept: {
                    name: "img",
                    attributes: [
                        {
                            name: "usemap"
                        }
                    ]
                }
            }
        ],
        type: "structure"
    };
    var _default$1h = ImageMapRole;
    ImageMapRole$1.default = _default$1h;
    var ImageRole$1 = {};
    Object.defineProperty(ImageRole$1, "__esModule", {
        value: true
    });
    ImageRole$1.default = void 0;
    var ImageRole = {
        relatedConcepts: [
            {
                module: "ARIA",
                concept: {
                    name: "img"
                }
            },
            {
                module: "HTML",
                concept: {
                    name: "img"
                }
            }
        ],
        type: "structure"
    };
    var _default$1g = ImageRole;
    ImageRole$1.default = _default$1g;
    var InlineTextBoxRole$1 = {};
    Object.defineProperty(InlineTextBoxRole$1, "__esModule", {
        value: true
    });
    InlineTextBoxRole$1.default = void 0;
    var InlineTextBoxRole = {
        relatedConcepts: [
            {
                module: "HTML",
                concept: {
                    name: "input"
                }
            }
        ],
        type: "widget"
    };
    var _default$1f = InlineTextBoxRole;
    InlineTextBoxRole$1.default = _default$1f;
    var InputTimeRole$1 = {};
    Object.defineProperty(InputTimeRole$1, "__esModule", {
        value: true
    });
    InputTimeRole$1.default = void 0;
    var InputTimeRole = {
        relatedConcepts: [
            {
                module: "HTML",
                concept: {
                    name: "input",
                    attributes: [
                        {
                            name: "type",
                            value: "time"
                        }
                    ]
                }
            }
        ],
        type: "widget"
    };
    var _default$1e = InputTimeRole;
    InputTimeRole$1.default = _default$1e;
    var LabelRole$1 = {};
    Object.defineProperty(LabelRole$1, "__esModule", {
        value: true
    });
    LabelRole$1.default = void 0;
    var LabelRole = {
        relatedConcepts: [
            {
                module: "HTML",
                concept: {
                    name: "label"
                }
            }
        ],
        type: "structure"
    };
    var _default$1d = LabelRole;
    LabelRole$1.default = _default$1d;
    var LegendRole$1 = {};
    Object.defineProperty(LegendRole$1, "__esModule", {
        value: true
    });
    LegendRole$1.default = void 0;
    var LegendRole = {
        relatedConcepts: [
            {
                module: "HTML",
                concept: {
                    name: "legend"
                }
            }
        ],
        type: "structure"
    };
    var _default$1c = LegendRole;
    LegendRole$1.default = _default$1c;
    var LineBreakRole$1 = {};
    Object.defineProperty(LineBreakRole$1, "__esModule", {
        value: true
    });
    LineBreakRole$1.default = void 0;
    var LineBreakRole = {
        relatedConcepts: [
            {
                module: "HTML",
                concept: {
                    name: "br"
                }
            }
        ],
        type: "structure"
    };
    var _default$1b = LineBreakRole;
    LineBreakRole$1.default = _default$1b;
    var LinkRole$1 = {};
    Object.defineProperty(LinkRole$1, "__esModule", {
        value: true
    });
    LinkRole$1.default = void 0;
    var LinkRole = {
        relatedConcepts: [
            {
                module: "ARIA",
                concept: {
                    name: "link"
                }
            },
            {
                module: "HTML",
                concept: {
                    name: "a",
                    attributes: [
                        {
                            name: "href"
                        }
                    ]
                }
            }
        ],
        type: "widget"
    };
    var _default$1a = LinkRole;
    LinkRole$1.default = _default$1a;
    var ListBoxOptionRole$1 = {};
    Object.defineProperty(ListBoxOptionRole$1, "__esModule", {
        value: true
    });
    ListBoxOptionRole$1.default = void 0;
    var ListBoxOptionRole = {
        relatedConcepts: [
            {
                module: "ARIA",
                concept: {
                    name: "option"
                }
            },
            {
                module: "HTML",
                concept: {
                    name: "option"
                }
            }
        ],
        type: "widget"
    };
    var _default$19 = ListBoxOptionRole;
    ListBoxOptionRole$1.default = _default$19;
    var ListBoxRole$1 = {};
    Object.defineProperty(ListBoxRole$1, "__esModule", {
        value: true
    });
    ListBoxRole$1.default = void 0;
    var ListBoxRole = {
        relatedConcepts: [
            {
                module: "ARIA",
                concept: {
                    name: "listbox"
                }
            },
            {
                module: "HTML",
                concept: {
                    name: "datalist"
                }
            },
            {
                module: "HTML",
                concept: {
                    name: "select"
                }
            }
        ],
        type: "widget"
    };
    var _default$18 = ListBoxRole;
    ListBoxRole$1.default = _default$18;
    var ListItemRole$1 = {};
    Object.defineProperty(ListItemRole$1, "__esModule", {
        value: true
    });
    ListItemRole$1.default = void 0;
    var ListItemRole = {
        relatedConcepts: [
            {
                module: "ARIA",
                concept: {
                    name: "listitem"
                }
            },
            {
                module: "HTML",
                concept: {
                    name: "li"
                }
            }
        ],
        type: "structure"
    };
    var _default$17 = ListItemRole;
    ListItemRole$1.default = _default$17;
    var ListMarkerRole$1 = {};
    Object.defineProperty(ListMarkerRole$1, "__esModule", {
        value: true
    });
    ListMarkerRole$1.default = void 0;
    var ListMarkerRole = {
        relatedConcepts: [],
        type: "structure"
    };
    var _default$16 = ListMarkerRole;
    ListMarkerRole$1.default = _default$16;
    var ListRole$1 = {};
    Object.defineProperty(ListRole$1, "__esModule", {
        value: true
    });
    ListRole$1.default = void 0;
    var ListRole = {
        relatedConcepts: [
            {
                module: "ARIA",
                concept: {
                    name: "list"
                }
            },
            {
                module: "HTML",
                concept: {
                    name: "ul"
                }
            },
            {
                module: "HTML",
                concept: {
                    name: "ol"
                }
            }
        ],
        type: "structure"
    };
    var _default$15 = ListRole;
    ListRole$1.default = _default$15;
    var LogRole$1 = {};
    Object.defineProperty(LogRole$1, "__esModule", {
        value: true
    });
    LogRole$1.default = void 0;
    var LogRole = {
        relatedConcepts: [
            {
                module: "ARIA",
                concept: {
                    name: "log"
                }
            }
        ],
        type: "structure"
    };
    var _default$14 = LogRole;
    LogRole$1.default = _default$14;
    var MainRole$1 = {};
    Object.defineProperty(MainRole$1, "__esModule", {
        value: true
    });
    MainRole$1.default = void 0;
    var MainRole = {
        relatedConcepts: [
            {
                module: "ARIA",
                concept: {
                    name: "main"
                }
            },
            {
                module: "HTML",
                concept: {
                    name: "main"
                }
            }
        ],
        type: "structure"
    };
    var _default$13 = MainRole;
    MainRole$1.default = _default$13;
    var MarkRole$1 = {};
    Object.defineProperty(MarkRole$1, "__esModule", {
        value: true
    });
    MarkRole$1.default = void 0;
    var MarkRole = {
        relatedConcepts: [
            {
                module: "HTML",
                concept: {
                    name: "mark"
                }
            }
        ],
        type: "structure"
    };
    var _default$12 = MarkRole;
    MarkRole$1.default = _default$12;
    var MarqueeRole$1 = {};
    Object.defineProperty(MarqueeRole$1, "__esModule", {
        value: true
    });
    MarqueeRole$1.default = void 0;
    var MarqueeRole = {
        relatedConcepts: [
            {
                module: "ARIA",
                concept: {
                    name: "marquee"
                }
            },
            {
                module: "HTML",
                concept: {
                    name: "marquee"
                }
            }
        ],
        type: "structure"
    };
    var _default$11 = MarqueeRole;
    MarqueeRole$1.default = _default$11;
    var MathRole$1 = {};
    Object.defineProperty(MathRole$1, "__esModule", {
        value: true
    });
    MathRole$1.default = void 0;
    var MathRole = {
        relatedConcepts: [
            {
                module: "ARIA",
                concept: {
                    name: "math"
                }
            }
        ],
        type: "structure"
    };
    var _default$10 = MathRole;
    MathRole$1.default = _default$10;
    var MenuBarRole$1 = {};
    Object.defineProperty(MenuBarRole$1, "__esModule", {
        value: true
    });
    MenuBarRole$1.default = void 0;
    var MenuBarRole = {
        relatedConcepts: [
            {
                module: "ARIA",
                concept: {
                    name: "menubar"
                }
            }
        ],
        type: "structure"
    };
    var _default$$ = MenuBarRole;
    MenuBarRole$1.default = _default$$;
    var MenuButtonRole$1 = {};
    Object.defineProperty(MenuButtonRole$1, "__esModule", {
        value: true
    });
    MenuButtonRole$1.default = void 0;
    var MenuButtonRole = {
        relatedConcepts: [],
        type: "widget"
    };
    var _default$_ = MenuButtonRole;
    MenuButtonRole$1.default = _default$_;
    var MenuItemRole$1 = {};
    Object.defineProperty(MenuItemRole$1, "__esModule", {
        value: true
    });
    MenuItemRole$1.default = void 0;
    var MenuItemRole = {
        relatedConcepts: [
            {
                module: "ARIA",
                concept: {
                    name: "menuitem"
                }
            },
            {
                module: "HTML",
                concept: {
                    name: "menuitem"
                }
            }
        ],
        type: "widget"
    };
    var _default$Z = MenuItemRole;
    MenuItemRole$1.default = _default$Z;
    var MenuItemCheckBoxRole$1 = {};
    Object.defineProperty(MenuItemCheckBoxRole$1, "__esModule", {
        value: true
    });
    MenuItemCheckBoxRole$1.default = void 0;
    var MenuItemCheckBoxRole = {
        relatedConcepts: [
            {
                module: "ARIA",
                concept: {
                    name: "menuitemcheckbox"
                }
            }
        ],
        type: "widget"
    };
    var _default$Y = MenuItemCheckBoxRole;
    MenuItemCheckBoxRole$1.default = _default$Y;
    var MenuItemRadioRole$1 = {};
    Object.defineProperty(MenuItemRadioRole$1, "__esModule", {
        value: true
    });
    MenuItemRadioRole$1.default = void 0;
    var MenuItemRadioRole = {
        relatedConcepts: [
            {
                module: "ARIA",
                concept: {
                    name: "menuitemradio"
                }
            }
        ],
        type: "widget"
    };
    var _default$X = MenuItemRadioRole;
    MenuItemRadioRole$1.default = _default$X;
    var MenuListOptionRole$1 = {};
    Object.defineProperty(MenuListOptionRole$1, "__esModule", {
        value: true
    });
    MenuListOptionRole$1.default = void 0;
    var MenuListOptionRole = {
        relatedConcepts: [],
        type: "widget"
    };
    var _default$W = MenuListOptionRole;
    MenuListOptionRole$1.default = _default$W;
    var MenuListPopupRole$1 = {};
    Object.defineProperty(MenuListPopupRole$1, "__esModule", {
        value: true
    });
    MenuListPopupRole$1.default = void 0;
    var MenuListPopupRole = {
        relatedConcepts: [],
        type: "widget"
    };
    var _default$V = MenuListPopupRole;
    MenuListPopupRole$1.default = _default$V;
    var MenuRole$1 = {};
    Object.defineProperty(MenuRole$1, "__esModule", {
        value: true
    });
    MenuRole$1.default = void 0;
    var MenuRole = {
        relatedConcepts: [
            {
                module: "ARIA",
                concept: {
                    name: "menu"
                }
            },
            {
                module: "HTML",
                concept: {
                    name: "menu"
                }
            }
        ],
        type: "structure"
    };
    var _default$U = MenuRole;
    MenuRole$1.default = _default$U;
    var MeterRole$1 = {};
    Object.defineProperty(MeterRole$1, "__esModule", {
        value: true
    });
    MeterRole$1.default = void 0;
    var MeterRole = {
        relatedConcepts: [
            {
                module: "HTML",
                concept: {
                    name: "meter"
                }
            }
        ],
        type: "structure"
    };
    var _default$T = MeterRole;
    MeterRole$1.default = _default$T;
    var NavigationRole$1 = {};
    Object.defineProperty(NavigationRole$1, "__esModule", {
        value: true
    });
    NavigationRole$1.default = void 0;
    var NavigationRole = {
        relatedConcepts: [
            {
                module: "ARIA",
                concept: {
                    name: "navigation"
                }
            },
            {
                module: "HTML",
                concept: {
                    name: "nav"
                }
            }
        ],
        type: "structure"
    };
    var _default$S = NavigationRole;
    NavigationRole$1.default = _default$S;
    var NoneRole$1 = {};
    Object.defineProperty(NoneRole$1, "__esModule", {
        value: true
    });
    NoneRole$1.default = void 0;
    var NoneRole = {
        relatedConcepts: [
            {
                module: "ARIA",
                concept: {
                    name: "none"
                }
            }
        ],
        type: "structure"
    };
    var _default$R = NoneRole;
    NoneRole$1.default = _default$R;
    var NoteRole$1 = {};
    Object.defineProperty(NoteRole$1, "__esModule", {
        value: true
    });
    NoteRole$1.default = void 0;
    var NoteRole = {
        relatedConcepts: [
            {
                module: "ARIA",
                concept: {
                    name: "note"
                }
            }
        ],
        type: "structure"
    };
    var _default$Q = NoteRole;
    NoteRole$1.default = _default$Q;
    var OutlineRole$1 = {};
    Object.defineProperty(OutlineRole$1, "__esModule", {
        value: true
    });
    OutlineRole$1.default = void 0;
    var OutlineRole = {
        relatedConcepts: [],
        type: "structure"
    };
    var _default$P = OutlineRole;
    OutlineRole$1.default = _default$P;
    var ParagraphRole$1 = {};
    Object.defineProperty(ParagraphRole$1, "__esModule", {
        value: true
    });
    ParagraphRole$1.default = void 0;
    var ParagraphRole = {
        relatedConcepts: [
            {
                module: "HTML",
                concept: {
                    name: "p"
                }
            }
        ],
        type: "structure"
    };
    var _default$O = ParagraphRole;
    ParagraphRole$1.default = _default$O;
    var PopUpButtonRole$1 = {};
    Object.defineProperty(PopUpButtonRole$1, "__esModule", {
        value: true
    });
    PopUpButtonRole$1.default = void 0;
    var PopUpButtonRole = {
        relatedConcepts: [],
        type: "widget"
    };
    var _default$N = PopUpButtonRole;
    PopUpButtonRole$1.default = _default$N;
    var PreRole$1 = {};
    Object.defineProperty(PreRole$1, "__esModule", {
        value: true
    });
    PreRole$1.default = void 0;
    var PreRole = {
        relatedConcepts: [
            {
                module: "HTML",
                concept: {
                    name: "pre"
                }
            }
        ],
        type: "structure"
    };
    var _default$M = PreRole;
    PreRole$1.default = _default$M;
    var PresentationalRole$1 = {};
    Object.defineProperty(PresentationalRole$1, "__esModule", {
        value: true
    });
    PresentationalRole$1.default = void 0;
    var PresentationalRole = {
        relatedConcepts: [
            {
                module: "ARIA",
                concept: {
                    name: "presentation"
                }
            }
        ],
        type: "structure"
    };
    var _default$L = PresentationalRole;
    PresentationalRole$1.default = _default$L;
    var ProgressIndicatorRole$1 = {};
    Object.defineProperty(ProgressIndicatorRole$1, "__esModule", {
        value: true
    });
    ProgressIndicatorRole$1.default = void 0;
    var ProgressIndicatorRole = {
        relatedConcepts: [
            {
                module: "ARIA",
                concept: {
                    name: "progressbar"
                }
            },
            {
                module: "HTML",
                concept: {
                    name: "progress"
                }
            }
        ],
        type: "structure"
    };
    var _default$K = ProgressIndicatorRole;
    ProgressIndicatorRole$1.default = _default$K;
    var RadioButtonRole$1 = {};
    Object.defineProperty(RadioButtonRole$1, "__esModule", {
        value: true
    });
    RadioButtonRole$1.default = void 0;
    var RadioButtonRole = {
        relatedConcepts: [
            {
                module: "ARIA",
                concept: {
                    name: "radio"
                }
            },
            {
                module: "HTML",
                concept: {
                    name: "input",
                    attributes: [
                        {
                            name: "type",
                            value: "radio"
                        }
                    ]
                }
            }
        ],
        type: "widget"
    };
    var _default$J = RadioButtonRole;
    RadioButtonRole$1.default = _default$J;
    var RadioGroupRole$1 = {};
    Object.defineProperty(RadioGroupRole$1, "__esModule", {
        value: true
    });
    RadioGroupRole$1.default = void 0;
    var RadioGroupRole = {
        relatedConcepts: [
            {
                module: "ARIA",
                concept: {
                    name: "radiogroup"
                }
            }
        ],
        type: "structure"
    };
    var _default$I = RadioGroupRole;
    RadioGroupRole$1.default = _default$I;
    var RegionRole$1 = {};
    Object.defineProperty(RegionRole$1, "__esModule", {
        value: true
    });
    RegionRole$1.default = void 0;
    var RegionRole = {
        relatedConcepts: [
            {
                module: "ARIA",
                concept: {
                    name: "region"
                }
            }
        ],
        type: "structure"
    };
    var _default$H = RegionRole;
    RegionRole$1.default = _default$H;
    var RootWebAreaRole$1 = {};
    Object.defineProperty(RootWebAreaRole$1, "__esModule", {
        value: true
    });
    RootWebAreaRole$1.default = void 0;
    var RootWebAreaRole = {
        relatedConcepts: [],
        type: "structure"
    };
    var _default$G = RootWebAreaRole;
    RootWebAreaRole$1.default = _default$G;
    var RowHeaderRole$1 = {};
    Object.defineProperty(RowHeaderRole$1, "__esModule", {
        value: true
    });
    RowHeaderRole$1.default = void 0;
    var RowHeaderRole = {
        relatedConcepts: [
            {
                module: "ARIA",
                concept: {
                    name: "rowheader"
                }
            },
            {
                module: "HTML",
                concept: {
                    name: "th",
                    attributes: [
                        {
                            name: "scope",
                            value: "row"
                        }
                    ]
                }
            }
        ],
        type: "widget"
    };
    var _default$F = RowHeaderRole;
    RowHeaderRole$1.default = _default$F;
    var RowRole$1 = {};
    Object.defineProperty(RowRole$1, "__esModule", {
        value: true
    });
    RowRole$1.default = void 0;
    var RowRole = {
        relatedConcepts: [
            {
                module: "ARIA",
                concept: {
                    name: "row"
                }
            },
            {
                module: "HTML",
                concept: {
                    name: "tr"
                }
            }
        ],
        type: "structure"
    };
    var _default$E = RowRole;
    RowRole$1.default = _default$E;
    var RubyRole$1 = {};
    Object.defineProperty(RubyRole$1, "__esModule", {
        value: true
    });
    RubyRole$1.default = void 0;
    var RubyRole = {
        relatedConcepts: [
            {
                module: "HTML",
                concept: {
                    name: "ruby"
                }
            }
        ],
        type: "structure"
    };
    var _default$D = RubyRole;
    RubyRole$1.default = _default$D;
    var RulerRole$1 = {};
    Object.defineProperty(RulerRole$1, "__esModule", {
        value: true
    });
    RulerRole$1.default = void 0;
    var RulerRole = {
        relatedConcepts: [],
        type: "structure"
    };
    var _default$C = RulerRole;
    RulerRole$1.default = _default$C;
    var ScrollAreaRole$1 = {};
    Object.defineProperty(ScrollAreaRole$1, "__esModule", {
        value: true
    });
    ScrollAreaRole$1.default = void 0;
    var ScrollAreaRole = {
        relatedConcepts: [],
        type: "structure"
    };
    var _default$B = ScrollAreaRole;
    ScrollAreaRole$1.default = _default$B;
    var ScrollBarRole$1 = {};
    Object.defineProperty(ScrollBarRole$1, "__esModule", {
        value: true
    });
    ScrollBarRole$1.default = void 0;
    var ScrollBarRole = {
        relatedConcepts: [
            {
                module: "ARIA",
                concept: {
                    name: "scrollbar"
                }
            }
        ],
        type: "widget"
    };
    var _default$A = ScrollBarRole;
    ScrollBarRole$1.default = _default$A;
    var SeamlessWebAreaRole$1 = {};
    Object.defineProperty(SeamlessWebAreaRole$1, "__esModule", {
        value: true
    });
    SeamlessWebAreaRole$1.default = void 0;
    var SeamlessWebAreaRole = {
        relatedConcepts: [],
        type: "structure"
    };
    var _default$z = SeamlessWebAreaRole;
    SeamlessWebAreaRole$1.default = _default$z;
    var SearchRole$1 = {};
    Object.defineProperty(SearchRole$1, "__esModule", {
        value: true
    });
    SearchRole$1.default = void 0;
    var SearchRole = {
        relatedConcepts: [
            {
                module: "ARIA",
                concept: {
                    name: "search"
                }
            }
        ],
        type: "structure"
    };
    var _default$y = SearchRole;
    SearchRole$1.default = _default$y;
    var SearchBoxRole$1 = {};
    Object.defineProperty(SearchBoxRole$1, "__esModule", {
        value: true
    });
    SearchBoxRole$1.default = void 0;
    var SearchBoxRole = {
        relatedConcepts: [
            {
                module: "ARIA",
                concept: {
                    name: "searchbox"
                }
            },
            {
                module: "HTML",
                concept: {
                    name: "input",
                    attributes: [
                        {
                            name: "type",
                            value: "search"
                        }
                    ]
                }
            }
        ],
        type: "widget"
    };
    var _default$x = SearchBoxRole;
    SearchBoxRole$1.default = _default$x;
    var SliderRole$1 = {};
    Object.defineProperty(SliderRole$1, "__esModule", {
        value: true
    });
    SliderRole$1.default = void 0;
    var SliderRole = {
        relatedConcepts: [
            {
                module: "ARIA",
                concept: {
                    name: "slider"
                }
            },
            {
                module: "HTML",
                concept: {
                    name: "input",
                    attributes: [
                        {
                            name: "type",
                            value: "range"
                        }
                    ]
                }
            }
        ],
        type: "widget"
    };
    var _default$w = SliderRole;
    SliderRole$1.default = _default$w;
    var SliderThumbRole$1 = {};
    Object.defineProperty(SliderThumbRole$1, "__esModule", {
        value: true
    });
    SliderThumbRole$1.default = void 0;
    var SliderThumbRole = {
        relatedConcepts: [],
        type: "structure"
    };
    var _default$v = SliderThumbRole;
    SliderThumbRole$1.default = _default$v;
    var SpinButtonRole$1 = {};
    Object.defineProperty(SpinButtonRole$1, "__esModule", {
        value: true
    });
    SpinButtonRole$1.default = void 0;
    var SpinButtonRole = {
        relatedConcepts: [
            {
                module: "ARIA",
                concept: {
                    name: "spinbutton"
                }
            },
            {
                module: "HTML",
                concept: {
                    name: "input",
                    attributes: [
                        {
                            name: "type",
                            value: "number"
                        }
                    ]
                }
            }
        ],
        type: "widget"
    };
    var _default$u = SpinButtonRole;
    SpinButtonRole$1.default = _default$u;
    var SpinButtonPartRole$1 = {};
    Object.defineProperty(SpinButtonPartRole$1, "__esModule", {
        value: true
    });
    SpinButtonPartRole$1.default = void 0;
    var SpinButtonPartRole = {
        relatedConcepts: [],
        type: "structure"
    };
    var _default$t = SpinButtonPartRole;
    SpinButtonPartRole$1.default = _default$t;
    var SplitterRole$1 = {};
    Object.defineProperty(SplitterRole$1, "__esModule", {
        value: true
    });
    SplitterRole$1.default = void 0;
    var SplitterRole = {
        relatedConcepts: [
            {
                module: "ARIA",
                concept: {
                    name: "separator"
                }
            }
        ],
        type: "widget"
    };
    var _default$s = SplitterRole;
    SplitterRole$1.default = _default$s;
    var StaticTextRole$1 = {};
    Object.defineProperty(StaticTextRole$1, "__esModule", {
        value: true
    });
    StaticTextRole$1.default = void 0;
    var StaticTextRole = {
        relatedConcepts: [],
        type: "structure"
    };
    var _default$r = StaticTextRole;
    StaticTextRole$1.default = _default$r;
    var StatusRole$1 = {};
    Object.defineProperty(StatusRole$1, "__esModule", {
        value: true
    });
    StatusRole$1.default = void 0;
    var StatusRole = {
        relatedConcepts: [
            {
                module: "ARIA",
                concept: {
                    name: "status"
                }
            }
        ],
        type: "structure"
    };
    var _default$q = StatusRole;
    StatusRole$1.default = _default$q;
    var SVGRootRole$1 = {};
    Object.defineProperty(SVGRootRole$1, "__esModule", {
        value: true
    });
    SVGRootRole$1.default = void 0;
    var SVGRootRole = {
        relatedConcepts: [],
        type: "structure"
    };
    var _default$p = SVGRootRole;
    SVGRootRole$1.default = _default$p;
    var SwitchRole$1 = {};
    Object.defineProperty(SwitchRole$1, "__esModule", {
        value: true
    });
    SwitchRole$1.default = void 0;
    var SwitchRole = {
        relatedConcepts: [
            {
                module: "ARIA",
                concept: {
                    name: "switch"
                }
            },
            {
                module: "HTML",
                concept: {
                    name: "input",
                    attributes: [
                        {
                            name: "type",
                            value: "checkbox"
                        }
                    ]
                }
            }
        ],
        type: "widget"
    };
    var _default$o = SwitchRole;
    SwitchRole$1.default = _default$o;
    var TabGroupRole$1 = {};
    Object.defineProperty(TabGroupRole$1, "__esModule", {
        value: true
    });
    TabGroupRole$1.default = void 0;
    var TabGroupRole = {
        relatedConcepts: [
            {
                module: "ARIA",
                concept: {
                    name: "tablist"
                }
            }
        ],
        type: "structure"
    };
    var _default$n = TabGroupRole;
    TabGroupRole$1.default = _default$n;
    var TabRole$1 = {};
    Object.defineProperty(TabRole$1, "__esModule", {
        value: true
    });
    TabRole$1.default = void 0;
    var TabRole = {
        relatedConcepts: [
            {
                module: "ARIA",
                concept: {
                    name: "tab"
                }
            }
        ],
        type: "widget"
    };
    var _default$m = TabRole;
    TabRole$1.default = _default$m;
    var TableHeaderContainerRole$1 = {};
    Object.defineProperty(TableHeaderContainerRole$1, "__esModule", {
        value: true
    });
    TableHeaderContainerRole$1.default = void 0;
    var TableHeaderContainerRole = {
        relatedConcepts: [],
        type: "structure"
    };
    var _default$l = TableHeaderContainerRole;
    TableHeaderContainerRole$1.default = _default$l;
    var TableRole$1 = {};
    Object.defineProperty(TableRole$1, "__esModule", {
        value: true
    });
    TableRole$1.default = void 0;
    var TableRole = {
        relatedConcepts: [
            {
                module: "ARIA",
                concept: {
                    name: "table"
                }
            },
            {
                module: "HTML",
                concept: {
                    name: "table"
                }
            }
        ],
        type: "structure"
    };
    var _default$k = TableRole;
    TableRole$1.default = _default$k;
    var TabListRole$1 = {};
    Object.defineProperty(TabListRole$1, "__esModule", {
        value: true
    });
    TabListRole$1.default = void 0;
    var TabListRole = {
        relatedConcepts: [
            {
                module: "ARIA",
                concept: {
                    name: "tablist"
                }
            }
        ],
        type: "structure"
    };
    var _default$j = TabListRole;
    TabListRole$1.default = _default$j;
    var TabPanelRole$1 = {};
    Object.defineProperty(TabPanelRole$1, "__esModule", {
        value: true
    });
    TabPanelRole$1.default = void 0;
    var TabPanelRole = {
        relatedConcepts: [
            {
                module: "ARIA",
                concept: {
                    name: "tabpanel"
                }
            }
        ],
        type: "structure"
    };
    var _default$i = TabPanelRole;
    TabPanelRole$1.default = _default$i;
    var TermRole$1 = {};
    Object.defineProperty(TermRole$1, "__esModule", {
        value: true
    });
    TermRole$1.default = void 0;
    var TermRole = {
        relatedConcepts: [
            {
                module: "ARIA",
                concept: {
                    name: "term"
                }
            }
        ],
        type: "structure"
    };
    var _default$h = TermRole;
    TermRole$1.default = _default$h;
    var TextAreaRole$1 = {};
    Object.defineProperty(TextAreaRole$1, "__esModule", {
        value: true
    });
    TextAreaRole$1.default = void 0;
    var TextAreaRole = {
        relatedConcepts: [
            {
                module: "ARIA",
                concept: {
                    attributes: [
                        {
                            name: "aria-multiline",
                            value: "true"
                        }
                    ],
                    name: "textbox"
                }
            },
            {
                module: "HTML",
                concept: {
                    name: "textarea"
                }
            }
        ],
        type: "widget"
    };
    var _default$g = TextAreaRole;
    TextAreaRole$1.default = _default$g;
    var TextFieldRole$1 = {};
    Object.defineProperty(TextFieldRole$1, "__esModule", {
        value: true
    });
    TextFieldRole$1.default = void 0;
    var TextFieldRole = {
        relatedConcepts: [
            {
                module: "ARIA",
                concept: {
                    name: "textbox"
                }
            },
            {
                module: "HTML",
                concept: {
                    name: "input"
                }
            },
            {
                module: "HTML",
                concept: {
                    name: "input",
                    attributes: [
                        {
                            name: "type",
                            value: "text"
                        }
                    ]
                }
            }
        ],
        type: "widget"
    };
    var _default$f = TextFieldRole;
    TextFieldRole$1.default = _default$f;
    var TimeRole$1 = {};
    Object.defineProperty(TimeRole$1, "__esModule", {
        value: true
    });
    TimeRole$1.default = void 0;
    var TimeRole = {
        relatedConcepts: [
            {
                module: "HTML",
                concept: {
                    name: "time"
                }
            }
        ],
        type: "structure"
    };
    var _default$e = TimeRole;
    TimeRole$1.default = _default$e;
    var TimerRole$1 = {};
    Object.defineProperty(TimerRole$1, "__esModule", {
        value: true
    });
    TimerRole$1.default = void 0;
    var TimerRole = {
        relatedConcepts: [
            {
                module: "ARIA",
                concept: {
                    name: "timer"
                }
            }
        ],
        type: "structure"
    };
    var _default$d = TimerRole;
    TimerRole$1.default = _default$d;
    var ToggleButtonRole$1 = {};
    Object.defineProperty(ToggleButtonRole$1, "__esModule", {
        value: true
    });
    ToggleButtonRole$1.default = void 0;
    var ToggleButtonRole = {
        relatedConcepts: [
            {
                module: "ARIA",
                concept: {
                    attributes: [
                        {
                            name: "aria-pressed"
                        }
                    ]
                }
            }
        ],
        type: "widget"
    };
    var _default$c = ToggleButtonRole;
    ToggleButtonRole$1.default = _default$c;
    var ToolbarRole$1 = {};
    Object.defineProperty(ToolbarRole$1, "__esModule", {
        value: true
    });
    ToolbarRole$1.default = void 0;
    var ToolbarRole = {
        relatedConcepts: [
            {
                module: "ARIA",
                concept: {
                    name: "toolbar"
                }
            }
        ],
        type: "structure"
    };
    var _default$b = ToolbarRole;
    ToolbarRole$1.default = _default$b;
    var TreeRole$1 = {};
    Object.defineProperty(TreeRole$1, "__esModule", {
        value: true
    });
    TreeRole$1.default = void 0;
    var TreeRole = {
        relatedConcepts: [
            {
                module: "ARIA",
                concept: {
                    name: "tree"
                }
            }
        ],
        type: "widget"
    };
    var _default$a = TreeRole;
    TreeRole$1.default = _default$a;
    var TreeGridRole$1 = {};
    Object.defineProperty(TreeGridRole$1, "__esModule", {
        value: true
    });
    TreeGridRole$1.default = void 0;
    var TreeGridRole = {
        relatedConcepts: [
            {
                module: "ARIA",
                concept: {
                    name: "treegrid"
                }
            }
        ],
        type: "widget"
    };
    var _default$9 = TreeGridRole;
    TreeGridRole$1.default = _default$9;
    var TreeItemRole$1 = {};
    Object.defineProperty(TreeItemRole$1, "__esModule", {
        value: true
    });
    TreeItemRole$1.default = void 0;
    var TreeItemRole = {
        relatedConcepts: [
            {
                module: "ARIA",
                concept: {
                    name: "treeitem"
                }
            }
        ],
        type: "widget"
    };
    var _default$8 = TreeItemRole;
    TreeItemRole$1.default = _default$8;
    var UserInterfaceTooltipRole$1 = {};
    Object.defineProperty(UserInterfaceTooltipRole$1, "__esModule", {
        value: true
    });
    UserInterfaceTooltipRole$1.default = void 0;
    var UserInterfaceTooltipRole = {
        relatedConcepts: [
            {
                module: "ARIA",
                concept: {
                    name: "tooltip"
                }
            }
        ],
        type: "structure"
    };
    var _default$7 = UserInterfaceTooltipRole;
    UserInterfaceTooltipRole$1.default = _default$7;
    var VideoRole$1 = {};
    Object.defineProperty(VideoRole$1, "__esModule", {
        value: true
    });
    VideoRole$1.default = void 0;
    var VideoRole = {
        relatedConcepts: [
            {
                module: "HTML",
                concept: {
                    name: "video"
                }
            }
        ],
        type: "widget"
    };
    var _default$6 = VideoRole;
    VideoRole$1.default = _default$6;
    var WebAreaRole$1 = {};
    Object.defineProperty(WebAreaRole$1, "__esModule", {
        value: true
    });
    WebAreaRole$1.default = void 0;
    var WebAreaRole = {
        relatedConcepts: [],
        type: "structure"
    };
    var _default$5 = WebAreaRole;
    WebAreaRole$1.default = _default$5;
    var WindowRole$1 = {};
    Object.defineProperty(WindowRole$1, "__esModule", {
        value: true
    });
    WindowRole$1.default = void 0;
    var WindowRole = {
        relatedConcepts: [],
        type: "window"
    };
    var _default$4 = WindowRole;
    WindowRole$1.default = _default$4;
    Object.defineProperty(AXObjectsMap$1, "__esModule", {
        value: true
    });
    AXObjectsMap$1.default = void 0;
    var _iterationDecorator$3 = _interopRequireDefault$4(iterationDecorator$1);
    var _AbbrRole = _interopRequireDefault$4(AbbrRole$1);
    var _AlertDialogRole = _interopRequireDefault$4(AlertDialogRole$1);
    var _AlertRole = _interopRequireDefault$4(AlertRole$1);
    var _AnnotationRole = _interopRequireDefault$4(AnnotationRole$1);
    var _ApplicationRole = _interopRequireDefault$4(ApplicationRole$1);
    var _ArticleRole = _interopRequireDefault$4(ArticleRole$1);
    var _AudioRole = _interopRequireDefault$4(AudioRole$1);
    var _BannerRole = _interopRequireDefault$4(BannerRole$1);
    var _BlockquoteRole = _interopRequireDefault$4(BlockquoteRole$1);
    var _BusyIndicatorRole = _interopRequireDefault$4(BusyIndicatorRole$1);
    var _ButtonRole = _interopRequireDefault$4(ButtonRole$1);
    var _CanvasRole = _interopRequireDefault$4(CanvasRole$1);
    var _CaptionRole = _interopRequireDefault$4(CaptionRole$1);
    var _CellRole = _interopRequireDefault$4(CellRole$1);
    var _CheckBoxRole = _interopRequireDefault$4(CheckBoxRole$1);
    var _ColorWellRole = _interopRequireDefault$4(ColorWellRole$1);
    var _ColumnHeaderRole = _interopRequireDefault$4(ColumnHeaderRole$1);
    var _ColumnRole = _interopRequireDefault$4(ColumnRole$1);
    var _ComboBoxRole = _interopRequireDefault$4(ComboBoxRole$1);
    var _ComplementaryRole = _interopRequireDefault$4(ComplementaryRole$1);
    var _ContentInfoRole = _interopRequireDefault$4(ContentInfoRole$1);
    var _DateRole = _interopRequireDefault$4(DateRole$1);
    var _DateTimeRole = _interopRequireDefault$4(DateTimeRole$1);
    var _DefinitionRole = _interopRequireDefault$4(DefinitionRole$1);
    var _DescriptionListDetailRole = _interopRequireDefault$4(DescriptionListDetailRole$1);
    var _DescriptionListRole = _interopRequireDefault$4(DescriptionListRole$1);
    var _DescriptionListTermRole = _interopRequireDefault$4(DescriptionListTermRole$1);
    var _DetailsRole = _interopRequireDefault$4(DetailsRole$1);
    var _DialogRole = _interopRequireDefault$4(DialogRole$1);
    var _DirectoryRole = _interopRequireDefault$4(DirectoryRole$1);
    var _DisclosureTriangleRole = _interopRequireDefault$4(DisclosureTriangleRole$1);
    var _DivRole = _interopRequireDefault$4(DivRole$1);
    var _DocumentRole = _interopRequireDefault$4(DocumentRole$1);
    var _EmbeddedObjectRole = _interopRequireDefault$4(EmbeddedObjectRole$1);
    var _FeedRole = _interopRequireDefault$4(FeedRole$1);
    var _FigcaptionRole = _interopRequireDefault$4(FigcaptionRole$1);
    var _FigureRole = _interopRequireDefault$4(FigureRole$1);
    var _FooterRole = _interopRequireDefault$4(FooterRole$1);
    var _FormRole = _interopRequireDefault$4(FormRole$1);
    var _GridRole = _interopRequireDefault$4(GridRole$1);
    var _GroupRole = _interopRequireDefault$4(GroupRole$1);
    var _HeadingRole = _interopRequireDefault$4(HeadingRole$1);
    var _IframePresentationalRole = _interopRequireDefault$4(IframePresentationalRole$1);
    var _IframeRole = _interopRequireDefault$4(IframeRole$1);
    var _IgnoredRole = _interopRequireDefault$4(IgnoredRole$1);
    var _ImageMapLinkRole = _interopRequireDefault$4(ImageMapLinkRole$1);
    var _ImageMapRole = _interopRequireDefault$4(ImageMapRole$1);
    var _ImageRole = _interopRequireDefault$4(ImageRole$1);
    var _InlineTextBoxRole = _interopRequireDefault$4(InlineTextBoxRole$1);
    var _InputTimeRole = _interopRequireDefault$4(InputTimeRole$1);
    var _LabelRole = _interopRequireDefault$4(LabelRole$1);
    var _LegendRole = _interopRequireDefault$4(LegendRole$1);
    var _LineBreakRole = _interopRequireDefault$4(LineBreakRole$1);
    var _LinkRole = _interopRequireDefault$4(LinkRole$1);
    var _ListBoxOptionRole = _interopRequireDefault$4(ListBoxOptionRole$1);
    var _ListBoxRole = _interopRequireDefault$4(ListBoxRole$1);
    var _ListItemRole = _interopRequireDefault$4(ListItemRole$1);
    var _ListMarkerRole = _interopRequireDefault$4(ListMarkerRole$1);
    var _ListRole = _interopRequireDefault$4(ListRole$1);
    var _LogRole = _interopRequireDefault$4(LogRole$1);
    var _MainRole = _interopRequireDefault$4(MainRole$1);
    var _MarkRole = _interopRequireDefault$4(MarkRole$1);
    var _MarqueeRole = _interopRequireDefault$4(MarqueeRole$1);
    var _MathRole = _interopRequireDefault$4(MathRole$1);
    var _MenuBarRole = _interopRequireDefault$4(MenuBarRole$1);
    var _MenuButtonRole = _interopRequireDefault$4(MenuButtonRole$1);
    var _MenuItemRole = _interopRequireDefault$4(MenuItemRole$1);
    var _MenuItemCheckBoxRole = _interopRequireDefault$4(MenuItemCheckBoxRole$1);
    var _MenuItemRadioRole = _interopRequireDefault$4(MenuItemRadioRole$1);
    var _MenuListOptionRole = _interopRequireDefault$4(MenuListOptionRole$1);
    var _MenuListPopupRole = _interopRequireDefault$4(MenuListPopupRole$1);
    var _MenuRole = _interopRequireDefault$4(MenuRole$1);
    var _MeterRole = _interopRequireDefault$4(MeterRole$1);
    var _NavigationRole = _interopRequireDefault$4(NavigationRole$1);
    var _NoneRole = _interopRequireDefault$4(NoneRole$1);
    var _NoteRole = _interopRequireDefault$4(NoteRole$1);
    var _OutlineRole = _interopRequireDefault$4(OutlineRole$1);
    var _ParagraphRole = _interopRequireDefault$4(ParagraphRole$1);
    var _PopUpButtonRole = _interopRequireDefault$4(PopUpButtonRole$1);
    var _PreRole = _interopRequireDefault$4(PreRole$1);
    var _PresentationalRole = _interopRequireDefault$4(PresentationalRole$1);
    var _ProgressIndicatorRole = _interopRequireDefault$4(ProgressIndicatorRole$1);
    var _RadioButtonRole = _interopRequireDefault$4(RadioButtonRole$1);
    var _RadioGroupRole = _interopRequireDefault$4(RadioGroupRole$1);
    var _RegionRole = _interopRequireDefault$4(RegionRole$1);
    var _RootWebAreaRole = _interopRequireDefault$4(RootWebAreaRole$1);
    var _RowHeaderRole = _interopRequireDefault$4(RowHeaderRole$1);
    var _RowRole = _interopRequireDefault$4(RowRole$1);
    var _RubyRole = _interopRequireDefault$4(RubyRole$1);
    var _RulerRole = _interopRequireDefault$4(RulerRole$1);
    var _ScrollAreaRole = _interopRequireDefault$4(ScrollAreaRole$1);
    var _ScrollBarRole = _interopRequireDefault$4(ScrollBarRole$1);
    var _SeamlessWebAreaRole = _interopRequireDefault$4(SeamlessWebAreaRole$1);
    var _SearchRole = _interopRequireDefault$4(SearchRole$1);
    var _SearchBoxRole = _interopRequireDefault$4(SearchBoxRole$1);
    var _SliderRole = _interopRequireDefault$4(SliderRole$1);
    var _SliderThumbRole = _interopRequireDefault$4(SliderThumbRole$1);
    var _SpinButtonRole = _interopRequireDefault$4(SpinButtonRole$1);
    var _SpinButtonPartRole = _interopRequireDefault$4(SpinButtonPartRole$1);
    var _SplitterRole = _interopRequireDefault$4(SplitterRole$1);
    var _StaticTextRole = _interopRequireDefault$4(StaticTextRole$1);
    var _StatusRole = _interopRequireDefault$4(StatusRole$1);
    var _SVGRootRole = _interopRequireDefault$4(SVGRootRole$1);
    var _SwitchRole = _interopRequireDefault$4(SwitchRole$1);
    var _TabGroupRole = _interopRequireDefault$4(TabGroupRole$1);
    var _TabRole = _interopRequireDefault$4(TabRole$1);
    var _TableHeaderContainerRole = _interopRequireDefault$4(TableHeaderContainerRole$1);
    var _TableRole = _interopRequireDefault$4(TableRole$1);
    var _TabListRole = _interopRequireDefault$4(TabListRole$1);
    var _TabPanelRole = _interopRequireDefault$4(TabPanelRole$1);
    var _TermRole = _interopRequireDefault$4(TermRole$1);
    var _TextAreaRole = _interopRequireDefault$4(TextAreaRole$1);
    var _TextFieldRole = _interopRequireDefault$4(TextFieldRole$1);
    var _TimeRole = _interopRequireDefault$4(TimeRole$1);
    var _TimerRole = _interopRequireDefault$4(TimerRole$1);
    var _ToggleButtonRole = _interopRequireDefault$4(ToggleButtonRole$1);
    var _ToolbarRole = _interopRequireDefault$4(ToolbarRole$1);
    var _TreeRole = _interopRequireDefault$4(TreeRole$1);
    var _TreeGridRole = _interopRequireDefault$4(TreeGridRole$1);
    var _TreeItemRole = _interopRequireDefault$4(TreeItemRole$1);
    var _UserInterfaceTooltipRole = _interopRequireDefault$4(UserInterfaceTooltipRole$1);
    var _VideoRole = _interopRequireDefault$4(VideoRole$1);
    var _WebAreaRole = _interopRequireDefault$4(WebAreaRole$1);
    var _WindowRole = _interopRequireDefault$4(WindowRole$1);
    function _interopRequireDefault$4(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    function _slicedToArray$3(arr, i) {
        return _arrayWithHoles$3(arr) || _iterableToArrayLimit$3(arr, i) || _unsupportedIterableToArray$3(arr, i) || _nonIterableRest$3();
    }
    function _nonIterableRest$3() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _iterableToArrayLimit$3(arr, i) {
        var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
        if (_i == null) return;
        var _arr = [];
        var _n = true;
        var _d = false;
        var _s, _e;
        try {
            for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){
                _arr.push(_s.value);
                if (i && _arr.length === i) break;
            }
        } catch (err) {
            _d = true;
            _e = err;
        } finally{
            try {
                if (!_n && _i["return"] != null) _i["return"]();
            } finally{
                if (_d) throw _e;
            }
        }
        return _arr;
    }
    function _arrayWithHoles$3(arr) {
        if (Array.isArray(arr)) return arr;
    }
    function _createForOfIteratorHelper$3(o, allowArrayLike) {
        var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
        if (!it) {
            if (Array.isArray(o) || (it = _unsupportedIterableToArray$3(o)) || allowArrayLike && o && typeof o.length === "number") {
                if (it) o = it;
                var i = 0;
                var F = function F() {};
                return {
                    s: F,
                    n: function n() {
                        if (i >= o.length) return {
                            done: true
                        };
                        return {
                            done: false,
                            value: o[i++]
                        };
                    },
                    e: function e(_e2) {
                        throw _e2;
                    },
                    f: F
                };
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var normalCompletion = true, didErr = false, err;
        return {
            s: function s() {
                it = it.call(o);
            },
            n: function n() {
                var step = it.next();
                normalCompletion = step.done;
                return step;
            },
            e: function e(_e3) {
                didErr = true;
                err = _e3;
            },
            f: function f() {
                try {
                    if (!normalCompletion && it.return != null) it.return();
                } finally{
                    if (didErr) throw err;
                }
            }
        };
    }
    function _unsupportedIterableToArray$3(o, minLen) {
        if (!o) return;
        if (typeof o === "string") return _arrayLikeToArray$3(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor) n = o.constructor.name;
        if (n === "Map" || n === "Set") return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$3(o, minLen);
    }
    function _arrayLikeToArray$3(arr, len) {
        if (len == null || len > arr.length) len = arr.length;
        for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
        return arr2;
    }
    var AXObjects$1 = [
        [
            "AbbrRole",
            _AbbrRole.default
        ],
        [
            "AlertDialogRole",
            _AlertDialogRole.default
        ],
        [
            "AlertRole",
            _AlertRole.default
        ],
        [
            "AnnotationRole",
            _AnnotationRole.default
        ],
        [
            "ApplicationRole",
            _ApplicationRole.default
        ],
        [
            "ArticleRole",
            _ArticleRole.default
        ],
        [
            "AudioRole",
            _AudioRole.default
        ],
        [
            "BannerRole",
            _BannerRole.default
        ],
        [
            "BlockquoteRole",
            _BlockquoteRole.default
        ],
        [
            "BusyIndicatorRole",
            _BusyIndicatorRole.default
        ],
        [
            "ButtonRole",
            _ButtonRole.default
        ],
        [
            "CanvasRole",
            _CanvasRole.default
        ],
        [
            "CaptionRole",
            _CaptionRole.default
        ],
        [
            "CellRole",
            _CellRole.default
        ],
        [
            "CheckBoxRole",
            _CheckBoxRole.default
        ],
        [
            "ColorWellRole",
            _ColorWellRole.default
        ],
        [
            "ColumnHeaderRole",
            _ColumnHeaderRole.default
        ],
        [
            "ColumnRole",
            _ColumnRole.default
        ],
        [
            "ComboBoxRole",
            _ComboBoxRole.default
        ],
        [
            "ComplementaryRole",
            _ComplementaryRole.default
        ],
        [
            "ContentInfoRole",
            _ContentInfoRole.default
        ],
        [
            "DateRole",
            _DateRole.default
        ],
        [
            "DateTimeRole",
            _DateTimeRole.default
        ],
        [
            "DefinitionRole",
            _DefinitionRole.default
        ],
        [
            "DescriptionListDetailRole",
            _DescriptionListDetailRole.default
        ],
        [
            "DescriptionListRole",
            _DescriptionListRole.default
        ],
        [
            "DescriptionListTermRole",
            _DescriptionListTermRole.default
        ],
        [
            "DetailsRole",
            _DetailsRole.default
        ],
        [
            "DialogRole",
            _DialogRole.default
        ],
        [
            "DirectoryRole",
            _DirectoryRole.default
        ],
        [
            "DisclosureTriangleRole",
            _DisclosureTriangleRole.default
        ],
        [
            "DivRole",
            _DivRole.default
        ],
        [
            "DocumentRole",
            _DocumentRole.default
        ],
        [
            "EmbeddedObjectRole",
            _EmbeddedObjectRole.default
        ],
        [
            "FeedRole",
            _FeedRole.default
        ],
        [
            "FigcaptionRole",
            _FigcaptionRole.default
        ],
        [
            "FigureRole",
            _FigureRole.default
        ],
        [
            "FooterRole",
            _FooterRole.default
        ],
        [
            "FormRole",
            _FormRole.default
        ],
        [
            "GridRole",
            _GridRole.default
        ],
        [
            "GroupRole",
            _GroupRole.default
        ],
        [
            "HeadingRole",
            _HeadingRole.default
        ],
        [
            "IframePresentationalRole",
            _IframePresentationalRole.default
        ],
        [
            "IframeRole",
            _IframeRole.default
        ],
        [
            "IgnoredRole",
            _IgnoredRole.default
        ],
        [
            "ImageMapLinkRole",
            _ImageMapLinkRole.default
        ],
        [
            "ImageMapRole",
            _ImageMapRole.default
        ],
        [
            "ImageRole",
            _ImageRole.default
        ],
        [
            "InlineTextBoxRole",
            _InlineTextBoxRole.default
        ],
        [
            "InputTimeRole",
            _InputTimeRole.default
        ],
        [
            "LabelRole",
            _LabelRole.default
        ],
        [
            "LegendRole",
            _LegendRole.default
        ],
        [
            "LineBreakRole",
            _LineBreakRole.default
        ],
        [
            "LinkRole",
            _LinkRole.default
        ],
        [
            "ListBoxOptionRole",
            _ListBoxOptionRole.default
        ],
        [
            "ListBoxRole",
            _ListBoxRole.default
        ],
        [
            "ListItemRole",
            _ListItemRole.default
        ],
        [
            "ListMarkerRole",
            _ListMarkerRole.default
        ],
        [
            "ListRole",
            _ListRole.default
        ],
        [
            "LogRole",
            _LogRole.default
        ],
        [
            "MainRole",
            _MainRole.default
        ],
        [
            "MarkRole",
            _MarkRole.default
        ],
        [
            "MarqueeRole",
            _MarqueeRole.default
        ],
        [
            "MathRole",
            _MathRole.default
        ],
        [
            "MenuBarRole",
            _MenuBarRole.default
        ],
        [
            "MenuButtonRole",
            _MenuButtonRole.default
        ],
        [
            "MenuItemRole",
            _MenuItemRole.default
        ],
        [
            "MenuItemCheckBoxRole",
            _MenuItemCheckBoxRole.default
        ],
        [
            "MenuItemRadioRole",
            _MenuItemRadioRole.default
        ],
        [
            "MenuListOptionRole",
            _MenuListOptionRole.default
        ],
        [
            "MenuListPopupRole",
            _MenuListPopupRole.default
        ],
        [
            "MenuRole",
            _MenuRole.default
        ],
        [
            "MeterRole",
            _MeterRole.default
        ],
        [
            "NavigationRole",
            _NavigationRole.default
        ],
        [
            "NoneRole",
            _NoneRole.default
        ],
        [
            "NoteRole",
            _NoteRole.default
        ],
        [
            "OutlineRole",
            _OutlineRole.default
        ],
        [
            "ParagraphRole",
            _ParagraphRole.default
        ],
        [
            "PopUpButtonRole",
            _PopUpButtonRole.default
        ],
        [
            "PreRole",
            _PreRole.default
        ],
        [
            "PresentationalRole",
            _PresentationalRole.default
        ],
        [
            "ProgressIndicatorRole",
            _ProgressIndicatorRole.default
        ],
        [
            "RadioButtonRole",
            _RadioButtonRole.default
        ],
        [
            "RadioGroupRole",
            _RadioGroupRole.default
        ],
        [
            "RegionRole",
            _RegionRole.default
        ],
        [
            "RootWebAreaRole",
            _RootWebAreaRole.default
        ],
        [
            "RowHeaderRole",
            _RowHeaderRole.default
        ],
        [
            "RowRole",
            _RowRole.default
        ],
        [
            "RubyRole",
            _RubyRole.default
        ],
        [
            "RulerRole",
            _RulerRole.default
        ],
        [
            "ScrollAreaRole",
            _ScrollAreaRole.default
        ],
        [
            "ScrollBarRole",
            _ScrollBarRole.default
        ],
        [
            "SeamlessWebAreaRole",
            _SeamlessWebAreaRole.default
        ],
        [
            "SearchRole",
            _SearchRole.default
        ],
        [
            "SearchBoxRole",
            _SearchBoxRole.default
        ],
        [
            "SliderRole",
            _SliderRole.default
        ],
        [
            "SliderThumbRole",
            _SliderThumbRole.default
        ],
        [
            "SpinButtonRole",
            _SpinButtonRole.default
        ],
        [
            "SpinButtonPartRole",
            _SpinButtonPartRole.default
        ],
        [
            "SplitterRole",
            _SplitterRole.default
        ],
        [
            "StaticTextRole",
            _StaticTextRole.default
        ],
        [
            "StatusRole",
            _StatusRole.default
        ],
        [
            "SVGRootRole",
            _SVGRootRole.default
        ],
        [
            "SwitchRole",
            _SwitchRole.default
        ],
        [
            "TabGroupRole",
            _TabGroupRole.default
        ],
        [
            "TabRole",
            _TabRole.default
        ],
        [
            "TableHeaderContainerRole",
            _TableHeaderContainerRole.default
        ],
        [
            "TableRole",
            _TableRole.default
        ],
        [
            "TabListRole",
            _TabListRole.default
        ],
        [
            "TabPanelRole",
            _TabPanelRole.default
        ],
        [
            "TermRole",
            _TermRole.default
        ],
        [
            "TextAreaRole",
            _TextAreaRole.default
        ],
        [
            "TextFieldRole",
            _TextFieldRole.default
        ],
        [
            "TimeRole",
            _TimeRole.default
        ],
        [
            "TimerRole",
            _TimerRole.default
        ],
        [
            "ToggleButtonRole",
            _ToggleButtonRole.default
        ],
        [
            "ToolbarRole",
            _ToolbarRole.default
        ],
        [
            "TreeRole",
            _TreeRole.default
        ],
        [
            "TreeGridRole",
            _TreeGridRole.default
        ],
        [
            "TreeItemRole",
            _TreeItemRole.default
        ],
        [
            "UserInterfaceTooltipRole",
            _UserInterfaceTooltipRole.default
        ],
        [
            "VideoRole",
            _VideoRole.default
        ],
        [
            "WebAreaRole",
            _WebAreaRole.default
        ],
        [
            "WindowRole",
            _WindowRole.default
        ]
    ];
    var AXObjectsMap = {
        entries: function entries() {
            return AXObjects$1;
        },
        forEach: function forEach(fn) {
            var thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
            var _iterator = _createForOfIteratorHelper$3(AXObjects$1), _step;
            try {
                for(_iterator.s(); !(_step = _iterator.n()).done;){
                    var _step$value = _slicedToArray$3(_step.value, 2), key = _step$value[0], values = _step$value[1];
                    fn.call(thisArg, values, key, AXObjects$1);
                }
            } catch (err) {
                _iterator.e(err);
            } finally{
                _iterator.f();
            }
        },
        get: function get(key) {
            var item = AXObjects$1.find(function(tuple) {
                return tuple[0] === key ? true : false;
            });
            return item && item[1];
        },
        has: function has(key) {
            return !!AXObjectsMap.get(key);
        },
        keys: function keys() {
            return AXObjects$1.map(function(_ref) {
                var _ref2 = _slicedToArray$3(_ref, 1), key = _ref2[0];
                return key;
            });
        },
        values: function values() {
            return AXObjects$1.map(function(_ref3) {
                var _ref4 = _slicedToArray$3(_ref3, 2), values = _ref4[1];
                return values;
            });
        }
    };
    var _default$3 = (0, _iterationDecorator$3.default)(AXObjectsMap, AXObjectsMap.entries());
    AXObjectsMap$1.default = _default$3;
    Object.defineProperty(AXObjectElementMap$1, "__esModule", {
        value: true
    });
    AXObjectElementMap$1.default = void 0;
    var _iterationDecorator$2 = _interopRequireDefault$3(iterationDecorator$1);
    var _AXObjectsMap$3 = _interopRequireDefault$3(AXObjectsMap$1);
    function _interopRequireDefault$3(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    function _slicedToArray$2(arr, i) {
        return _arrayWithHoles$2(arr) || _iterableToArrayLimit$2(arr, i) || _unsupportedIterableToArray$2(arr, i) || _nonIterableRest$2();
    }
    function _nonIterableRest$2() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _iterableToArrayLimit$2(arr, i) {
        var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
        if (_i == null) return;
        var _arr = [];
        var _n = true;
        var _d = false;
        var _s, _e;
        try {
            for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){
                _arr.push(_s.value);
                if (i && _arr.length === i) break;
            }
        } catch (err) {
            _d = true;
            _e = err;
        } finally{
            try {
                if (!_n && _i["return"] != null) _i["return"]();
            } finally{
                if (_d) throw _e;
            }
        }
        return _arr;
    }
    function _arrayWithHoles$2(arr) {
        if (Array.isArray(arr)) return arr;
    }
    function _createForOfIteratorHelper$2(o, allowArrayLike) {
        var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
        if (!it) {
            if (Array.isArray(o) || (it = _unsupportedIterableToArray$2(o)) || allowArrayLike && o && typeof o.length === "number") {
                if (it) o = it;
                var i = 0;
                var F = function F() {};
                return {
                    s: F,
                    n: function n() {
                        if (i >= o.length) return {
                            done: true
                        };
                        return {
                            done: false,
                            value: o[i++]
                        };
                    },
                    e: function e(_e2) {
                        throw _e2;
                    },
                    f: F
                };
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var normalCompletion = true, didErr = false, err;
        return {
            s: function s() {
                it = it.call(o);
            },
            n: function n() {
                var step = it.next();
                normalCompletion = step.done;
                return step;
            },
            e: function e(_e3) {
                didErr = true;
                err = _e3;
            },
            f: function f() {
                try {
                    if (!normalCompletion && it.return != null) it.return();
                } finally{
                    if (didErr) throw err;
                }
            }
        };
    }
    function _unsupportedIterableToArray$2(o, minLen) {
        if (!o) return;
        if (typeof o === "string") return _arrayLikeToArray$2(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor) n = o.constructor.name;
        if (n === "Map" || n === "Set") return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$2(o, minLen);
    }
    function _arrayLikeToArray$2(arr, len) {
        if (len == null || len > arr.length) len = arr.length;
        for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
        return arr2;
    }
    var AXObjectElements$1 = [];
    var _iterator$2 = _createForOfIteratorHelper$2(_AXObjectsMap$3.default.entries()), _step$2;
    try {
        var _loop$2 = function _loop() {
            var _step$value = _slicedToArray$2(_step$2.value, 2), name = _step$value[0], def = _step$value[1];
            var relatedConcepts = def.relatedConcepts;
            if (Array.isArray(relatedConcepts)) relatedConcepts.forEach(function(relation) {
                if (relation.module === "HTML") {
                    var concept = relation.concept;
                    if (concept) {
                        var index = AXObjectElements$1.findIndex(function(_ref5) {
                            var _ref6 = _slicedToArray$2(_ref5, 1), key = _ref6[0];
                            return key === name;
                        });
                        if (index === -1) {
                            AXObjectElements$1.push([
                                name,
                                []
                            ]);
                            index = AXObjectElements$1.length - 1;
                        }
                        AXObjectElements$1[index][1].push(concept);
                    }
                }
            });
        };
        for(_iterator$2.s(); !(_step$2 = _iterator$2.n()).done;)_loop$2();
    } catch (err) {
        _iterator$2.e(err);
    } finally{
        _iterator$2.f();
    }
    var AXObjectElementMap = {
        entries: function entries() {
            return AXObjectElements$1;
        },
        forEach: function forEach(fn) {
            var thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
            var _iterator2 = _createForOfIteratorHelper$2(AXObjectElements$1), _step2;
            try {
                for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){
                    var _step2$value = _slicedToArray$2(_step2.value, 2), key = _step2$value[0], values = _step2$value[1];
                    fn.call(thisArg, values, key, AXObjectElements$1);
                }
            } catch (err) {
                _iterator2.e(err);
            } finally{
                _iterator2.f();
            }
        },
        get: function get(key) {
            var item = AXObjectElements$1.find(function(tuple) {
                return tuple[0] === key ? true : false;
            });
            return item && item[1];
        },
        has: function has(key) {
            return !!AXObjectElementMap.get(key);
        },
        keys: function keys() {
            return AXObjectElements$1.map(function(_ref) {
                var _ref2 = _slicedToArray$2(_ref, 1), key = _ref2[0];
                return key;
            });
        },
        values: function values() {
            return AXObjectElements$1.map(function(_ref3) {
                var _ref4 = _slicedToArray$2(_ref3, 2), values = _ref4[1];
                return values;
            });
        }
    };
    var _default$2 = (0, _iterationDecorator$2.default)(AXObjectElementMap, AXObjectElementMap.entries());
    AXObjectElementMap$1.default = _default$2;
    var AXObjectRoleMap$1 = {};
    Object.defineProperty(AXObjectRoleMap$1, "__esModule", {
        value: true
    });
    AXObjectRoleMap$1.default = void 0;
    var _iterationDecorator$1 = _interopRequireDefault$2(iterationDecorator$1);
    var _AXObjectsMap$2 = _interopRequireDefault$2(AXObjectsMap$1);
    function _interopRequireDefault$2(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    function _slicedToArray$1(arr, i) {
        return _arrayWithHoles$1(arr) || _iterableToArrayLimit$1(arr, i) || _unsupportedIterableToArray$1(arr, i) || _nonIterableRest$1();
    }
    function _nonIterableRest$1() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _iterableToArrayLimit$1(arr, i) {
        var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
        if (_i == null) return;
        var _arr = [];
        var _n = true;
        var _d = false;
        var _s, _e;
        try {
            for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){
                _arr.push(_s.value);
                if (i && _arr.length === i) break;
            }
        } catch (err) {
            _d = true;
            _e = err;
        } finally{
            try {
                if (!_n && _i["return"] != null) _i["return"]();
            } finally{
                if (_d) throw _e;
            }
        }
        return _arr;
    }
    function _arrayWithHoles$1(arr) {
        if (Array.isArray(arr)) return arr;
    }
    function _createForOfIteratorHelper$1(o, allowArrayLike) {
        var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
        if (!it) {
            if (Array.isArray(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === "number") {
                if (it) o = it;
                var i = 0;
                var F = function F() {};
                return {
                    s: F,
                    n: function n() {
                        if (i >= o.length) return {
                            done: true
                        };
                        return {
                            done: false,
                            value: o[i++]
                        };
                    },
                    e: function e(_e2) {
                        throw _e2;
                    },
                    f: F
                };
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var normalCompletion = true, didErr = false, err;
        return {
            s: function s() {
                it = it.call(o);
            },
            n: function n() {
                var step = it.next();
                normalCompletion = step.done;
                return step;
            },
            e: function e(_e3) {
                didErr = true;
                err = _e3;
            },
            f: function f() {
                try {
                    if (!normalCompletion && it.return != null) it.return();
                } finally{
                    if (didErr) throw err;
                }
            }
        };
    }
    function _unsupportedIterableToArray$1(o, minLen) {
        if (!o) return;
        if (typeof o === "string") return _arrayLikeToArray$1(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor) n = o.constructor.name;
        if (n === "Map" || n === "Set") return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen);
    }
    function _arrayLikeToArray$1(arr, len) {
        if (len == null || len > arr.length) len = arr.length;
        for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
        return arr2;
    }
    var AXObjectRoleElements = [];
    var _iterator$1 = _createForOfIteratorHelper$1(_AXObjectsMap$2.default.entries()), _step$1;
    try {
        var _loop$1 = function _loop() {
            var _step$value = _slicedToArray$1(_step$1.value, 2), name = _step$value[0], def = _step$value[1];
            var relatedConcepts = def.relatedConcepts;
            if (Array.isArray(relatedConcepts)) relatedConcepts.forEach(function(relation) {
                if (relation.module === "ARIA") {
                    var concept = relation.concept;
                    if (concept) {
                        var index = AXObjectRoleElements.findIndex(function(_ref5) {
                            var _ref6 = _slicedToArray$1(_ref5, 1), key = _ref6[0];
                            return key === name;
                        });
                        if (index === -1) {
                            AXObjectRoleElements.push([
                                name,
                                []
                            ]);
                            index = AXObjectRoleElements.length - 1;
                        }
                        AXObjectRoleElements[index][1].push(concept);
                    }
                }
            });
        };
        for(_iterator$1.s(); !(_step$1 = _iterator$1.n()).done;)_loop$1();
    } catch (err) {
        _iterator$1.e(err);
    } finally{
        _iterator$1.f();
    }
    var AXObjectRoleMap = {
        entries: function entries() {
            return AXObjectRoleElements;
        },
        forEach: function forEach(fn) {
            var thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
            var _iterator2 = _createForOfIteratorHelper$1(AXObjectRoleElements), _step2;
            try {
                for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){
                    var _step2$value = _slicedToArray$1(_step2.value, 2), key = _step2$value[0], values = _step2$value[1];
                    fn.call(thisArg, values, key, AXObjectRoleElements);
                }
            } catch (err) {
                _iterator2.e(err);
            } finally{
                _iterator2.f();
            }
        },
        get: function get(key) {
            var item = AXObjectRoleElements.find(function(tuple) {
                return tuple[0] === key ? true : false;
            });
            return item && item[1];
        },
        has: function has(key) {
            return !!AXObjectRoleMap.get(key);
        },
        keys: function keys() {
            return AXObjectRoleElements.map(function(_ref) {
                var _ref2 = _slicedToArray$1(_ref, 1), key = _ref2[0];
                return key;
            });
        },
        values: function values() {
            return AXObjectRoleElements.map(function(_ref3) {
                var _ref4 = _slicedToArray$1(_ref3, 2), values = _ref4[1];
                return values;
            });
        }
    };
    var _default$1 = (0, _iterationDecorator$1.default)(AXObjectRoleMap, AXObjectRoleMap.entries());
    AXObjectRoleMap$1.default = _default$1;
    var elementAXObjectMap$1 = {};
    Object.defineProperty(elementAXObjectMap$1, "__esModule", {
        value: true
    });
    elementAXObjectMap$1.default = void 0;
    var _lite = lite;
    var _AXObjectsMap$1 = _interopRequireDefault$1(AXObjectsMap$1);
    var _iterationDecorator = _interopRequireDefault$1(iterationDecorator$1);
    function _interopRequireDefault$1(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    function _slicedToArray(arr, i) {
        return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }
    function _nonIterableRest() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _iterableToArrayLimit(arr, i) {
        var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
        if (_i == null) return;
        var _arr = [];
        var _n = true;
        var _d = false;
        var _s, _e;
        try {
            for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){
                _arr.push(_s.value);
                if (i && _arr.length === i) break;
            }
        } catch (err) {
            _d = true;
            _e = err;
        } finally{
            try {
                if (!_n && _i["return"] != null) _i["return"]();
            } finally{
                if (_d) throw _e;
            }
        }
        return _arr;
    }
    function _arrayWithHoles(arr) {
        if (Array.isArray(arr)) return arr;
    }
    function _createForOfIteratorHelper(o, allowArrayLike) {
        var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
        if (!it) {
            if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
                if (it) o = it;
                var i = 0;
                var F = function F() {};
                return {
                    s: F,
                    n: function n() {
                        if (i >= o.length) return {
                            done: true
                        };
                        return {
                            done: false,
                            value: o[i++]
                        };
                    },
                    e: function e(_e2) {
                        throw _e2;
                    },
                    f: F
                };
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var normalCompletion = true, didErr = false, err;
        return {
            s: function s() {
                it = it.call(o);
            },
            n: function n() {
                var step = it.next();
                normalCompletion = step.done;
                return step;
            },
            e: function e(_e3) {
                didErr = true;
                err = _e3;
            },
            f: function f() {
                try {
                    if (!normalCompletion && it.return != null) it.return();
                } finally{
                    if (didErr) throw err;
                }
            }
        };
    }
    function _unsupportedIterableToArray(o, minLen) {
        if (!o) return;
        if (typeof o === "string") return _arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor) n = o.constructor.name;
        if (n === "Map" || n === "Set") return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length) len = arr.length;
        for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
        return arr2;
    }
    var elementAXObjects$1 = [];
    var _iterator = _createForOfIteratorHelper(_AXObjectsMap$1.default.entries()), _step;
    try {
        var _loop = function _loop() {
            var _step$value = _slicedToArray(_step.value, 2), name = _step$value[0], def = _step$value[1];
            var relatedConcepts = def.relatedConcepts;
            if (Array.isArray(relatedConcepts)) relatedConcepts.forEach(function(relation) {
                if (relation.module === "HTML") {
                    var concept = relation.concept;
                    if (concept != null) {
                        var conceptStr = JSON.stringify(concept);
                        var axObjects;
                        var index = 0;
                        for(; index < elementAXObjects$1.length; index++){
                            var key = elementAXObjects$1[index][0];
                            if (JSON.stringify(key) === conceptStr) {
                                axObjects = elementAXObjects$1[index][1];
                                break;
                            }
                        }
                        if (!Array.isArray(axObjects)) axObjects = [];
                        var loc = axObjects.findIndex(function(item) {
                            return item === name;
                        });
                        if (loc === -1) axObjects.push(name);
                        if (index < elementAXObjects$1.length) elementAXObjects$1.splice(index, 1, [
                            concept,
                            axObjects
                        ]);
                        else elementAXObjects$1.push([
                            concept,
                            axObjects
                        ]);
                    }
                }
            });
        };
        for(_iterator.s(); !(_step = _iterator.n()).done;)_loop();
    } catch (err) {
        _iterator.e(err);
    } finally{
        _iterator.f();
    }
    var elementAXObjectMap = {
        entries: function entries() {
            return elementAXObjects$1;
        },
        forEach: function forEach(fn) {
            var thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
            var _iterator2 = _createForOfIteratorHelper(elementAXObjects$1), _step2;
            try {
                for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){
                    var _step2$value = _slicedToArray(_step2.value, 2), key = _step2$value[0], values = _step2$value[1];
                    fn.call(thisArg, values, key, elementAXObjects$1);
                }
            } catch (err) {
                _iterator2.e(err);
            } finally{
                _iterator2.f();
            }
        },
        get: function get(key) {
            var item = elementAXObjects$1.find(function(tuple) {
                return key.name === tuple[0].name && (0, _lite.dequal)(key.attributes, tuple[0].attributes);
            });
            return item && item[1];
        },
        has: function has(key) {
            return !!elementAXObjectMap.get(key);
        },
        keys: function keys() {
            return elementAXObjects$1.map(function(_ref) {
                var _ref2 = _slicedToArray(_ref, 1), key = _ref2[0];
                return key;
            });
        },
        values: function values() {
            return elementAXObjects$1.map(function(_ref3) {
                var _ref4 = _slicedToArray(_ref3, 2), values = _ref4[1];
                return values;
            });
        }
    };
    var _default = (0, _iterationDecorator.default)(elementAXObjectMap, elementAXObjectMap.entries());
    elementAXObjectMap$1.default = _default;
    Object.defineProperty(lib, "__esModule", {
        value: true
    });
    var elementAXObjects_1 = lib.elementAXObjects = AXObjects_1 = lib.AXObjects = AXObjectRoles_1 = lib.AXObjectRoles = lib.AXObjectElements = void 0;
    var _AXObjectElementMap = _interopRequireDefault(AXObjectElementMap$1);
    var _AXObjectRoleMap = _interopRequireDefault(AXObjectRoleMap$1);
    var _AXObjectsMap = _interopRequireDefault(AXObjectsMap$1);
    var _elementAXObjectMap = _interopRequireDefault(elementAXObjectMap$1);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    var AXObjectElements = _AXObjectElementMap.default;
    lib.AXObjectElements = AXObjectElements;
    var AXObjectRoles = _AXObjectRoleMap.default;
    var AXObjectRoles_1 = lib.AXObjectRoles = AXObjectRoles;
    var AXObjects = _AXObjectsMap.default;
    var AXObjects_1 = lib.AXObjects = AXObjects;
    var elementAXObjects = _elementAXObjectMap.default;
    elementAXObjects_1 = lib.elementAXObjects = elementAXObjects;
    const aria_roles$1 = roles_1.keys();
    const abstract_roles = new Set(aria_roles$1.filter((role)=>roles_1.get(role).abstract));
    const non_abstract_roles = aria_roles$1.filter((name)=>!abstract_roles.has(name));
    const non_interactive_roles = new Set(non_abstract_roles.filter((name)=>{
        const role = roles_1.get(name);
        return(// 'toolbar' does not descend from widget, but it does support
        // aria-activedescendant, thus in practice we treat it as a widget.
        // focusable tabpanel elements are recommended if any panels in a set contain content where the first element in the panel is not focusable.
        // 'generic' is meant to have no semantic meaning.
        // 'cell' is treated as CellRole by the AXObject which is interactive, so we treat 'cell' it as interactive as well.
        ![
            "toolbar",
            "tabpanel",
            "generic",
            "cell"
        ].includes(name) && !role.superClass.some((classes)=>classes.includes("widget")));
    }).concat(// The `progressbar` is descended from `widget`, but in practice, its
    // value is always `readonly`, so we treat it as a non-interactive role.
    "progressbar"));
    const interactive_roles = new Set(non_abstract_roles.filter((name)=>!non_interactive_roles.has(name) && // 'generic' is meant to have no semantic meaning.
        name !== "generic"));
    /**
 * @param {import('aria-query').ARIARoleDefinitionKey} role
 */ function is_non_interactive_roles(role) {
        return non_interactive_roles.has(role);
    }
    /**
 * @param {import('aria-query').ARIARoleDefinitionKey} role
 */ function is_interactive_roles(role) {
        return interactive_roles.has(role);
    }
    /**
 * @param {import('aria-query').ARIARoleDefinitionKey} role
 */ function is_abstract_role(role) {
        return abstract_roles.has(role);
    }
    const presentation_roles = new Set([
        "presentation",
        "none"
    ]);
    /**
 * @param {import('aria-query').ARIARoleDefinitionKey} role
 */ function is_presentation_role(role) {
        return presentation_roles.has(role);
    }
    /**
 * @param {string} tag_name
 * @param {Map<string, import('../nodes/Attribute.js').default>} attribute_map
 */ function is_hidden_from_screen_reader(tag_name, attribute_map) {
        if (tag_name === "input") {
            const type = attribute_map.get("type")?.get_static_value();
            if (type && type === "hidden") return true;
        }
        const aria_hidden = attribute_map.get("aria-hidden");
        if (!aria_hidden) return false;
        if (!aria_hidden.is_static) return true;
        const aria_hidden_value = aria_hidden.get_static_value();
        return aria_hidden_value === true || aria_hidden_value === "true";
    }
    /**
 * @param {Map<string, import('../nodes/Attribute.js').default>} attribute_map
 */ function has_disabled_attribute(attribute_map) {
        const disabled_attr = attribute_map.get("disabled");
        const disabled_attr_value = disabled_attr && disabled_attr.get_static_value();
        if (disabled_attr_value) return true;
        const aria_disabled_attr = attribute_map.get("aria-disabled");
        if (aria_disabled_attr) {
            const aria_disabled_attr_value = aria_disabled_attr.get_static_value();
            if (aria_disabled_attr_value === true) return true;
        }
        return false;
    }
    /**
 * @type {import('aria-query').ARIARoleRelationConcept[]}
 */ const non_interactive_element_role_schemas = [];
    elementRoles_1.entries().forEach(([schema, roles])=>{
        if ([
            ...roles
        ].every((role)=>role !== "generic" && non_interactive_roles.has(role))) non_interactive_element_role_schemas.push(schema);
    });
    /**
 * @type {import('aria-query').ARIARoleRelationConcept[]}
 */ const interactive_element_role_schemas = [];
    elementRoles_1.entries().forEach(([schema, roles])=>{
        if ([
            ...roles
        ].every((role)=>interactive_roles.has(role))) interactive_element_role_schemas.push(schema);
    });
    const interactive_ax_objects = new Set([
        ...AXObjects_1.keys()
    ].filter((name)=>AXObjects_1.get(name).type === "widget"));
    const non_interactive_ax_objects = new Set([
        ...AXObjects_1.keys()
    ].filter((name)=>[
            "windows",
            "structure"
        ].includes(AXObjects_1.get(name).type)));
    /**
 * @type {import('aria-query').ARIARoleRelationConcept[]}
 */ const interactive_element_ax_object_schemas = [];
    elementAXObjects_1.entries().forEach(([schema, ax_object])=>{
        if ([
            ...ax_object
        ].every((role)=>interactive_ax_objects.has(role))) interactive_element_ax_object_schemas.push(schema);
    });
    /**
 * @type {import('aria-query').ARIARoleRelationConcept[]}
 */ const non_interactive_element_ax_object_schemas = [];
    elementAXObjects_1.entries().forEach(([schema, ax_object])=>{
        if ([
            ...ax_object
        ].every((role)=>non_interactive_ax_objects.has(role))) non_interactive_element_ax_object_schemas.push(schema);
    });
    /**
 * @param {import('aria-query').ARIARoleRelationConcept} schema
 * @param {string} tag_name
 * @param {Map<string, import('../nodes/Attribute.js').default>} attribute_map
 */ function match_schema(schema, tag_name, attribute_map) {
        if (schema.name !== tag_name) return false;
        if (!schema.attributes) return true;
        return schema.attributes.every((schema_attribute)=>{
            const attribute = attribute_map.get(schema_attribute.name);
            if (!attribute) return false;
            if (schema_attribute.value && schema_attribute.value !== attribute.get_static_value()) return false;
            return true;
        });
    }
    const ElementInteractivity = /** @type {const} */ {
        Interactive: "interactive",
        NonInteractive: "non-interactive",
        Static: "static"
    };
    /**
 * @param {string} tag_name
 * @param {Map<string, import('../nodes/Attribute.js').default>} attribute_map
 * @returns {ElementInteractivity[keyof ElementInteractivity]}
 */ function element_interactivity(tag_name, attribute_map) {
        if (interactive_element_role_schemas.some((schema)=>match_schema(schema, tag_name, attribute_map))) return ElementInteractivity.Interactive;
        if (tag_name !== "header" && non_interactive_element_role_schemas.some((schema)=>match_schema(schema, tag_name, attribute_map))) return ElementInteractivity.NonInteractive;
        if (interactive_element_ax_object_schemas.some((schema)=>match_schema(schema, tag_name, attribute_map))) return ElementInteractivity.Interactive;
        if (non_interactive_element_ax_object_schemas.some((schema)=>match_schema(schema, tag_name, attribute_map))) return ElementInteractivity.NonInteractive;
        return ElementInteractivity.Static;
    }
    /**
 * @param {string} tag_name
 * @param {Map<string, import('../nodes/Attribute.js').default>} attribute_map
 * @returns {boolean}
 */ function is_interactive_element(tag_name, attribute_map) {
        return element_interactivity(tag_name, attribute_map) === ElementInteractivity.Interactive;
    }
    /**
 * @param {string} tag_name
 * @param {Map<string, import('../nodes/Attribute.js').default>} attribute_map
 * @returns {boolean}
 */ function is_non_interactive_element(tag_name, attribute_map) {
        return element_interactivity(tag_name, attribute_map) === ElementInteractivity.NonInteractive;
    }
    /**
 * @param {string} tag_name
 * @param {Map<string, import('../nodes/Attribute.js').default>} attribute_map
 * @returns {boolean}
 */ function is_static_element(tag_name, attribute_map) {
        return element_interactivity(tag_name, attribute_map) === ElementInteractivity.Static;
    }
    /**
 * @param {import('aria-query').ARIARoleDefinitionKey} role
 * @param {string} tag_name
 * @param {Map<string, import('../nodes/Attribute.js').default>} attribute_map
 */ function is_semantic_role_element(role, tag_name, attribute_map) {
        for (const [schema, ax_object] of elementAXObjects_1.entries()){
            if (schema.name === tag_name && (!schema.attributes || schema.attributes.every((attr)=>attribute_map.has(attr.name) && attribute_map.get(attr.name).get_static_value() === attr.value))) for (const name of ax_object){
                const roles = AXObjectRoles_1.get(name);
                if (roles) for (const { name: name } of roles){
                    if (name === role) return true;
                }
            }
        }
        return false;
    }
    // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofilling-form-controls:-the-autocomplete-attribute
    const address_type_tokens = new Set([
        "shipping",
        "billing"
    ]);
    const autofill_field_name_tokens = new Set([
        "",
        "on",
        "off",
        "name",
        "honorific-prefix",
        "given-name",
        "additional-name",
        "family-name",
        "honorific-suffix",
        "nickname",
        "username",
        "new-password",
        "current-password",
        "one-time-code",
        "organization-title",
        "organization",
        "street-address",
        "address-line1",
        "address-line2",
        "address-line3",
        "address-level4",
        "address-level3",
        "address-level2",
        "address-level1",
        "country",
        "country-name",
        "postal-code",
        "cc-name",
        "cc-given-name",
        "cc-additional-name",
        "cc-family-name",
        "cc-number",
        "cc-exp",
        "cc-exp-month",
        "cc-exp-year",
        "cc-csc",
        "cc-type",
        "transaction-currency",
        "transaction-amount",
        "language",
        "bday",
        "bday-day",
        "bday-month",
        "bday-year",
        "sex",
        "url",
        "photo"
    ]);
    const contact_type_tokens = new Set([
        "home",
        "work",
        "mobile",
        "fax",
        "pager"
    ]);
    const autofill_contact_field_name_tokens = new Set([
        "tel",
        "tel-country-code",
        "tel-national",
        "tel-area-code",
        "tel-local",
        "tel-local-prefix",
        "tel-local-suffix",
        "tel-extension",
        "email",
        "impp"
    ]);
    /**
 * @param {null | true | string} autocomplete
 */ function is_valid_autocomplete(autocomplete) {
        if (autocomplete === true) return false;
        else if (!autocomplete) return true; // dynamic value
        const tokens = autocomplete.trim().toLowerCase().split(regex_whitespaces);
        if (typeof tokens[0] === "string" && tokens[0].startsWith("section-")) tokens.shift();
        if (address_type_tokens.has(tokens[0])) tokens.shift();
        if (autofill_field_name_tokens.has(tokens[0])) tokens.shift();
        else {
            if (contact_type_tokens.has(tokens[0])) tokens.shift();
            if (autofill_contact_field_name_tokens.has(tokens[0])) tokens.shift();
            else return false;
        }
        if (tokens[0] === "webauthn") tokens.shift();
        return tokens.length === 0;
    }
    const aria_attributes = "activedescendant atomic autocomplete busy checked colcount colindex colspan controls current describedby description details disabled dropeffect errormessage expanded flowto grabbed haspopup hidden invalid keyshortcuts label labelledby level live modal multiline multiselectable orientation owns placeholder posinset pressed readonly relevant required roledescription rowcount rowindex rowspan selected setsize sort valuemax valuemin valuenow valuetext".split(" ");
    const aria_attribute_set = new Set(aria_attributes);
    const aria_roles = roles_1.keys();
    const aria_role_set = new Set(aria_roles);
    const a11y_required_attributes = {
        a: [
            "href"
        ],
        area: [
            "alt",
            "aria-label",
            "aria-labelledby"
        ],
        // html-has-lang
        html: [
            "lang"
        ],
        // iframe-has-title
        iframe: [
            "title"
        ],
        img: [
            "alt"
        ],
        object: [
            "title",
            "aria-label",
            "aria-labelledby"
        ]
    };
    const a11y_distracting_elements = new Set([
        "blink",
        "marquee"
    ]);
    const a11y_required_content = new Set([
        // anchor-has-content
        "a",
        // heading-has-content
        "h1",
        "h2",
        "h3",
        "h4",
        "h5",
        "h6"
    ]);
    const a11y_labelable = new Set([
        "button",
        "input",
        "keygen",
        "meter",
        "output",
        "progress",
        "select",
        "textarea"
    ]);
    const a11y_interactive_handlers = new Set([
        // Keyboard events
        "keypress",
        "keydown",
        "keyup",
        // Click events
        "click",
        "contextmenu",
        "dblclick",
        "drag",
        "dragend",
        "dragenter",
        "dragexit",
        "dragleave",
        "dragover",
        "dragstart",
        "drop",
        "mousedown",
        "mouseenter",
        "mouseleave",
        "mousemove",
        "mouseout",
        "mouseover",
        "mouseup"
    ]);
    const a11y_recommended_interactive_handlers = new Set([
        "click",
        "mousedown",
        "mouseup",
        "keypress",
        "keydown",
        "keyup"
    ]);
    const a11y_nested_implicit_semantics = new Map([
        [
            "header",
            "banner"
        ],
        [
            "footer",
            "contentinfo"
        ]
    ]);
    const a11y_implicit_semantics = new Map([
        [
            "a",
            "link"
        ],
        [
            "area",
            "link"
        ],
        [
            "article",
            "article"
        ],
        [
            "aside",
            "complementary"
        ],
        [
            "body",
            "document"
        ],
        [
            "button",
            "button"
        ],
        [
            "datalist",
            "listbox"
        ],
        [
            "dd",
            "definition"
        ],
        [
            "dfn",
            "term"
        ],
        [
            "dialog",
            "dialog"
        ],
        [
            "details",
            "group"
        ],
        [
            "dt",
            "term"
        ],
        [
            "fieldset",
            "group"
        ],
        [
            "figure",
            "figure"
        ],
        [
            "form",
            "form"
        ],
        [
            "h1",
            "heading"
        ],
        [
            "h2",
            "heading"
        ],
        [
            "h3",
            "heading"
        ],
        [
            "h4",
            "heading"
        ],
        [
            "h5",
            "heading"
        ],
        [
            "h6",
            "heading"
        ],
        [
            "hr",
            "separator"
        ],
        [
            "img",
            "img"
        ],
        [
            "li",
            "listitem"
        ],
        [
            "link",
            "link"
        ],
        [
            "main",
            "main"
        ],
        [
            "menu",
            "list"
        ],
        [
            "meter",
            "progressbar"
        ],
        [
            "nav",
            "navigation"
        ],
        [
            "ol",
            "list"
        ],
        [
            "option",
            "option"
        ],
        [
            "optgroup",
            "group"
        ],
        [
            "output",
            "status"
        ],
        [
            "progress",
            "progressbar"
        ],
        [
            "section",
            "region"
        ],
        [
            "summary",
            "button"
        ],
        [
            "table",
            "table"
        ],
        [
            "tbody",
            "rowgroup"
        ],
        [
            "textarea",
            "textbox"
        ],
        [
            "tfoot",
            "rowgroup"
        ],
        [
            "thead",
            "rowgroup"
        ],
        [
            "tr",
            "row"
        ],
        [
            "ul",
            "list"
        ]
    ]);
    const menuitem_type_to_implicit_role = new Map([
        [
            "command",
            "menuitem"
        ],
        [
            "checkbox",
            "menuitemcheckbox"
        ],
        [
            "radio",
            "menuitemradio"
        ]
    ]);
    const input_type_to_implicit_role = new Map([
        [
            "button",
            "button"
        ],
        [
            "image",
            "button"
        ],
        [
            "reset",
            "button"
        ],
        [
            "submit",
            "button"
        ],
        [
            "checkbox",
            "checkbox"
        ],
        [
            "radio",
            "radio"
        ],
        [
            "range",
            "slider"
        ],
        [
            "number",
            "spinbutton"
        ],
        [
            "email",
            "textbox"
        ],
        [
            "search",
            "searchbox"
        ],
        [
            "tel",
            "textbox"
        ],
        [
            "text",
            "textbox"
        ],
        [
            "url",
            "textbox"
        ]
    ]);
    /**
 * Exceptions to the rule which follows common A11y conventions
 * TODO make this configurable by the user
 */ const a11y_non_interactive_element_to_interactive_role_exceptions = {
        ul: [
            "listbox",
            "menu",
            "menubar",
            "radiogroup",
            "tablist",
            "tree",
            "treegrid"
        ],
        ol: [
            "listbox",
            "menu",
            "menubar",
            "radiogroup",
            "tablist",
            "tree",
            "treegrid"
        ],
        li: [
            "menuitem",
            "option",
            "row",
            "tab",
            "treeitem"
        ],
        table: [
            "grid"
        ],
        td: [
            "gridcell"
        ],
        fieldset: [
            "radiogroup",
            "presentation"
        ]
    };
    const combobox_if_list = new Set([
        "email",
        "search",
        "tel",
        "text",
        "url"
    ]);
    /** @param {Map<string, import('./Attribute.js').default>} attribute_map */ function input_implicit_role(attribute_map) {
        const type_attribute = attribute_map.get("type");
        if (!type_attribute || !type_attribute.is_static) return;
        const type = /** @type {string} */ type_attribute.get_static_value();
        const list_attribute_exists = attribute_map.has("list");
        if (list_attribute_exists && combobox_if_list.has(type)) return "combobox";
        return input_type_to_implicit_role.get(type);
    }
    /** @param {Map<string, import('./Attribute.js').default>} attribute_map */ function menuitem_implicit_role(attribute_map) {
        const type_attribute = attribute_map.get("type");
        if (!type_attribute || !type_attribute.is_static) return;
        const type = /** @type {string} */ type_attribute.get_static_value();
        return menuitem_type_to_implicit_role.get(type);
    }
    /**
 * @param {string} name
 * @param {Map<string, import('./Attribute.js').default>} attribute_map
 * @returns {string}
 */ function get_implicit_role(name, attribute_map) {
        if (name === "menuitem") return menuitem_implicit_role(attribute_map);
        else if (name === "input") return input_implicit_role(attribute_map);
        else return a11y_implicit_semantics.get(name);
    }
    const invisible_elements = new Set([
        "meta",
        "html",
        "script",
        "style"
    ]);
    const valid_modifiers = new Set([
        "preventDefault",
        "stopPropagation",
        "stopImmediatePropagation",
        "capture",
        "once",
        "passive",
        "nonpassive",
        "self",
        "trusted"
    ]);
    const passive_events = new Set([
        "wheel",
        "touchstart",
        "touchmove",
        "touchend",
        "touchcancel"
    ]);
    const react_attributes = new Map([
        [
            "className",
            "class"
        ],
        [
            "htmlFor",
            "for"
        ]
    ]);
    const attributes_to_compact_whitespace = [
        "class",
        "style"
    ];
    /**
 * @param {import('./interfaces.js').INode} parent
 * @param {string[]} elements
 */ function is_parent(parent, elements) {
        let check = false;
        while(parent){
            const parent_name = /** @type {Element} */ parent.name;
            if (elements.includes(parent_name)) {
                check = true;
                break;
            }
            if (parent.type === "Element") break;
            parent = parent.parent;
        }
        return check;
    }
    /**
 * @param {Element} parent
 * @param {Element} element
 * @param {string} explicit_namespace
 */ function get_namespace$1(parent, element, explicit_namespace) {
        const parent_element = parent.find_nearest(/^Element/);
        if (!parent_element) return explicit_namespace || (is_svg(element.name) ? namespaces.svg : null);
        if (parent_element.namespace !== namespaces.foreign) {
            if (is_svg(element.name.toLowerCase())) return namespaces.svg;
            if (parent_element.name.toLowerCase() === "foreignobject") return null;
        }
        return parent_element.namespace;
    }
    /**
 * @param {import('aria-query').ARIAPropertyDefinition} schema
 * @param {string | boolean} value
 * @returns {boolean}
 */ function is_valid_aria_attribute_value(schema, value) {
        switch(schema.type){
            case "boolean":
                return typeof value === "boolean";
            case "string":
            case "id":
                return typeof value === "string";
            case "tristate":
                return typeof value === "boolean" || value === "mixed";
            case "integer":
            case "number":
                return typeof value !== "boolean" && isNaN(Number(value)) === false;
            case "token":
                return (schema.values || []).indexOf(typeof value === "string" ? value.toLowerCase() : value) > -1;
            case "idlist":
                return typeof value === "string" && value.split(regex_any_repeated_whitespaces).every((id)=>typeof id === "string");
            case "tokenlist":
                return typeof value === "string" && value.split(regex_any_repeated_whitespaces).every((token)=>(schema.values || []).indexOf(token.toLowerCase()) > -1);
            default:
                return false;
        }
    }
    const regex_any_repeated_whitespaces = /[\s]+/g;
    const regex_heading_tags = /^h[1-6]$/;
    const regex_illegal_attribute_character = /(^[0-9-.])|[\^$@%&#?!|()[\]{}^*+~;]/;
    /** @extends Node<'Element'> */ let Element$1 = class Element extends Node {
        /** @type {string} */ name;
        /** @type {import('./shared/TemplateScope.js').default} */ scope;
        /** @type {import('./Action.js').default[]} */ actions = [];
        /** @type {import('./Binding.js').default[]} */ bindings = [];
        /** @type {import('./Class.js').default[]} */ classes = [];
        /** @type {import('./StyleDirective.js').default[]} */ styles = [];
        /** @type {import('./EventHandler.js').default[]} */ handlers = [];
        /** @type {import('./Let.js').default[]} */ lets = [];
        /** @type {import('./Transition.js').default} */ intro = null;
        /** @type {import('./Transition.js').default} */ outro = null;
        /** @type {import('./Animation.js').default} */ animation = null;
        /** @type {import('./interfaces.js').INode[]} */ children;
        /** @type {string} */ namespace;
        /** @type {boolean} */ needs_manual_style_scoping;
        /** @type {import('./shared/Expression.js').default} */ tag_expr;
        /** @type {boolean} */ contains_a11y_label;
        get is_dynamic_element() {
            return this.name === "svelte:element";
        }
        /**
	 * @param {import('../Component.js').default} component
	 * @param {import('./shared/Node.js').default} parent
	 * @param {import('./shared/TemplateScope.js').default} scope
	 * @param {any} info
	 */ constructor(component, parent, scope, info){
            super(component, parent, scope, info);
            this.name = info.name;
            if (info.name === "svelte:element") {
                if (typeof info.tag !== "string") this.tag_expr = new Expression(component, this, scope, info.tag);
                else {
                    this.tag_expr = new Expression(component, this, scope, /** @type {import('estree').Literal} */ string_literal(info.tag));
                    this.name = info.tag;
                }
            } else this.tag_expr = new Expression(component, this, scope, /** @type {import('estree').Literal} */ string_literal(this.name));
            this.namespace = get_namespace$1(/** @type {Element} */ parent, this, component.namespace);
            if (this.namespace !== namespaces.foreign) {
                if (this.name === "pre" || this.name === "textarea") {
                    const first = info.children[0];
                    if (first && first.type === "Text") // The leading newline character needs to be stripped because of a quirk,
                    // it is ignored by browsers if the tag and its contents are set through
                    // innerHTML (NOT if set through the innerHTML of the tag or dynamically).
                    // Therefore strip it here but add it back in the appropriate
                    // places if there's another newline afterwards.
                    // see https://html.spec.whatwg.org/multipage/syntax.html#element-restrictions
                    // see https://html.spec.whatwg.org/multipage/grouping-content.html#the-pre-element
                    first.data = first.data.replace(regex_starts_with_newline, "");
                }
                if (this.name === "textarea") {
                    if (info.children.length > 0) {
                        const value_attribute = get_value_attribute(info.attributes);
                        if (value_attribute) {
                            component.error(value_attribute, compiler_errors.textarea_duplicate_value);
                            return;
                        }
                        // this is an egregious hack, but it's the easiest way to get <textarea>
                        // children treated the same way as a value attribute
                        info.attributes.push({
                            type: "Attribute",
                            name: "value",
                            value: info.children
                        });
                        info.children = [];
                    }
                }
                if (this.name === "option") {
                    // Special case — treat these the same way:
                    //   <option>{foo}</option>
                    //   <option value={foo}>{foo}</option>
                    const value_attribute = get_value_attribute(info.attributes);
                    if (!value_attribute) info.attributes.push({
                        type: "Attribute",
                        name: "value",
                        value: info.children,
                        synthetic: true
                    });
                }
            }
            const has_let = info.attributes.some((node)=>node.type === "Let");
            if (has_let) scope = scope.child();
            // Binding relies on Attribute, defer its evaluation
            const order = [
                "Binding"
            ]; // everything else is -1
            info.attributes.sort((a, b)=>order.indexOf(a.type) - order.indexOf(b.type));
            info.attributes.forEach((node)=>{
                switch(node.type){
                    case "Action":
                        this.actions.push(new Action(component, this, scope, node));
                        break;
                    case "Attribute":
                    case "Spread":
                        // special case
                        if (node.name === "xmlns") this.namespace = node.value[0].data;
                        this.attributes.push(new Attribute(component, this, scope, node));
                        break;
                    case "Binding":
                        this.bindings.push(new Binding(component, this, scope, node));
                        break;
                    case "Class":
                        this.classes.push(new Class(component, this, scope, node));
                        break;
                    case "StyleDirective":
                        this.styles.push(new StyleDirective(component, this, scope, node));
                        break;
                    case "EventHandler":
                        this.handlers.push(new EventHandler(component, this, scope, node));
                        break;
                    case "Let":
                        {
                            const l = new Let(component, this, scope, node);
                            this.lets.push(l);
                            const dependencies = new Set([
                                l.name.name
                            ]);
                            l.names.forEach((name)=>{
                                scope.add(name, dependencies, this);
                            });
                            break;
                        }
                    case "Transition":
                        {
                            const transition = new Transition(component, this, scope, node);
                            if (node.intro) this.intro = transition;
                            if (node.outro) this.outro = transition;
                            break;
                        }
                    case "Animation":
                        this.animation = new Animation(component, this, scope, node);
                        break;
                    default:
                        throw new Error(`Not implemented: ${node.type}`);
                }
            });
            this.scope = scope;
            this.children = map_children(component, this, this.scope, info.children);
            this.validate();
            this.optimise();
            component.apply_stylesheet(this);
            if (this.parent) {
                if (this.actions.length > 0 || this.animation || this.bindings.length > 0 || this.classes.length > 0 || this.intro || this.outro || this.handlers.length > 0 || this.styles.length > 0 || this.name === "option" || this.is_dynamic_element || this.tag_expr.dynamic_dependencies().length || component.compile_options.dev) {
                    this.parent.cannot_use_innerhtml(); // need to use add_location
                    this.parent.not_static_content();
                }
            }
        }
        validate() {
            if (this.component.var_lookup.has(this.name) && this.component.var_lookup.get(this.name).imported && !is_svg(this.name) && !is_html(this.name)) this.component.warn(this, compiler_warnings.component_name_lowercase(this.name));
            this.validate_attributes();
            this.validate_event_handlers();
            if (this.namespace === namespaces.foreign) this.validate_bindings_foreign();
            else {
                this.validate_attributes_a11y();
                this.validate_special_cases();
                this.validate_bindings();
                this.validate_content();
            }
        }
        validate_attributes() {
            const { component: component, parent: parent } = this;
            this.attributes.forEach((attribute)=>{
                if (attribute.is_spread) return;
                const name = attribute.name.toLowerCase();
                // Errors
                if (regex_illegal_attribute_character.test(name)) return component.error(attribute, compiler_errors.illegal_attribute(name));
                if (name === "slot") {
                    if (!attribute.is_static) return component.error(attribute, compiler_errors.invalid_slot_attribute);
                    if (component.slot_outlets.has(name)) return component.error(attribute, compiler_errors.duplicate_slot_attribute(name));
                    if (!(parent.type === "SlotTemplate" || within_custom_element(parent))) return component.error(attribute, compiler_errors.invalid_slotted_content);
                }
                // Warnings
                if (this.namespace !== namespaces.foreign) {
                    if (name === "is") component.warn(attribute, compiler_warnings.avoid_is);
                    if (react_attributes.has(attribute.name)) component.warn(attribute, compiler_warnings.invalid_html_attribute(attribute.name, react_attributes.get(attribute.name)));
                }
            });
        }
        validate_attributes_a11y() {
            const { component: component, attributes: attributes, handlers: handlers } = this;
            const attribute_map = new Map();
            const handlers_map = new Map();
            attributes.forEach((attribute)=>attribute_map.set(attribute.name, attribute));
            handlers.forEach((handler)=>handlers_map.set(handler.name, handler));
            attributes.forEach((attribute)=>{
                if (attribute.is_spread) return;
                const name = attribute.name.toLowerCase();
                // aria-props
                if (name.startsWith("aria-")) {
                    if (invisible_elements.has(this.name)) // aria-unsupported-elements
                    component.warn(attribute, compiler_warnings.a11y_aria_attributes(this.name));
                    const type = name.slice(5);
                    if (!aria_attribute_set.has(type)) {
                        const match = fuzzymatch(type, aria_attributes);
                        component.warn(attribute, compiler_warnings.a11y_unknown_aria_attribute(type, match));
                    }
                    if (name === "aria-hidden" && regex_heading_tags.test(this.name)) component.warn(attribute, compiler_warnings.a11y_hidden(this.name));
                    // aria-proptypes
                    let value = attribute.get_static_value();
                    if (value === "true") value = true;
                    if (value === "false") value = false;
                    if (value !== null && value !== undefined && aria_1.has(/** @type {import('aria-query').ARIAProperty} */ name)) {
                        const schema = aria_1.get(/** @type {import('aria-query').ARIAProperty} */ name);
                        if (!is_valid_aria_attribute_value(schema, value)) component.warn(attribute, compiler_warnings.a11y_incorrect_attribute_type(schema, name));
                    }
                    // aria-activedescendant-has-tabindex
                    if (name === "aria-activedescendant" && !this.is_dynamic_element && !is_interactive_element(this.name, attribute_map) && !attribute_map.has("tabindex")) component.warn(attribute, compiler_warnings.a11y_aria_activedescendant_has_tabindex);
                }
                // aria-role
                if (name === "role") {
                    if (invisible_elements.has(this.name)) // aria-unsupported-elements
                    component.warn(attribute, compiler_warnings.a11y_misplaced_role(this.name));
                    const value = attribute.get_static_value();
                    if (typeof value === "string") value.split(regex_any_repeated_whitespaces).forEach(/** @param {import('aria-query').ARIARoleDefinitionKey} current_role */ (current_role)=>{
                        if (current_role && is_abstract_role(current_role)) component.warn(attribute, compiler_warnings.a11y_no_abstract_role(current_role));
                        else if (current_role && !aria_role_set.has(current_role)) {
                            const match = fuzzymatch(current_role, aria_roles);
                            component.warn(attribute, compiler_warnings.a11y_unknown_role(current_role, match));
                        }
                        // no-redundant-roles
                        if (current_role === get_implicit_role(this.name, attribute_map) && // <ul role="list"> is ok because CSS list-style:none removes the semantics and this is a way to bring them back
                        ![
                            "ul",
                            "ol",
                            "li"
                        ].includes(this.name)) component.warn(attribute, compiler_warnings.a11y_no_redundant_roles(current_role));
                        // Footers and headers are special cases, and should not have redundant roles unless they are the children of sections or articles.
                        const is_parent_section_or_article = is_parent(this.parent, [
                            "section",
                            "article"
                        ]);
                        if (!is_parent_section_or_article) {
                            const has_nested_redundant_role = current_role === a11y_nested_implicit_semantics.get(this.name);
                            if (has_nested_redundant_role) component.warn(attribute, compiler_warnings.a11y_no_redundant_roles(current_role));
                        }
                        // role-has-required-aria-props
                        if (!this.is_dynamic_element && !is_semantic_role_element(current_role, this.name, attribute_map)) {
                            const role = roles_1.get(current_role);
                            if (role) {
                                const required_role_props = Object.keys(role.requiredProps);
                                const has_missing_props = required_role_props.some((prop)=>!attributes.find((a)=>a.name === prop));
                                if (has_missing_props) component.warn(attribute, compiler_warnings.a11y_role_has_required_aria_props(current_role, required_role_props));
                            }
                        }
                        // interactive-supports-focus
                        if (!has_disabled_attribute(attribute_map) && !is_hidden_from_screen_reader(this.name, attribute_map) && !is_presentation_role(current_role) && is_interactive_roles(current_role) && is_static_element(this.name, attribute_map) && !attribute_map.get("tabindex")) {
                            const has_interactive_handlers = handlers.some((handler)=>a11y_interactive_handlers.has(handler.name));
                            if (has_interactive_handlers) component.warn(this, compiler_warnings.a11y_interactive_supports_focus(current_role));
                        }
                        // no-interactive-element-to-noninteractive-role
                        if (is_interactive_element(this.name, attribute_map) && (is_non_interactive_roles(current_role) || is_presentation_role(current_role))) component.warn(this, compiler_warnings.a11y_no_interactive_element_to_noninteractive_role(current_role, this.name));
                        // no-noninteractive-element-to-interactive-role
                        if (is_non_interactive_element(this.name, attribute_map) && is_interactive_roles(current_role) && !a11y_non_interactive_element_to_interactive_role_exceptions[this.name]?.includes(current_role)) component.warn(this, compiler_warnings.a11y_no_noninteractive_element_to_interactive_role(current_role, this.name));
                    });
                }
                // no-access-key
                if (name === "accesskey") component.warn(attribute, compiler_warnings.a11y_accesskey);
                // no-autofocus
                if (name === "autofocus") component.warn(attribute, compiler_warnings.a11y_autofocus);
                // scope
                if (name === "scope" && !this.is_dynamic_element && this.name !== "th") component.warn(attribute, compiler_warnings.a11y_misplaced_scope);
                // tabindex-no-positive
                if (name === "tabindex") {
                    const value = attribute.get_static_value();
                    // @ts-ignore todo is tabindex=true correct case?
                    if (!isNaN(value) && +value > 0) component.warn(attribute, compiler_warnings.a11y_positive_tabindex);
                }
            });
            // click-events-have-key-events
            if (handlers_map.has("click")) {
                const role = attribute_map.get("role");
                const is_non_presentation_role = role?.is_static && !is_presentation_role(/** @type {import('aria-query').ARIARoleDefinitionKey} */ role.get_static_value());
                if (!this.is_dynamic_element && !is_hidden_from_screen_reader(this.name, attribute_map) && (!role || is_non_presentation_role) && !is_interactive_element(this.name, attribute_map) && !this.attributes.find((attr)=>attr.is_spread)) {
                    const has_key_event = handlers_map.has("keydown") || handlers_map.has("keyup") || handlers_map.has("keypress");
                    if (!has_key_event) component.warn(this, compiler_warnings.a11y_click_events_have_key_events);
                }
            }
            const role = attribute_map.get("role");
            const role_static_value = /** @type {import('aria-query').ARIARoleDefinitionKey} */ role?.get_static_value();
            const role_value = /** @type {import('aria-query').ARIARoleDefinitionKey} */ role ? role_static_value : get_implicit_role(this.name, attribute_map);
            // no-noninteractive-tabindex
            if (!this.is_dynamic_element && !is_interactive_element(this.name, attribute_map) && !is_interactive_roles(role_static_value)) {
                const tab_index = attribute_map.get("tabindex");
                if (tab_index && (!tab_index.is_static || Number(tab_index.get_static_value()) >= 0)) component.warn(this, compiler_warnings.a11y_no_noninteractive_tabindex);
            }
            // role-supports-aria-props
            if (typeof role_value === "string" && roles_1.has(role_value)) {
                const { props: props } = roles_1.get(role_value);
                const invalid_aria_props = new Set(aria_1.keys().filter((attribute)=>!(attribute in props)));
                const is_implicit = role_value && role === undefined;
                attributes.filter((prop)=>prop.type !== "Spread").forEach((prop)=>{
                    if (invalid_aria_props.has(/** @type {import('aria-query').ARIAProperty} */ prop.name)) component.warn(prop, compiler_warnings.a11y_role_supports_aria_props(prop.name, role_value, is_implicit, this.name));
                });
            }
            // no-noninteractive-element-interactions
            if (!has_contenteditable_attr(this) && !is_hidden_from_screen_reader(this.name, attribute_map) && !is_presentation_role(role_static_value) && (!is_interactive_element(this.name, attribute_map) && is_non_interactive_roles(role_static_value) || is_non_interactive_element(this.name, attribute_map) && !role)) {
                const has_interactive_handlers = handlers.some((handler)=>a11y_recommended_interactive_handlers.has(handler.name));
                if (has_interactive_handlers) component.warn(this, compiler_warnings.a11y_no_noninteractive_element_interactions(this.name));
            }
            const has_dynamic_role = attribute_map.get("role") && !attribute_map.get("role").is_static;
            // no-static-element-interactions
            if (!has_dynamic_role && !is_hidden_from_screen_reader(this.name, attribute_map) && !is_presentation_role(role_static_value) && !is_interactive_element(this.name, attribute_map) && !is_interactive_roles(role_static_value) && !is_non_interactive_element(this.name, attribute_map) && !is_non_interactive_roles(role_static_value) && !is_abstract_role(role_static_value)) {
                const interactive_handlers = handlers.map((handler)=>handler.name).filter((handler_name)=>a11y_interactive_handlers.has(handler_name));
                if (interactive_handlers.length > 0) component.warn(this, compiler_warnings.a11y_no_static_element_interactions(this.name, interactive_handlers));
            }
        }
        validate_special_cases() {
            const { component: component, attributes: attributes, handlers: handlers } = this;
            const attribute_map = new Map();
            const handlers_map = new Map();
            attributes.forEach((attribute)=>attribute_map.set(attribute.name, attribute));
            handlers.forEach((handler)=>handlers_map.set(handler.name, handler));
            if (this.name === "a") {
                const href_attribute = attribute_map.get("href") || attribute_map.get("xlink:href");
                const id_attribute = attribute_map.get("id");
                const name_attribute = attribute_map.get("name");
                const target_attribute = attribute_map.get("target");
                const aria_label_attribute = attribute_map.get("aria-label");
                // links with target="_blank" should have noopener or noreferrer: https://developer.chrome.com/docs/lighthouse/best-practices/external-anchors-use-rel-noopener/
                // modern browsers add noopener by default, so we only need to check legacy browsers
                // legacy browsers don't support noopener so we only check for noreferrer there
                if (component.compile_options.legacy && target_attribute && target_attribute.get_static_value() === "_blank" && href_attribute) {
                    const href_static_value = href_attribute.get_static_value() ? href_attribute.get_static_value().toLowerCase() : null;
                    if (href_static_value === null || href_static_value.match(/^(https?:)?\/\//i)) {
                        const rel = attribute_map.get("rel");
                        if (rel == null || rel.is_static) {
                            const rel_values = rel ? rel.get_static_value().split(regex_any_repeated_whitespaces) : [];
                            if (!rel || !rel_values.includes("noreferrer")) component.warn(this, {
                                code: "security-anchor-rel-noreferrer",
                                message: 'Security: Anchor with "target=_blank" should have rel attribute containing the value "noreferrer"'
                            });
                        }
                    }
                }
                if (aria_label_attribute) {
                    const aria_value = aria_label_attribute.get_static_value();
                    if (aria_value != "") this.contains_a11y_label = true;
                }
                if (href_attribute) {
                    const href_value = href_attribute.get_static_value();
                    if (href_value === "" || href_value === "#" || /^\W*javascript:/i.test(href_value)) component.warn(href_attribute, compiler_warnings.a11y_invalid_attribute(href_attribute.name, href_value));
                } else {
                    const id_attribute_valid = id_attribute && id_attribute.get_static_value() !== "";
                    const name_attribute_valid = name_attribute && name_attribute.get_static_value() !== "";
                    if (!id_attribute_valid && !name_attribute_valid) component.warn(this, compiler_warnings.a11y_missing_attribute("a", "an", "href"));
                }
            } else {
                const required_attributes = a11y_required_attributes[this.name];
                if (required_attributes) {
                    const has_attribute = required_attributes.some((name)=>attribute_map.has(name));
                    if (!has_attribute) should_have_attribute(this, required_attributes);
                }
            }
            if (this.name === "input") {
                const type = attribute_map.get("type");
                if (type && type.get_static_value() === "image") {
                    const required_attributes = [
                        "alt",
                        "aria-label",
                        "aria-labelledby"
                    ];
                    const has_attribute = required_attributes.some((name)=>attribute_map.has(name));
                    if (!has_attribute) should_have_attribute(this, required_attributes, 'input type="image"');
                }
                // autocomplete-valid
                const autocomplete = attribute_map.get("autocomplete");
                if (type && autocomplete) {
                    const type_value = type.get_static_value();
                    const autocomplete_value = autocomplete.get_static_value();
                    if (!is_valid_autocomplete(autocomplete_value)) component.warn(autocomplete, compiler_warnings.a11y_autocomplete_valid(type_value, autocomplete_value));
                }
            }
            if (this.name === "img") {
                const alt_attribute = attribute_map.get("alt");
                const aria_hidden_attribute = attribute_map.get("aria-hidden");
                const aria_hidden_exist = aria_hidden_attribute && aria_hidden_attribute.get_static_value();
                if (alt_attribute && !aria_hidden_exist) {
                    const alt_value = alt_attribute.get_static_value();
                    if (/\b(image|picture|photo)\b/i.test(alt_value)) component.warn(this, compiler_warnings.a11y_img_redundant_alt);
                }
            }
            if (this.name === "label") {
                /** @param {import('./interfaces.js').INode[]} children */ const has_input_child = (children)=>{
                    if (children.some((child)=>child instanceof Element && (a11y_labelable.has(child.name) || child.name === "slot"))) return true;
                    for (const child of children){
                        if (!("children" in child) || child.children.length === 0) continue;
                        if (has_input_child(child.children)) return true;
                    }
                    return false;
                };
                if (!attribute_map.has("for") && !has_input_child(this.children)) component.warn(this, compiler_warnings.a11y_label_has_associated_control);
            }
            if (this.name === "video") {
                const aria_hidden_attribute = attribute_map.get("aria-hidden");
                const aria_hidden_exist = aria_hidden_attribute && aria_hidden_attribute.get_static_value();
                if (attribute_map.has("muted") || aria_hidden_exist === "true") return;
                let has_caption;
                const track = this.children.find(/** @param {Element} i */ (i)=>i.name === "track");
                if (track) has_caption = track.attributes.find((a)=>a.name === "kind" && a.get_static_value() === "captions");
                if (!has_caption) component.warn(this, compiler_warnings.a11y_media_has_caption);
            }
            if (a11y_distracting_elements.has(this.name)) // no-distracting-elements
            component.warn(this, compiler_warnings.a11y_distracting_elements(this.name));
            if (this.name === "figcaption") {
                let { parent: parent } = this;
                let is_figure_parent = false;
                while(parent){
                    if (/** @type {Element} */ parent.name === "figure") {
                        is_figure_parent = true;
                        break;
                    }
                    if (parent.type === "Element") break;
                    parent = parent.parent;
                }
                if (!is_figure_parent) component.warn(this, compiler_warnings.a11y_structure_immediate);
            }
            if (this.name === "figure") {
                const children = this.children.filter((node)=>{
                    if (node.type === "Comment") return false;
                    if (node.type === "Text") return regex_non_whitespace_character.test(node.data);
                    return true;
                });
                const index = children.findIndex((child)=>/** @type {Element} */ child.name === "figcaption");
                if (index !== -1 && index !== 0 && index !== children.length - 1) component.warn(children[index], compiler_warnings.a11y_structure_first_or_last);
            }
            if (handlers_map.has("mouseover") && !handlers_map.has("focus")) component.warn(this, compiler_warnings.a11y_mouse_events_have_key_events("mouseover", "focus"));
            if (handlers_map.has("mouseout") && !handlers_map.has("blur")) component.warn(this, compiler_warnings.a11y_mouse_events_have_key_events("mouseout", "blur"));
        }
        validate_bindings_foreign() {
            this.bindings.forEach((binding)=>{
                if (binding.name !== "this") return this.component.error(binding, compiler_errors.invalid_binding_foreign(binding.name));
            });
        }
        validate_bindings() {
            const { component: component } = this;
            const check_type_attribute = ()=>{
                const attribute = this.attributes.find(/** @param {import('./Attribute.js').default} attribute */ (attribute)=>attribute.name === "type");
                if (!attribute) return null;
                if (!attribute.is_static) return component.error(attribute, compiler_errors.invalid_type);
                const value = attribute.get_static_value();
                if (value === true) return component.error(attribute, compiler_errors.missing_type);
                return value;
            };
            this.bindings.forEach((binding)=>{
                const { name: name } = binding;
                if (name === "value") {
                    if (this.name !== "input" && this.name !== "textarea" && this.name !== "select") return component.error(binding, compiler_errors.invalid_binding_elements(this.name, "value"));
                    if (this.name === "select") {
                        const attribute = this.attributes.find(/** @param {import('./Attribute.js').default} attribute */ (attribute)=>attribute.name === "multiple");
                        if (attribute && !attribute.is_static) return component.error(attribute, compiler_errors.dynamic_multiple_attribute);
                    } else check_type_attribute();
                } else if (name === "checked" || name === "indeterminate") {
                    if (this.name !== "input") return component.error(binding, compiler_errors.invalid_binding_elements(this.name, name));
                    const type = check_type_attribute();
                    if (type !== "checkbox") return component.error(binding, compiler_errors.invalid_binding_no_checkbox(name, type === "radio"));
                } else if (name === "group") {
                    if (this.name !== "input") return component.error(binding, compiler_errors.invalid_binding_elements(this.name, "group"));
                    const type = check_type_attribute();
                    if (type !== "checkbox" && type !== "radio") return component.error(binding, compiler_errors.invalid_binding_element_with('<input type="checkbox"> or <input type="radio">', "group"));
                } else if (name === "files") {
                    if (this.name !== "input") return component.error(binding, compiler_errors.invalid_binding_elements(this.name, "files"));
                    const type = check_type_attribute();
                    if (type !== "file") return component.error(binding, compiler_errors.invalid_binding_element_with('<input type="file">', "files"));
                } else if (name === "open") {
                    if (this.name !== "details") return component.error(binding, compiler_errors.invalid_binding_element_with("<details>", name));
                } else if (name === "currentTime" || name === "duration" || name === "paused" || name === "buffered" || name === "seekable" || name === "played" || name === "volume" || name === "muted" || name === "playbackRate" || name === "seeking" || name === "ended" || name === "readyState") {
                    if (this.name !== "audio" && this.name !== "video") return component.error(binding, compiler_errors.invalid_binding_element_with("audio> or <video>", name));
                } else if (name === "videoHeight" || name === "videoWidth") {
                    if (this.name !== "video") return component.error(binding, compiler_errors.invalid_binding_element_with("<video>", name));
                } else if (regex_dimensions.test(name)) {
                    if (this.name === "svg" && (name === "offsetWidth" || name === "offsetHeight")) return component.error(binding, compiler_errors.invalid_binding_on(binding.name, `<svg>. Use '${name.replace("offset", "client")}' instead`));
                    else if (is_svg(this.name)) return component.error(binding, compiler_errors.invalid_binding_on(binding.name, "SVG elements"));
                    else if (is_void(this.name)) return component.error(binding, compiler_errors.invalid_binding_on(binding.name, `void elements like <${this.name}>. Use a wrapper element instead`));
                } else if (name === "naturalWidth" || name === "naturalHeight") {
                    if (this.name !== "img") return component.error(binding, compiler_errors.invalid_binding_element_with("<img>", name));
                } else if (is_name_contenteditable(name)) {
                    const contenteditable = get_contenteditable_attr(this);
                    if (!contenteditable) return component.error(binding, compiler_errors.missing_contenteditable_attribute);
                    else if (contenteditable && !contenteditable.is_static) return component.error(contenteditable, compiler_errors.dynamic_contenteditable_attribute);
                } else if (name !== "this" && !regex_box_size.test(name)) return component.error(binding, compiler_errors.invalid_binding(binding.name));
            });
        }
        validate_content() {
            if (!a11y_required_content.has(this.name)) return;
            if (this.contains_a11y_label) return;
            if (this.bindings.some((binding)=>[
                    "textContent",
                    "innerHTML"
                ].includes(binding.name))) return;
            if (this.children.length === 0) this.component.warn(this, compiler_warnings.a11y_missing_content(this.name));
        }
        validate_event_handlers() {
            const { component: component } = this;
            this.handlers.forEach((handler)=>{
                if (handler.modifiers.has("passive") && handler.modifiers.has("preventDefault")) return component.error(handler, compiler_errors.invalid_event_modifier_combination("passive", "preventDefault"));
                if (handler.modifiers.has("passive") && handler.modifiers.has("nonpassive")) return component.error(handler, compiler_errors.invalid_event_modifier_combination("passive", "nonpassive"));
                handler.modifiers.forEach((modifier)=>{
                    if (!valid_modifiers.has(modifier)) return component.error(handler, compiler_errors.invalid_event_modifier(list(Array.from(valid_modifiers))));
                    if (modifier === "passive") {
                        if (passive_events.has(handler.name)) {
                            if (handler.can_make_passive) component.warn(handler, compiler_warnings.redundant_event_modifier_for_touch);
                        } else component.warn(handler, compiler_warnings.redundant_event_modifier_passive);
                    }
                    if (component.compile_options.legacy && (modifier === "once" || modifier === "passive")) // TODO this could be supported, but it would need a few changes to
                    // how event listeners work
                    return component.error(handler, compiler_errors.invalid_event_modifier_legacy(modifier));
                });
                if (passive_events.has(handler.name) && handler.can_make_passive && !handler.modifiers.has("preventDefault") && !handler.modifiers.has("nonpassive")) // touch/wheel events should be passive by default
                handler.modifiers.add("passive");
            });
        }
        is_media_node() {
            return this.name === "audio" || this.name === "video";
        }
        add_css_class() {
            if (this.attributes.some((attr)=>attr.is_spread)) {
                this.needs_manual_style_scoping = true;
                return;
            }
            const { id: id } = this.component.stylesheet;
            const class_attribute = this.attributes.find((a)=>a.name === "class");
            if (class_attribute && !class_attribute.is_true) {
                if (class_attribute.chunks.length === 1 && class_attribute.chunks[0].type === "Text") /** @type {import('./Text.js').default} */ class_attribute.chunks[0].data += ` ${id}`;
                else /** @type {import('./shared/Node.js').default[]} */ class_attribute.chunks.push(new Text$1(this.component, this, this.scope, /** @type {any} */ {
                    type: "Text",
                    data: ` ${id}`,
                    synthetic: true
                }));
            } else this.attributes.push(new Attribute(this.component, this, this.scope, /** @type {any} */ {
                type: "Attribute",
                name: "class",
                value: [
                    {
                        type: "Text",
                        data: id,
                        synthetic: true
                    }
                ]
            }));
        }
        get slot_template_name() {
            return /** @type {string} */ this.attributes.find((attribute)=>attribute.name === "slot").get_static_value();
        }
        optimise() {
            attributes_to_compact_whitespace.forEach((attribute_name)=>{
                const attribute = this.attributes.find((a)=>a.name === attribute_name);
                if (attribute && !attribute.is_true) attribute.chunks.forEach((chunk, index)=>{
                    if (chunk.type === "Text") {
                        let data = chunk.data.replace(regex_any_repeated_whitespaces, " ");
                        if (index === 0) data = data.trimLeft();
                        else if (index === attribute.chunks.length - 1) data = data.trimRight();
                        chunk.data = data;
                    }
                });
            });
        }
        get can_use_textcontent() {
            return this.is_static_content && this.children.every((node)=>node.type === "Text" || node.type === "MustacheTag");
        }
        get can_optimise_to_html_string() {
            const can_use_textcontent = this.can_use_textcontent;
            const is_template_with_text_content = this.name === "template" && can_use_textcontent;
            return !is_template_with_text_content && !this.namespace && (this.can_use_innerhtml || can_use_textcontent) && this.children.length > 0;
        }
        get can_optimise_hydration() {
            // In contrast to normal html string optimization, we also bail in case of mustache tags even
            // if they seem to contain static content. This is because we cannot know whether that static
            // value is different between client and server builds, e.g. {browser ? 'hi' : 'bye'} which
            // becomes {'hi'} and {'bye'} respectively.
            const is_static_text_content = this.is_static_content && this.children.every((node)=>node.type === "Text");
            return this.can_optimise_to_html_string && (this.can_use_innerhtml || is_static_text_content);
        }
        hash() {
            return `svelte-${hash(this.component.source.slice(this.start, this.end))}`;
        }
    };
    const regex_starts_with_vowel = /^[aeiou]/;
    /**
 * @param {any} node
 * @param {string[]} attributes
 * @param {any} name
 */ function should_have_attribute(node, attributes, name = node.name) {
        const article = regex_starts_with_vowel.test(attributes[0]) ? "an" : "a";
        const sequence = attributes.length > 1 ? attributes.slice(0, -1).join(", ") + ` or ${attributes[attributes.length - 1]}` : attributes[0];
        node.component.warn(node, compiler_warnings.a11y_missing_attribute(name, article, sequence));
    }
    const regex_minus_sign$1 = /-/;
    /** @param {import('./interfaces.js').INode} parent */ function within_custom_element(parent) {
        while(parent){
            if (parent.type === "InlineComponent") return false;
            if (parent.type === "Element") {
                if (regex_minus_sign$1.test(parent.name) || parent.is_dynamic_element) return true;
            }
            parent = parent.parent;
        }
        return false;
    }
    /**
 * @param {any[]} attributes
 */ function get_value_attribute(attributes) {
        let node_value;
        attributes.forEach((node)=>{
            if (node.type !== "Spread" && node.name.toLowerCase() === "value") node_value = node;
            if (node.type === "Spread") walk(/** @type {any} */ node.expression, {
                enter (/** @type {import('estree').Node} */ node) {
                    if (node_value) this.skip();
                    if (node.type === "Identifier") {
                        if (/** @type {import('estree').Identifier} */ node.name.toLowerCase() === "value") node_value = node;
                    }
                }
            });
        });
        return node_value;
    }
    /** @extends Node<'Head'> */ let Head$1 = class Head extends Node {
        /** @type {any[]} */ children;
        /** @type {string} */ id;
        /**
	 * @param {import('../Component.js').default} component
	 * @param {import('./shared/Node.js').default} parent
	 * @param {import('./shared/TemplateScope.js').default} scope
	 * @param {import('../../interfaces.js').TemplateNode} info
	 */ constructor(component, parent, scope, info){
            super(component, parent, scope, info);
            this.cannot_use_innerhtml();
            if (info.attributes.length) {
                component.error(info.attributes[0], compiler_errors.invalid_attribute_head);
                return;
            }
            this.children = map_children(component, parent, scope, info.children.filter((child)=>{
                return child.type !== "Text" || regex_non_whitespace_character.test(child.data);
            }));
            if (this.children.length > 0) this.id = `svelte-${hash(this.component.source.slice(this.start, this.end))}`;
        }
    };
    /** @extends AbstractBlock<'IfBlock'> */ let IfBlock$1 = class IfBlock extends AbstractBlock {
        /** @type {import('./shared/Expression.js').default} */ expression;
        /** @type {import('./ElseBlock.js').default} */ else;
        /** @type {import('./shared/TemplateScope.js').default} */ scope;
        /** @type {import('./ConstTag.js').default[]} */ const_tags;
        /**
	 * @param {import('../Component.js').default} component
	 * @param {import('./shared/Node.js').default} parent
	 * @param {import('./shared/TemplateScope.js').default} scope
	 * @param {import('../../interfaces.js').TemplateNode} info
	 */ constructor(component, parent, scope, info){
            super(component, parent, scope, info);
            this.scope = scope.child();
            this.cannot_use_innerhtml();
            this.not_static_content();
            this.expression = new Expression(component, this, this.scope, info.expression);
            [this.const_tags, this.children] = get_const_tags$1(info.children, component, this, this);
            this.else = info.else ? new ElseBlock(component, this, scope, info.else) : null;
            this.warn_if_empty_block();
        }
    };
    /** @extends Node<'InlineComponent'> */ let InlineComponent$1 = class InlineComponent extends Node {
        /** @type {string} */ name;
        /** @type {import('./shared/Expression.js').default} */ expression;
        /** @type {import('./Binding.js').default[]} */ bindings = [];
        /** @type {import('./EventHandler.js').default[]} */ handlers = [];
        /** @type {import('./Attribute.js').default[]} */ css_custom_properties = [];
        /** @type {import('./interfaces.js').INode[]} */ children;
        /** @type {import('./shared/TemplateScope.js').default} */ scope;
        /** @type {string} */ namespace;
        /** @type {Attribute[]} */ let_attributes;
        /**
	 * @param {import('../Component.js').default} component
	 * @param {import('./shared/Node.js').default} parent
	 * @param {import('./shared/TemplateScope.js').default} scope
	 * @param {import('../../interfaces.js').TemplateNode} info
	 */ constructor(component, parent, scope, info){
            super(component, parent, scope, info);
            this.cannot_use_innerhtml();
            this.not_static_content();
            if (info.name !== "svelte:component" && info.name !== "svelte:self") {
                const name = info.name.split(".")[0]; // accommodate namespaces
                component.warn_if_undefined(name, info, scope);
                component.add_reference(/** @type {any} */ this, name);
            }
            this.name = info.name;
            this.namespace = get_namespace(parent, component.namespace);
            this.expression = this.name === "svelte:component" ? new Expression(component, this, scope, info.expression) : null;
            const let_attributes = this.let_attributes = [];
            info.attributes.forEach(/** @param {import('../../interfaces.js').BaseDirective | import('../../interfaces.js').Attribute | import('../../interfaces.js').SpreadAttribute} node */ (node)=>{
                /* eslint-disable no-fallthrough */ switch(node.type){
                    case "Action":
                        return component.error(node, compiler_errors.invalid_action);
                    case "Attribute":
                        if (node.name.startsWith("--")) {
                            this.css_custom_properties.push(new Attribute(component, this, scope, node));
                            break;
                        }
                    // fallthrough
                    case "Spread":
                        this.attributes.push(new Attribute(component, this, scope, node));
                        break;
                    case "Binding":
                        this.bindings.push(new Binding(component, this, scope, node));
                        break;
                    case "Class":
                        return component.error(node, compiler_errors.invalid_class);
                    case "EventHandler":
                        this.handlers.push(new EventHandler(component, this, scope, node));
                        break;
                    case "Let":
                        let_attributes.push(node);
                        break;
                    case "Transition":
                        return component.error(node, compiler_errors.invalid_transition);
                    case "StyleDirective":
                        return component.error(node, compiler_errors.invalid_component_style_directive);
                    case "Animation":
                        return component.error(node, compiler_errors.invalid_animation);
                    default:
                        throw new Error(`Not implemented: ${node.type}`);
                }
            /* eslint-enable no-fallthrough */ });
            this.scope = scope;
            this.handlers.forEach((handler)=>{
                handler.modifiers.forEach((modifier)=>{
                    if (modifier !== "once") return component.error(handler, compiler_errors.invalid_event_modifier_component);
                });
            });
            const children = [];
            for(let i = info.children.length - 1; i >= 0; i--){
                const child = info.children[i];
                if (child.type === "SlotTemplate") {
                    children.push(child);
                    info.children.splice(i, 1);
                } else if ((child.type === "Element" || child.type === "InlineComponent" || child.type === "Slot") && child.attributes.find((attribute)=>attribute.name === "slot")) {
                    const slot_template = {
                        start: child.start,
                        end: child.end,
                        type: "SlotTemplate",
                        name: "svelte:fragment",
                        attributes: [],
                        children: [
                            child
                        ]
                    };
                    // transfer attributes
                    for(let i = child.attributes.length - 1; i >= 0; i--){
                        const attribute = child.attributes[i];
                        if (attribute.type === "Let") {
                            slot_template.attributes.push(attribute);
                            child.attributes.splice(i, 1);
                        } else if (attribute.type === "Attribute" && attribute.name === "slot") slot_template.attributes.push(attribute);
                    }
                    // transfer const
                    for(let i = child.children.length - 1; i >= 0; i--){
                        const child_child = child.children[i];
                        if (child_child.type === "ConstTag") {
                            slot_template.children.push(child_child);
                            child.children.splice(i, 1);
                        }
                    }
                    children.push(slot_template);
                    info.children.splice(i, 1);
                } else if (child.type === "Comment" && children.length > 0) children[children.length - 1].children.unshift(child);
            }
            if (info.children.some((node)=>not_whitespace_text(node))) children.push({
                start: info.start,
                end: info.end,
                type: "SlotTemplate",
                name: "svelte:fragment",
                attributes: [],
                children: info.children
            });
            if (let_attributes.length) // copy let: attribute from <Component /> to <svelte:fragment slot="default" />
            // as they are for `slot="default"` only
            children.forEach((child)=>{
                const slot = child.attributes.find((attribute)=>attribute.name === "slot");
                if (!slot || slot.value[0].data === "default") child.attributes.push(...let_attributes);
            });
            this.children = map_children(component, this, this.scope, children);
        }
        get slot_template_name() {
            return /** @type {string} */ this.attributes.find((attribute)=>attribute.name === "slot").get_static_value();
        }
    };
    /** @param {any} node */ function not_whitespace_text(node) {
        return !(node.type === "Text" && regex_only_whitespaces.test(node.data));
    }
    /**
 * @param {import('./shared/Node.js').default} parent
 * @param {string} explicit_namespace
 */ function get_namespace(parent, explicit_namespace) {
        const parent_element = parent.find_nearest(/^Element/);
        if (!parent_element) return explicit_namespace;
        return parent_element.namespace;
    }
    /** @extends AbstractBlock<'KeyBlock'> */ let KeyBlock$1 = class KeyBlock extends AbstractBlock {
        /** @type {import('./shared/Expression.js').default} */ expression;
        /**
	 * @param {import('../Component.js').default} component
	 * @param {import('./shared/Node.js').default} parent
	 * @param {import('./shared/TemplateScope.js').default} scope
	 * @param {import('../../interfaces.js').TemplateNode} info
	 */ constructor(component, parent, scope, info){
            super(component, parent, scope, info);
            this.cannot_use_innerhtml();
            this.not_static_content();
            this.expression = new Expression(component, this, scope, info.expression);
            this.children = map_children(component, this, scope, info.children);
            this.warn_if_empty_block();
        }
    };
    /**
 * @template {'MustacheTag' | 'RawMustacheTag'} [Type='MustacheTag' | 'RawMustacheTag']
 * @extends Node<Type>
 */ let Tag$2 = class Tag extends Node {
        /** @type {import('./Expression.js').default} */ expression;
        /** @type {boolean} */ should_cache;
        /**
	 * @param {any} component
	 * @param {any} parent
	 * @param {any} scope
	 * @param {any} info
	 */ constructor(component, parent, scope, info){
            super(component, parent, scope, info);
            component.tags.push(this);
            this.cannot_use_innerhtml();
            this.expression = new Expression(component, this, scope, info.expression);
            this.should_cache = info.expression.type !== "Identifier" || this.expression.dependencies.size && scope.names.has(info.expression.name);
        }
        is_dependencies_static() {
            return this.expression.dynamic_contextual_dependencies().length === 0 && this.expression.dynamic_dependencies().length === 0;
        }
        check_if_content_dynamic() {
            if (!this.is_dependencies_static()) this.not_static_content();
        }
    };
    /** @extends Tag<'MustacheTag'> */ class MustacheTag extends Tag$2 {
    }
    /** @extends Node<'Options'> */ class Options extends Node {
    }
    /** @extends Tag<'RawMustacheTag'> */ class RawMustacheTag extends Tag$2 {
        /**
	 * @param {any} component
	 * @param {any} parent
	 * @param {any} scope
	 * @param {any} info
	 */ constructor(component, parent, scope, info){
            super(component, parent, scope, info);
            this.cannot_use_innerhtml();
            this.not_static_content();
        }
    }
    /** @extends Node<'DebugTag'> */ let DebugTag$1 = class DebugTag extends Node {
        /** @type {import('./shared/Expression.js').default[]} */ expressions;
        /**
	 * @param {import('../Component.js').default} component
	 * @param {import('./interfaces.js').INode} parent
	 * @param {import('./shared/TemplateScope.js').default} scope
	 * @param {import('../../interfaces.js').TemplateNode} info
	 */ constructor(component, parent, scope, info){
            super(component, parent, scope, info);
            this.expressions = info.identifiers.map(/** @param {import('estree').Node} node */ (node)=>{
                return new Expression(component, parent, scope, node);
            });
        }
    };
    /** @extends Element */ let Slot$1 = class Slot extends Element$1 {
        /** @type {'Slot'} */ // @ts-ignore Slot elements have the 'Slot' type, but TypeScript doesn't allow us to have 'Slot' when it extends Element
        type = "Slot";
        /** @type {string} */ slot_name;
        /** @type {Map<string, import('./Attribute.js').default>} */ values = new Map();
        /**
	 * @param {import('../Component.js').default} component
	 * @param {import('./interfaces.js').INode} parent
	 * @param {import('./shared/TemplateScope.js').default} scope
	 * @param {import('../../interfaces.js').TemplateNode} info
	 */ constructor(component, parent, scope, info){
            super(component, parent, scope, info);
            info.attributes.forEach((attr)=>{
                if (attr.type !== "Attribute" && attr.type !== "Spread") return component.error(attr, compiler_errors.invalid_slot_directive);
                if (attr.name === "name") {
                    if (attr.value.length !== 1 || attr.value[0].type !== "Text") return component.error(attr, compiler_errors.dynamic_slot_name);
                    this.slot_name = attr.value[0].data;
                    if (this.slot_name === "default") return component.error(attr, compiler_errors.invalid_slot_name);
                }
                this.values.set(attr.name, new Attribute(component, this, scope, attr));
            });
            if (!this.slot_name) this.slot_name = "default";
            component.slots.set(this.slot_name, this);
            this.cannot_use_innerhtml();
            this.not_static_content();
        }
    };
    /** @extends Node<'SlotTemplate'> */ let SlotTemplate$1 = class SlotTemplate extends Node {
        /** @type {import('./shared/TemplateScope.js').default} */ scope;
        /** @type {import('./interfaces.js').INode[]} */ children;
        /** @type {import('./Let.js').default[]} */ lets = [];
        /** @type {import('./ConstTag.js').default[]} */ const_tags;
        /** @type {import('./Attribute.js').default} */ slot_attribute;
        /** @type {string} */ slot_template_name = "default";
        /**
	 * @param {import('../Component.js').default} component
	 * @param {import('./interfaces.js').INode} parent
	 * @param {import('./shared/TemplateScope.js').default} scope
	 * @param {any} info
	 */ constructor(component, parent, scope, info){
            super(component, parent, scope, info);
            this.validate_slot_template_placement();
            scope = scope.child();
            info.attributes.forEach((node)=>{
                switch(node.type){
                    case "Let":
                        {
                            const l = new Let(component, this, scope, node);
                            this.lets.push(l);
                            const dependencies = new Set([
                                l.name.name
                            ]);
                            l.names.forEach((name)=>{
                                scope.add(name, dependencies, this);
                            });
                            break;
                        }
                    case "Attribute":
                        if (node.name === "slot") {
                            this.slot_attribute = new Attribute(component, this, scope, node);
                            if (!this.slot_attribute.is_static) return component.error(node, compiler_errors.invalid_slot_attribute);
                            const value = this.slot_attribute.get_static_value();
                            if (typeof value === "boolean") return component.error(node, compiler_errors.invalid_slot_attribute_value_missing);
                            this.slot_template_name = /** @type {string} */ value;
                            break;
                        }
                        throw new Error(`Invalid attribute '${node.name}' in <svelte:fragment>`);
                    default:
                        throw new Error(`Not implemented: ${node.type}`);
                }
            });
            this.scope = scope;
            [this.const_tags, this.children] = get_const_tags$1(info.children, component, this, this);
        }
        validate_slot_template_placement() {
            if (this.parent.type !== "InlineComponent") return this.component.error(this, compiler_errors.invalid_slotted_content_fragment);
        }
    };
    /** @extends Node<'Title'> */ let Title$1 = class Title extends Node {
        /** @type {import('./shared/map_children.js').Children} */ children;
        /** @type {boolean} */ should_cache;
        /**
	 * @param {import('../Component.js').default} component
	 * @param {import('./shared/Node.js').default} parent
	 * @param {import('./shared/TemplateScope.js').default} scope
	 * @param {import('../../interfaces.js').TemplateNode} info
	 */ constructor(component, parent, scope, info){
            super(component, parent, scope, info);
            this.children = map_children(component, parent, scope, info.children);
            if (info.attributes.length > 0) {
                component.error(info.attributes[0], compiler_errors.illegal_attribute_title);
                return;
            }
            info.children.forEach((child)=>{
                if (child.type !== "Text" && child.type !== "MustacheTag") return component.error(child, compiler_errors.illegal_structure_title);
            });
            this.should_cache = info.children.length === 1 ? info.children[0].type !== "Identifier" || scope.names.has(info.children[0].name) : true;
        }
    };
    const valid_bindings = [
        "innerWidth",
        "innerHeight",
        "outerWidth",
        "outerHeight",
        "scrollX",
        "scrollY",
        "devicePixelRatio",
        "online"
    ];
    /** @extends Node<'Window'> */ class Window extends Node {
        /** @type {import('./EventHandler.js').default[]} */ handlers = [];
        /** @type {import('./Binding.js').default[]} */ bindings = [];
        /** @type {import('./Action.js').default[]} */ actions = [];
        /**
	 * @param {import('../Component.js').default} component
	 * @param {import('./shared/Node.js').default} parent
	 * @param {import('./shared/TemplateScope.js').default} scope
	 * @param {import('../../interfaces.js').TemplateNode} info
	 */ constructor(component, parent, scope, info){
            super(component, parent, scope, info);
            info.attributes.forEach((node)=>{
                if (node.type === "EventHandler") this.handlers.push(new EventHandler(component, this, scope, node));
                else if (node.type === "Binding") {
                    if (node.expression.type !== "Identifier") {
                        const { parts: parts } = flatten_reference(node.expression);
                        // TODO is this constraint necessary?
                        return component.error(node.expression, compiler_errors.invalid_binding_window(parts));
                    }
                    if (!~valid_bindings.indexOf(node.name)) {
                        const match = node.name === "width" ? "innerWidth" : node.name === "height" ? "innerHeight" : fuzzymatch(node.name, valid_bindings);
                        if (match) return component.error(node, compiler_errors.invalid_binding_on(node.name, "<svelte:window>", ` (did you mean '${match}'?)`));
                        else return component.error(node, compiler_errors.invalid_binding_on(node.name, "<svelte:window>", ` \u{2014} valid bindings are ${list(valid_bindings)}`));
                    }
                    this.bindings.push(new Binding(component, this, scope, node));
                } else if (node.type === "Action") this.actions.push(new Action(component, this, scope, node));
            });
        }
    }
    /**
 * Pushes all `items` into `array` using `push`, therefore mutating the array.
 * We do this for memory and perf reasons, and because `array.push(...items)` would
 * run into a "max call stack size exceeded" error with too many items (~65k).
 * @template T
 * @param {T[]} array
 * @param {T[]} items
 */ function push_array(array, items) {
        for(let i = 0; i < items.length; i++)array.push(items[i]);
    }
    /** @typedef {ReturnType<typeof map_children>} Children */ /** @param {any} type */ function get_constructor(type) {
        switch(type){
            case "AwaitBlock":
                return AwaitBlock$1;
            case "Body":
                return Body;
            case "Comment":
                return Comment$1;
            case "ConstTag":
                return ConstTag;
            case "Document":
                return Document;
            case "EachBlock":
                return EachBlock$1;
            case "Element":
                return Element$1;
            case "Head":
                return Head$1;
            case "IfBlock":
                return IfBlock$1;
            case "InlineComponent":
                return InlineComponent$1;
            case "KeyBlock":
                return KeyBlock$1;
            case "MustacheTag":
                return MustacheTag;
            case "Options":
                return Options;
            case "RawMustacheTag":
                return RawMustacheTag;
            case "DebugTag":
                return DebugTag$1;
            case "Slot":
                return Slot$1;
            case "SlotTemplate":
                return SlotTemplate$1;
            case "Text":
                return Text$1;
            case "Title":
                return Title$1;
            case "Window":
                return Window;
            default:
                throw new Error(`Not implemented: ${type}`);
        }
    }
    /**
 * @param {any} component
 * @param {any} parent
 * @param {any} scope
 * @param {import('../../../interfaces.js').TemplateNode[]} children
 */ function map_children(component, parent, scope, children) {
        let last = null;
        let ignores = [];
        return children.map((child)=>{
            const constructor = get_constructor(child.type);
            const use_ignores = child.type !== "Text" && child.type !== "Comment" && ignores.length;
            if (use_ignores) component.push_ignores(ignores);
            const node = new constructor(component, parent, scope, child);
            if (use_ignores) component.pop_ignores(), ignores = [];
            if (node.type === "Comment" && node.ignores.length) push_array(ignores, node.ignores);
            if (last) last.next = node;
            node.prev = last;
            last = node;
            return node;
        });
    }
    /**
 * @param {Array<[any, any]>} edges
 * @returns {any[]}
 */ function check_graph_for_cycles(edges) {
        /** @type {Map<any, any[]>} */ const graph = edges.reduce((g, edge)=>{
            const [u, v] = edge;
            if (!g.has(u)) g.set(u, []);
            if (!g.has(v)) g.set(v, []);
            g.get(u).push(v);
            return g;
        }, new Map());
        const visited = new Set();
        const on_stack = new Set();
        const cycles = [];
        function visit(v) {
            visited.add(v);
            on_stack.add(v);
            graph.get(v).forEach((w)=>{
                if (!visited.has(w)) visit(w);
                else if (on_stack.has(w)) cycles.push([
                    ...on_stack,
                    w
                ]);
            });
            on_stack.delete(v);
        }
        graph.forEach((_, v)=>{
            if (!visited.has(v)) visit(v);
        });
        return cycles[0];
    }
    /**
 * @param {import('../../../interfaces.js').TemplateNode[]} children
 * @param {import('../../Component.js').default} component
 * @param {import('../interfaces.js').INodeAllowConstTag} node
 * @param {import('../interfaces.js').INode} parent
 * @returns {[ConstTag[], Array<Exclude<import('../interfaces.js').INode, ConstTag>>]}
 */ function get_const_tags$1(children, component, node, parent) {
        /** @type {import('../../../interfaces.js').ConstTag[]} */ const const_tags = [];
        /** @type {Array<Exclude<import('../../../interfaces.js').TemplateNode, import('../../../interfaces.js').ConstTag>>} */ const others = [];
        for (const child of children)if (child.type === "ConstTag") const_tags.push(/** @type {import('../../../interfaces.js').ConstTag} */ child);
        else others.push(child);
        const consts_nodes = const_tags.map((tag)=>new ConstTag(component, node, node.scope, tag));
        const sorted_consts_nodes = sort_consts_nodes(consts_nodes, component);
        sorted_consts_nodes.forEach((node)=>node.parse_expression());
        const children_nodes = map_children(component, parent, node.scope, others);
        return [
            sorted_consts_nodes,
            /** @type {Array<Exclude<import('../interfaces.js').INode, ConstTag>>} */ children_nodes
        ];
    }
    /**
 * @param {ConstTag[]} consts_nodes
 * @param {import('../../Component.js').default} component
 */ function sort_consts_nodes(consts_nodes, component) {
        /** @typedef {{ assignees: Set<string>; dependencies: Set<string>; node: ConstTag; }} ConstNode */ /** @type {ConstNode[]} */ const sorted_consts_nodes = [];
        /** @type {ConstNode[]} */ const unsorted_consts_nodes = consts_nodes.map((node)=>{
            return {
                assignees: node.assignees,
                dependencies: node.dependencies,
                node: node
            };
        });
        const lookup = new Map();
        unsorted_consts_nodes.forEach((node)=>{
            node.assignees.forEach((name)=>{
                if (!lookup.has(name)) lookup.set(name, []);
                lookup.get(name).push(node);
            });
        });
        const cycle = check_graph_for_cycles(unsorted_consts_nodes.reduce((acc, node)=>{
            node.assignees.forEach((v)=>{
                node.dependencies.forEach((w)=>{
                    if (!node.assignees.has(w)) acc.push([
                        v,
                        w
                    ]);
                });
            });
            return acc;
        }, []));
        if (cycle && cycle.length) {
            const node_list = lookup.get(cycle[0]);
            const node = node_list[0];
            component.error(node.node, compiler_errors.cyclical_const_tags(cycle));
        }
        /** @param {ConstNode} node */ const add_node = (node)=>{
            if (sorted_consts_nodes.includes(node)) return;
            node.dependencies.forEach((name)=>{
                if (node.assignees.has(name)) return;
                const earlier_nodes = lookup.get(name);
                if (earlier_nodes) earlier_nodes.forEach(add_node);
            });
            sorted_consts_nodes.push(node);
        };
        unsorted_consts_nodes.forEach(add_node);
        return sorted_consts_nodes.map((node)=>node.node);
    }
    /** @extends AbstractBlock<'ThenBlock'> */ class ThenBlock extends AbstractBlock {
        /** @type {import('./shared/TemplateScope.js').default} */ scope;
        /** @type {import('./ConstTag.js').default[]} */ const_tags;
        /**
	 * @param {import('../Component.js').default} component
	 * @param {import('./AwaitBlock.js').default} parent
	 * @param {import('./shared/TemplateScope.js').default} scope
	 * @param {import('../../interfaces.js').TemplateNode} info
	 */ constructor(component, parent, scope, info){
            super(component, parent, scope, info);
            this.scope = scope.child();
            if (parent.then_node) parent.then_contexts.forEach((context)=>{
                if (context.type !== "DestructuredVariable") return;
                this.scope.add(context.key.name, parent.expression.dependencies, this);
            });
            [this.const_tags, this.children] = get_const_tags$1(info.children, component, this, parent);
            if (!info.skip) this.warn_if_empty_block();
        }
    }
    /**
 * @param {import('../../Block.js').default} block
 * @param {import('../../../nodes/ConstTag.js').default[]} const_tags
 * @param {string} ctx
 */ function add_const_tags(block, const_tags, ctx) {
        const const_tags_props = [];
        const_tags.forEach((const_tag, i)=>{
            const name = `#constants_${i}`;
            const_tags_props.push(b$1`const ${name} = ${const_tag.expression.manipulate(block, ctx)}`);
            /** @param {string} name */ const to_ctx = (name)=>block.renderer.context_lookup.has(name) ? x$1`${ctx}[${block.renderer.context_lookup.get(name).index}]` : /** @type {import('code-red').Node} */ {
                    type: "Identifier",
                    name: name
                };
            const_tag.contexts.forEach((context)=>{
                if (context.type === "DestructuredVariable") const_tags_props.push(b$1`${ctx}[${block.renderer.context_lookup.get(context.key.name).index}] = ${context.default_modifier(context.modifier({
                    type: "Identifier",
                    name: name
                }), to_ctx)}`);
                else {
                    const expression = new Expression(block.renderer.component, const_tag, const_tag.scope, context.key);
                    const_tags_props.push(b$1`const ${context.property_name} = ${expression.manipulate(block, ctx)}`);
                }
            });
        });
        return const_tags_props;
    }
    /**
 * @param {import('../../Renderer.js').default} renderer
 * @param {import('../../../nodes/ConstTag.js').default[]} const_tags
 */ function add_const_tags_context(renderer, const_tags) {
        const_tags.forEach((const_tag)=>{
            const_tag.contexts.forEach((context)=>{
                if (context.type !== "DestructuredVariable") return;
                renderer.add_to_context(context.key.name, true);
            });
        });
    }
    /** @extends Wrapper<import('../../nodes/PendingBlock.js').default | import('../../nodes/ThenBlock.js').default | import('../../nodes/CatchBlock.js').default> */ class AwaitBlockBranch extends Wrapper {
        /** @typedef {'pending' | 'then' | 'catch'} Status */ /** @type {import('../Block.js').default} */ block;
        /** @type {import('./Fragment.js').default} */ fragment;
        /** @type {boolean} */ is_dynamic;
        var = null;
        /** @type {Status} */ status;
        /** @type {string} */ value;
        /** @type {import('estree').Literal} */ value_index;
        /** @type {import('../../nodes/shared/Context.js').Context[]} */ value_contexts;
        /** @type {boolean} */ is_destructured;
        /**
	 * @param {Status} status
	 * @param {import('../Renderer.js').default} renderer
	 * @param {import('../Block.js').default} block
	 * @param {AwaitBlockWrapper} parent
	 * @param {import('../../nodes/PendingBlock.js').default | import('../../nodes/ThenBlock.js').default | import('../../nodes/CatchBlock.js').default} node
	 * @param {boolean} strip_whitespace
	 * @param {import('./shared/Wrapper.js').default} next_sibling
	 */ constructor(status, renderer, block, parent, node, strip_whitespace, next_sibling){
            super(renderer, block, parent, node);
            this.status = status;
            this.block = block.child({
                comment: create_debugging_comment(node, this.renderer.component),
                name: this.renderer.component.get_unique_name(`create_${status}_block`),
                type: status
            });
            this.add_context(parent.node[status + "_node"], parent.node[status + "_contexts"]);
            this.fragment = new FragmentWrapper(renderer, this.block, this.node.children, parent, strip_whitespace, next_sibling);
            this.is_dynamic = this.block.dependencies.size > 0;
        }
        /**
	 * @param {import('estree').Node | null} node
	 * @param {import('../../nodes/shared/Context.js').Context[]} contexts
	 */ add_context(node, contexts) {
            if (!node) return;
            if (node.type === "Identifier") {
                this.value = node.name;
                this.renderer.add_to_context(this.value, true);
            } else {
                contexts.forEach((context)=>{
                    if (context.type !== "DestructuredVariable") return;
                    this.renderer.add_to_context(context.key.name, true);
                });
                this.value = this.block.parent.get_unique_name("value").name;
                this.value_contexts = contexts;
                this.renderer.add_to_context(this.value, true);
                this.is_destructured = true;
            }
            this.value_index = this.renderer.context_lookup.get(this.value).index;
            if (this.has_consts(this.node)) add_const_tags_context(this.renderer, this.node.const_tags);
        }
        /**
	 * @param {import('../../nodes/PendingBlock.js').default | import('../../nodes/ThenBlock.js').default | import('../../nodes/CatchBlock.js').default} node
	 * @returns {node is import('../../nodes/ThenBlock.js').default | import('../../nodes/CatchBlock.js').default}
	 */ has_consts(node) {
            return node instanceof ThenBlock || node instanceof CatchBlock;
        }
        /**
	 * @param {import('../Block.js').default} block
	 * @param {import('estree').Identifier} parent_node
	 * @param {import('estree').Identifier} parent_nodes
	 */ render(block, parent_node, parent_nodes) {
            this.fragment.render(block, parent_node, parent_nodes);
            if (this.is_destructured || this.has_consts(this.node) && this.node.const_tags.length > 0) this.render_get_context();
        }
        render_get_context() {
            const props = this.is_destructured ? this.value_contexts.map((prop)=>{
                if (prop.type === "ComputedProperty") {
                    const expression = new Expression(this.renderer.component, this.node, this.has_consts(this.node) ? this.node.scope : null, prop.key);
                    return b$1`const ${prop.property_name} = ${expression.manipulate(this.block, "#ctx")};`;
                } else {
                    /** @param {any} name */ const to_ctx = (name)=>this.renderer.reference(name);
                    return b$1`#ctx[${this.block.renderer.context_lookup.get(prop.key.name).index}] = ${prop.default_modifier(prop.modifier(x$1`#ctx[${this.value_index}]`), to_ctx)};`;
                }
            }) : null;
            const const_tags_props = this.has_consts(this.node) ? add_const_tags(this.block, this.node.const_tags, "#ctx") : null;
            const get_context = this.block.renderer.component.get_unique_name(`get_${this.status}_context`);
            this.block.renderer.blocks.push(b$1`
			function ${get_context}(#ctx) {
				${props}
				${const_tags_props}
			}
		`);
            this.block.chunks.declarations.push(b$1`${get_context}(#ctx)`);
            if (this.block.has_update_method) this.block.chunks.update.unshift(b$1`${get_context}(#ctx)`);
        }
    }
    /** @extends Wrapper<import('../../nodes/AwaitBlock.js').default> */ class AwaitBlockWrapper extends Wrapper {
        /** @type {AwaitBlockBranch} */ pending;
        /** @type {AwaitBlockBranch} */ then;
        /** @type {AwaitBlockBranch} */ catch;
        /** @type {import('estree').Identifier} */ var = {
            type: "Identifier",
            name: "await_block"
        };
        /**
	 * @param {import('../Renderer.js').default} renderer
	 * @param {import('../Block.js').default} block
	 * @param {import('./shared/Wrapper.js').default} parent
	 * @param {import('../../nodes/AwaitBlock.js').default} node
	 * @param {boolean} strip_whitespace
	 * @param {import('./shared/Wrapper.js').default} next_sibling
	 */ constructor(renderer, block, parent, node, strip_whitespace, next_sibling){
            super(renderer, block, parent, node);
            block.add_dependencies(this.node.expression.dependencies);
            let is_dynamic = false;
            let has_intros = false;
            let has_outros = false;
            /** @type {const} */ [
                "pending",
                "then",
                "catch"
            ].forEach((status)=>{
                const child = this.node[status];
                const branch = new AwaitBlockBranch(status, renderer, block, this, child, strip_whitespace, next_sibling);
                renderer.blocks.push(branch.block);
                if (branch.is_dynamic) {
                    is_dynamic = true;
                    // TODO should blocks update their own parents?
                    block.add_dependencies(branch.block.dependencies);
                }
                if (branch.block.has_intros) has_intros = true;
                if (branch.block.has_outros) has_outros = true;
                this[status] = branch;
            });
            [
                "pending",
                "then",
                "catch"
            ].forEach((status)=>{
                this[status].block.has_update_method = is_dynamic;
                this[status].block.has_intro_method = has_intros;
                this[status].block.has_outro_method = has_outros;
            });
            if (has_outros) block.add_outro();
        }
        /**
	 * @param {import('../Block.js').default} block
	 * @param {import('estree').Identifier} parent_node
	 * @param {import('estree').Identifier} parent_nodes
	 */ render(block, parent_node, parent_nodes) {
            const anchor = this.get_or_create_anchor(block, parent_node, parent_nodes);
            const update_mount_node = this.get_update_mount_node(anchor);
            const snippet = this.node.expression.manipulate(block);
            const info = block.get_unique_name("info");
            const promise = block.get_unique_name("promise");
            block.add_variable(promise);
            block.maintain_context = true;
            /** @type {any} */ const info_props = x$1`{
			ctx: #ctx,
			current: null,
			token: null,
			hasCatch: ${this.catch.node.start !== null ? "true" : "false"},
			pending: ${this.pending.block.name},
			then: ${this.then.block.name},
			catch: ${this.catch.block.name},
			value: ${this.then.value_index},
			error: ${this.catch.value_index},
			blocks: ${this.pending.block.has_outro_method && x$1`[,,,]`}
		}`;
            block.chunks.init.push(b$1`
			let ${info} = ${info_props};
		`);
            block.chunks.init.push(b$1`
			@handle_promise(${promise} = ${snippet}, ${info});
		`);
            block.chunks.create.push(b$1`
			${info}.block.c();
		`);
            if (parent_nodes && this.renderer.options.hydratable) block.chunks.claim.push(b$1`
				${info}.block.l(${parent_nodes});
			`);
            const initial_mount_node = parent_node || "#target";
            const anchor_node = parent_node ? "null" : "#anchor";
            const has_transitions = this.pending.block.has_intro_method || this.pending.block.has_outro_method;
            block.chunks.mount.push(b$1`
			${info}.block.m(${initial_mount_node}, ${info}.anchor = ${anchor_node});
			${info}.mount = () => ${update_mount_node};
			${info}.anchor = ${anchor};
		`);
            if (has_transitions) block.chunks.intro.push(b$1`@transition_in(${info}.block);`);
            const dependencies = this.node.expression.dynamic_dependencies();
            const update_await_block_branch = b$1`@update_await_block_branch(${info}, #ctx, #dirty)`;
            if (dependencies.length > 0) {
                const condition = x$1`
				${block.renderer.dirty(dependencies)} &&
				${promise} !== (${promise} = ${snippet}) &&
				@handle_promise(${promise}, ${info})`;
                block.chunks.update.push(b$1`${info}.ctx = #ctx;`);
                if (this.pending.block.has_update_method) block.chunks.update.push(b$1`
					if (${condition}) {

					} else {
						${update_await_block_branch}
					}
				`);
                else block.chunks.update.push(b$1`
					${condition}
				`);
            } else if (this.pending.block.has_update_method) block.chunks.update.push(b$1`
					${update_await_block_branch}
				`);
            if (this.pending.block.has_outro_method) block.chunks.outro.push(b$1`
				for (let #i = 0; #i < 3; #i += 1) {
					const block = ${info}.blocks[#i];
					@transition_out(block);
				}
			`);
            block.chunks.destroy.push(b$1`
			${info}.block.d(${parent_node ? null : "detaching"});
			${info}.token = null;
			${info} = null;
		`);
            [
                this.pending,
                this.then,
                this.catch
            ].forEach((branch)=>{
                branch.render(branch.block, null, /** @type {import('estree').Identifier} */ x$1`#nodes`);
            });
        }
    }
    const TRUE = x$1`true`;
    const FALSE = x$1`false`;
    class EventHandlerWrapper {
        /** @type {import('../../../nodes/EventHandler.js').default} */ node;
        /** @type {import('../shared/Wrapper.js').default} */ parent;
        /**
	 * @param {import('../../../nodes/EventHandler.js').default} node
	 * @param {import('../shared/Wrapper.js').default} parent
	 */ constructor(node, parent){
            this.node = node;
            this.parent = parent;
            if (!node.expression) {
                this.parent.renderer.add_to_context(node.handler_name.name);
                this.parent.renderer.component.partly_hoisted.push(b$1`
				function ${node.handler_name.name}(event) {
					@bubble.call(this, $$self, event);
				}
			`);
            }
        }
        /** @param {import('../../Block.js').default} block */ get_snippet(block) {
            const snippet = this.node.expression ? this.node.expression.manipulate(block) : block.renderer.reference(this.node.handler_name);
            if (this.node.reassigned) {
                block.maintain_context = true;
                return x$1`function () { if (@is_function(${snippet})) ${snippet}.apply(this, arguments); }`;
            }
            return snippet;
        }
        /**
	 * @param {import('../../Block.js').default} block
	 * @param {string | import('estree').Expression} target
	 */ render(block, target) {
            let snippet = this.get_snippet(block);
            if (this.node.modifiers.has("preventDefault")) snippet = x$1`@prevent_default(${snippet})`;
            if (this.node.modifiers.has("stopPropagation")) snippet = x$1`@stop_propagation(${snippet})`;
            if (this.node.modifiers.has("stopImmediatePropagation")) snippet = x$1`@stop_immediate_propagation(${snippet})`;
            if (this.node.modifiers.has("self")) snippet = x$1`@self(${snippet})`;
            if (this.node.modifiers.has("trusted")) snippet = x$1`@trusted(${snippet})`;
            const args = [];
            const opts = [
                "nonpassive",
                "passive",
                "once",
                "capture"
            ].filter((mod)=>this.node.modifiers.has(mod));
            if (opts.length) {
                if (opts.length === 1 && opts[0] === "capture") args.push(TRUE);
                else args.push(x$1`{ ${opts.map((opt)=>opt === "nonpassive" ? p`passive: false` : p`${opt}: true`)} }`);
            } else if (block.renderer.options.dev) args.push(FALSE);
            if (block.renderer.options.dev) {
                args.push(this.node.modifiers.has("preventDefault") ? TRUE : FALSE);
                args.push(this.node.modifiers.has("stopPropagation") ? TRUE : FALSE);
                args.push(this.node.modifiers.has("stopImmediatePropagation") ? TRUE : FALSE);
            }
            block.event_listeners.push(x$1`@listen(${target}, "${this.node.name}", ${snippet}, ${args})`);
        }
    }
    /**
 * @param {import('../../Block.js').default} block
 * @param {string | import('estree').Expression} target
 * @param {import('../Element/EventHandler.js').default[]} handlers
 */ function add_event_handlers(block, target, handlers) {
        handlers.forEach((handler)=>add_event_handler(block, target, handler));
    }
    /**
 * @param {import('../../Block.js').default} block
 * @param {string | import('estree').Expression} target
 * @param {import('../Element/EventHandler.js').default} handler
 */ function add_event_handler(block, target, handler) {
        handler.render(block, target);
    }
    /**
 * @param {import('../../Block.js').default} block
 * @param {string | import('estree').Expression} target
 * @param {import('../../../nodes/Action.js').default[]} actions
 */ function add_actions(block, target, actions) {
        actions.forEach((action)=>add_action(block, target, action));
    }
    const regex_invalid_variable_identifier_characters$3 = /[^a-zA-Z0-9_$]/g;
    /**
 * @param {import('../../Block.js').default} block
 * @param {string | import('estree').Expression} target
 * @param {import('../../../nodes/Action.js').default} action
 */ function add_action(block, target, action) {
        const { expression: expression, template_scope: template_scope } = action;
        /** @type {import('estree').Node | undefined} */ let snippet;
        /** @type {string[] | undefined} */ let dependencies;
        if (expression) {
            snippet = expression.manipulate(block);
            dependencies = expression.dynamic_dependencies();
        }
        const id = block.get_unique_name(`${action.name.replace(regex_invalid_variable_identifier_characters$3, "_")}_action`);
        block.add_variable(id);
        const [obj, ...properties] = action.name.split(".");
        const fn = is_contextual(action.component, template_scope, obj) ? block.renderer.reference(obj) : obj;
        if (properties.length) {
            const member_expression = properties.reduce((lhs, rhs)=>x$1`${lhs}.${rhs}`, fn);
            block.event_listeners.push(x$1`@action_destroyer(${id} = ${member_expression}(${target}, ${snippet}))`);
        } else block.event_listeners.push(x$1`@action_destroyer(${id} = ${fn}.call(null, ${target}, ${snippet}))`);
        if (dependencies && dependencies.length > 0) {
            let condition = x$1`${id} && @is_function(${id}.update)`;
            if (dependencies.length > 0) condition = x$1`${condition} && ${block.renderer.dirty(dependencies)}`;
            block.chunks.update.push(b$1`if (${condition}) ${id}.update.call(null, ${snippet});`);
        }
    }
    /** @extends Wrapper<import('../../nodes/Body.js').default> */ class BodyWrapper extends Wrapper {
        /** @type {import('./Element/EventHandler.js').default[]} */ handlers;
        /**
	 * @param {import('../Renderer.js').default} renderer
	 * @param {import('../Block.js').default} block
	 * @param {import('./shared/Wrapper.js').default} parent
	 * @param {import('../../nodes/Body.js').default} node
	 */ constructor(renderer, block, parent, node){
            super(renderer, block, parent, node);
            this.handlers = this.node.handlers.map((handler)=>new EventHandlerWrapper(handler, this));
        }
        /**
	 * @param {import('../Block.js').default} block
	 * @param {import('estree').Identifier} _parent_node
	 * @param {import('estree').Identifier} _parent_nodes
	 */ render(block, _parent_node, _parent_nodes) {
            add_event_handlers(block, x$1`@_document.body`, this.handlers);
            add_actions(block, x$1`@_document.body`, this.node.actions);
        }
    }
    /** @extends Wrapper<import('../../nodes/DebugTag.js').default> */ class DebugTagWrapper extends Wrapper {
        /**
	 * @param {import('../Renderer.js').default} renderer
	 * @param {import('../Block.js').default} block
	 * @param {import('./shared/Wrapper.js').default} parent
	 * @param {import('../../nodes/DebugTag.js').default} node
	 * @param {boolean} _strip_whitespace
	 * @param {import('./shared/Wrapper.js').default} _next_sibling
	 */ constructor(renderer, block, parent, node, _strip_whitespace, _next_sibling){
            super(renderer, block, parent, node);
        }
        /**
	 * @param {import('../Block.js').default} block
	 * @param {import('estree').Identifier} _parent_node
	 * @param {import('estree').Identifier} _parent_nodes
	 */ render(block, _parent_node, _parent_nodes) {
            const { renderer: renderer } = this;
            const { component: component } = renderer;
            if (!renderer.options.dev) return;
            const { var_lookup: var_lookup } = component;
            const start = component.locate(this.node.start + 1);
            const end = {
                line: start.line,
                column: start.column + 6
            };
            const loc = {
                start: start,
                end: end
            };
            /** @type {import('estree').DebuggerStatement} */ const debug = {
                type: "DebuggerStatement",
                loc: loc
            };
            if (this.node.expressions.length === 0) {
                // Debug all
                block.chunks.create.push(debug);
                block.chunks.update.push(debug);
            } else {
                /** @type {import('estree').Identifier} */ const log = {
                    type: "Identifier",
                    name: "log",
                    loc: loc
                };
                /** @type {Set<string>} */ const dependencies = new Set();
                this.node.expressions.forEach((expression)=>{
                    add_to_set(dependencies, expression.dependencies);
                });
                const contextual_identifiers = this.node.expressions.filter((e)=>{
                    const variable = var_lookup.get(/** @type {import('estree').Identifier} */ e.node.name);
                    return !(variable && variable.hoistable);
                }).map((e)=>/** @type {import('estree').Identifier} */ e.node.name);
                const logged_identifiers = this.node.expressions.map((e)=>p`${e.node.name}`);
                const debug_statements = b$1`
				${contextual_identifiers.map((name)=>b$1`const ${name} = ${renderer.reference(name)};`)}
				@_console.${log}({ ${logged_identifiers} });
				debugger;`;
                if (dependencies.size) {
                    const condition = renderer.dirty(Array.from(dependencies));
                    block.chunks.update.push(b$1`
					if (${condition}) {
						${debug_statements}
					}
				`);
                }
                block.chunks.create.push(b$1`{
				${debug_statements}
			}`);
            }
        }
    }
    const associated_events$1 = {
        fullscreenElement: [
            "fullscreenchange"
        ],
        visibilityState: [
            "visibilitychange"
        ]
    };
    const readonly$1 = new Set([
        "fullscreenElement",
        "visibilityState"
    ]);
    /** @extends Wrapper<import('../../nodes/Document.js').default> */ class DocumentWrapper extends Wrapper {
        /** @type {import('./Element/EventHandler.js').default[]} */ handlers;
        /**
	 * @param {import('../Renderer.js').default} renderer
	 * @param {import('../Block.js').default} block
	 * @param {import('./shared/Wrapper.js').default} parent
	 * @param {import('../../nodes/Document.js').default} node
	 */ constructor(renderer, block, parent, node){
            super(renderer, block, parent, node);
            this.handlers = this.node.handlers.map((handler)=>new EventHandlerWrapper(handler, this));
        }
        /**
	 * @param {import('../Block.js').default} block
	 * @param {import('estree').Identifier} _parent_node
	 * @param {import('estree').Identifier} _parent_nodes
	 */ render(block, _parent_node, _parent_nodes) {
            const { renderer: renderer } = this;
            const { component: component } = renderer;
            /** @type {Record<string, Array<{ name: string; value: string }>>} */ const events = {};
            /** @type {Record<string, string>} */ const bindings = {};
            add_event_handlers(block, x$1`@_document`, this.handlers);
            add_actions(block, x$1`@_document`, this.node.actions);
            this.node.bindings.forEach((binding)=>{
                // TODO: what if it's a MemberExpression?
                const binding_name = /** @type {import('estree').Identifier} */ binding.expression.node.name;
                // in dev mode, throw if read-only values are written to
                if (readonly$1.has(binding.name)) renderer.readonly.add(binding_name);
                bindings[binding.name] = binding_name;
                const binding_events = associated_events$1[binding.name];
                const property = binding.name;
                binding_events.forEach((associated_event)=>{
                    if (!events[associated_event]) events[associated_event] = [];
                    events[associated_event].push({
                        name: binding_name,
                        value: property
                    });
                });
            });
            Object.keys(events).forEach((event)=>{
                const id = block.get_unique_name(`ondocument${event}`);
                const props = events[event];
                renderer.add_to_context(id.name);
                const fn = renderer.reference(id.name);
                props.forEach((prop)=>{
                    renderer.meta_bindings.push(b$1`this._state.${prop.name} = @_document.${prop.value};`);
                });
                block.event_listeners.push(x$1`
				@listen(@_document, "${event}", ${fn})
			`);
                component.partly_hoisted.push(b$1`
				function ${id}() {
					${props.map((prop)=>renderer.invalidate(prop.name, x$1`${prop.name} = @_document.${prop.value}`))}
				}
			`);
                block.chunks.init.push(b$1`
				@add_render_callback(${fn});
			`);
                component.has_reactive_assignments = true;
            });
        }
    }
    /** @extends Wrapper<import('../../nodes/ElseBlock.js').default> */ class ElseBlockWrapper extends Wrapper {
        /** @type {import('../Block.js').default} */ block;
        /** @type {import('./Fragment.js').default} */ fragment;
        /** @type {boolean} */ is_dynamic;
        var = null;
        /**
	 * @param {import('../Renderer.js').default} renderer
	 * @param {import('../Block.js').default} block
	 * @param {import('./shared/Wrapper.js').default} parent
	 * @param {import('../../nodes/ElseBlock.js').default} node
	 * @param {boolean} strip_whitespace
	 * @param {import('./shared/Wrapper.js').default} next_sibling
	 */ constructor(renderer, block, parent, node, strip_whitespace, next_sibling){
            super(renderer, block, parent, node);
            add_const_tags_context(renderer, this.node.const_tags);
            this.block = block.child({
                comment: create_debugging_comment(node, this.renderer.component),
                name: this.renderer.component.get_unique_name("create_else_block"),
                type: "else"
            });
            this.fragment = new FragmentWrapper(renderer, this.block, this.node.children, parent, strip_whitespace, next_sibling);
            this.is_dynamic = this.block.dependencies.size > 0;
        }
    }
    /** @extends Wrapper<import('../../nodes/EachBlock.js').default> */ class EachBlockWrapper extends Wrapper {
        /** @type {import('../Block.js').default} */ block;
        /** @type {import('./Fragment.js').default} */ fragment;
        /** @type {ElseBlockWrapper} */ else;
        /**
	 * @type {{
	 * 		create_each_block: import('estree').Identifier;
	 * 		each_block_value: import('estree').Identifier;
	 * 		get_each_context: import('estree').Identifier;
	 * 		iterations: import('estree').Identifier;
	 * 		fixed_length: number;
	 * 		data_length: import('estree').Node | number;
	 * 		view_length: import('estree').Node | number;
	 * 	}}
	 */ vars;
        /** @type {Array<import('estree').Node | import('estree').Node[]>} */ context_props;
        /** @type {import('estree').Identifier} */ index_name;
        /** @type {Array<import('estree').Node | import('estree').Node[]>} */ updates = [];
        /** @type {Set<string>} */ dependencies;
        /** @type {import('estree').Identifier} */ var = {
            type: "Identifier",
            name: "each"
        };
        /**
	 * @param {import('../Renderer.js').default} renderer
	 * @param {import('../Block.js').default} block
	 * @param {import('./shared/Wrapper.js').default} parent
	 * @param {import('../../nodes/EachBlock.js').default} node
	 * @param {boolean} strip_whitespace
	 * @param {import('./shared/Wrapper.js').default} next_sibling
	 */ constructor(renderer, block, parent, node, strip_whitespace, next_sibling){
            super(renderer, block, parent, node);
            const { dependencies: dependencies } = node.expression;
            block.add_dependencies(dependencies);
            this.node.contexts.forEach((context)=>{
                if (context.type !== "DestructuredVariable") return;
                renderer.add_to_context(context.key.name, true);
            });
            add_const_tags_context(renderer, this.node.const_tags);
            this.block = block.child({
                comment: create_debugging_comment(this.node, this.renderer.component),
                name: renderer.component.get_unique_name("create_each_block"),
                type: "each",
                // @ts-ignore todo: probably error
                key: /** @type {string} */ node.key,
                bindings: new Map(block.bindings)
            });
            // TODO this seems messy
            this.block.has_animation = this.node.has_animation;
            this.index_name = this.node.index ? {
                type: "Identifier",
                name: this.node.index
            } : renderer.component.get_unique_name(`${this.node.context}_index`);
            const fixed_length = node.expression.node.type === "ArrayExpression" && node.expression.node.elements.every((element)=>element.type !== "SpreadElement") ? node.expression.node.elements.length : null;
            // hack the sourcemap, so that if data is missing the bug
            // is easy to find
            let c = this.node.start + 2;
            while(renderer.component.source[c] !== "e")c += 1;
            const start = renderer.component.locate(c);
            const end = {
                line: start.line,
                column: start.column + 4
            };
            const length = {
                type: "Identifier",
                name: "length",
                loc: {
                    start: start,
                    end: end
                }
            };
            const each_block_value = renderer.component.get_unique_name(`${this.var.name}_value`);
            const iterations = block.get_unique_name(`${this.var.name}_blocks`);
            renderer.add_to_context(each_block_value.name, true);
            renderer.add_to_context(this.index_name.name, true);
            this.vars = {
                create_each_block: this.block.name,
                each_block_value: each_block_value,
                get_each_context: renderer.component.get_unique_name(`get_${this.var.name}_context`),
                iterations: iterations,
                fixed_length: // optimisation for array literal
                fixed_length,
                data_length: fixed_length === null ? x$1`${each_block_value}.${length}` : fixed_length,
                view_length: fixed_length === null ? x$1`${iterations}.length` : fixed_length
            };
            const object = get_object(node.expression.node);
            const store = object.type === "Identifier" && object.name[0] === "$" ? object.name.slice(1) : null;
            node.contexts.forEach((prop)=>{
                if (prop.type !== "DestructuredVariable") return;
                this.block.bindings.set(prop.key.name, {
                    object: this.vars.each_block_value,
                    property: this.index_name,
                    modifier: prop.modifier,
                    snippet: prop.modifier(/** @type {import('estree').Node} */ x$1`${this.vars.each_block_value}[${this.index_name}]`),
                    store: store
                });
            });
            if (this.node.index) this.block.get_unique_name(this.node.index); // this prevents name collisions (#1254)
            renderer.blocks.push(this.block);
            this.fragment = new FragmentWrapper(renderer, this.block, node.children, this, strip_whitespace, next_sibling);
            if (this.node.else) {
                this.else = new ElseBlockWrapper(renderer, block, this, this.node.else, strip_whitespace, next_sibling);
                renderer.blocks.push(this.else.block);
                if (this.else.is_dynamic) this.block.add_dependencies(this.else.block.dependencies);
            }
            block.add_dependencies(this.block.dependencies);
            if (this.block.has_outros || this.else && this.else.block.has_outros) block.add_outro();
        }
        /**
	 * @param {import('../Block.js').default} block
	 * @param {import('estree').Identifier} parent_node
	 * @param {import('estree').Identifier} parent_nodes
	 */ render(block, parent_node, parent_nodes) {
            if (this.fragment.nodes.length === 0) return;
            const { renderer: renderer } = this;
            const { component: component } = renderer;
            const needs_anchor = this.next ? !this.next.is_dom_node() : !parent_node || !this.parent.is_dom_node();
            const snippet = x$1`@ensure_array_like(${this.node.expression.manipulate(block)})`;
            block.chunks.init.push(b$1`let ${this.vars.each_block_value} = ${snippet};`);
            /** @type {import('estree').Identifier} */ const initial_anchor_node = {
                type: "Identifier",
                name: parent_node ? "null" : "#anchor"
            };
            /** @type {import('estree').Identifier} */ const initial_mount_node = parent_node || {
                type: "Identifier",
                name: "#target"
            };
            const update_anchor_node = needs_anchor ? block.get_unique_name(`${this.var.name}_anchor`) : this.next && this.next.var || {
                type: "Identifier",
                name: "null"
            };
            /** @type {import('estree').Identifier} */ const update_mount_node = this.get_update_mount_node(/** @type {import('estree').Identifier} */ update_anchor_node);
            const args = {
                block: block,
                parent_node: parent_node,
                parent_nodes: parent_nodes,
                snippet: snippet,
                initial_anchor_node: initial_anchor_node,
                initial_mount_node: initial_mount_node,
                update_anchor_node: update_anchor_node,
                update_mount_node: update_mount_node
            };
            const all_dependencies = new Set(this.block.dependencies); // TODO should be dynamic deps only
            this.node.expression.dynamic_dependencies().forEach((dependency)=>{
                all_dependencies.add(dependency);
            });
            if (this.node.key) this.node.key.dynamic_dependencies().forEach((dependency)=>{
                all_dependencies.add(dependency);
            });
            this.dependencies = all_dependencies;
            if (this.node.key) this.render_keyed(args);
            else this.render_unkeyed(args);
            if (this.block.has_intro_method || this.block.has_outro_method) block.chunks.intro.push(b$1`
				for (let #i = 0; #i < ${this.vars.data_length}; #i += 1) {
					@transition_in(${this.vars.iterations}[#i]);
				}
			`);
            if (needs_anchor) block.add_element(/** @type {import('estree').Identifier} */ update_anchor_node, x$1`@empty()`, parent_nodes && x$1`@empty()`, parent_node);
            if (this.else) {
                let else_ctx = x$1`#ctx`;
                if (this.else.node.const_tags.length > 0) {
                    const get_ctx_name = this.renderer.component.get_unique_name("get_else_ctx");
                    this.renderer.blocks.push(b$1`
					function ${get_ctx_name}(#ctx) {
						const child_ctx = #ctx.slice();
						${add_const_tags(block, this.else.node.const_tags, "child_ctx")}
						return child_ctx;
					}
				`);
                    else_ctx = x$1`${get_ctx_name}(#ctx)`;
                }
                const each_block_else = component.get_unique_name(`${this.var.name}_else`);
                block.chunks.init.push(b$1`let ${each_block_else} = null;`);
                // TODO neaten this up... will end up with an empty line in the block
                block.chunks.init.push(b$1`
				if (!${this.vars.data_length}) {
					${each_block_else} = ${this.else.block.name}(${else_ctx});
				}
			`);
                block.chunks.create.push(b$1`
				if (${each_block_else}) {
					${each_block_else}.c();
				}
			`);
                if (this.renderer.options.hydratable) block.chunks.claim.push(b$1`
					if (${each_block_else}) {
						${each_block_else}.l(${parent_nodes});
					}
				`);
                block.chunks.mount.push(b$1`
				if (${each_block_else}) {
					${each_block_else}.m(${initial_mount_node}, ${initial_anchor_node});
				}
			`);
                const has_transitions = !!(this.else.block.has_intro_method || this.else.block.has_outro_method);
                const destroy_block_else = this.else.block.has_outro_method ? b$1`
					@group_outros();
					@transition_out(${each_block_else}, 1, 1, () => {
						${each_block_else} = null;
					});
					@check_outros();` : b$1`
					${each_block_else}.d(1);
					${each_block_else} = null;`;
                if (this.else.block.has_update_method) this.updates.push(b$1`
					if (!${this.vars.data_length} && ${each_block_else}) {
						${each_block_else}.p(${else_ctx}, #dirty);
					} else if (!${this.vars.data_length}) {
						${each_block_else} = ${this.else.block.name}(${else_ctx});
						${each_block_else}.c();
						${has_transitions && b$1`@transition_in(${each_block_else}, 1);`}
						${each_block_else}.m(${update_mount_node}, ${update_anchor_node});
					} else if (${each_block_else}) {
						${destroy_block_else};
					}
				`);
                else this.updates.push(b$1`
					if (${this.vars.data_length}) {
						if (${each_block_else}) {
							${destroy_block_else};
						}
					} else if (!${each_block_else}) {
						${each_block_else} = ${this.else.block.name}(${else_ctx});
						${each_block_else}.c();
						${has_transitions && b$1`@transition_in(${each_block_else}, 1);`}
						${each_block_else}.m(${update_mount_node}, ${update_anchor_node});
					}
				`);
                block.chunks.destroy.push(b$1`
				if (${each_block_else}) ${each_block_else}.d(${parent_node ? "" : "detaching"});
			`);
            }
            if (this.updates.length) block.chunks.update.push(b$1`
				if (${block.renderer.dirty(Array.from(all_dependencies))}) {
					${this.updates}
				}
			`);
            this.fragment.render(this.block, null, /** @type {import('estree').Identifier} */ x$1`#nodes`);
            if (this.else) this.else.fragment.render(this.else.block, null, /** @type {import('estree').Identifier} */ x$1`#nodes`);
            this.context_props = this.node.contexts.map((prop)=>{
                if (prop.type === "DestructuredVariable") {
                    /** @param {string} name */ const to_ctx = (name)=>renderer.context_lookup.has(name) ? x$1`child_ctx[${renderer.context_lookup.get(name).index}]` : /** @type {import('estree').Node} */ {
                            type: "Identifier",
                            name: name
                        };
                    return b$1`child_ctx[${renderer.context_lookup.get(prop.key.name).index}] = ${prop.default_modifier(prop.modifier(x$1`list[i]`), to_ctx)};`;
                } else {
                    const expression = new Expression(this.renderer.component, this.node, this.node.scope, prop.key);
                    return b$1`const ${prop.property_name} = ${expression.manipulate(block, "child_ctx")};`;
                }
            });
            if (this.node.has_binding) this.context_props.push(b$1`child_ctx[${renderer.context_lookup.get(this.vars.each_block_value.name).index}] = list;`);
            if (this.node.has_binding || this.node.has_index_binding || this.node.index) this.context_props.push(b$1`child_ctx[${renderer.context_lookup.get(this.index_name.name).index}] = i;`);
            // TODO which is better — Object.create(array) or array.slice()?
            renderer.blocks.push(b$1`
			function ${this.vars.get_each_context}(#ctx, list, i) {
				const child_ctx = #ctx.slice();
				${this.context_props}
				${add_const_tags(this.block, this.node.const_tags, "child_ctx")}
				return child_ctx;
			}
		`);
        }
        /**
	 * @param {{
	 * 		block: import('../Block.js').default;
	 * 		parent_node: import('estree').Identifier;
	 * 		parent_nodes: import('estree').Identifier;
	 * 		snippet: import('estree').Node;
	 * 		initial_anchor_node: import('estree').Identifier;
	 * 		initial_mount_node: import('estree').Identifier;
	 * 		update_anchor_node: import('estree').Identifier;
	 * 		update_mount_node: import('estree').Identifier;
	 * 	}} params
	 */ render_keyed({ block: block, parent_node: parent_node, parent_nodes: parent_nodes, snippet: snippet, initial_anchor_node: initial_anchor_node, initial_mount_node: initial_mount_node, update_anchor_node: update_anchor_node, update_mount_node: update_mount_node }) {
            const { create_each_block: create_each_block, iterations: iterations, data_length: data_length, view_length: view_length } = this.vars;
            const get_key = block.get_unique_name("get_key");
            const lookup = block.get_unique_name(`${this.var.name}_lookup`);
            block.add_variable(iterations, x$1`[]`);
            block.add_variable(lookup, x$1`new @_Map()`);
            if (this.fragment.nodes[0].is_dom_node()) this.block.first = this.fragment.nodes[0].var;
            else {
                this.block.first = this.block.get_unique_name("first");
                this.block.add_element(this.block.first, x$1`@empty()`, parent_nodes && x$1`@empty()`, null);
            }
            block.chunks.init.push(b$1`
			const ${get_key} = #ctx => ${this.node.key.manipulate(block)};

			${this.renderer.options.dev && b$1`@validate_each_keys(#ctx, ${this.vars.each_block_value}, ${this.vars.get_each_context}, ${get_key});`}
			for (let #i = 0; #i < ${data_length}; #i += 1) {
				let child_ctx = ${this.vars.get_each_context}(#ctx, ${this.vars.each_block_value}, #i);
				let key = ${get_key}(child_ctx);
				${lookup}.set(key, ${iterations}[#i] = ${create_each_block}(key, child_ctx));
			}
		`);
            block.chunks.create.push(b$1`
			for (let #i = 0; #i < ${view_length}; #i += 1) {
				${iterations}[#i].c();
			}
		`);
            if (parent_nodes && this.renderer.options.hydratable) block.chunks.claim.push(b$1`
				for (let #i = 0; #i < ${view_length}; #i += 1) {
					${iterations}[#i].l(${parent_nodes});
				}
			`);
            block.chunks.mount.push(b$1`
			for (let #i = 0; #i < ${view_length}; #i += 1) {
				if (${iterations}[#i]) {
					${iterations}[#i].m(${initial_mount_node}, ${initial_anchor_node});
				}
			}
		`);
            const dynamic = this.block.has_update_method;
            const destroy = this.node.has_animation ? this.block.has_outros ? "@fix_and_outro_and_destroy_block" : "@fix_and_destroy_block" : this.block.has_outros ? "@outro_and_destroy_block" : "@destroy_block";
            if (this.dependencies.size) {
                this.block.maintain_context = true;
                this.updates.push(b$1`
				${this.vars.each_block_value} = ${snippet};

				${this.block.has_outros && b$1`@group_outros();`}
				${this.node.has_animation && b$1`for (let #i = 0; #i < ${view_length}; #i += 1) ${iterations}[#i].r();`}
				${this.renderer.options.dev && b$1`@validate_each_keys(#ctx, ${this.vars.each_block_value}, ${this.vars.get_each_context}, ${get_key});`}
				${iterations} = @update_keyed_each(${iterations}, #dirty, ${get_key}, ${dynamic ? 1 : 0}, #ctx, ${this.vars.each_block_value}, ${lookup}, ${update_mount_node}, ${destroy}, ${create_each_block}, ${update_anchor_node}, ${this.vars.get_each_context});
				${this.node.has_animation && b$1`for (let #i = 0; #i < ${view_length}; #i += 1) ${iterations}[#i].a();`}
				${this.block.has_outros && b$1`@check_outros();`}
			`);
            }
            if (this.block.has_outros) block.chunks.outro.push(b$1`
				for (let #i = 0; #i < ${view_length}; #i += 1) {
					@transition_out(${iterations}[#i]);
				}
			`);
            block.chunks.destroy.push(b$1`
			for (let #i = 0; #i < ${view_length}; #i += 1) {
				${iterations}[#i].d(${parent_node ? null : "detaching"});
			}
		`);
        }
        /**
	 * @param {{
	 * 		block: import('../Block.js').default;
	 * 		parent_nodes: import('estree').Identifier;
	 * 		snippet: import('estree').Node;
	 * 		initial_anchor_node: import('estree').Identifier;
	 * 		initial_mount_node: import('estree').Identifier;
	 * 		update_anchor_node: import('estree').Identifier;
	 * 		update_mount_node: import('estree').Identifier;
	 * 	}} params
	 */ render_unkeyed({ block: block, parent_nodes: parent_nodes, snippet: snippet, initial_anchor_node: initial_anchor_node, initial_mount_node: initial_mount_node, update_anchor_node: update_anchor_node, update_mount_node: update_mount_node }) {
            const { create_each_block: create_each_block, iterations: iterations, fixed_length: fixed_length, data_length: data_length, view_length: view_length } = this.vars;
            block.chunks.init.push(b$1`
			let ${iterations} = [];

			for (let #i = 0; #i < ${data_length}; #i += 1) {
				${iterations}[#i] = ${create_each_block}(${this.vars.get_each_context}(#ctx, ${this.vars.each_block_value}, #i));
			}
		`);
            block.chunks.create.push(b$1`
			for (let #i = 0; #i < ${view_length}; #i += 1) {
				${iterations}[#i].c();
			}
		`);
            if (parent_nodes && this.renderer.options.hydratable) block.chunks.claim.push(b$1`
				for (let #i = 0; #i < ${view_length}; #i += 1) {
					${iterations}[#i].l(${parent_nodes});
				}
			`);
            block.chunks.mount.push(b$1`
			for (let #i = 0; #i < ${view_length}; #i += 1) {
				if (${iterations}[#i]) {
					${iterations}[#i].m(${initial_mount_node}, ${initial_anchor_node});
				}
			}
		`);
            if (this.dependencies.size) {
                const has_transitions = !!(this.block.has_intro_method || this.block.has_outro_method);
                const for_loop_body = this.block.has_update_method ? b$1`
					if (${iterations}[#i]) {
						${iterations}[#i].p(child_ctx, #dirty);
						${has_transitions && b$1`@transition_in(${this.vars.iterations}[#i], 1);`}
					} else {
						${iterations}[#i] = ${create_each_block}(child_ctx);
						${iterations}[#i].c();
						${has_transitions && b$1`@transition_in(${this.vars.iterations}[#i], 1);`}
						${iterations}[#i].m(${update_mount_node}, ${update_anchor_node});
					}
				` : has_transitions ? b$1`
						if (${iterations}[#i]) {
							@transition_in(${this.vars.iterations}[#i], 1);
						} else {
							${iterations}[#i] = ${create_each_block}(child_ctx);
							${iterations}[#i].c();
							@transition_in(${this.vars.iterations}[#i], 1);
							${iterations}[#i].m(${update_mount_node}, ${update_anchor_node});
						}
					` : b$1`
						if (!${iterations}[#i]) {
							${iterations}[#i] = ${create_each_block}(child_ctx);
							${iterations}[#i].c();
							${iterations}[#i].m(${update_mount_node}, ${update_anchor_node});
						}
					`;
                const start = this.block.has_update_method ? 0 : "#old_length";
                /** @type {import('estree').Node[]} */ let remove_old_blocks;
                if (this.block.has_outros) {
                    const out = block.get_unique_name("out");
                    block.chunks.init.push(b$1`
					const ${out} = i => @transition_out(${iterations}[i], 1, 1, () => {
						${iterations}[i] = null;
					});
				`);
                    remove_old_blocks = b$1`
					@group_outros();
					for (#i = ${data_length}; #i < ${view_length}; #i += 1) {
						${out}(#i);
					}
					@check_outros();
				`;
                } else remove_old_blocks = b$1`
					for (${this.block.has_update_method ? null : x$1`#i = ${data_length}`}; #i < ${this.block.has_update_method ? view_length : "#old_length"}; #i += 1) {
						${iterations}[#i].d(1);
					}
					${!fixed_length && b$1`${view_length} = ${data_length};`}
				`;
                // We declare `i` as block scoped here, as the `remove_old_blocks` code
                // may rely on continuing where this iteration stopped.
                const update = b$1`
				${!this.block.has_update_method && b$1`const #old_length = ${this.vars.each_block_value}.length;`}
				${this.vars.each_block_value} = ${snippet};

				let #i;
				for (#i = ${start}; #i < ${data_length}; #i += 1) {
					const child_ctx = ${this.vars.get_each_context}(#ctx, ${this.vars.each_block_value}, #i);

					${for_loop_body}
				}

				${remove_old_blocks}
			`;
                this.updates.push(update);
            }
            if (this.block.has_outros) block.chunks.outro.push(b$1`
				${iterations} = ${iterations}.filter(@_Boolean);
				for (let #i = 0; #i < ${view_length}; #i += 1) {
					@transition_out(${iterations}[#i]);
				}
			`);
            block.chunks.destroy.push(b$1`@destroy_each(${iterations}, detaching);`);
        }
    }
    /** @extends Wrapper<import('../../nodes/Text.js').default> */ class TextWrapper extends Wrapper {
        /** @type {string} */ _data;
        /** @type {boolean} */ skip;
        /** @type {import('estree').Identifier} */ var;
        /**
	 * @param {import('../Renderer.js').default} renderer
	 * @param {import('../Block.js').default} block
	 * @param {import('./shared/Wrapper.js').default} parent
	 * @param {import('../../nodes/Text.js').default} node
	 * @param {string} data
	 */ constructor(renderer, block, parent, node, data){
            super(renderer, block, parent, node);
            this.skip = this.node.should_skip();
            this._data = data;
            this.var = /** @type {unknown} */ /** @type {import('estree').Identifier} */ this.skip ? null : x$1`t`;
        }
        use_space() {
            return this.node.use_space();
        }
        set data(value) {
            // when updating `this.data` during optimisation
            // propagate the changes over to the underlying node
            // so that the node.use_space reflects on the latest `data` value
            this.node.data = this._data = value;
        }
        get data() {
            return this._data;
        }
        /**
	 * @param {import('../Block.js').default} block
	 * @param {import('estree').Identifier} parent_node
	 * @param {import('estree').Identifier} parent_nodes
	 */ render(block, parent_node, parent_nodes) {
            if (this.skip) return;
            const use_space = this.use_space();
            const string_literal = {
                type: "Literal",
                value: this.data,
                loc: {
                    start: this.renderer.locate(this.node.start),
                    end: this.renderer.locate(this.node.end)
                }
            };
            block.add_element(this.var, use_space ? x$1`@space()` : x$1`@text(${string_literal})`, parent_nodes && (use_space ? x$1`@claim_space(${parent_nodes})` : x$1`@claim_text(${parent_nodes}, ${string_literal})`), /** @type {import('estree').Identifier} */ parent_node);
        }
    }
    const svg_attributes = "accent-height accumulate additive alignment-baseline allowReorder alphabetic amplitude arabic-form ascent attributeName attributeType autoReverse azimuth baseFrequency baseline-shift baseProfile bbox begin bias by calcMode cap-height class clip clipPathUnits clip-path clip-rule color color-interpolation color-interpolation-filters color-profile color-rendering contentScriptType contentStyleType cursor cx cy d decelerate descent diffuseConstant direction display divisor dominant-baseline dur dx dy edgeMode elevation enable-background end exponent externalResourcesRequired fill fill-opacity fill-rule filter filterRes filterUnits flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight format from fr fx fy g1 g2 glyph-name glyph-orientation-horizontal glyph-orientation-vertical glyphRef gradientTransform gradientUnits hanging height href horiz-adv-x horiz-origin-x id ideographic image-rendering in in2 intercept k k1 k2 k3 k4 kernelMatrix kernelUnitLength kerning keyPoints keySplines keyTimes lang lengthAdjust letter-spacing lighting-color limitingConeAngle local marker-end marker-mid marker-start markerHeight markerUnits markerWidth mask maskContentUnits maskUnits mathematical max media method min mode name numOctaves offset onabort onactivate onbegin onclick onend onerror onfocusin onfocusout onload onmousedown onmousemove onmouseout onmouseover onmouseup onrepeat onresize onscroll onunload opacity operator order orient orientation origin overflow overline-position overline-thickness panose-1 paint-order pathLength patternContentUnits patternTransform patternUnits pointer-events points pointsAtX pointsAtY pointsAtZ preserveAlpha preserveAspectRatio primitiveUnits r radius refX refY rendering-intent repeatCount repeatDur requiredExtensions requiredFeatures restart result rotate rx ry scale seed shape-rendering slope spacing specularConstant specularExponent speed spreadMethod startOffset stdDeviation stemh stemv stitchTiles stop-color stop-opacity strikethrough-position strikethrough-thickness string stroke stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width style surfaceScale systemLanguage tabindex tableValues target targetX targetY text-anchor text-decoration text-rendering textLength to transform type u1 u2 underline-position underline-thickness unicode unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical values version vert-adv-y vert-origin-x vert-origin-y viewBox viewTarget visibility width widths word-spacing writing-mode x x-height x1 x2 xChannelSelector xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type xml:base xml:lang xml:space y y1 y2 yChannelSelector z zoomAndPan".split(" ");
    const svg_attribute_lookup = new Map();
    svg_attributes.forEach((name)=>{
        svg_attribute_lookup.set(name.toLowerCase(), name);
    });
    /**
 * @param {string} name
 */ function fix_attribute_casing(name) {
        name = name.toLowerCase();
        return svg_attribute_lookup.get(name) || name;
    }
    /**
 * @param {import('./Attribute.js').default | import('./Binding.js').default} attr
 * @param {Set<string>} dependencies
 */ function handle_select_value_binding(attr, dependencies) {
        const { parent: parent } = attr;
        if (parent.node.name === "select") {
            /** @type {import('./index.js').default} */ parent.select_binding_dependencies = dependencies;
            dependencies.forEach((prop)=>{
                parent.renderer.component.indirect_dependencies.set(prop, new Set());
            });
        }
    }
    const _boolean_attributes = /** @type {const} */ [
        "allowfullscreen",
        "allowpaymentrequest",
        "async",
        "autofocus",
        "autoplay",
        "checked",
        "controls",
        "default",
        "defer",
        "disabled",
        "formnovalidate",
        "hidden",
        "inert",
        "ismap",
        "loop",
        "multiple",
        "muted",
        "nomodule",
        "novalidate",
        "open",
        "playsinline",
        "readonly",
        "required",
        "reversed",
        "selected"
    ];
    /**
 * List of HTML boolean attributes (e.g. `<input disabled>`).
 * Source: https://html.spec.whatwg.org/multipage/indices.html
 *
 * @type {Set<string>}
 */ const boolean_attributes = new Set([
        ..._boolean_attributes
    ]);
    /** @typedef {typeof _boolean_attributes[number]} BooleanAttributes */ const non_textlike_input_types = new Set([
        "button",
        "checkbox",
        "color",
        "date",
        "datetime-local",
        "file",
        "hidden",
        "image",
        "radio",
        "range",
        "reset",
        "submit"
    ]);
    class BaseAttributeWrapper {
        /** @type {import('../../../nodes/Attribute.js').default} */ node;
        /** @type {import('./index.js').default} */ parent;
        /**
	 * @param {import('./index.js').default} parent
	 * @param {import('../../Block.js').default} block
	 * @param {import('../../../nodes/Attribute.js').default} node
	 */ constructor(parent, block, node){
            this.node = node;
            this.parent = parent;
            if (node.dependencies.size > 0) block.add_dependencies(node.dependencies);
        }
        /** @param {import('../../Block.js').default} _block */ render(_block) {}
    }
    const regex_minus_sign = /-/;
    const regex_invalid_variable_identifier_characters$2 = /[^a-zA-Z_$]/g;
    /** @extends BaseAttributeWrapper */ class AttributeWrapper extends BaseAttributeWrapper {
        /** @type {any} */ metadata;
        /** @type {string} */ name;
        /** @type {string} */ property_name;
        /** @type {boolean} */ is_indirectly_bound_value;
        /** @type {boolean} */ is_src;
        /** @type {boolean} */ is_srcset;
        /** @type {boolean} */ is_select_value_attribute;
        /** @type {boolean} */ is_input_value;
        /** @type {boolean} */ should_cache;
        /** @type {import('estree').Identifier} */ last;
        constructor(parent, block, node){
            super(parent, block, node);
            if (node.dependencies.size > 0) {
                // special case — <option value={foo}> — see below
                if (this.parent.node.name === "option" && node.name === "value") {
                    let select = this.parent;
                    while(select && (select.node.type !== "Element" || select.node.name !== "select"))// @ts-ignore todo: doublecheck this, but looks to be correct
                    select = select.parent;
                    if (select && select.select_binding_dependencies) select.select_binding_dependencies.forEach((prop)=>{
                        this.node.dependencies.forEach((dependency)=>{
                            if (this.node.scope.is_top_level(dependency)) this.parent.renderer.component.indirect_dependencies.get(prop).add(dependency);
                        });
                    });
                }
                if (node.name === "value") {
                    handle_select_value_binding(this, node.dependencies);
                    this.parent.has_dynamic_value = true;
                }
            }
            if (this.parent.node.namespace == namespaces.foreign || this.parent.node.name.includes("-")) {
                // leave attribute case alone for elements in the "foreign" namespace and for custom elements
                this.name = this.node.name;
                this.metadata = this.get_metadata();
                this.is_indirectly_bound_value = false;
                this.property_name = null;
                this.is_select_value_attribute = false;
                this.is_input_value = false;
            } else {
                this.name = fix_attribute_casing(this.node.name);
                this.metadata = this.get_metadata();
                this.is_indirectly_bound_value = is_indirectly_bound_value(this);
                this.property_name = this.is_indirectly_bound_value ? "__value" : this.metadata && this.metadata.property_name;
                this.is_select_value_attribute = this.name === "value" && this.parent.node.name === "select";
                this.is_input_value = this.name === "value" && this.parent.node.name === "input";
            }
            // TODO retire this exception in favour of https://github.com/sveltejs/svelte/issues/3750
            this.is_src = this.name === "src" && (!this.parent.node.namespace || this.parent.node.namespace === namespaces.html);
            this.is_srcset = this.name === "srcset" && (!this.parent.node.namespace || this.parent.node.namespace === namespaces.html);
            this.should_cache = should_cache(this);
        }
        /** @param {import('../../Block.js').default} block */ render(block) {
            const element = this.parent;
            const { name: name, property_name: property_name, should_cache: should_cache, is_indirectly_bound_value: is_indirectly_bound_value } = this;
            // xlink is a special case... we could maybe extend this to generic
            // namespaced attributes but I'm not sure that's applicable in
            // HTML5?
            const method = regex_minus_sign.test(element.node.name) ? "@set_custom_element_data" : name.slice(0, 6) === "xlink:" ? "@xlink_attr" : "@attr";
            const is_legacy_input_type = element.renderer.component.compile_options.legacy && name === "type" && this.parent.node.name === "input";
            const dependencies = this.get_dependencies();
            const value = this.get_value(block);
            /** @type {import('estree').Node[]} */ let updater;
            const init = this.get_init(block, value);
            if (is_legacy_input_type) {
                block.chunks.hydrate.push(b$1`@set_input_type(${element.var}, ${init});`);
                updater = b$1`@set_input_type(${element.var}, ${should_cache ? this.last : value});`;
            } else if (this.is_select_value_attribute) {
                // annoying special case
                const is_multiple_select = element.node.get_static_attribute_value("multiple");
                if (is_multiple_select) updater = b$1`@select_options(${element.var}, ${value});`;
                else updater = b$1`@select_option(${element.var}, ${value});`;
                block.chunks.mount.push(b$1`
				${updater}
			`);
            } else if (this.is_src) {
                block.chunks.hydrate.push(b$1`if (!@src_url_equal(${element.var}.src, ${init})) ${method}(${element.var}, "${name}", ${this.last});`);
                updater = b$1`${method}(${element.var}, "${name}", ${should_cache ? this.last : value});`;
            } else if (this.is_srcset) {
                block.chunks.hydrate.push(b$1`if (!@srcset_url_equal(${element.var}, ${init})) ${method}(${element.var}, "${name}", ${this.last});`);
                updater = b$1`${method}(${element.var}, "${name}", ${should_cache ? this.last : value});`;
            } else if (property_name) {
                block.chunks.hydrate.push(b$1`${element.var}.${property_name} = ${init};`);
                updater = block.renderer.options.dev ? b$1`@prop_dev(${element.var}, "${property_name}", ${should_cache ? this.last : value});` : b$1`${element.var}.${property_name} = ${should_cache ? this.last : value};`;
            } else {
                block.chunks.hydrate.push(b$1`${method}(${element.var}, "${name}", ${init});`);
                updater = b$1`${method}(${element.var}, "${name}", ${should_cache ? this.last : value});`;
            }
            if (is_indirectly_bound_value) {
                const update_value = b$1`@set_input_value(${element.var}, ${element.var}.__value);`;
                block.chunks.hydrate.push(update_value);
                updater = b$1`
				${updater}
				${update_value};
			`;
            }
            if (this.node.name === "value" && dependencies.length > 0) {
                if (this.parent.bindings.some((binding)=>binding.node.name === "group")) {
                    this.parent.dynamic_value_condition = block.get_unique_name("value_has_changed");
                    block.add_variable(this.parent.dynamic_value_condition, x$1`false`);
                    updater = b$1`
					${updater}
					${this.parent.dynamic_value_condition} = true;
				`;
                }
            }
            if (dependencies.length > 0) {
                const condition = this.get_dom_update_conditions(block, block.renderer.dirty(dependencies));
                block.chunks.update.push(b$1`
				if (${condition}) {
					${updater}
				}`);
            }
            // special case – autofocus. has to be handled in a bit of a weird way
            if (name === "autofocus") block.autofocus = {
                element_var: element.var,
                condition_expression: this.node.is_true ? undefined : value
            };
        }
        /**
	 * @param {import('../../Block.js').default} block
	 * @param {any} value
	 */ get_init(block, value) {
            this.last = this.should_cache && block.get_unique_name(`${this.parent.var.name}_${this.name.replace(regex_invalid_variable_identifier_characters$2, "_")}_value`);
            if (this.should_cache) block.add_variable(this.last);
            return this.should_cache ? x$1`${this.last} = ${value}` : value;
        }
        /**
	 * @param {import('../../Block.js').default} block
	 * @param {import('estree').Node} dependency_condition
	 */ get_dom_update_conditions(block, dependency_condition) {
            const { property_name: property_name, should_cache: should_cache, last: last } = this;
            const element = this.parent;
            const value = this.get_value(block);
            let condition = dependency_condition;
            if (should_cache) condition = this.is_src ? x$1`${condition} && (!@src_url_equal(${element.var}.src, (${last} = ${value})))` : x$1`${condition} && (${last} !== (${last} = ${value}))`;
            if (this.is_input_value) {
                const type = element.node.get_static_attribute_value("type");
                if (type !== true && !non_textlike_input_types.has(type)) condition = x$1`${condition} && ${element.var}.${property_name} !== ${should_cache ? last : value}`;
            }
            if (block.has_outros) condition = x$1`!#current || ${condition}`;
            return condition;
        }
        get_dependencies() {
            const node_dependencies = this.node.get_dependencies();
            const dependencies = new Set(node_dependencies);
            node_dependencies.forEach((prop)=>{
                const indirect_dependencies = this.parent.renderer.component.indirect_dependencies.get(prop);
                if (indirect_dependencies) indirect_dependencies.forEach((indirect_dependency)=>{
                    dependencies.add(indirect_dependency);
                });
            });
            return Array.from(dependencies);
        }
        get_metadata() {
            if (this.parent.node.namespace) return null;
            const metadata = attribute_lookup[this.name];
            if (metadata && metadata.applies_to && !metadata.applies_to.includes(this.parent.node.name)) return null;
            return metadata;
        }
        /** @param {import('../../Block.js').default} block */ get_value(block) {
            if (this.node.is_true) {
                if (this.metadata && boolean_attributes.has(this.metadata.property_name.toLowerCase())) return x$1`true`;
                return x$1`""`;
            }
            if (this.node.chunks.length === 0) return x$1`""`;
            // TODO some of this code is repeated in Tag.ts — would be good to
            // DRY it out if that's possible without introducing crazy indirection
            if (this.node.chunks.length === 1) return this.node.chunks[0].type === "Text" ? string_literal(/** @type {import('../../../nodes/Text.js').default} */ this.node.chunks[0].data) : /** @type {import('../../../nodes/shared/Expression.js').default} */ this.node.chunks[0].manipulate(block);
            let value = this.node.name === "class" ? this.get_class_name_text(block) : this.render_chunks(block).reduce((lhs, rhs)=>x$1`${lhs} + ${rhs}`);
            // '{foo} {bar}' — treat as string concatenation
            if (this.node.chunks[0].type !== "Text") value = x$1`"" + ${value}`;
            return value;
        }
        /** @param {import('../../Block.js').default} block */ get_class_name_text(block) {
            const scoped_css = this.node.chunks.some((/** @type {import('../../../nodes/Text.js').default} */ chunk)=>chunk.synthetic);
            const rendered = this.render_chunks(block);
            if (scoped_css && rendered.length === 2) // we have a situation like class={possiblyUndefined}
            rendered[0] = x$1`@null_to_empty(${rendered[0]})`;
            return rendered.reduce((lhs, rhs)=>x$1`${lhs} + ${rhs}`);
        }
        /** @param {import('../../Block.js').default} block */ render_chunks(block) {
            return this.node.chunks.map((chunk)=>{
                if (chunk.type === "Text") return string_literal(chunk.data);
                return chunk.manipulate(block);
            });
        }
        stringify() {
            if (this.node.is_true) return "";
            const value = this.node.chunks;
            if (value.length === 0) return '=""';
            return `="${value.map((chunk)=>{
                return chunk.type === "Text" ? chunk.data.replace(regex_double_quotes, '\\"') : `\${${chunk.manipulate()}}`;
            }).join("")}"`;
        }
    }
    /**
 * @type {{
 *  [key in import('../../../../../shared/boolean_attributes.js').BooleanAttributes]: { property_name?: string; applies_to?: string[] } } &
 *  { [key in string]: { property_name?: string; applies_to?: string[] }; }
 * }
 */ const attribute_lookup = {
        allowfullscreen: {
            property_name: "allowFullscreen",
            applies_to: [
                "iframe"
            ]
        },
        allowpaymentrequest: {
            property_name: "allowPaymentRequest",
            applies_to: [
                "iframe"
            ]
        },
        async: {
            applies_to: [
                "script"
            ]
        },
        autofocus: {
            applies_to: [
                "button",
                "input",
                "keygen",
                "select",
                "textarea"
            ]
        },
        autoplay: {
            applies_to: [
                "audio",
                "video"
            ]
        },
        checked: {
            applies_to: [
                "input"
            ]
        },
        controls: {
            applies_to: [
                "audio",
                "video"
            ]
        },
        default: {
            applies_to: [
                "track"
            ]
        },
        defer: {
            applies_to: [
                "script"
            ]
        },
        disabled: {
            applies_to: [
                "button",
                "fieldset",
                "input",
                "keygen",
                "optgroup",
                "option",
                "select",
                "textarea"
            ]
        },
        formnovalidate: {
            property_name: "formNoValidate",
            applies_to: [
                "button",
                "input"
            ]
        },
        hidden: {},
        indeterminate: {
            applies_to: [
                "input"
            ]
        },
        inert: {},
        ismap: {
            property_name: "isMap",
            applies_to: [
                "img"
            ]
        },
        loop: {
            applies_to: [
                "audio",
                "bgsound",
                "video"
            ]
        },
        multiple: {
            applies_to: [
                "input",
                "select"
            ]
        },
        muted: {
            applies_to: [
                "audio",
                "video"
            ]
        },
        nomodule: {
            property_name: "noModule",
            applies_to: [
                "script"
            ]
        },
        novalidate: {
            property_name: "noValidate",
            applies_to: [
                "form"
            ]
        },
        open: {
            applies_to: [
                "details",
                "dialog"
            ]
        },
        playsinline: {
            property_name: "playsInline",
            applies_to: [
                "video"
            ]
        },
        readonly: {
            property_name: "readOnly",
            applies_to: [
                "input",
                "textarea"
            ]
        },
        required: {
            applies_to: [
                "input",
                "select",
                "textarea"
            ]
        },
        reversed: {
            applies_to: [
                "ol"
            ]
        },
        selected: {
            applies_to: [
                "option"
            ]
        },
        value: {
            applies_to: [
                "button",
                "option",
                "input",
                "li",
                "meter",
                "progress",
                "param",
                "select",
                "textarea"
            ]
        }
    };
    Object.keys(attribute_lookup).forEach((name)=>{
        const metadata = attribute_lookup[name];
        if (!metadata.property_name) metadata.property_name = name;
    });
    /** @param {AttributeWrapper} attribute */ function should_cache(attribute) {
        return attribute.is_src || attribute.is_srcset || attribute.node.should_cache();
    }
    const regex_contains_checked_or_group = /checked|group/;
    /** @param {AttributeWrapper} attribute */ function is_indirectly_bound_value(attribute) {
        const element = attribute.parent;
        return attribute.name === "value" && (element.node.name === "option" || // TODO check it's actually bound
        element.node.name === "input" && element.node.bindings.some((binding)=>regex_contains_checked_or_group.test(binding.name)));
    }
    /** @extends AttributeWrapper */ class StyleAttributeWrapper extends AttributeWrapper {
        /** @param {import('../../Block.js').default} block */ render(block) {
            const style_props = optimize_style(this.node.chunks);
            if (!style_props) return super.render(block);
            style_props.forEach((prop)=>{
                let value;
                if (is_dynamic(prop.value)) {
                    const prop_dependencies = new Set();
                    value = prop.value.map((chunk)=>{
                        if (chunk.type === "Text") return string_literal(chunk.data);
                        else {
                            add_to_set(prop_dependencies, chunk.dynamic_dependencies());
                            return chunk.manipulate(block);
                        }
                    }).reduce((lhs, rhs)=>x$1`${lhs} + ${rhs}`);
                    // TODO is this necessary? style.setProperty always treats value as string, no?
                    // if (prop.value.length === 1 || prop.value[0].type !== 'Text') {
                    // 	value = x`"" + ${value}`;
                    // }
                    if (prop_dependencies.size) {
                        let condition = block.renderer.dirty(Array.from(prop_dependencies));
                        if (block.has_outros) condition = x$1`!#current || ${condition}`;
                        const update = b$1`
						if (${condition}) {
							@set_style(${this.parent.var}, "${prop.key}", ${value}, ${prop.important ? 1 : null});
						}`;
                        block.chunks.update.push(update);
                    }
                } else value = string_literal(/** @type {import('../../../nodes/Text.js').default} */ prop.value[0].data);
                block.chunks.hydrate.push(b$1`@set_style(${this.parent.var}, "${prop.key}", ${value}, ${prop.important ? 1 : null});`);
            });
        }
    }
    const regex_style_prop_key = /^\s*([\w-]+):\s*/;
    /** @param {Array<import('../../../nodes/Text.js').default | import('../../../nodes/shared/Expression.js').default>} value */ function optimize_style(value) {
        /** @type {Array<{ key: string; value: Array<import('../../../nodes/Text.js').default | import('../../../nodes/shared/Expression.js').default>; important: boolean; }>} */ const props = [];
        let chunks = value.slice();
        while(chunks.length){
            const chunk = chunks[0];
            if (chunk.type !== "Text") return null;
            const key_match = regex_style_prop_key.exec(chunk.data);
            if (!key_match) return null;
            const key = key_match[1];
            const offset = key_match.index + key_match[0].length;
            const remaining_data = chunk.data.slice(offset);
            if (remaining_data) chunks[0] = /** @type {import('../../../nodes/Text.js').default} */ {
                start: chunk.start + offset,
                end: chunk.end,
                type: "Text",
                data: remaining_data
            };
            else chunks.shift();
            const result = get_style_value(chunks);
            props.push({
                key: key,
                value: result.value,
                important: result.important
            });
            chunks = result.chunks;
        }
        return props;
    }
    const regex_important_flag = /\s*!important\s*$/;
    const regex_semicolon_or_whitespace = /[;\s]/;
    /** @param {Array<import('../../../nodes/Text.js').default | import('../../../nodes/shared/Expression.js').default>} chunks */ function get_style_value(chunks) {
        /** @type {Array<import('../../../nodes/Text.js').default | import('../../../nodes/shared/Expression.js').default>} */ const value = [];
        let in_url = false;
        let quote_mark = null;
        let escaped = false;
        let closed = false;
        while(chunks.length && !closed){
            const chunk = chunks.shift();
            if (chunk.type === "Text") {
                let c = 0;
                while(c < chunk.data.length){
                    const char = chunk.data[c];
                    if (escaped) escaped = false;
                    else if (char === "\\") escaped = true;
                    else if (char === quote_mark) quote_mark = null;
                    else if (char === '"' || char === "'") quote_mark = char;
                    else if (char === ")" && in_url) in_url = false;
                    else if (char === "u" && chunk.data.slice(c, c + 4) === "url(") in_url = true;
                    else if (char === ";" && !in_url && !quote_mark) {
                        closed = true;
                        break;
                    }
                    c += 1;
                }
                if (c > 0) value.push(/** @type {import('../../../nodes/Text.js').default} */ {
                    type: "Text",
                    start: chunk.start,
                    end: chunk.start + c,
                    data: chunk.data.slice(0, c)
                });
                while(regex_semicolon_or_whitespace.test(chunk.data[c]))c += 1;
                const remaining_data = chunk.data.slice(c);
                if (remaining_data) {
                    chunks.unshift(/** @type {import('../../../nodes/Text.js').default} */ {
                        start: chunk.start + c,
                        end: chunk.end,
                        type: "Text",
                        data: remaining_data
                    });
                    break;
                }
            } else value.push(chunk);
        }
        let important = false;
        const last_chunk = value[value.length - 1];
        if (last_chunk && last_chunk.type === "Text" && regex_important_flag.test(last_chunk.data)) {
            important = true;
            last_chunk.data = last_chunk.data.replace(regex_important_flag, "");
            if (!last_chunk.data) value.pop();
        }
        return {
            chunks: chunks,
            value: value,
            important: important
        };
    }
    /** @param {Array<import('../../../nodes/Text.js').default | import('../../../nodes/shared/Expression.js').default>} value */ function is_dynamic(value) {
        return value.length > 1 || value[0].type !== "Text";
    }
    class SpreadAttributeWrapper extends BaseAttributeWrapper {
    }
    /**
 * @param {import('../Element/index.js').default | import('../InlineComponent/index.js').default} parent
 * @param {import('../../../nodes/Binding.js').default} binding
 */ function mark_each_block_bindings(parent, binding) {
        // we need to ensure that the each block creates a context including
        // the list and the index, if they're not otherwise referenced
        binding.expression.references.forEach((name)=>{
            const each_block = parent.node.scope.get_owner(name);
            if (each_block) /** @type {import('../../../nodes/EachBlock.js').default} */ each_block.has_binding = true;
        });
        if (binding.name === "group") {
            /** @param {string} name */ const add_index_binding = (name)=>{
                const each_block = parent.node.scope.get_owner(name);
                if (each_block.type === "EachBlock") {
                    each_block.has_index_binding = true;
                    for (const dep of each_block.expression.contextual_dependencies)add_index_binding(dep);
                }
            };
            // for `<input bind:group={} >`, we make sure that all the each blocks creates context with `index`
            for (const name of binding.expression.contextual_dependencies)add_index_binding(name);
        }
    }
    /** */ class BindingWrapper {
        /** @type {import('../../../nodes/Binding.js').default} */ node = undefined;
        /** @type {import('./index.js').default | import('../InlineComponent/index.js').default} */ parent = undefined;
        /** @type {string} */ object = undefined;
        /**
	 * @type {{
	 * 		uses_context: boolean;
	 * 		mutation: import('estree').Node | import('estree').Node[];
	 * 		contextual_dependencies: Set<string>;
	 * 		lhs?: import('estree').Node;
	 * 	}}
	 */ handler = undefined;
        /** @type {import('estree').Node} */ snippet = undefined;
        /** @type {boolean} */ is_readonly = undefined;
        /** @type {boolean} */ needs_lock = undefined;
        /** @type {import('../../Renderer.js').BindingGroup} */ binding_group = undefined;
        /**
	 * @param {import('../../Block.js').default} block
	 * @param {import('../../../nodes/Binding.js').default} node
	 * @param {import('./index.js').default | import('../InlineComponent/index.js').default} parent
	 */ constructor(block, node, parent){
            this.node = node;
            this.parent = parent;
            const { dependencies: dependencies } = this.node.expression;
            block.add_dependencies(dependencies);
            // TODO does this also apply to e.g. `<input type='checkbox' bind:group='foo'>`?
            handle_select_value_binding(this, dependencies);
            if (node.is_contextual) mark_each_block_bindings(this.parent, this.node);
            this.object = get_object(this.node.expression.node).name;
            if (this.node.name === "group") this.binding_group = get_binding_group(parent.renderer, this, block);
            // view to model
            this.handler = get_event_handler(this, parent.renderer, block, this.object, this.node.raw_expression);
            this.snippet = this.node.expression.manipulate(block);
            this.is_readonly = this.node.is_readonly;
            this.needs_lock = this.node.name === "currentTime"; // TODO others?
        }
        get_dependencies() {
            const dependencies = new Set(this.node.expression.dependencies);
            this.node.expression.dependencies.forEach((prop)=>{
                const indirect_dependencies = this.parent.renderer.component.indirect_dependencies.get(prop);
                if (indirect_dependencies) indirect_dependencies.forEach((indirect_dependency)=>{
                    dependencies.add(indirect_dependency);
                });
            });
            if (this.binding_group) this.binding_group.list_dependencies.forEach((dep)=>dependencies.add(dep));
            return dependencies;
        }
        get_update_dependencies() {
            const object = this.object;
            const dependencies = new Set();
            if (this.node.expression.template_scope.names.has(object)) this.node.expression.template_scope.dependencies_for_name.get(object).forEach((name)=>dependencies.add(name));
            else dependencies.add(object);
            const result = new Set(dependencies);
            dependencies.forEach((dependency)=>{
                const indirect_dependencies = this.parent.renderer.component.indirect_dependencies.get(dependency);
                if (indirect_dependencies) indirect_dependencies.forEach((indirect_dependency)=>{
                    result.add(indirect_dependency);
                });
            });
            return result;
        }
        is_readonly_media_attribute() {
            return this.node.is_readonly_media_attribute();
        }
        /**
	 * @param {import('../../Block.js').default} block
	 * @param {import('estree').Identifier} lock
	 */ render(block, lock) {
            if (this.is_readonly) return;
            const { parent: parent } = this;
            /** @type {any[]} */ const update_conditions = this.needs_lock ? [
                x$1`!${lock}`
            ] : [];
            /** @type {any[]} */ const mount_conditions = [];
            /** @type {any} */ let update_or_condition = null;
            const dependency_array = Array.from(this.get_dependencies());
            if (dependency_array.length > 0) update_conditions.push(block.renderer.dirty(dependency_array));
            if (parent.node.name === "input") {
                const type = parent.node.get_static_attribute_value("type");
                if (type === null || type === "" || type === "text" || type === "email" || type === "password" || type === "search" || type === "url") update_conditions.push(x$1`${parent.var}.${this.node.name} !== ${this.snippet}`);
                else if (type === "number") update_conditions.push(x$1`@to_number(${parent.var}.${this.node.name}) !== ${this.snippet}`);
            }
            // model to view
            let update_dom = get_dom_updater(parent, this, false);
            let mount_dom = get_dom_updater(parent, this, true);
            // special cases
            switch(this.node.name){
                case "group":
                    block.renderer.add_to_context("$$binding_groups");
                    this.binding_group.add_element(block, this.parent.var);
                    if (/** @type {import('./index.js').default} */ this.parent.has_dynamic_value) update_or_condition = /** @type {import('./index.js').default} */ this.parent.dynamic_value_condition;
                    break;
                case "textContent":
                    update_conditions.push(x$1`${this.snippet} !== ${parent.var}.textContent`);
                    mount_conditions.push(x$1`${this.snippet} !== void 0`);
                    break;
                case "innerText":
                    update_conditions.push(x$1`${this.snippet} !== ${parent.var}.innerText`);
                    mount_conditions.push(x$1`${this.snippet} !== void 0`);
                    break;
                case "innerHTML":
                    update_conditions.push(x$1`${this.snippet} !== ${parent.var}.innerHTML`);
                    mount_conditions.push(x$1`${this.snippet} !== void 0`);
                    break;
                case "currentTime":
                    update_conditions.push(x$1`!@_isNaN(${this.snippet})`);
                    mount_dom = null;
                    break;
                case "playbackRate":
                case "volume":
                    update_conditions.push(x$1`!@_isNaN(${this.snippet})`);
                    mount_conditions.push(x$1`!@_isNaN(${this.snippet})`);
                    break;
                case "paused":
                    {
                        // this is necessary to prevent audio restarting by itself
                        const last = block.get_unique_name(`${parent.var.name}_is_paused`);
                        block.add_variable(last, x$1`true`);
                        update_conditions.push(x$1`${last} !== (${last} = ${this.snippet})`);
                        update_dom = b$1`${parent.var}[${last} ? "pause" : "play"]();`;
                        mount_dom = null;
                        break;
                    }
                case "value":
                    if (parent.node.get_static_attribute_value("type") === "file") {
                        update_dom = null;
                        mount_dom = null;
                    }
            }
            if (update_dom) {
                if (update_conditions.length > 0) {
                    let condition = update_conditions.reduce((lhs, rhs)=>x$1`${lhs} && ${rhs}`);
                    if (update_or_condition) condition = x$1`${update_or_condition} || (${condition})`;
                    block.chunks.update.push(b$1`
					if (${condition}) {
						${update_dom}
					}
				`);
                } else block.chunks.update.push(update_dom);
            }
            if (mount_dom) {
                if (mount_conditions.length > 0) {
                    const condition = mount_conditions.reduce((lhs, rhs)=>x$1`${lhs} && ${rhs}`);
                    block.chunks.mount.push(b$1`
					if (${condition}) {
						${mount_dom}
					}
				`);
                } else block.chunks.mount.push(mount_dom);
            }
        }
    }
    /**
 * @param {import('./index.js').default | import('../InlineComponent/index.js').default} element
 * @param {BindingWrapper} binding
 * @param {boolean} mounting
 */ function get_dom_updater(element, binding, mounting) {
        const { node: node } = element;
        if (binding.is_readonly_media_attribute()) return null;
        if (binding.node.name === "this") return null;
        if (node.name === "select") return node.get_static_attribute_value("multiple") === true ? b$1`@select_options(${element.var}, ${binding.snippet})` : mounting ? b$1`@select_option(${element.var}, ${binding.snippet}, true)` : b$1`@select_option(${element.var}, ${binding.snippet})`;
        if (binding.node.name === "group") {
            const type = node.get_static_attribute_value("type");
            const condition = type === "checkbox" ? x$1`~(${binding.snippet} || []).indexOf(${element.var}.__value)` : x$1`${element.var}.__value === ${binding.snippet}`;
            return b$1`${element.var}.checked = ${condition};`;
        }
        if (binding.node.name === "value") return b$1`@set_input_value(${element.var}, ${binding.snippet});`;
        return b$1`${element.var}.${binding.node.name} = ${binding.snippet};`;
    }
    /**
 * @param {import('../../Renderer.js').default} renderer
 * @param {BindingWrapper} binding
 * @param {import('../../Block.js').default} block
 */ function get_binding_group(renderer, binding, block) {
        const value = binding.node;
        const { parts: parts } = flatten_reference(value.raw_expression);
        let keypath = parts.join(".");
        const contexts = [];
        const contextual_dependencies = new Set();
        const { template_scope: template_scope } = value.expression;
        /** @param {string} dep */ const add_contextual_dependency = (dep)=>{
            contextual_dependencies.add(dep);
            const owner = template_scope.get_owner(dep);
            if (owner.type === "EachBlock") for (const dep of owner.expression.contextual_dependencies)add_contextual_dependency(dep);
        };
        for (const dep of value.expression.contextual_dependencies)add_contextual_dependency(dep);
        for (const dep of contextual_dependencies){
            const context = block.bindings.get(dep);
            let key;
            let name;
            if (context) {
                key = context.object.name;
                name = context.property.name;
            } else {
                key = dep;
                name = dep;
            }
            keypath = `${key}@${keypath}`;
            contexts.push(name);
        }
        // create a global binding_group across blocks
        if (!renderer.binding_groups.has(keypath)) {
            const index = renderer.binding_groups.size;
            // the bind:group depends on the list in the {#each} block as well
            // as reordering (removing and adding back to the DOM) may affect the value
            const list_dependencies = new Set();
            let parent = value.parent;
            while(parent){
                if (parent.type === "EachBlock") for (const dep of parent.expression.dynamic_dependencies())list_dependencies.add(dep);
                parent = parent.parent;
            }
            /**
		 * When using bind:group with logic blocks, the inputs with bind:group may be scattered across different blocks.
		 * This therefore keeps track of all the <input> elements that have the same bind:group within the same block.
		 */ const elements = new Map();
            contexts.forEach((context)=>{
                renderer.add_to_context(context, true);
            });
            renderer.binding_groups.set(keypath, {
                binding_group: ()=>{
                    let obj = x$1`$$binding_groups[${index}]`;
                    if (contexts.length > 0) contexts.forEach((secondary_index)=>{
                        obj = x$1`${obj}[${secondary_index}]`;
                    });
                    return obj;
                },
                contexts: contexts,
                list_dependencies: list_dependencies,
                keypath: keypath,
                add_element (block, element) {
                    if (!elements.has(block)) elements.set(block, []);
                    elements.get(block).push(element);
                },
                render (block) {
                    const local_name = block.get_unique_name("binding_group");
                    const binding_group = block.renderer.reference("$$binding_groups");
                    block.add_variable(local_name);
                    if (contexts.length > 0) {
                        const indexes = {
                            type: "ArrayExpression",
                            elements: contexts.map((name)=>block.renderer.reference(name))
                        };
                        block.chunks.init.push(b$1`${local_name} = @init_binding_group_dynamic(${binding_group}[${index}], ${indexes})`);
                        block.chunks.update.push(b$1`if (${block.renderer.dirty(Array.from(list_dependencies))}) ${local_name}.u(${indexes})`);
                    } else block.chunks.init.push(b$1`${local_name} = @init_binding_group(${binding_group}[${index}])`);
                    block.chunks.hydrate.push(b$1`${local_name}.p(${elements.get(block)})`);
                    block.chunks.destroy.push(b$1`${local_name}.r()`);
                }
            });
        }
        // register the binding_group for the block
        const binding_group = renderer.binding_groups.get(keypath);
        block.binding_groups.add(binding_group);
        return binding_group;
    }
    /**
 * @param {BindingWrapper} binding
 * @param {import('../../Renderer.js').default} renderer
 * @param {import('../../Block.js').default} block
 * @param {string} name
 * @param {import('estree').Node} lhs
 * @returns {{ uses_context: boolean; mutation: import('estree').Node | import('estree').Node[]; contextual_dependencies: Set<string>; lhs?: import('estree').Node; }}
 */ function get_event_handler(binding, renderer, block, name, lhs) {
        const contextual_dependencies = new Set(binding.node.expression.contextual_dependencies);
        const context = block.bindings.get(name);
        /** @type {import('estree').Node[] | undefined} */ let set_store;
        if (context) {
            const { object: object, property: property, store: store, snippet: snippet } = context;
            lhs = replace_object(lhs, snippet);
            contextual_dependencies.add(object.name);
            contextual_dependencies.add(property.name);
            contextual_dependencies.delete(name);
            if (store) set_store = b$1`${store}.set(${`$${store}`});`;
        } else {
            const object = get_object(lhs);
            if (object.name[0] === "$") {
                const store = object.name.slice(1);
                set_store = b$1`${store}.set(${object.name});`;
            }
        }
        const value = get_value_from_dom(renderer, binding.parent, binding, contextual_dependencies);
        const mutation = b$1`
		${lhs} = ${value};
		${set_store}
	`;
        return {
            uses_context: binding.node.is_contextual || binding.node.expression.uses_context,
            mutation: mutation,
            contextual_dependencies: contextual_dependencies,
            lhs: lhs
        };
    }
    /**
 * @param {import('../../Renderer.js').default} _renderer
 * @param {import('./index.js').default | import('../InlineComponent/index.js').default} element
 * @param {BindingWrapper} binding
 * @param {Set<string>} contextual_dependencies
 */ function get_value_from_dom(_renderer, element, binding, contextual_dependencies) {
        const { node: node } = element;
        const { name: name } = binding.node;
        if (name === "this") return x$1`$$value`;
        // <div bind:contentRect|contentBoxSize|borderBoxSize|devicePixelContentBoxSize>
        if (regex_box_size.test(name)) return x$1`@ResizeObserverSingleton.entries.get(this)?.${name}`;
        // <select bind:value='selected>
        if (node.name === "select") return node.get_static_attribute_value("multiple") === true ? x$1`@select_multiple_value(this)` : x$1`@select_value(this)`;
        const type = node.get_static_attribute_value("type");
        // <input type='checkbox' bind:group='foo'>
        if (name === "group") {
            if (type === "checkbox") {
                const { binding_group: binding_group, contexts: contexts } = binding.binding_group;
                add_to_set(contextual_dependencies, contexts);
                return x$1`@get_binding_group_value(${binding_group()}, this.__value, this.checked)`;
            }
            return x$1`this.__value`;
        }
        // <input type='range|number' bind:value>
        if (type === "range" || type === "number") return x$1`@to_number(this.${name})`;
        if (name === "buffered" || name === "seekable" || name === "played") return x$1`@time_ranges_to_array(this.${name})`;
        // everything else
        return x$1`this.${name}`;
    }
    /**
 * @param {import('estree').Node | void} a
 * @param {import('estree').Node | void} b
 */ function compare_node(a, b) {
        if (a === b) return true;
        if (!a || !b) return false;
        if (a.type !== b.type) return false;
        switch(a.type){
            case "Identifier":
                return a.name === /** @type {import('estree').Identifier} */ b.name;
            case "MemberExpression":
                return compare_node(a.object, /** @type {import('estree').MemberExpression} */ b.object) && compare_node(a.property, /** @type {import('estree').MemberExpression} */ b.property) && a.computed === /** @type {import('estree').MemberExpression} */ b.computed;
            case "Literal":
                return a.value === /** @type {import('estree').Literal} */ b.value;
        }
    }
    /**
 * @param {import('../../../Component.js').default} component
 * @param {import('../../Block.js').default} block
 * @param {import('../Element/Binding.js').default} binding
 * @param {import('estree').Identifier} variable
 */ function bind_this(component, block, binding, variable) {
        const fn = component.get_unique_name(`${variable.name}_binding`);
        block.renderer.add_to_context(fn.name);
        const callee = block.renderer.reference(fn.name);
        const { contextual_dependencies: contextual_dependencies, mutation: mutation } = binding.handler;
        const dependencies = binding.get_update_dependencies();
        const body = b$1`
		${mutation}
		${Array.from(dependencies).filter((dep)=>dep[0] !== "$").filter((dep)=>!contextual_dependencies.has(dep)).map((dep)=>b$1`${block.renderer.invalidate(dep)};`)}
	`;
        if (contextual_dependencies.size) {
            /** @type {import('estree').Identifier[]} */ const params = Array.from(contextual_dependencies).map((name)=>({
                    type: "Identifier",
                    name: name
                }));
            component.partly_hoisted.push(b$1`
			function ${fn}($$value, ${params}) {
				@binding_callbacks[$$value ? 'unshift' : 'push'](() => {
					${body}
				});
			}
		`);
            const alias_map = new Map();
            const args = [];
            for (let id of params){
                const value = block.renderer.reference(id.name);
                let found = false;
                if (block.variables.has(id.name)) {
                    let alias = id.name;
                    for(let i = 1; block.variables.has(alias) && !compare_node(block.variables.get(alias).init, value); alias = `${id.name}_${i++}`);
                    alias_map.set(alias, id.name);
                    id = {
                        type: "Identifier",
                        name: alias
                    };
                    found = block.variables.has(alias);
                }
                args.push(id);
                if (!found) block.add_variable(id, value);
            }
            const assign = block.get_unique_name(`assign_${variable.name}`);
            const unassign = block.get_unique_name(`unassign_${variable.name}`);
            block.chunks.init.push(b$1`
			const ${assign} = () => ${callee}(${variable}, ${args});
			const ${unassign} = () => ${callee}(null, ${args});
		`);
            const condition = Array.from(args).map((name)=>x$1`${name} !== ${block.renderer.reference(alias_map.get(name.name) || name.name)}`).reduce((lhs, rhs)=>x$1`${lhs} || ${rhs}`);
            // we push unassign and unshift assign so that references are
            // nulled out before they're created, to avoid glitches
            // with shifting indices
            block.chunks.update.push(b$1`
			if (${condition}) {
				${unassign}();
				${args.map((a)=>b$1`${a} = ${block.renderer.reference(alias_map.get(a.name) || a.name)}`)};
				${assign}();
			}`);
            block.chunks.destroy.push(b$1`${unassign}();`);
            return b$1`${assign}();`;
        }
        component.partly_hoisted.push(b$1`
		function ${fn}($$value) {
			@binding_callbacks[$$value ? 'unshift' : 'push'](() => {
				${body}
			});
		}
	`);
        block.chunks.destroy.push(b$1`${callee}(null);`);
        return b$1`${callee}(${variable});`;
    }
    /**
 * @template {import('../../../nodes/MustacheTag.js').default | import('../../../nodes/RawMustacheTag.js').default} NodeType
 * @extends Wrapper<NodeType>
 */ let Tag$1 = class Tag extends Wrapper {
        /**
	 * @param {import('../../Renderer.js').default} renderer
	 * @param {import('../../Block.js').default} block
	 * @param {import('./Wrapper.js').default} parent
	 * @param {NodeType} node
	 */ constructor(renderer, block, parent, node){
            super(renderer, block, parent, node);
            block.add_dependencies(node.expression.dependencies);
        }
        /**
	 * @param {import('../../Block.js').default} block
	 * @param {(value: import('estree').Node) => import('estree').Node | import('estree').Node[]} update
	 */ rename_this_method(block, update) {
            const dependencies = this.node.expression.dynamic_dependencies();
            let snippet = this.node.expression.manipulate(block);
            const value = this.node.should_cache && block.get_unique_name(`${this.var.name}_value`);
            const content = this.node.should_cache ? value : snippet;
            snippet = x$1`${snippet} + ""`;
            if (this.node.should_cache) block.add_variable(value, snippet); // TODO may need to coerce snippet to string
            if (dependencies.length > 0) {
                let condition = block.renderer.dirty(dependencies);
                if (block.has_outros) condition = x$1`!#current || ${condition}`;
                const update_cached_value = x$1`${value} !== (${value} = ${snippet})`;
                if (this.node.should_cache) condition = x$1`${condition} && ${update_cached_value}`;
                block.chunks.update.push(b$1`if (${condition}) ${update(/** @type {import('estree').Node} */ content)}`);
            }
            return {
                init: content
            };
        }
    };
    /** @extends Tag */ class MustacheTagWrapper extends Tag$1 {
        /** @type {import('estree').Identifier} */ var = {
            type: "Identifier",
            name: "t"
        };
        /**
	 * @param {import('../Renderer.js').default} renderer
	 * @param {import('../Block.js').default} block
	 * @param {import('./shared/Wrapper.js').default} parent
	 * @param {import('../../nodes/MustacheTag.js').default | import('../../nodes/RawMustacheTag.js').default} node
	 */ constructor(renderer, block, parent, node){
            super(renderer, block, parent, node);
        }
        /**
	 * @param {import('../Block.js').default} block
	 * @param {import('estree').Identifier} parent_node
	 * @param {import('estree').Identifier} parent_nodes
	 * @param {Record<string, unknown> | undefined} data
	 */ render(block, parent_node, parent_nodes, data) {
            const contenteditable_attributes = this.parent instanceof ElementWrapper && this.parent.attributes.filter((a)=>a.node.name === "contenteditable");
            const spread_attributes = this.parent instanceof ElementWrapper && this.parent.attributes.filter((a)=>a.node.is_spread);
            /** @type {import('estree').Expression | true | undefined} */ let contenteditable_attr_value = undefined;
            if (contenteditable_attributes.length > 0) {
                const attribute = /** @type {import('./Element/Attribute.js').default} */ contenteditable_attributes[0];
                if ([
                    true,
                    "true",
                    ""
                ].includes(attribute.node.get_static_value())) contenteditable_attr_value = true;
                else contenteditable_attr_value = x$1`${attribute.get_value(block)}`;
            } else if (spread_attributes.length > 0 && data.element_data_name) contenteditable_attr_value = x$1`${data.element_data_name}['contenteditable']`;
            const { init: init } = this.rename_this_method(block, (value)=>{
                if (contenteditable_attr_value) {
                    if (contenteditable_attr_value === true) return x$1`@set_data_contenteditable(${this.var}, ${value})`;
                    else return x$1`@set_data_maybe_contenteditable(${this.var}, ${value}, ${contenteditable_attr_value})`;
                } else return x$1`@set_data(${this.var}, ${value})`;
            });
            block.add_element(this.var, x$1`@text(${init})`, parent_nodes && x$1`@claim_text(${parent_nodes}, ${init})`, parent_node);
        }
    }
    /** @extends Tag */ class RawMustacheTagWrapper extends Tag$1 {
        /** @type {import('estree').Identifier} */ var = {
            type: "Identifier",
            name: "raw"
        };
        /**
	 * @param {import('../Renderer.js').default} renderer
	 * @param {import('../Block.js').default} block
	 * @param {import('./shared/Wrapper.js').default} parent
	 * @param {import('../../nodes/MustacheTag.js').default | import('../../nodes/RawMustacheTag.js').default} node
	 */ constructor(renderer, block, parent, node){
            super(renderer, block, parent, node);
        }
        /**
	 * @param {import('../Block.js').default} block
	 * @param {import('estree').Identifier} parent_node
	 * @param {import('estree').Identifier} _parent_nodes
	 */ render(block, parent_node, _parent_nodes) {
            const in_head = is_head(parent_node);
            const can_use_innerhtml = !in_head && parent_node && !this.prev && !this.next;
            if (can_use_innerhtml && !this.renderer.options.hydratable) {
                /** @param {import('estree').Node} content */ const insert = (content)=>b$1`${parent_node}.innerHTML = ${content};`[0];
                const { init: init } = this.rename_this_method(block, (content)=>insert(content));
                block.chunks.mount.push(insert(init));
            } else {
                const needs_anchor = in_head || (this.next ? !this.next.is_dom_node() : !this.parent || !this.parent.is_dom_node());
                const html_tag = block.get_unique_name("html_tag");
                const html_anchor = needs_anchor && block.get_unique_name("html_anchor");
                block.add_variable(html_tag);
                const { init: init } = this.rename_this_method(block, (content)=>x$1`${html_tag}.p(${content})`);
                const update_anchor = needs_anchor ? html_anchor : this.next ? this.next.var : "null";
                const parent_element = /** @type {import('../../nodes/Element.js').default} */ this.node.find_nearest(/^Element/);
                const is_svg = parent_element && parent_element.namespace === namespaces.svg;
                block.chunks.create.push(b$1`${html_tag} = new @HtmlTag(${is_svg ? "true" : "false"});`);
                if (this.renderer.options.hydratable) block.chunks.claim.push(b$1`${html_tag} = @claim_html_tag(${_parent_nodes}, ${is_svg ? "true" : "false"});`);
                block.chunks.hydrate.push(b$1`${html_tag}.a = ${update_anchor};`);
                block.chunks.mount.push(b$1`${html_tag}.m(${init}, ${parent_node || "#target"}, ${parent_node ? null : "#anchor"});`);
                if (needs_anchor) block.add_element(html_anchor, x$1`@empty()`, x$1`@empty()`, parent_node);
                if (!parent_node || in_head) block.chunks.destroy.push(b$1`if (detaching) ${html_tag}.d();`);
            }
        }
    }
    /** @extends Wrapper<import('../../nodes/Comment.js').default> */ class CommentWrapper extends Wrapper {
        /**
	 * @param {import('../Renderer.js').default} renderer
	 * @param {import('../Block.js').default} block
	 * @param {import('./shared/Wrapper.js').default} parent
	 * @param {import('../../nodes/Comment.js').default} node
	 */ constructor(renderer, block, parent, node){
            super(renderer, block, parent, node);
            this.var = /** @type {import('estree').Identifier} */ x$1`c`;
        }
        /**
	 * @param {import('../Block.js').default} block
	 * @param {import('estree').Identifier} parent_node
	 * @param {import('estree').Identifier} parent_nodes
	 */ render(block, parent_node, parent_nodes) {
            if (!this.renderer.options.preserveComments) return;
            const string_literal = {
                type: "Literal",
                value: this.node.data,
                loc: {
                    start: this.renderer.locate(this.node.start),
                    end: this.renderer.locate(this.node.end)
                }
            };
            block.add_element(this.var, x$1`@comment(${string_literal})`, parent_nodes && x$1`@claim_comment(${parent_nodes}, ${string_literal})`, parent_node);
        }
        text() {
            if (!this.renderer.options.preserveComments) return "";
            return `<!--${this.node.data}-->`;
        }
    }
    const regex_contains_radio_or_checkbox_or_file = /radio|checkbox|file/;
    const regex_contains_radio_or_checkbox_or_range_or_file = /radio|checkbox|range|file/;
    const events = [
        {
            event_names: [
                "input"
            ],
            filter: (node, _name)=>node.name === "textarea" || node.name === "input" && !regex_contains_radio_or_checkbox_or_range_or_file.test(/** @type {string} */ node.get_static_attribute_value("type"))
        },
        {
            event_names: [
                "input"
            ],
            filter: (node, name)=>is_name_contenteditable(name) && has_contenteditable_attr(node)
        },
        {
            event_names: [
                "change"
            ],
            filter: (node, _name)=>node.name === "select" || node.name === "input" && regex_contains_radio_or_checkbox_or_file.test(/** @type {string} */ node.get_static_attribute_value("type"))
        },
        {
            event_names: [
                "change",
                "input"
            ],
            filter: (node, _name)=>node.name === "input" && node.get_static_attribute_value("type") === "range"
        },
        // resize events
        {
            event_names: [
                "elementresize"
            ],
            filter: (_node, name)=>regex_dimensions.test(name)
        },
        {
            event_names: [
                "elementresizecontentbox"
            ],
            filter: (_node, name)=>regex_content_rect.test(name) ?? regex_content_box_size.test(name)
        },
        {
            event_names: [
                "elementresizeborderbox"
            ],
            filter: (_node, name)=>regex_border_box_size.test(name)
        },
        {
            event_names: [
                "elementresizedevicepixelcontentbox"
            ],
            filter: (_node, name)=>regex_device_pixel_content_box_size.test(name)
        },
        // media events
        {
            event_names: [
                "timeupdate"
            ],
            filter: (node, name)=>node.is_media_node() && (name === "currentTime" || name === "played" || name === "ended")
        },
        {
            event_names: [
                "durationchange"
            ],
            filter: (node, name)=>node.is_media_node() && name === "duration"
        },
        {
            event_names: [
                "play",
                "pause"
            ],
            filter: (node, name)=>node.is_media_node() && name === "paused"
        },
        {
            event_names: [
                "progress"
            ],
            filter: (node, name)=>node.is_media_node() && name === "buffered"
        },
        {
            event_names: [
                "loadedmetadata"
            ],
            filter: (node, name)=>node.is_media_node() && (name === "buffered" || name === "seekable")
        },
        {
            event_names: [
                "volumechange"
            ],
            filter: (node, name)=>node.is_media_node() && (name === "volume" || name === "muted")
        },
        {
            event_names: [
                "ratechange"
            ],
            filter: (node, name)=>node.is_media_node() && name === "playbackRate"
        },
        {
            event_names: [
                "seeking",
                "seeked"
            ],
            filter: (node, name)=>node.is_media_node() && name === "seeking"
        },
        {
            event_names: [
                "ended"
            ],
            filter: (node, name)=>node.is_media_node() && name === "ended"
        },
        {
            event_names: [
                "resize"
            ],
            filter: (node, name)=>node.is_media_node() && (name === "videoHeight" || name === "videoWidth")
        },
        {
            // from https://html.spec.whatwg.org/multipage/media.html#ready-states
            // and https://html.spec.whatwg.org/multipage/media.html#loading-the-media-resource
            event_names: [
                "loadedmetadata",
                "loadeddata",
                "canplay",
                "canplaythrough",
                "playing",
                "waiting",
                "emptied"
            ],
            filter: (node, name)=>node.is_media_node() && name === "readyState"
        },
        // details event
        {
            event_names: [
                "toggle"
            ],
            filter: (node, _name)=>node.name === "details"
        },
        {
            event_names: [
                "load"
            ],
            filter: (_, name)=>name === "naturalHeight" || name === "naturalWidth"
        }
    ];
    const CHILD_DYNAMIC_ELEMENT_BLOCK = "child_dynamic_element";
    const regex_invalid_variable_identifier_characters$1 = /[^a-zA-Z0-9_$]/g;
    const regex_minus_signs = /-/g;
    /** @extends Wrapper<import('../../../nodes/Element.js').default> */ class ElementWrapper extends Wrapper {
        /** @type {import('../Fragment.js').default} */ fragment;
        /** @type {Array<AttributeWrapper | import('./StyleAttribute.js').default | import('./SpreadAttribute.js').default>} */ attributes;
        /** @type {import('./Binding.js').default[]} */ bindings;
        /** @type {import('./EventHandler.js').default[]} */ event_handlers;
        /** @type {string[]} */ class_dependencies;
        /** @type {Set<string>} */ dynamic_style_dependencies;
        /** @type {boolean} */ has_dynamic_attribute;
        /** @type {Set<string>} */ select_binding_dependencies;
        /** @type {boolean} */ has_dynamic_value;
        /** @type {any} */ dynamic_value_condition;
        /** @type {any} */ var;
        /** @type {boolean} */ void;
        /** @type {import('../../Block.js').default} */ child_dynamic_element_block = null;
        /** @type {ElementWrapper} */ child_dynamic_element = null;
        /** */ element_data_name = null;
        /**
	 * @param {import('../../Renderer.js').default} renderer
	 * @param {import('../../Block.js').default} block
	 * @param {import('../shared/Wrapper.js').default} parent
	 * @param {import('../../../nodes/Element.js').default} node
	 * @param {boolean} strip_whitespace
	 * @param {import('../shared/Wrapper.js').default} next_sibling
	 */ constructor(renderer, block, parent, node, strip_whitespace, next_sibling){
            super(renderer, block, parent, node);
            this.var = {
                type: "Identifier",
                name: node.name.replace(regex_invalid_variable_identifier_characters$1, "_")
            };
            this.void = is_void(node.name);
            this.class_dependencies = [];
            if (node.is_dynamic_element && block.type !== CHILD_DYNAMIC_ELEMENT_BLOCK) {
                this.child_dynamic_element_block = block.child({
                    comment: create_debugging_comment(node, renderer.component),
                    name: renderer.component.get_unique_name("create_dynamic_element"),
                    type: CHILD_DYNAMIC_ELEMENT_BLOCK
                });
                renderer.blocks.push(this.child_dynamic_element_block);
                this.child_dynamic_element = new ElementWrapper(renderer, this.child_dynamic_element_block, parent, node, strip_whitespace, next_sibling);
                // in the case of `parent_block -> child_dynamic_element_block -> child_dynamic_element`
                // `child_dynamic_element_block.add_intro/outro` is called inside `new ElementWrapper()`
                // but when `is_local === true` it does not bubble to parent_block
                // we manually add transitions back to the parent_block (#8233)
                if (node.intro) block.add_intro(node.intro.is_local);
                if (node.outro) block.add_outro(node.outro.is_local);
                // the original svelte:element is never used for rendering, because
                // it gets assigned a child_dynamic_element which is used in all rendering logic.
                // so doing all of this on the original svelte:element will just cause double
                // code, because it will be done again on the child_dynamic_element.
                return;
            }
            this.dynamic_style_dependencies = new Set();
            if (this.node.children.length) this.node.lets.forEach((l)=>{
                extract_names(l.value || l.name).forEach((name)=>{
                    renderer.add_to_context(name, true);
                });
            });
            this.attributes = this.node.attributes.map((attribute)=>{
                if (attribute.name === "style") return new StyleAttributeWrapper(this, block, attribute);
                if (attribute.type === "Spread") return new SpreadAttributeWrapper(this, block, attribute);
                return new AttributeWrapper(this, block, attribute);
            });
            this.has_dynamic_attribute = !!this.attributes.find((attr)=>attr.node.get_dependencies().length > 0);
            // ordinarily, there'll only be one... but we need to handle
            // the rare case where an element can have multiple bindings,
            // e.g. <audio bind:paused bind:currentTime>
            this.bindings = this.node.bindings.map((binding)=>new BindingWrapper(block, binding, this));
            this.event_handlers = this.node.handlers.map((event_handler)=>new EventHandlerWrapper(event_handler, this));
            if (node.intro) block.add_intro(node.intro.is_local);
            if (node.outro) block.add_outro(node.outro.is_local);
            if (node.animation) block.add_animation();
            block.add_dependencies(node.tag_expr.dependencies);
            // add directive and handler dependencies
            [
                node.animation,
                node.outro,
                ...node.actions,
                ...node.classes,
                ...node.styles
            ].forEach((directive)=>{
                if (directive && directive.expression) block.add_dependencies(directive.expression.dependencies);
            });
            node.handlers.forEach((handler)=>{
                if (handler.expression) block.add_dependencies(handler.expression.dependencies);
            });
            this.fragment = new FragmentWrapper(renderer, block, node.children, this, strip_whitespace, next_sibling);
            this.element_data_name = block.get_unique_name(`${this.var.name}_data`);
        }
        /**
	 * @param {import('../../Block.js').default} block
	 * @param {import('estree').Identifier} parent_node
	 * @param {import('estree').Identifier} parent_nodes
	 */ render(block, parent_node, parent_nodes) {
            if (this.child_dynamic_element) this.render_dynamic_element(block, parent_node, parent_nodes);
            else this.render_element(block, parent_node, parent_nodes);
        }
        /**
	 * @param {import('../../Block.js').default} block
	 * @param {import('estree').Identifier} parent_node
	 * @param {import('estree').Identifier} parent_nodes
	 */ render_dynamic_element(block, parent_node, parent_nodes) {
            this.child_dynamic_element.render(this.child_dynamic_element_block, null, /** @type {unknown} */ /** @type {import('estree').Identifier} */ x$1`#nodes`);
            const is_tag_dynamic = this.node.tag_expr.dynamic_dependencies().length > 0;
            const tag = this.node.tag_expr.manipulate(block);
            block.chunks.init.push(b$1`
			${this.renderer.options.dev && b$1`@validate_dynamic_element(${tag});`}
			${this.renderer.options.dev && this.node.children.length > 0 && b$1`@validate_void_dynamic_element(${tag});`}
			let ${this.var} = ${tag} && ${this.child_dynamic_element_block.name}(#ctx);
		`);
            block.chunks.create.push(b$1`
			if (${this.var}) ${this.var}.c();
		`);
            if (this.renderer.options.hydratable) block.chunks.claim.push(b$1`
				if (${this.var}) ${this.var}.l(${parent_nodes});
			`);
            block.chunks.mount.push(b$1`
			if (${this.var}) ${this.var}.m(${parent_node || "#target"}, ${parent_node ? "null" : "#anchor"});
		`);
            if (is_tag_dynamic) {
                const previous_tag = block.get_unique_name("previous_tag");
                block.add_variable(previous_tag, tag);
                const anchor = this.get_or_create_anchor(block, parent_node, parent_nodes);
                const has_transitions = !!(this.node.intro || this.node.outro);
                const not_equal = this.renderer.component.component_options.immutable ? x$1`@not_equal` : x$1`@safe_not_equal`;
                const tag_will_be_removed = block.get_unique_name("tag_will_be_removed");
                if (has_transitions) block.add_variable(tag_will_be_removed, x$1`false`);
                block.chunks.update.push(b$1`
				if (${tag}) {
					if (!${previous_tag}) {
						${this.var} = ${this.child_dynamic_element_block.name}(#ctx);
						${previous_tag} = ${tag};
						${this.var}.c();
						${has_transitions && b$1`@transition_in(${this.var})`}
						${this.var}.m(${this.get_update_mount_node(anchor)}, ${anchor});
					} else if (${not_equal}(${previous_tag}, ${tag})) {
						${this.var}.d(1);
						${this.renderer.options.dev && b$1`@validate_dynamic_element(${tag});`}
						${this.renderer.options.dev && this.node.children.length > 0 && b$1`@validate_void_dynamic_element(${tag});`}
						${this.var} = ${this.child_dynamic_element_block.name}(#ctx);
						${previous_tag} = ${tag};
						${this.var}.c();
						${has_transitions && b$1`if (${tag_will_be_removed}) {
							${tag_will_be_removed} = false;
							@transition_in(${this.var})
						}`}
						${this.var}.m(${this.get_update_mount_node(anchor)}, ${anchor});
					} else {
						${has_transitions && b$1`if (${tag_will_be_removed}) {
							${tag_will_be_removed} = false;
							@transition_in(${this.var})
						}`}
						${this.var}.p(#ctx, #dirty);
					}
				} else if (${previous_tag}) {
					${has_transitions ? b$1`
								${tag_will_be_removed} = true;
								@group_outros();
								@transition_out(${this.var}, 1, 1, () => {
									${this.var} = null;
									${previous_tag} = ${tag};
									${tag_will_be_removed} = false;
								});
								@check_outros();
							` : b$1`
								${this.var}.d(1);
								${this.var} = null;
								${previous_tag} = ${tag};
							`}
				}
			`);
            } else block.chunks.update.push(b$1`
				if (${tag}) {
					${this.var}.p(#ctx, #dirty);
				}
			`);
            if (this.child_dynamic_element_block.has_intros) block.chunks.intro.push(b$1`@transition_in(${this.var}, #local);`);
            if (this.child_dynamic_element_block.has_outros) block.chunks.outro.push(b$1`@transition_out(${this.var}, #local);`);
            block.chunks.destroy.push(b$1`if (${this.var}) ${this.var}.d(detaching)`);
            if (this.node.animation) {
                const measurements = block.get_unique_name("measurements");
                block.add_variable(measurements);
                block.chunks.measure.push(b$1`${measurements} = ${this.var}.r()`);
                block.chunks.fix.push(b$1`${this.var}.f();`);
                block.chunks.animate.push(b$1`
				${this.var}.s(${measurements});
				${this.var}.a()
			`);
            }
        }
        is_dom_node() {
            return super.is_dom_node() && !this.child_dynamic_element;
        }
        /**
	 * @param {import('../../Block.js').default} block
	 * @param {import('estree').Identifier} parent_node
	 * @param {import('estree').Identifier} parent_nodes
	 */ render_element(block, parent_node, parent_nodes) {
            const { renderer: renderer } = this;
            const hydratable = renderer.options.hydratable;
            if (this.node.name === "noscript") return;
            const node = this.var;
            const nodes = parent_nodes && block.get_unique_name(`${this.var.name}_nodes`); // if we're in unclaimable territory, i.e. <head>, parent_nodes is null
            const children = x$1`@children(${this.node.name === "template" ? x$1`${node}.content` : node})`;
            block.add_variable(node);
            const render_statement = this.get_render_statement(block);
            block.chunks.create.push(b$1`${node} = ${render_statement};`);
            const { can_use_textcontent: can_use_textcontent, can_optimise_to_html_string: can_optimise_to_html_string, can_optimise_hydration: can_optimise_hydration } = this.node;
            if (hydratable) {
                if (parent_nodes) {
                    block.chunks.claim.push(b$1`
					${node} = ${this.get_claim_statement(block, parent_nodes, can_optimise_hydration)};
				`);
                    if (!can_optimise_hydration && !this.void && this.node.children.length > 0) block.chunks.claim.push(b$1`
						var ${nodes} = ${children};
					`);
                } else block.chunks.claim.push(b$1`${node} = ${render_statement};`);
            }
            if (parent_node) {
                const append = b$1`@append(${parent_node}, ${node});`;
                /** @type {import('estree').CallExpression} */ /** @type {import('estree').ExpressionStatement} */ append[0].expression.callee.loc = {
                    start: this.renderer.locate(this.node.start),
                    end: this.renderer.locate(this.node.end)
                };
                block.chunks.mount.push(append);
                if (is_head(parent_node)) block.chunks.destroy.push(b$1`@detach(${node});`);
            } else {
                const insert = b$1`@insert(#target, ${node}, #anchor);`;
                /** @type {import('estree').CallExpression} */ /** @type {import('estree').ExpressionStatement} */ insert[0].expression.callee.loc = {
                    start: this.renderer.locate(this.node.start),
                    end: this.renderer.locate(this.node.end)
                };
                block.chunks.mount.push(insert);
                // TODO we eventually need to consider what happens to elements
                // that belong to the same outgroup as an outroing element...
                block.chunks.destroy.push(b$1`if (detaching) @detach(${node});`);
            }
            // insert static children with textContent or innerHTML
            // skip textcontent for <template>.  append nodes to TemplateElement.content instead
            if (can_optimise_to_html_string && (!hydratable || can_optimise_hydration)) {
                if (this.fragment.nodes.length === 1 && this.fragment.nodes[0].node.type === "Text") {
                    /** @type {import('estree').Node} */ let text = string_literal(/** @type {import('../Text.js').default} */ this.fragment.nodes[0].data);
                    if (hydratable) {
                        const variable = block.get_unique_name("textContent");
                        block.add_variable(variable, text);
                        text = variable;
                    }
                    block.chunks.create.push(b$1`${node}.textContent = ${text};`);
                    if (hydratable) block.chunks.claim.push(b$1`if (@get_svelte_dataset(${node}) !== "${this.node.hash()}") ${node}.textContent = ${text};`);
                } else {
                    const state = {
                        quasi: {
                            type: "TemplateElement",
                            value: {
                                raw: ""
                            }
                        }
                    };
                    /** @type {import('estree').Node} */ let literal = {
                        type: "TemplateLiteral",
                        expressions: [],
                        quasis: []
                    };
                    const can_use_raw_text = !this.node.can_use_innerhtml && can_use_textcontent;
                    to_html(/** @type {unknown} */ /** @type {Array<ElementWrapper | import('../Comment.js').default | import('../Text.js').default>} */ this.fragment.nodes, block, literal, state, can_use_raw_text);
                    literal.quasis.push(/** @type {any} */ state.quasi);
                    if (hydratable) {
                        const variable = block.get_unique_name("textContent");
                        block.add_variable(variable, literal);
                        literal = variable;
                    }
                    const property = this.node.can_use_innerhtml ? "innerHTML" : "textContent";
                    block.chunks.create.push(b$1`${node}.${property} = ${literal};`);
                    if (hydratable) block.chunks.claim.push(b$1`if (@get_svelte_dataset(${node}) !== "${this.node.hash()}") ${node}.${property} = ${literal};`);
                }
            } else this.fragment.nodes.forEach((child)=>{
                child.render(block, this.node.name === "template" ? x$1`${node}.content` : node, nodes, {
                    element_data_name: this.element_data_name
                });
            });
            const event_handler_or_binding_uses_context = this.bindings.some((binding)=>binding.handler.uses_context) || this.node.handlers.some((handler)=>handler.uses_context) || this.node.actions.some((action)=>action.uses_context);
            if (event_handler_or_binding_uses_context) block.maintain_context = true;
            if (this.node.is_dynamic_element) this.add_dynamic_element_attributes(block);
            else this.add_attributes(block);
            this.add_directives_in_order(block);
            this.add_transitions(block);
            this.add_animation(block);
            this.add_classes(block);
            this.add_styles(block);
            this.add_manual_style_scoping(block);
            if (nodes && hydratable && !this.void && !can_optimise_hydration) block.chunks.claim.push(b$1`${this.node.children.length > 0 ? nodes : children}.forEach(@detach);`);
            if (renderer.options.dev) {
                const loc = renderer.meta_locate(this.node.start);
                block.chunks.hydrate.push(b$1`@add_location(${this.var}, ${renderer.file_var}, ${loc.line - 1}, ${loc.column}, ${// TODO this.node.start isn't correct if there's a source map. But since we don't know how the
                // original source file looked, there's not much we can do.
                this.node.start});`);
            }
            block.renderer.dirty(this.node.tag_expr.dynamic_dependencies());
        }
        /** @param {import('../../Block.js').default} block */ get_render_statement(block) {
            const { name: name, namespace: namespace, tag_expr: tag_expr } = this.node;
            const reference = tag_expr.manipulate(block);
            if (namespace === namespaces.svg) return x$1`@svg_element(${reference})`;
            if (namespace) return x$1`@_document.createElementNS("${namespace}", "${name}")`;
            /** @type {import('./Attribute.js').default} */ const is = /** @type {any} */ this.attributes.find((attr)=>attr.node.name === "is");
            if (is) return x$1`@element_is("${name}", ${is.render_chunks(block).reduce((lhs, rhs)=>x$1`${lhs} + ${rhs}`)})`;
            return x$1`@element(${reference})`;
        }
        /**
	 * @param {import('../../Block.js').default} block
	 * @param {import('estree').Identifier} nodes
	 * @param {boolean} to_optimise_hydration
	 */ get_claim_statement(block, nodes, to_optimise_hydration) {
            const attributes = this.attributes.filter((attr)=>!(attr instanceof SpreadAttributeWrapper) && !attr.property_name).map((attr)=>p`${/** @type {import('./StyleAttribute.js').default | import('./Attribute.js').default} */ attr.name}: true`);
            /** @type {string | ReturnType<typeof x>} */ let reference;
            if (this.node.tag_expr.node.type === "Literal") {
                if (this.node.namespace) reference = `"${this.node.tag_expr.node.value}"`;
                else reference = `"${/** @type {String} */ (this.node.tag_expr.node.value || "").toUpperCase()}"`;
            } else if (this.node.namespace) reference = x$1`${this.node.tag_expr.manipulate(block)}`;
            else reference = x$1`(${this.node.tag_expr.manipulate(block)} || 'null').toUpperCase()`;
            if (to_optimise_hydration) attributes.push(p`["data-svelte-h"]: true`);
            if (this.node.namespace === namespaces.svg) return x$1`@claim_svg_element(${nodes}, ${reference}, { ${attributes} })`;
            else return x$1`@claim_element(${nodes}, ${reference}, { ${attributes} })`;
        }
        /** @param {import('../../Block.js').default} block */ add_directives_in_order(block) {
            /** @typedef {EventHandler | BindingGroup | Binding | Action} OrderedAttribute */ const binding_groups = events.map((event)=>({
                    events: event.event_names,
                    bindings: this.bindings.filter((binding)=>binding.node.name !== "this").filter((binding)=>event.filter(this.node, binding.node.name))
                })).filter((group)=>group.bindings.length);
            const this_binding = this.bindings.find((b)=>b.node.name === "this");
            /** @param {OrderedAttribute} item */ function getOrder(item) {
                if (item instanceof EventHandlerWrapper) return item.node.start;
                else if (item instanceof BindingWrapper) return item.node.start;
                else if (item instanceof Action) return item.start;
                else return item.bindings[0].node.start;
            }
            /** @type {OrderedAttribute[]} */ [
                ...binding_groups,
                ...this.event_handlers,
                this_binding,
                ...this.node.actions
            ].filter(Boolean).sort((a, b)=>getOrder(a) - getOrder(b)).forEach((item)=>{
                if (item instanceof EventHandlerWrapper) add_event_handler(block, this.var, item);
                else if (item instanceof BindingWrapper) this.add_this_binding(block, item);
                else if (item instanceof Action) add_action(block, this.var, item);
                else this.add_bindings(block, item);
            });
        }
        /**
	 * @param {import('../../Block.js').default} block
	 * @param {BindingGroup} binding_group
	 */ add_bindings(block, binding_group) {
            const { renderer: renderer } = this;
            if (binding_group.bindings.length === 0) return;
            renderer.component.has_reactive_assignments = true;
            const lock = binding_group.bindings.some((binding)=>binding.needs_lock) ? block.get_unique_name(`${this.var.name}_updating`) : null;
            if (lock) block.add_variable(lock, x$1`false`);
            const handler = renderer.component.get_unique_name(`${this.var.name}_${binding_group.events.join("_")}_handler`);
            renderer.add_to_context(handler.name);
            // TODO figure out how to handle locks
            const needs_lock = binding_group.bindings.some((binding)=>binding.needs_lock);
            /** @type {Set<string>} */ const dependencies = new Set();
            /** @type {Set<string>} */ const contextual_dependencies = new Set();
            binding_group.bindings.forEach((binding)=>{
                // TODO this is a mess
                add_to_set(dependencies, binding.get_update_dependencies());
                add_to_set(contextual_dependencies, binding.handler.contextual_dependencies);
                binding.render(block, lock);
            });
            // media bindings — awkward special case. The native timeupdate events
            // fire too infrequently, so we need to take matters into our
            // own hands
            /** @type {import('estree').Identifier | undefined} */ let animation_frame;
            if (binding_group.events[0] === "timeupdate") {
                animation_frame = block.get_unique_name(`${this.var.name}_animationframe`);
                block.add_variable(animation_frame);
            }
            const has_local_function = contextual_dependencies.size > 0 || needs_lock || animation_frame;
            let callee = renderer.reference(handler);
            // TODO dry this out — similar code for event handlers and component bindings
            if (has_local_function) {
                const args = Array.from(contextual_dependencies).map((name)=>renderer.reference(name));
                // need to create a block-local function that calls an instance-level function
                if (animation_frame) block.chunks.init.push(b$1`
					function ${handler}() {
						@_cancelAnimationFrame(${animation_frame});
						if (!${this.var}.paused) {
							${animation_frame} = @raf(${handler});
							${needs_lock && b$1`${lock} = true;`}
						}
						${callee}.call(${this.var}, ${args});
					}
				`);
                else block.chunks.init.push(b$1`
					function ${handler}() {
						${needs_lock && b$1`${lock} = true;`}
						${callee}.call(${this.var}, ${args});
					}
				`);
                callee = handler;
            }
            const params = Array.from(contextual_dependencies).map((name)=>({
                    type: "Identifier",
                    name: name
                }));
            this.renderer.component.partly_hoisted.push(b$1`
			function ${handler}(${params}) {
				${binding_group.bindings.map((b)=>b.handler.mutation)}
				${Array.from(dependencies).filter((dep)=>dep[0] !== "$").filter((dep)=>!contextual_dependencies.has(dep)).map((dep)=>b$1`${this.renderer.invalidate(dep)};`)}
			}
		`);
            binding_group.events.forEach((name)=>{
                if ([
                    "elementresize",
                    "elementresizecontentbox",
                    "elementresizeborderbox",
                    "elementresizedevicepixelcontentbox"
                ].indexOf(name) !== -1) {
                    const resize_listener = block.get_unique_name(`${this.var.name}_resize_listener`);
                    block.add_variable(resize_listener);
                    // Can't dynamically do `@fn[name]`, code-red doesn't know how to resolve it
                    switch(name){
                        case "elementresize":
                            block.chunks.mount.push(b$1`${resize_listener} = @add_iframe_resize_listener(${this.var}, ${callee}.bind(${this.var}));`);
                            break;
                        case "elementresizecontentbox":
                            block.chunks.mount.push(b$1`${resize_listener} = @resize_observer_content_box.observe(${this.var}, ${callee}.bind(${this.var}));`);
                            break;
                        case "elementresizeborderbox":
                            block.chunks.mount.push(b$1`${resize_listener} = @resize_observer_border_box.observe(${this.var}, ${callee}.bind(${this.var}));`);
                            break;
                        case "elementresizedevicepixelcontentbox":
                            block.chunks.mount.push(b$1`${resize_listener} = @resize_observer_device_pixel_content_box.observe(${this.var}, ${callee}.bind(${this.var}));`);
                            break;
                    }
                    block.chunks.destroy.push(b$1`${resize_listener}();`);
                } else block.event_listeners.push(x$1`@listen(${this.var}, "${name}", ${callee})`);
            });
            const some_initial_state_is_undefined = binding_group.bindings.map((binding)=>x$1`${binding.snippet} === void 0`).reduce((lhs, rhs)=>x$1`${lhs} || ${rhs}`);
            const should_initialise = this.node.name === "select" || binding_group.bindings.find((binding)=>binding.node.name === "indeterminate" || is_name_contenteditable(binding.node.name) || binding.is_readonly_media_attribute());
            if (should_initialise) {
                const callback = has_local_function ? handler : x$1`() => ${callee}.call(${this.var})`;
                block.chunks.hydrate.push(b$1`if (${some_initial_state_is_undefined}) @add_render_callback(${callback});`);
            }
            if (binding_group.events[0] === "elementresize") block.chunks.hydrate.push(b$1`@add_render_callback(() => ${callee}.call(${this.var}));`);
            if (lock) block.chunks.update.push(b$1`${lock} = false;`);
        }
        /**
	 * @param {import('../../Block.js').default} block
	 * @param {import('./Binding.js').default} this_binding
	 */ add_this_binding(block, this_binding) {
            const { renderer: renderer } = this;
            renderer.component.has_reactive_assignments = true;
            const binding_callback = bind_this(renderer.component, block, this_binding, this.var);
            block.chunks.mount.push(binding_callback);
        }
        /** @param {import('../../Block.js').default} block */ add_attributes(block) {
            // Get all the class and style dependencies first
            this.attributes.forEach((attribute)=>{
                if (attribute.node.name === "class") {
                    const dependencies = attribute.node.get_dependencies();
                    push_array(this.class_dependencies, dependencies);
                } else if (attribute.node.name === "style") add_to_set(this.dynamic_style_dependencies, attribute.node.get_dependencies());
            });
            if (this.node.attributes.some((attr)=>attr.is_spread)) {
                this.add_spread_attributes(block);
                return;
            }
            this.attributes.forEach((attribute)=>{
                attribute.render(block);
            });
        }
        /** @param {import('../../Block.js').default} block */ add_spread_attributes(block) {
            const levels = block.get_unique_name(`${this.var.name}_levels`);
            const initial_props = [];
            const updates = [];
            this.attributes.forEach((attr)=>{
                const dependencies = attr.node.get_dependencies();
                const condition = dependencies.length > 0 ? block.renderer.dirty(dependencies) : null;
                if (attr instanceof SpreadAttributeWrapper) {
                    const snippet = attr.node.expression.manipulate(block);
                    initial_props.push(snippet);
                    updates.push(condition ? x$1`${condition} && ${snippet}` : snippet);
                } else {
                    const name = attr.property_name || attr.name;
                    initial_props.push(x$1`{ ${name}: ${attr.get_init(block, attr.get_value(block))} }`);
                    const snippet = x$1`{ ${name}: ${attr.should_cache ? attr.last : attr.get_value(block)} }`;
                    updates.push(condition ? x$1`${attr.get_dom_update_conditions(block, condition)} && ${snippet}` : snippet);
                }
            });
            block.chunks.init.push(b$1`
			let ${levels} = [${initial_props}];

			let ${this.element_data_name} = {};
			for (let #i = 0; #i < ${levels}.length; #i += 1) {
				${this.element_data_name} = @assign(${this.element_data_name}, ${levels}[#i]);
			}
		`);
            const fn = this.node.namespace === namespaces.svg ? x$1`@set_svg_attributes` : this.node.is_dynamic_element ? x$1`@set_dynamic_element_data(${this.node.tag_expr.manipulate(block)})` : x$1`@set_attributes`;
            block.chunks.hydrate.push(b$1`${fn}(${this.var}, ${this.element_data_name});`);
            if (this.has_dynamic_attribute) block.chunks.update.push(b$1`
				${fn}(${this.var}, ${this.element_data_name} = @get_spread_update(${levels}, [
					${updates}
				]));
			`);
            // handle edge cases for elements
            if (this.node.name === "select") {
                const dependencies = new Set();
                for (const attr of this.attributes)for (const dep of attr.node.dependencies)dependencies.add(dep);
                block.chunks.mount.push(b$1`
				'value' in ${this.element_data_name} && (${this.element_data_name}.multiple ? @select_options : @select_option)(${this.var}, ${this.element_data_name}.value);
			`);
                block.chunks.update.push(b$1`
				if (${block.renderer.dirty(Array.from(dependencies))} && 'value' in ${this.element_data_name}) (${this.element_data_name}.multiple ? @select_options : @select_option)(${this.var}, ${this.element_data_name}.value);
			`);
            } else if (this.node.name === "input" && this.attributes.find((attr)=>attr.node.name === "value")) {
                const type = this.node.get_static_attribute_value("type");
                if (type === null || type === "" || type === "text" || type === "email" || type === "password") {
                    block.chunks.mount.push(b$1`
					if ('value' in ${this.element_data_name}) {
						${this.var}.value = ${this.element_data_name}.value;
					}
				`);
                    block.chunks.update.push(b$1`
					if ('value' in ${this.element_data_name}) {
						${this.var}.value = ${this.element_data_name}.value;
					}
				`);
                }
            }
            if ([
                "button",
                "input",
                "keygen",
                "select",
                "textarea"
            ].includes(this.node.name)) block.chunks.mount.push(b$1`
				if (${this.var}.autofocus) ${this.var}.focus();
			`);
        }
        /** @param {import('../../Block.js').default} block */ add_dynamic_element_attributes(block) {
            if (this.attributes.length === 0) return;
            if (this.has_dynamic_attribute) {
                this.add_spread_attributes(block);
                return;
            }
            const static_attributes = [];
            this.attributes.forEach((attr)=>{
                if (attr instanceof SpreadAttributeWrapper) {
                    const snippet = {
                        type: "SpreadElement",
                        argument: attr.node.expression.manipulate(block)
                    };
                    static_attributes.push(snippet);
                } else {
                    const name = attr.property_name || attr.name;
                    static_attributes.push(p`${name}: ${attr.get_value(block)}`);
                }
            });
            const fn = this.node.namespace === namespaces.svg ? x$1`@set_svg_attributes` : this.node.is_dynamic_element ? x$1`@set_dynamic_element_data(${this.node.tag_expr.manipulate(block)})` : x$1`@set_attributes`;
            block.chunks.hydrate.push(b$1`${fn}(${this.var}, {${static_attributes}});`);
        }
        /** @param {import('../../Block.js').default} block */ add_transitions(block) {
            const { intro: intro, outro: outro } = this.node;
            if (!intro && !outro) return;
            if (intro === outro) {
                // bidirectional transition
                const name = block.get_unique_name(`${this.var.name}_transition`);
                const snippet = intro.expression ? intro.expression.manipulate(block) : x$1`{}`;
                block.add_variable(name);
                const fn = this.renderer.reference(intro.name);
                const intro_block = b$1`
				@add_render_callback(() => {
					if (!#current) return;
					if (!${name}) ${name} = @create_bidirectional_transition(${this.var}, ${fn}, ${snippet}, true);
					${name}.run(1);
				});
			`;
                const outro_block = b$1`
				if (!${name}) ${name} = @create_bidirectional_transition(${this.var}, ${fn}, ${snippet}, false);
				${name}.run(0);
			`;
                if (intro.is_local) {
                    block.chunks.intro.push(b$1`
					if (#local) {
						${intro_block}
					}
				`);
                    block.chunks.outro.push(b$1`
					if (#local) {
						${outro_block}
					}
				`);
                } else {
                    block.chunks.intro.push(intro_block);
                    block.chunks.outro.push(outro_block);
                }
                block.chunks.destroy.push(b$1`if (detaching && ${name}) ${name}.end();`);
            } else {
                const intro_name = intro && block.get_unique_name(`${this.var.name}_intro`);
                const outro_name = outro && block.get_unique_name(`${this.var.name}_outro`);
                if (intro) {
                    block.add_variable(intro_name);
                    const snippet = intro.expression ? intro.expression.manipulate(block) : x$1`{}`;
                    const fn = this.renderer.reference(intro.name);
                    let intro_block;
                    if (outro) {
                        intro_block = b$1`
						@add_render_callback(() => {
							if (!#current) return;
							if (${outro_name}) ${outro_name}.end(1);
							${intro_name} = @create_in_transition(${this.var}, ${fn}, ${snippet});
							${intro_name}.start();
						});
					`;
                        block.chunks.outro.push(b$1`if (${intro_name}) ${intro_name}.invalidate();`);
                    } else intro_block = b$1`
						if (!${intro_name}) {
							@add_render_callback(() => {
								${intro_name} = @create_in_transition(${this.var}, ${fn}, ${snippet});
								${intro_name}.start();
							});
						}
					`;
                    if (intro.is_local) intro_block = b$1`
						if (#local) {
							${intro_block}
						}
					`;
                    block.chunks.intro.push(intro_block);
                }
                if (outro) {
                    block.add_variable(outro_name);
                    const snippet = outro.expression ? outro.expression.manipulate(block) : x$1`{}`;
                    const fn = this.renderer.reference(outro.name);
                    if (!intro) block.chunks.intro.push(b$1`
						if (${outro_name}) ${outro_name}.end(1);
					`);
                    // TODO hide elements that have outro'd (unless they belong to a still-outroing
                    // group) prior to their removal from the DOM
                    let outro_block = b$1`
					${outro_name} = @create_out_transition(${this.var}, ${fn}, ${snippet});
				`;
                    if (outro.is_local) outro_block = b$1`
						if (#local) {
							${outro_block}
						}
					`;
                    block.chunks.outro.push(outro_block);
                    block.chunks.destroy.push(b$1`if (detaching && ${outro_name}) ${outro_name}.end();`);
                }
            }
            if (intro && intro.expression && intro.expression.dependencies.size || outro && outro.expression && outro.expression.dependencies.size) block.maintain_context = true;
        }
        /** @param {import('../../Block.js').default} block */ add_animation(block) {
            if (!this.node.animation) return;
            const { outro: outro } = this.node;
            const rect = block.get_unique_name("rect");
            const stop_animation = block.get_unique_name("stop_animation");
            block.add_variable(rect);
            block.add_variable(stop_animation, x$1`@noop`);
            block.chunks.measure.push(b$1`
			${rect} = ${this.var}.getBoundingClientRect();
		`);
            if (block.type === CHILD_DYNAMIC_ELEMENT_BLOCK) {
                block.chunks.measure.push(b$1`return ${rect}`);
                block.chunks.restore_measurements.push(b$1`${rect} = #measurement;`);
            }
            block.chunks.fix.push(b$1`
			@fix_position(${this.var});
			${stop_animation}();
			${outro && b$1`@add_transform(${this.var}, ${rect});`}
		`);
            /** @type {import('estree').Node | ReturnType<typeof x>} */ let params;
            if (this.node.animation.expression) {
                params = this.node.animation.expression.manipulate(block);
                if (this.node.animation.expression.dynamic_dependencies().length) {
                    // if `params` is dynamic, calculate params ahead of time in the `.r()` method
                    const params_var = block.get_unique_name("params");
                    block.add_variable(params_var);
                    block.chunks.measure.push(b$1`${params_var} = ${params};`);
                    params = params_var;
                }
            } else params = x$1`{}`;
            const name = this.renderer.reference(this.node.animation.name);
            block.chunks.animate.push(b$1`
			${stop_animation}();
			${stop_animation} = @create_animation(${this.var}, ${rect}, ${name}, ${params});
		`);
        }
        /** @param {import('../../Block.js').default} block */ add_classes(block) {
            const has_spread = this.node.attributes.some((attr)=>attr.is_spread);
            this.node.classes.forEach((class_directive)=>{
                const { expression: expression, name: name } = class_directive;
                let snippet;
                let dependencies;
                if (expression) {
                    snippet = expression.manipulate(block);
                    dependencies = expression.dependencies;
                } else {
                    snippet = name;
                    dependencies = new Set([
                        name
                    ]);
                }
                const updater = b$1`@toggle_class(${this.var}, "${name}", ${snippet});`;
                block.chunks.hydrate.push(updater);
                if ((this.node.is_dynamic_element || has_spread) && this.has_dynamic_attribute) block.chunks.update.push(updater);
                else if (dependencies && dependencies.size > 0 || this.class_dependencies.length) {
                    const all_dependencies = this.class_dependencies.concat(...dependencies);
                    let condition = block.renderer.dirty(all_dependencies);
                    if (block.has_outros) condition = x$1`!#current || ${condition}`;
                    // If all of the dependencies are non-dynamic (don't get updated) then there is no reason
                    // to add an updater for this.
                    const any_dynamic_dependencies = all_dependencies.some((dep)=>{
                        const variable = this.renderer.component.var_lookup.get(dep);
                        return !variable || is_dynamic$1(variable);
                    });
                    if (any_dynamic_dependencies) block.chunks.update.push(b$1`
						if (${condition}) {
							${updater}
						}
					`);
                }
            });
        }
        /** @param {import('../../Block.js').default} block */ add_styles(block) {
            const has_spread = this.node.attributes.some((attr)=>attr.is_spread);
            /** @type {import('estree').Identifier | undefined} */ let style_changed_var;
            const maybe_create_style_changed_var = ()=>{
                if (!style_changed_var && this.dynamic_style_dependencies.size) {
                    style_changed_var = block.get_unique_name("style_changed");
                    const style_attr_dirty = block.renderer.dirty([
                        ...this.dynamic_style_dependencies
                    ]);
                    block.chunks.update.push(b$1`const ${style_changed_var} = ${style_attr_dirty};`);
                }
            };
            this.node.styles.forEach((style_directive)=>{
                const { name: name, expression: expression, important: important, should_cache: should_cache } = style_directive;
                const snippet = expression.manipulate(block);
                let cached_snippet;
                if (should_cache) {
                    cached_snippet = block.get_unique_name(`style_${name.replace(regex_minus_signs, "_")}`);
                    block.add_variable(cached_snippet, snippet);
                }
                const updater = b$1`@set_style(${this.var}, "${name}", ${should_cache ? cached_snippet : snippet}, ${important ? 1 : null})`;
                block.chunks.hydrate.push(updater);
                const self_deps = expression.dynamic_dependencies();
                const all_deps = new Set([
                    ...self_deps,
                    ...this.dynamic_style_dependencies
                ]);
                let condition = block.renderer.dirty([
                    ...all_deps
                ]);
                // Assume that style has changed through the spread attribute
                if (has_spread) {
                    if (should_cache && all_deps.size) // Update the cached value
                    block.chunks.update.push(b$1`
						if (${condition}) {
							${cached_snippet} = ${snippet};
						}`);
                    block.chunks.update.push(updater);
                } else {
                    if (all_deps.size === 0) return;
                    if (should_cache) condition = x$1`${condition} && ${cached_snippet} !== (${cached_snippet} = ${snippet})`;
                    if (this.dynamic_style_dependencies.size > 0) {
                        maybe_create_style_changed_var();
                        condition = x$1`${condition} || ${style_changed_var}`;
                    }
                    block.chunks.update.push(b$1`
					if (${condition}) {
						${updater}
					}
				`);
                }
            });
        }
        /** @param {import('../../Block.js').default} block */ add_manual_style_scoping(block) {
            if (this.node.needs_manual_style_scoping) {
                const updater = b$1`@toggle_class(${this.var}, "${this.node.component.stylesheet.id}", true);`;
                block.chunks.hydrate.push(updater);
                block.chunks.update.push(updater);
            }
        }
    }
    const regex_backticks = /`/g;
    const regex_dollar_signs = /\$/g;
    /**
 * @param {Array<
 * 		import('../Comment.js').default | ElementWrapper | import('../Text.js').default | import('../MustacheTag.js').default | import('../RawMustacheTag.js').default
 * 	>} wrappers
 * @param {import('../../Block.js').default} block
 * @param {any} literal
 * @param {any} state
 * @param {boolean} [can_use_raw_text]
 */ function to_html(wrappers, block, literal, state, can_use_raw_text) {
        wrappers.forEach((wrapper)=>{
            if (wrapper instanceof CommentWrapper) state.quasi.value.raw += wrapper.text();
            else if (wrapper instanceof TextWrapper) {
                // Don't add the <pre>/<textarea> newline logic here because pre/textarea.innerHTML
                // would keep the leading newline, too, only someParent.innerHTML = '..<pre/textarea>..' won't
                if (wrapper.use_space()) {
                    // use space instead of the text content
                    state.quasi.value.raw += " ";
                    return;
                }
                const parent = /** @type {import('../../../nodes/Element.js').default} */ wrapper.node.parent;
                const raw = parent && (parent.name === "script" || parent.name === "style" || can_use_raw_text);
                state.quasi.value.raw += (raw ? wrapper.data : escape_html(wrapper.data)).replace(regex_backslashes, "\\\\").replace(regex_backticks, "\\`").replace(regex_dollar_signs, "\\$");
            } else if (wrapper instanceof MustacheTagWrapper || wrapper instanceof RawMustacheTagWrapper) {
                literal.quasis.push(state.quasi);
                literal.expressions.push(wrapper.node.expression.manipulate(block));
                state.quasi = {
                    type: "TemplateElement",
                    value: {
                        raw: ""
                    }
                };
            } else if (wrapper.node.name === "noscript") ;
            else {
                const nodeName = wrapper.node.name;
                // element
                state.quasi.value.raw += `<${nodeName}`;
                const is_empty_textarea = nodeName === "textarea" && wrapper.fragment.nodes.length === 0;
                /** @type {ElementWrapper} */ wrapper.attributes.forEach((attr)=>{
                    if (is_empty_textarea && attr.node.name === "value") // The value attribute of <textarea> renders as content.
                    return;
                    if (attr instanceof SpreadAttributeWrapper) {
                        literal.quasis.push(state.quasi);
                        literal.expressions.push(x$1`@stringify_spread(${attr.node.expression.manipulate(block)})`);
                        state.quasi = {
                            type: "TemplateElement",
                            value: {
                                raw: ""
                            }
                        };
                    } else {
                        state.quasi.value.raw += ` ${fix_attribute_casing(attr.node.name)}="`;
                        to_html_for_attr_value(attr, block, literal, state);
                        state.quasi.value.raw += '"';
                    }
                });
                if (!wrapper.void) {
                    state.quasi.value.raw += ">";
                    if (nodeName === "pre") {
                        // Two or more leading newlines are required to restore the leading newline immediately after `<pre>`.
                        // see https://html.spec.whatwg.org/multipage/grouping-content.html#the-pre-element
                        const first = wrapper.fragment.nodes[0];
                        if (first && first.node.type === "Text" && regex_starts_with_newline.test(first.node.data)) state.quasi.value.raw += "\n";
                    }
                    if (is_empty_textarea) {
                        // The <textarea> renders the value attribute as content because the content is stored in the value attribute.
                        const value_attribute = wrapper.attributes.find((attr)=>attr.node.name === "value");
                        if (value_attribute) {
                            // Two or more leading newlines are required to restore the leading newline immediately after `<textarea>`.
                            // see https://html.spec.whatwg.org/multipage/syntax.html#element-restrictions
                            const first = value_attribute.node.chunks[0];
                            if (first && first.type === "Text" && regex_starts_with_newline.test(first.data)) state.quasi.value.raw += "\n";
                            to_html_for_attr_value(value_attribute, block, literal, state);
                        }
                    }
                    to_html(/** @type {Array<ElementWrapper | import('../Text.js').default>} */ wrapper.fragment.nodes, block, literal, state);
                    state.quasi.value.raw += `</${nodeName}>`;
                } else state.quasi.value.raw += "/>";
            }
        });
    }
    /**
 * @param {import('./Attribute.js').default | import('./StyleAttribute.js').default | import('./SpreadAttribute.js').default} attr
 * @param {import('../../Block.js').default} block
 * @param {any} literal
 * @param {any} state
 */ function to_html_for_attr_value(attr, block, literal, state) {
        attr.node.chunks.forEach((chunk)=>{
            if (chunk.type === "Text") state.quasi.value.raw += escape_html(chunk.data);
            else {
                literal.quasis.push(state.quasi);
                literal.expressions.push(chunk.manipulate(block));
                state.quasi = {
                    type: "TemplateElement",
                    value: {
                        raw: ""
                    }
                };
            }
        });
    }
    /** @typedef {Object} BindingGroup
 * @property {string[]} events
 * @property {Binding[]} bindings
 */ /** @extends Wrapper<import('../../nodes/Head.js').default> */ class HeadWrapper extends Wrapper {
        /** @type {import('./Fragment.js').default} */ fragment;
        /**
	 * @param {import('../Renderer.js').default} renderer
	 * @param {import('../Block.js').default} block
	 * @param {import('./shared/Wrapper.js').default} parent
	 * @param {import('../../nodes/Head.js').default} node
	 * @param {boolean} strip_whitespace
	 * @param {import('./shared/Wrapper.js').default} next_sibling
	 */ constructor(renderer, block, parent, node, strip_whitespace, next_sibling){
            super(renderer, block, parent, node);
            this.fragment = new FragmentWrapper(renderer, block, node.children, this, strip_whitespace, next_sibling);
        }
        /**
	 * @param {import('../Block.js').default} block
	 * @param {import('estree').Identifier} _parent_node
	 * @param {import('estree').Identifier} _parent_nodes
	 */ render(block, _parent_node, _parent_nodes) {
            /** @type {import('estree').Identifier} */ let nodes;
            if (this.renderer.options.hydratable && this.fragment.nodes.length) {
                nodes = block.get_unique_name("head_nodes");
                block.chunks.claim.push(b$1`const ${nodes} = @head_selector('${this.node.id}', @_document.head);`);
            }
            this.fragment.render(block, /** @type {unknown} */ /** @type {import('estree').Identifier} */ x$1`@_document.head`, nodes);
            if (nodes && this.renderer.options.hydratable) block.chunks.claim.push(b$1`${nodes}.forEach(@detach);`);
        }
    }
    /** @param {import('../../nodes/ElseBlock.js').default} node */ function is_else_if(node) {
        return node && node.children.length === 1 && node.children[0].type === "IfBlock";
    }
    /** @extends Wrapper<import('../../nodes/IfBlock.js').default | import('../../nodes/ElseBlock.js').default> */ class IfBlockBranch extends Wrapper {
        /** @type {import('../Block.js').default} */ block;
        /** @type {import('./Fragment.js').default} */ fragment;
        /** @type {string[]} */ dependencies;
        /** @type {any} */ condition;
        /** @type {import('estree').Node} */ snippet;
        /** @type {boolean} */ is_dynamic;
        /** */ var = null;
        /** @type {import('estree').Node | undefined} */ get_ctx_name;
        /**
	 * @param {import('../Renderer.js').default} renderer
	 * @param {import('../Block.js').default} block
	 * @param {IfBlockWrapper} parent
	 * @param {import('../../nodes/IfBlock.js').default | import('../../nodes/ElseBlock.js').default} node
	 * @param {boolean} strip_whitespace
	 * @param {import('./shared/Wrapper.js').default} next_sibling
	 */ constructor(renderer, block, parent, node, strip_whitespace, next_sibling){
            super(renderer, block, parent, node);
            const { expression: expression } = /** @type {import('../../nodes/IfBlock.js').default} */ node;
            const is_else = !expression;
            if (expression) {
                this.dependencies = expression.dynamic_dependencies();
                // TODO is this the right rule? or should any non-reference count?
                // const should_cache = !is_reference(expression.node, null) && dependencies.length > 0;
                let should_cache = false;
                walk(expression.node, {
                    enter (node) {
                        if (node.type === "CallExpression" || node.type === "NewExpression") should_cache = true;
                    }
                });
                if (should_cache) {
                    this.condition = block.get_unique_name("show_if");
                    this.snippet = /** @type {import('estree').Node} */ expression.manipulate(block);
                } else this.condition = expression.manipulate(block);
            }
            add_const_tags_context(renderer, this.node.const_tags);
            this.block = block.child({
                comment: create_debugging_comment(node, parent.renderer.component),
                name: parent.renderer.component.get_unique_name(is_else ? "create_else_block" : "create_if_block"),
                type: /** @type {import('../../nodes/IfBlock.js').default} */ node.expression ? "if" : "else"
            });
            this.fragment = new FragmentWrapper(renderer, this.block, node.children, parent, strip_whitespace, next_sibling);
            this.is_dynamic = this.block.dependencies.size > 0;
            if (node.const_tags.length > 0) this.get_ctx_name = parent.renderer.component.get_unique_name(is_else ? "get_else_ctx" : "get_if_ctx");
        }
    }
    /** @extends Wrapper<import('../../nodes/IfBlock.js').default> */ class IfBlockWrapper extends Wrapper {
        /** @typedef {'detaching' | null} DetachingOrNull */ /** @type {IfBlockBranch[]} */ branches;
        /** */ needs_update = false;
        /** @type {import('estree').Identifier} */ var = {
            type: "Identifier",
            name: "if_block"
        };
        /**
	 * @param {import('../Renderer.js').default} renderer
	 * @param {import('../Block.js').default} block
	 * @param {import('./shared/Wrapper.js').default} parent
	 * @param {import('../../nodes/IfBlock.js').default} node
	 * @param {boolean} strip_whitespace
	 * @param {import('./shared/Wrapper.js').default} next_sibling
	 */ constructor(renderer, block, parent, node, strip_whitespace, next_sibling){
            super(renderer, block, parent, node);
            this.branches = [];
            /** @type {import('../Block.js').default[]} */ const blocks = [];
            let is_dynamic = false;
            let has_intros = false;
            let has_outros = false;
            /** @param {import('../../nodes/IfBlock.js').default} node */ const create_branches = (node)=>{
                const branch = new IfBlockBranch(renderer, block, this, node, strip_whitespace, next_sibling);
                this.branches.push(branch);
                blocks.push(branch.block);
                block.add_dependencies(node.expression.dependencies);
                if (branch.block.dependencies.size > 0) {
                    // the condition, or its contents, is dynamic
                    is_dynamic = true;
                    block.add_dependencies(branch.block.dependencies);
                }
                if (branch.dependencies && branch.dependencies.length > 0) // the condition itself is dynamic
                this.needs_update = true;
                if (branch.block.has_intros) has_intros = true;
                if (branch.block.has_outros) has_outros = true;
                if (is_else_if(node.else)) create_branches(/** @type {import('../../nodes/IfBlock.js').default} */ node.else.children[0]);
                else if (node.else) {
                    const branch = new IfBlockBranch(renderer, block, this, node.else, strip_whitespace, next_sibling);
                    this.branches.push(branch);
                    blocks.push(branch.block);
                    if (branch.block.dependencies.size > 0) {
                        is_dynamic = true;
                        block.add_dependencies(branch.block.dependencies);
                    }
                    if (branch.block.has_intros) has_intros = true;
                    if (branch.block.has_outros) has_outros = true;
                }
            };
            create_branches(this.node);
            blocks.forEach((block)=>{
                block.has_update_method = is_dynamic;
                block.has_intro_method = has_intros;
                block.has_outro_method = has_outros;
            });
            push_array(renderer.blocks, blocks);
        }
        /**
	 * @param {import('../Block.js').default} block
	 * @param {import('estree').Identifier} parent_node
	 * @param {import('estree').Identifier} parent_nodes
	 */ render(block, parent_node, parent_nodes) {
            const name = this.var;
            const needs_anchor = this.next ? !this.next.is_dom_node() : !parent_node || !this.parent.is_dom_node();
            const anchor = needs_anchor ? block.get_unique_name(`${this.var.name}_anchor`) : this.next && this.next.var || "null";
            const has_else = !this.branches[this.branches.length - 1].condition;
            const if_exists_condition = has_else ? null : name;
            const dynamic = this.branches[0].block.has_update_method; // can use [0] as proxy for all, since they necessarily have the same value
            const has_intros = this.branches[0].block.has_intro_method;
            const has_outros = this.branches[0].block.has_outro_method;
            const has_transitions = has_intros || has_outros;
            this.branches.forEach((branch)=>{
                if (branch.get_ctx_name) this.renderer.blocks.push(b$1`
				function ${branch.get_ctx_name}(#ctx) {
					const child_ctx = #ctx.slice();
					${add_const_tags(block, branch.node.const_tags, "child_ctx")}
					return child_ctx;
				}
				`);
            });
            const vars = {
                name: name,
                anchor: anchor,
                if_exists_condition: if_exists_condition,
                has_else: has_else,
                has_transitions: has_transitions
            };
            /** @type {DetachingOrNull} */ const detaching = parent_node && !is_head(parent_node) ? null : "detaching";
            if (this.node.else) {
                this.branches.forEach((branch)=>{
                    if (branch.snippet) block.add_variable(branch.condition);
                });
                if (has_outros) {
                    this.render_compound_with_outros(block, parent_node, parent_nodes, dynamic, vars, detaching);
                    block.chunks.outro.push(b$1`@transition_out(${name});`);
                } else this.render_compound(block, parent_node, parent_nodes, dynamic, vars, detaching);
            } else {
                this.render_simple(block, parent_node, parent_nodes, dynamic, vars, detaching);
                if (has_outros) block.chunks.outro.push(b$1`@transition_out(${name});`);
            }
            if (if_exists_condition) block.chunks.create.push(b$1`if (${if_exists_condition}) ${name}.c();`);
            else block.chunks.create.push(b$1`${name}.c();`);
            if (parent_nodes && this.renderer.options.hydratable) {
                if (if_exists_condition) block.chunks.claim.push(b$1`if (${if_exists_condition}) ${name}.l(${parent_nodes});`);
                else block.chunks.claim.push(b$1`${name}.l(${parent_nodes});`);
            }
            if (has_intros || has_outros) block.chunks.intro.push(b$1`@transition_in(${name});`);
            if (needs_anchor) block.add_element(/** @type {import('estree').Identifier} */ anchor, x$1`@empty()`, parent_nodes && x$1`@empty()`, parent_node);
            this.branches.forEach((branch)=>{
                branch.fragment.render(branch.block, null, /** @type {unknown} */ /** @type {import('estree').Identifier} */ x$1`#nodes`);
            });
        }
        /**
	 * @param {import('../Block.js').default} block
	 * @param {import('estree').Identifier} parent_node
	 * @param {import('estree').Identifier} _parent_nodes
	 * @param {boolean} dynamic
	 * @param {any} opts
	 * @param {DetachingOrNull} detaching
	 */ render_compound(block, parent_node, _parent_nodes, dynamic, { name: name, anchor: anchor, has_else: has_else, if_exists_condition: if_exists_condition, has_transitions: has_transitions }, detaching) {
            const select_block_type = this.renderer.component.get_unique_name("select_block_type");
            const current_block_type = block.get_unique_name("current_block_type");
            const need_select_block_ctx = this.branches.some((branch)=>branch.get_ctx_name);
            const select_block_ctx = need_select_block_ctx ? block.get_unique_name("select_block_ctx") : null;
            const if_ctx = select_block_ctx ? x$1`${select_block_ctx}(#ctx, ${current_block_type})` : x$1`#ctx`;
            const get_block = has_else ? x$1`${current_block_type}(${if_ctx})` : x$1`${current_block_type} && ${current_block_type}(${if_ctx})`;
            if (this.needs_update) block.chunks.init.push(b$1`
				function ${select_block_type}(#ctx, #dirty) {
					${this.branches.map(({ dependencies: dependencies, condition: condition, snippet: snippet })=>{
                return b$1`${snippet && dependencies.length > 0 ? b$1`if (${block.renderer.dirty(dependencies)}) ${condition} = null;` : null}`;
            })}
					${this.branches.map(({ condition: condition, snippet: snippet, block: block })=>condition ? b$1`
								${snippet && b$1`if (${condition} == null) ${condition} = !!${snippet}`}
								if (${condition}) return ${block.name};` : b$1`return ${block.name};`)}
				}
			`);
            else block.chunks.init.push(b$1`
				function ${select_block_type}(#ctx, #dirty) {
					${this.branches.map(({ condition: condition, snippet: snippet, block: block })=>condition ? b$1`if (${snippet || condition}) return ${block.name};` : b$1`return ${block.name};`)}
				}
			`);
            if (need_select_block_ctx) {
                // if all branches needs create a context
                if (this.branches.every((branch)=>branch.get_ctx_name)) block.chunks.init.push(b$1`
					function ${select_block_ctx}(#ctx, #type) {
						${this.branches.map(({ condition: condition, get_ctx_name: get_ctx_name, block: block })=>{
                    return condition ? b$1`if (#type === ${block.name}) return ${get_ctx_name}(#ctx);` : b$1`return ${get_ctx_name}(#ctx);`;
                }).filter(Boolean)}
					}
				`);
                else // when not all branches need to create a new context,
                // this code is simpler
                block.chunks.init.push(b$1`
					function ${select_block_ctx}(#ctx, #type) {
						${this.branches.map(({ get_ctx_name: get_ctx_name, block: block })=>{
                    return get_ctx_name ? b$1`if (#type === ${block.name}) return ${get_ctx_name}(#ctx);` : null;
                }).filter(Boolean)}
						return #ctx;
					}
				`);
            }
            block.chunks.init.push(b$1`
			let ${current_block_type} = ${select_block_type}(#ctx, ${this.renderer.get_initial_dirty()});
			let ${name} = ${get_block};
		`);
            const initial_mount_node = parent_node || "#target";
            const anchor_node = parent_node ? "null" : "#anchor";
            if (if_exists_condition) block.chunks.mount.push(b$1`if (${if_exists_condition}) ${name}.m(${initial_mount_node}, ${anchor_node});`);
            else block.chunks.mount.push(b$1`${name}.m(${initial_mount_node}, ${anchor_node});`);
            if (this.needs_update) {
                const update_mount_node = this.get_update_mount_node(anchor);
                const change_block = b$1`
				${if_exists_condition ? b$1`if (${if_exists_condition}) ${name}.d(1)` : b$1`${name}.d(1)`};
				${name} = ${get_block};
				if (${name}) {
					${name}.c();
					${has_transitions && b$1`@transition_in(${name}, 1);`}
					${name}.m(${update_mount_node}, ${anchor});
				}
			`;
                if (dynamic) block.chunks.update.push(b$1`
					if (${current_block_type} === (${current_block_type} = ${select_block_type}(#ctx, #dirty)) && ${name}) {
						${name}.p(${if_ctx}, #dirty);
					} else {
						${change_block}
					}
				`);
                else block.chunks.update.push(b$1`
					if (${current_block_type} !== (${current_block_type} = ${select_block_type}(#ctx, #dirty))) {
						${change_block}
					}
				`);
            } else if (dynamic) {
                if (if_exists_condition) block.chunks.update.push(b$1`if (${if_exists_condition}) ${name}.p(${if_ctx}, #dirty);`);
                else block.chunks.update.push(b$1`${name}.p(${if_ctx}, #dirty);`);
            }
            if (if_exists_condition) block.chunks.destroy.push(b$1`
				if (${if_exists_condition}) {
					${name}.d(${detaching});
				}
			`);
            else block.chunks.destroy.push(b$1`
				${name}.d(${detaching});
			`);
        }
        // if any of the siblings have outros, we need to keep references to the blocks
        // (TODO does this only apply to bidi transitions?)
        /**
	 * @param {import('../Block.js').default} block
	 * @param {import('estree').Identifier} parent_node
	 * @param {import('estree').Identifier} _parent_nodes
	 * @param {boolean} dynamic
	 * @param {any} opts
	 * @param {DetachingOrNull} detaching
	 */ render_compound_with_outros(block, parent_node, _parent_nodes, dynamic, { name: name, anchor: anchor, has_else: has_else, has_transitions: has_transitions, if_exists_condition: if_exists_condition }, detaching) {
            const select_block_type = this.renderer.component.get_unique_name("select_block_type");
            const current_block_type_index = block.get_unique_name("current_block_type_index");
            const previous_block_index = block.get_unique_name("previous_block_index");
            const if_block_creators = block.get_unique_name("if_block_creators");
            const if_blocks = block.get_unique_name("if_blocks");
            const need_select_block_ctx = this.branches.some((branch)=>branch.get_ctx_name);
            const select_block_ctx = need_select_block_ctx ? block.get_unique_name("select_block_ctx") : null;
            const if_ctx = select_block_ctx ? x$1`${select_block_ctx}(#ctx, ${current_block_type_index})` : x$1`#ctx`;
            const if_current_block_type_index = has_else ? (nodes)=>nodes : (nodes)=>b$1`if (~${current_block_type_index}) { ${nodes} }`;
            block.add_variable(current_block_type_index);
            block.add_variable(name);
            block.chunks.init.push(b$1`
			const ${if_block_creators} = [
				${this.branches.map((branch)=>branch.block.name)}
			];

			const ${if_blocks} = [];

			${this.needs_update ? b$1`
					function ${select_block_type}(#ctx, #dirty) {
						${this.branches.map(({ dependencies: dependencies, condition: condition, snippet: snippet })=>{
                return b$1`${snippet && dependencies.length > 0 ? b$1`if (${block.renderer.dirty(dependencies)}) ${condition} = null;` : null}`;
            })}
						${this.branches.map(({ condition: condition, snippet: snippet }, i)=>condition ? b$1`
								${snippet && b$1`if (${condition} == null) ${condition} = !!${snippet}`}
								if (${condition}) return ${i};` : b$1`return ${i};`)}
								${!has_else && b$1`return -1;`}
							}
						` : b$1`
					function ${select_block_type}(#ctx, #dirty) {
						${this.branches.map(({ condition: condition, snippet: snippet }, i)=>condition ? b$1`if (${snippet || condition}) return ${i};` : b$1`return ${i};`)}
						${!has_else && b$1`return -1;`}
					}
				`}
		`);
            if (need_select_block_ctx) {
                // if all branches needs create a context
                if (this.branches.every((branch)=>branch.get_ctx_name)) block.chunks.init.push(b$1`
					function ${select_block_ctx}(#ctx, #index) {
						${this.branches.map(({ condition: condition, get_ctx_name: get_ctx_name }, i)=>{
                    return condition ? b$1`if (#index === ${i}) return ${get_ctx_name}(#ctx);` : b$1`return ${get_ctx_name}(#ctx);`;
                }).filter(Boolean)}
					}
				`);
                else // when not all branches need to create a new context,
                // this code is simpler
                block.chunks.init.push(b$1`
					function ${select_block_ctx}(#ctx, #index) {
						${this.branches.map(({ get_ctx_name: get_ctx_name }, i)=>{
                    return get_ctx_name ? b$1`if (#index === ${i}) return ${get_ctx_name}(#ctx);` : null;
                }).filter(Boolean)}
						return #ctx;
					}
				`);
            }
            if (has_else) block.chunks.init.push(b$1`
				${current_block_type_index} = ${select_block_type}(#ctx, ${this.renderer.get_initial_dirty()});
				${name} = ${if_blocks}[${current_block_type_index}] = ${if_block_creators}[${current_block_type_index}](${if_ctx});
			`);
            else block.chunks.init.push(b$1`
				if (~(${current_block_type_index} = ${select_block_type}(#ctx, ${this.renderer.get_initial_dirty()}))) {
					${name} = ${if_blocks}[${current_block_type_index}] = ${if_block_creators}[${current_block_type_index}](${if_ctx});
				}
			`);
            const initial_mount_node = parent_node || "#target";
            const anchor_node = parent_node ? "null" : "#anchor";
            block.chunks.mount.push(if_current_block_type_index(b$1`${if_blocks}[${current_block_type_index}].m(${initial_mount_node}, ${anchor_node});`));
            if (this.needs_update) {
                const update_mount_node = this.get_update_mount_node(anchor);
                const destroy_old_block = b$1`
				@group_outros();
				@transition_out(${if_blocks}[${previous_block_index}], 1, 1, () => {
					${if_blocks}[${previous_block_index}] = null;
				});
				@check_outros();
			`;
                const create_new_block = b$1`
				${name} = ${if_blocks}[${current_block_type_index}];
				if (!${name}) {
					${name} = ${if_blocks}[${current_block_type_index}] = ${if_block_creators}[${current_block_type_index}](${if_ctx});
					${name}.c();
				} else {
					${dynamic && b$1`${name}.p(${if_ctx}, #dirty);`}
				}
				${has_transitions && b$1`@transition_in(${name}, 1);`}
				${name}.m(${update_mount_node}, ${anchor});
			`;
                const change_block = has_else ? b$1`
					${destroy_old_block}

					${create_new_block}
				` : b$1`
					if (${name}) {
						${destroy_old_block}
					}

					if (~${current_block_type_index}) {
						${create_new_block}
					} else {
						${name} = null;
					}
				`;
                block.chunks.update.push(b$1`
				let ${previous_block_index} = ${current_block_type_index};
				${current_block_type_index} = ${select_block_type}(#ctx, #dirty);
			`);
                if (dynamic) block.chunks.update.push(b$1`
					if (${current_block_type_index} === ${previous_block_index}) {
						${if_current_block_type_index(b$1`${if_blocks}[${current_block_type_index}].p(${if_ctx}, #dirty);`)}
					} else {
						${change_block}
					}
				`);
                else block.chunks.update.push(b$1`
					if (${current_block_type_index} !== ${previous_block_index}) {
						${change_block}
					}
				`);
            } else if (dynamic) {
                if (if_exists_condition) block.chunks.update.push(b$1`if (${if_exists_condition}) ${name}.p(${if_ctx}, #dirty);`);
                else block.chunks.update.push(b$1`${name}.p(${if_ctx}, #dirty);`);
            }
            block.chunks.destroy.push(if_current_block_type_index(b$1`${if_blocks}[${current_block_type_index}].d(${detaching});`));
        }
        /**
	 * @param {import('../Block.js').default} block
	 * @param {import('estree').Identifier} parent_node
	 * @param {import('estree').Identifier} _parent_nodes
	 * @param {boolean} dynamic
	 * @param {any} opts
	 * @param {DetachingOrNull} detaching
	 */ render_simple(block, parent_node, _parent_nodes, dynamic, { name: name, anchor: anchor, if_exists_condition: if_exists_condition, has_transitions: has_transitions }, detaching) {
            const branch = this.branches[0];
            const if_ctx = branch.get_ctx_name ? x$1`${branch.get_ctx_name}(#ctx)` : x$1`#ctx`;
            if (branch.snippet) block.add_variable(branch.condition, branch.snippet);
            block.chunks.init.push(b$1`
			let ${name} = ${branch.condition} && ${branch.block.name}(${if_ctx});
		`);
            const initial_mount_node = parent_node || "#target";
            const anchor_node = parent_node ? "null" : "#anchor";
            block.chunks.mount.push(b$1`if (${name}) ${name}.m(${initial_mount_node}, ${anchor_node});`);
            if (branch.dependencies.length > 0) {
                const update_mount_node = this.get_update_mount_node(anchor);
                const enter = b$1`
				if (${name}) {
					${dynamic && b$1`${name}.p(${if_ctx}, #dirty);`}
					${has_transitions && b$1`if (${block.renderer.dirty(branch.dependencies)}) {
									@transition_in(${name}, 1);
								}`}
				} else {
					${name} = ${branch.block.name}(${if_ctx});
					${name}.c();
					${has_transitions && b$1`@transition_in(${name}, 1);`}
					${name}.m(${update_mount_node}, ${anchor});
				}
			`;
                if (branch.snippet) block.chunks.update.push(b$1`if (${block.renderer.dirty(branch.dependencies)}) ${branch.condition} = ${branch.snippet}`);
                // no `p()` here — we don't want to update outroing nodes,
                // as that will typically result in glitching
                if (branch.block.has_outro_method) block.chunks.update.push(b$1`
					if (${branch.condition}) {
						${enter}
					} else if (${name}) {
						@group_outros();
						@transition_out(${name}, 1, 1, () => {
							${name} = null;
						});
						@check_outros();
					}
				`);
                else block.chunks.update.push(b$1`
					if (${branch.condition}) {
						${enter}
					} else if (${name}) {
						${name}.d(1);
						${name} = null;
					}
				`);
            } else if (dynamic) block.chunks.update.push(b$1`
				if (${branch.condition}) ${name}.p(${if_ctx}, #dirty);
			`);
            if (if_exists_condition) block.chunks.destroy.push(b$1`
				if (${if_exists_condition}) ${name}.d(${detaching});
			`);
            else block.chunks.destroy.push(b$1`
				${name}.d(${detaching});
			`);
        }
    }
    /** @extends Wrapper<import('../../nodes/KeyBlock.js').default> */ class KeyBlockWrapper extends Wrapper {
        /** @type {import('./Fragment.js').default} */ fragment;
        /** @type {import('../Block.js').default} */ block;
        /** @type {string[]} */ dependencies;
        /** @type {import('estree').Identifier} */ var = {
            type: "Identifier",
            name: "key_block"
        };
        /**
	 * @param {import('../Renderer.js').default} renderer
	 * @param {import('../Block.js').default} block
	 * @param {import('./shared/Wrapper.js').default} parent
	 * @param {import('../../nodes/KeyBlock.js').default} node
	 * @param {boolean} strip_whitespace
	 * @param {import('./shared/Wrapper.js').default} next_sibling
	 */ constructor(renderer, block, parent, node, strip_whitespace, next_sibling){
            super(renderer, block, parent, node);
            this.dependencies = node.expression.dynamic_dependencies();
            if (this.dependencies.length) {
                block = block.child({
                    comment: create_debugging_comment(node, renderer.component),
                    name: renderer.component.get_unique_name("create_key_block"),
                    type: "key"
                });
                block.add_dependencies(node.expression.dependencies);
                renderer.blocks.push(block);
            }
            this.block = block;
            this.fragment = new FragmentWrapper(renderer, this.block, node.children, this, strip_whitespace, next_sibling);
        }
        /**
	 * @param {import('../Block.js').default} block
	 * @param {import('estree').Identifier} parent_node
	 * @param {import('estree').Identifier} parent_nodes
	 */ render(block, parent_node, parent_nodes) {
            if (this.dependencies.length === 0) this.render_static_key(block, parent_node, parent_nodes);
            else this.render_dynamic_key(block, parent_node, parent_nodes);
        }
        /**
	 * @param {import('../Block.js').default} _block
	 * @param {import('estree').Identifier} parent_node
	 * @param {import('estree').Identifier} parent_nodes
	 */ render_static_key(_block, parent_node, parent_nodes) {
            this.fragment.render(this.block, parent_node, parent_nodes);
        }
        /**
	 * @param {import('../Block.js').default} block
	 * @param {import('estree').Identifier} parent_node
	 * @param {import('estree').Identifier} parent_nodes
	 */ render_dynamic_key(block, parent_node, parent_nodes) {
            this.fragment.render(this.block, null, /** @type {unknown} */ /** @type {import('estree').Identifier} */ x$1`#nodes`);
            const has_transitions = !!(this.block.has_intro_method || this.block.has_outro_method);
            const dynamic = this.block.has_update_method;
            const previous_key = block.get_unique_name("previous_key");
            const snippet = this.node.expression.manipulate(block);
            block.add_variable(previous_key, snippet);
            const not_equal = this.renderer.component.component_options.immutable ? x$1`@not_equal` : x$1`@safe_not_equal`;
            const condition = x$1`${this.renderer.dirty(this.dependencies)} && ${not_equal}(${previous_key}, ${previous_key} = ${snippet})`;
            block.chunks.init.push(b$1`
			let ${this.var} = ${this.block.name}(#ctx);
		`);
            block.chunks.create.push(b$1`${this.var}.c();`);
            if (this.renderer.options.hydratable) block.chunks.claim.push(b$1`${this.var}.l(${parent_nodes});`);
            block.chunks.mount.push(b$1`${this.var}.m(${parent_node || "#target"}, ${parent_node ? "null" : "#anchor"});`);
            const anchor = this.get_or_create_anchor(block, parent_node, parent_nodes);
            const body = b$1`
			${has_transitions ? b$1`
						@group_outros();
						@transition_out(${this.var}, 1, 1, @noop);
						@check_outros();
					` : b$1`${this.var}.d(1);`}
			${this.var} = ${this.block.name}(#ctx);
			${this.var}.c();
			${has_transitions && b$1`@transition_in(${this.var}, 1)`}
			${this.var}.m(${this.get_update_mount_node(anchor)}, ${anchor});
		`;
            if (dynamic) block.chunks.update.push(b$1`
				if (${condition}) {
					${body}
				} else {
					${this.var}.p(#ctx, #dirty);
				}
			`);
            else block.chunks.update.push(b$1`
				if (${condition}) {
					${body}
				}
			`);
            if (has_transitions) {
                block.chunks.intro.push(b$1`@transition_in(${this.var})`);
                block.chunks.outro.push(b$1`@transition_out(${this.var})`);
            }
            block.chunks.destroy.push(b$1`${this.var}.d(detaching)`);
        }
    }
    /**
 * @param {string} name
 */ function string_to_member_expression(name) {
        const parts = name.split(".");
        /** @type {import('estree').MemberExpression | import('estree').Identifier} */ let node = {
            type: "Identifier",
            name: parts[0]
        };
        for(let i = 1; i < parts.length; i++)node = /** @type {import('estree').MemberExpression} */ {
            type: "MemberExpression",
            object: node,
            property: {
                type: "Identifier",
                name: parts[i]
            }
        };
        return node;
    }
    /**
 * @param {import('../../Block.js').default} block
 * @param {import('../../../nodes/shared/TemplateScope.js').default} scope
 * @param {import('../../../nodes/Let.js').default[]} lets
 */ function get_slot_definition(block, scope, lets) {
        if (lets.length === 0) return {
            block: block,
            scope: scope
        };
        const context_input = {
            type: "ObjectPattern",
            properties: lets.map((l)=>({
                    type: "Property",
                    kind: "init",
                    key: l.name,
                    value: l.value || l.name
                }))
        };
        const properties = [];
        const value_map = new Map();
        lets.forEach((l)=>{
            /** @type {import('estree').Identifier} */ let value;
            if (l.names.length > 1) {
                // more than one, probably destructuring
                const unique_name = block.get_unique_name(l.names.join("_")).name;
                value_map.set(l.value, unique_name);
                value = {
                    type: "Identifier",
                    name: unique_name
                };
            } else value = l.value || l.name;
            properties.push({
                type: "Property",
                kind: "init",
                key: l.name,
                value: value
            });
        });
        const changes_input = {
            type: "ObjectPattern",
            properties: properties
        };
        /** @type {Set<string>} */ const names = new Set();
        /** @type {Map<string, string>} */ const names_lookup = new Map();
        lets.forEach((l)=>{
            l.names.forEach((name)=>{
                names.add(name);
                if (value_map.has(l.value)) names_lookup.set(name, value_map.get(l.value));
            });
        });
        const context = {
            type: "ObjectExpression",
            properties: Array.from(names).map((name)=>p`${block.renderer.context_lookup.get(name).index}: ${name}`)
        };
        const { context_lookup: context_lookup } = block.renderer;
        // i am well aware that this code is gross
        // TODO: context-overflow make it less gross
        const changes = {
            type: "ParenthesizedExpression",
            get expression () {
                if (block.renderer.context_overflow) {
                    const grouped = [];
                    Array.from(names).forEach((name)=>{
                        const i = /** @type {number} */ context_lookup.get(name).index.value;
                        const g = Math.floor(i / 31);
                        const lookup_name = names_lookup.has(name) ? names_lookup.get(name) : name;
                        if (!grouped[g]) grouped[g] = [];
                        grouped[g].push({
                            name: lookup_name,
                            n: i % 31
                        });
                    });
                    const elements = [];
                    for(let g = 0; g < grouped.length; g += 1)elements[g] = grouped[g] ? grouped[g].map(({ name: name, n: n })=>x$1`${name} ? ${1 << n} : 0`).reduce((lhs, rhs)=>x$1`${lhs} | ${rhs}`) : x$1`0`;
                    return {
                        type: "ArrayExpression",
                        elements: elements
                    };
                }
                return /** @type {import('estree').BinaryExpression} */ Array.from(names).map((name)=>{
                    const lookup_name = names_lookup.has(name) ? names_lookup.get(name) : name;
                    const i = /** @type {number} */ context_lookup.get(name).index.value;
                    return x$1`${lookup_name} ? ${1 << i} : 0`;
                }).reduce((lhs, rhs)=>x$1`${lhs} | ${rhs}`);
            }
        };
        return {
            block: block,
            scope: scope,
            get_context: x$1`${context_input} => ${context}`,
            get_changes: x$1`${changes_input} => ${changes}`
        };
    }
    /** @extends Wrapper<import('../../nodes/SlotTemplate.js').default> */ class SlotTemplateWrapper extends Wrapper {
        /** @type {import('./Fragment.js').default} */ fragment;
        /** @type {import('../Block.js').default} */ block;
        /**
	 * @param {import('../Renderer.js').default} renderer
	 * @param {import('../Block.js').default} block
	 * @param {import('./shared/Wrapper.js').default} parent
	 * @param {import('../../nodes/SlotTemplate.js').default} node
	 * @param {boolean} strip_whitespace
	 * @param {import('./shared/Wrapper.js').default} next_sibling
	 */ constructor(renderer, block, parent, node, strip_whitespace, next_sibling){
            super(renderer, block, parent, node);
            const { scope: scope, lets: lets, const_tags: const_tags, slot_template_name: slot_template_name } = this.node;
            lets.forEach((l)=>{
                extract_names(l.value || l.name).forEach((name)=>{
                    renderer.add_to_context(name, true);
                });
            });
            add_const_tags_context(renderer, const_tags);
            this.block = block.child({
                comment: create_debugging_comment(this.node, this.renderer.component),
                name: this.renderer.component.get_unique_name(`create_${sanitize(slot_template_name)}_slot`),
                type: "slot"
            });
            this.renderer.blocks.push(this.block);
            /** @type {import('./InlineComponent/index.js').default} */ this.parent.set_slot(slot_template_name, get_slot_definition(this.block, scope, lets));
            this.fragment = new FragmentWrapper(renderer, this.block, node.type === "SlotTemplate" ? node.children : [
                node
            ], this, strip_whitespace, next_sibling);
            this.block.parent.add_dependencies(this.block.dependencies);
        }
        render() {
            this.fragment.render(this.block, null, /** @type {import('estree').Identifier} */ x$1`#nodes`);
            if (this.node.const_tags.length > 0) this.render_get_context();
        }
        render_get_context() {
            const get_context = this.block.renderer.component.get_unique_name("get_context");
            this.block.renderer.blocks.push(b$1`
			function ${get_context}(#ctx) {
				${add_const_tags(this.block, this.node.const_tags, "#ctx")}
			}
		`);
            this.block.chunks.declarations.push(b$1`${get_context}(#ctx)`);
            if (this.block.has_update_method) this.block.chunks.update.unshift(b$1`${get_context}(#ctx)`);
        }
    }
    const regex_invalid_variable_identifier_characters = /[^a-zA-Z_$]/g;
    /** @extends Wrapper<import('../../../nodes/InlineComponent.js').default> */ class InlineComponentWrapper extends Wrapper {
        /**
	 * @typedef {{
	 * 	block: import('../../Block.js').default;
	 * 	scope: import('../../../nodes/shared/TemplateScope.js').default;
	 * 	get_context?: import('estree').Node;
	 * 	get_changes?: import('estree').Node;
	 * }} SlotDefinition
	 */ /** @type {Map<string, SlotDefinition>} */ slots = new Map();
        /** @type {import('../Fragment.js').default} */ fragment;
        /** @type {Array<Wrapper | import('../Fragment.js').default>} */ children = [];
        /**
	 * @param {import('../../Renderer.js').default} renderer
	 * @param {import('../../Block.js').default} block
	 * @param {import('../shared/Wrapper.js').default} parent
	 * @param {import('../../../nodes/InlineComponent.js').default} node
	 * @param {boolean} strip_whitespace
	 * @param {import('../shared/Wrapper.js').default} next_sibling
	 */ constructor(renderer, block, parent, node, strip_whitespace, next_sibling){
            super(renderer, block, parent, node);
            if (this.node.expression) block.add_dependencies(this.node.expression.dependencies);
            this.node.attributes.forEach((attr)=>{
                block.add_dependencies(attr.dependencies);
            });
            this.node.bindings.forEach((binding)=>{
                if (binding.is_contextual) mark_each_block_bindings(this, binding);
                block.add_dependencies(binding.expression.dependencies);
            });
            this.node.handlers.forEach((handler)=>{
                if (handler.expression) block.add_dependencies(handler.expression.dependencies);
            });
            this.node.css_custom_properties.forEach((attr)=>{
                block.add_dependencies(attr.dependencies);
            });
            this.var = {
                type: /** @type {const} */ "Identifier",
                name: (this.node.name === "svelte:self" ? renderer.component.name.name : this.node.name === "svelte:component" ? "switch_instance" : sanitize(this.node.name)).toLowerCase()
            };
            if (this.node.children.length) this.children = this.node.children.map((child)=>new SlotTemplateWrapper(renderer, block, this, /** @type {import('../../../nodes/SlotTemplate.js').default} */ child, strip_whitespace, next_sibling));
            block.add_outro();
        }
        /**
	 * @param {string} name
	 * @param {SlotDefinition} slot_definition
	 */ set_slot(name, slot_definition) {
            if (this.slots.has(name)) {
                if (name === "default") throw new Error('Found elements without slot attribute when using slot="default"');
                throw new Error(`Duplicate slot name "${name}" in <${this.node.name}>`);
            }
            this.slots.set(name, slot_definition);
        }
        warn_if_reactive() {
            let { name: name } = this.node;
            const top = name.split(".")[0]; // <T.foo/> etc. should check for T instead of "T.foo"
            const variable = this.renderer.component.var_lookup.get(top);
            if (!variable) return;
            const ignores = extract_ignores_above_node(this.node);
            this.renderer.component.push_ignores(ignores);
            if (variable.reassigned || variable.export_name || // or a prop
            variable.mutated) this.renderer.component.warn(this.node, compiler_warnings.reactive_component(name));
            this.renderer.component.pop_ignores();
        }
        /**
	 * @param {import('../../Block.js').default} block
	 * @param {import('estree').Identifier} parent_node
	 * @param {import('estree').Identifier} parent_nodes
	 */ render(block, parent_node, parent_nodes) {
            this.warn_if_reactive();
            const { renderer: renderer } = this;
            const { component: component } = renderer;
            const name = this.var;
            block.add_variable(name);
            const component_opts = /** @type {import('estree').ObjectExpression} */ x$1`{}`;
            /** @type {Array<import('estree').Node | import('estree').Node[]>} */ const statements = [];
            /** @type {Array<import('estree').Node | import('estree').Node[]>} */ const updates = [];
            this.children.forEach((child)=>{
                this.renderer.add_to_context("$$scope", true);
                child.render(block, null, /** @type {import('estree').Identifier} */ x$1`#nodes`);
            });
            /** @type {import('estree').Identifier | undefined} */ let props;
            const name_changes = block.get_unique_name(`${name.name}_changes`);
            const uses_spread = !!this.node.attributes.find((a)=>a.is_spread);
            // removing empty slot
            for (const slot of this.slots.keys())if (!this.slots.get(slot).block.has_content()) {
                this.renderer.remove_block(this.slots.get(slot).block);
                this.slots.delete(slot);
            }
            const has_css_custom_properties = this.node.css_custom_properties.length > 0;
            const is_svg_namespace = this.node.namespace === namespaces.svg;
            const css_custom_properties_wrapper_element = is_svg_namespace ? "g" : "div";
            const css_custom_properties_wrapper = has_css_custom_properties ? block.get_unique_name(css_custom_properties_wrapper_element) : null;
            if (has_css_custom_properties) block.add_variable(css_custom_properties_wrapper);
            const initial_props = this.slots.size > 0 ? [
                p`$$slots: {
					${Array.from(this.slots).map(([name, slot])=>{
                    return p`${name}: [${slot.block.name}, ${slot.get_context || null}, ${slot.get_changes || null}]`;
                })}
				}`,
                p`$$scope: {
					ctx: #ctx
				}`
            ] : [];
            const attribute_object = uses_spread ? x$1`{ ${initial_props} }` : x$1`{
				${this.node.attributes.map((attr)=>p`${attr.name}: ${attr.get_value(block)}`)},
				${initial_props}
			}`;
            if (this.node.attributes.length || this.node.bindings.length || initial_props.length) {
                if (!uses_spread && this.node.bindings.length === 0) component_opts.properties.push(p`props: ${attribute_object}`);
                else {
                    props = block.get_unique_name(`${name.name}_props`);
                    component_opts.properties.push(p`props: ${props}`);
                }
            }
            if (component.compile_options.dev) // TODO this is a terrible hack, but without it the component
            // will complain that options.target is missing. This would
            // work better if components had separate public and private
            // APIs
            component_opts.properties.push(p`$$inline: true`);
            const fragment_dependencies = new Set(this.slots.size ? [
                "$$scope"
            ] : []);
            this.slots.forEach((slot)=>{
                slot.block.dependencies.forEach((name)=>{
                    const is_let = slot.scope.is_let(name);
                    const variable = renderer.component.var_lookup.get(name);
                    if (is_let || is_dynamic$1(variable)) fragment_dependencies.add(name);
                });
            });
            const dynamic_attributes = this.node.attributes.filter((a)=>a.get_dependencies().length > 0);
            if (!uses_spread && (dynamic_attributes.length > 0 || this.node.bindings.length > 0 || fragment_dependencies.size > 0)) updates.push(b$1`const ${name_changes} = {};`);
            if (this.node.attributes.length) {
                if (uses_spread) {
                    const levels = block.get_unique_name(`${this.var.name}_spread_levels`);
                    const initial_props = [];
                    const changes = [];
                    /** @type {Set<string>} */ const all_dependencies = new Set();
                    this.node.attributes.forEach((attr)=>{
                        add_to_set(all_dependencies, attr.dependencies);
                    });
                    this.node.attributes.forEach((attr, i)=>{
                        const { name: name, dependencies: dependencies } = attr;
                        const condition = dependencies.size > 0 && dependencies.size !== all_dependencies.size ? renderer.dirty(Array.from(dependencies)) : null;
                        const unchanged = dependencies.size === 0;
                        /** @type {import('estree').Node | ReturnType<typeof x>} */ let change_object;
                        if (attr.is_spread) {
                            const value = attr.expression.manipulate(block);
                            initial_props.push(value);
                            let value_object = value;
                            if (attr.expression.node.type !== "ObjectExpression") value_object = x$1`@get_spread_object(${value})`;
                            change_object = value_object;
                        } else {
                            const obj = x$1`{ ${name}: ${attr.get_value(block)} }`;
                            initial_props.push(obj);
                            change_object = obj;
                        }
                        changes.push(unchanged ? x$1`${levels}[${i}]` : condition ? x$1`${condition} && ${change_object}` : change_object);
                    });
                    block.chunks.init.push(b$1`
					const ${levels} = [
						${initial_props}
					];
				`);
                    statements.push(b$1`
					for (let #i = 0; #i < ${levels}.length; #i += 1) {
						${props} = @assign(${props}, ${levels}[#i]);
					}
				`);
                    if (all_dependencies.size) {
                        const condition = renderer.dirty(Array.from(all_dependencies));
                        if (this.node.name === "svelte:component") // statements will become switch_props function body
                        // rewrite last statement, add props update logic
                        statements[statements.length - 1] = b$1`
							for (let #i = 0; #i < ${levels}.length; #i += 1) {
								${props} = @assign(${props}, ${levels}[#i]);
							}
							if (#dirty !== undefined && ${condition}) {
								${props} = @assign(${props}, @get_spread_update(${levels}, [
									${changes}
								]));
							}
						`;
                        updates.push(b$1`
						const ${name_changes} = ${condition} ? @get_spread_update(${levels}, [
							${changes}
						]) : {}
					`);
                    } else updates.push(b$1`
						const ${name_changes} = {};
					`);
                } else dynamic_attributes.forEach((attribute)=>{
                    const dependencies = attribute.get_dependencies();
                    if (dependencies.length > 0) {
                        const condition = renderer.dirty(dependencies);
                        updates.push(b$1`
							if (${condition}) ${name_changes}.${attribute.name} = ${attribute.get_value(block)};
						`);
                    }
                });
            }
            if (fragment_dependencies.size > 0) updates.push(b$1`
				if (${renderer.dirty(Array.from(fragment_dependencies))}) {
					${name_changes}.$$scope = { dirty: #dirty, ctx: #ctx };
				}`);
            const munged_bindings = this.node.bindings.map((binding)=>{
                component.has_reactive_assignments = true;
                if (binding.name === "this") return bind_this(component, block, new BindingWrapper(block, binding, this), this.var);
                const id = component.get_unique_name(`${this.var.name}_${binding.name}_binding`);
                renderer.add_to_context(id.name);
                const callee = renderer.reference(id);
                const updating = block.get_unique_name(`updating_${binding.name}`);
                block.add_variable(updating);
                const snippet = binding.expression.manipulate(block);
                statements.push(b$1`
				if (${snippet} !== void 0) {
					${props}.${binding.name} = ${snippet};
				}`);
                updates.push(b$1`
				if (!${updating} && ${renderer.dirty(Array.from(binding.expression.dependencies))}) {
					${updating} = true;
					${name_changes}.${binding.name} = ${snippet};
					@add_flush_callback(() => ${updating} = false);
				}
			`);
                const contextual_dependencies = Array.from(binding.expression.contextual_dependencies);
                const dependencies = Array.from(binding.expression.dependencies);
                let lhs = binding.raw_expression;
                if (binding.is_contextual && binding.expression.node.type === "Identifier") {
                    // bind:x={y} — we can't just do `y = x`, we need to
                    // to `array[index] = x;
                    const { name: name } = binding.expression.node;
                    const { object: object, property: property, snippet: snippet } = block.bindings.get(name);
                    lhs = snippet;
                    contextual_dependencies.push(object.name, property.name);
                }
                /** @type {import('estree').Identifier[]} */ const params = [
                    /** @type {import('estree').Identifier} */ x$1`#value`
                ];
                const args = [
                    x$1`#value`
                ];
                if (contextual_dependencies.length > 0) {
                    contextual_dependencies.forEach((name)=>{
                        params.push({
                            type: "Identifier",
                            name: name
                        });
                        renderer.add_to_context(name, true);
                        args.push(renderer.reference(name));
                    });
                    block.maintain_context = true; // TODO put this somewhere more logical
                }
                block.chunks.init.push(b$1`
				function ${id}(#value) {
					${callee}(${args});
				}
			`);
                let invalidate_binding = b$1`
				${lhs} = #value;
				${renderer.invalidate(dependencies[0])};
			`;
                if (binding.expression.node.type === "MemberExpression") invalidate_binding = b$1`
					if ($$self.$$.not_equal(${lhs}, #value)) {
						${invalidate_binding}
					}
				`;
                const body = b$1`
				function ${id}(${params}) {
					${invalidate_binding}
				}
			`;
                component.partly_hoisted.push(body);
                return b$1`@binding_callbacks.push(() => @bind(${this.var}, '${binding.name}', ${id}));`;
            });
            const munged_handlers = this.node.handlers.map((handler)=>{
                const event_handler = new EventHandlerWrapper(handler, this);
                let snippet = event_handler.get_snippet(block);
                if (handler.modifiers.has("once")) snippet = x$1`@once(${snippet})`;
                return b$1`${name}.$on("${handler.name}", ${snippet});`;
            });
            const mount_target = has_css_custom_properties ? css_custom_properties_wrapper : parent_node || "#target";
            const mount_anchor = has_css_custom_properties ? "null" : parent_node ? "null" : "#anchor";
            const to_claim = parent_nodes && this.renderer.options.hydratable;
            let claim_nodes = parent_nodes;
            if (this.node.name === "svelte:component") {
                const switch_value = block.get_unique_name("switch_value");
                const switch_props = block.get_unique_name("switch_props");
                const snippet = this.node.expression.manipulate(block);
                const dependencies = this.node.expression.dynamic_dependencies();
                if (has_css_custom_properties) this.set_css_custom_properties(block, css_custom_properties_wrapper, css_custom_properties_wrapper_element, is_svg_namespace);
                block.chunks.init.push(b$1`
				var ${switch_value} = ${snippet};

				function ${switch_props}(#ctx, #dirty) {
					${(this.node.attributes.length > 0 || this.node.bindings.length > 0) && b$1`
					${props && b$1`let ${props} = ${attribute_object};`}`}
					${statements}
					return ${component_opts};
				}

				if (${switch_value}) {
					${name} = @construct_svelte_component(${switch_value}, ${switch_props}(#ctx));

					${munged_bindings}
					${munged_handlers}
				}
			`);
                block.chunks.create.push(b$1`if (${name}) @create_component(${name}.$$.fragment);`);
                if (css_custom_properties_wrapper) this.create_css_custom_properties_wrapper_mount_chunk(block, parent_node, css_custom_properties_wrapper);
                block.chunks.mount.push(b$1`if (${name}) @mount_component(${name}, ${mount_target}, ${mount_anchor});`);
                if (to_claim) {
                    if (css_custom_properties_wrapper) claim_nodes = this.create_css_custom_properties_wrapper_claim_chunk(block, claim_nodes, css_custom_properties_wrapper, css_custom_properties_wrapper_element, is_svg_namespace);
                    block.chunks.claim.push(b$1`if (${name}) @claim_component(${name}.$$.fragment, ${claim_nodes});`);
                }
                const tmp_anchor = this.get_or_create_anchor(block, parent_node, parent_nodes);
                const anchor = has_css_custom_properties ? "null" : tmp_anchor;
                const update_mount_node = has_css_custom_properties ? css_custom_properties_wrapper : this.get_update_mount_node(tmp_anchor);
                const update_insert = css_custom_properties_wrapper && (tmp_anchor.name !== "null" ? b$1`@insert(${tmp_anchor}.parentNode, ${css_custom_properties_wrapper}, ${tmp_anchor});` : b$1`@insert(${parent_node}, ${css_custom_properties_wrapper}, ${tmp_anchor});`);
                let update_condition = x$1`${switch_value} !== (${switch_value} = ${snippet})`;
                if (dependencies.length > 0) update_condition = x$1`${block.renderer.dirty(dependencies)} && ${update_condition}`;
                block.chunks.update.push(b$1`
				if (${update_condition}) {
					if (${name}) {
						@group_outros();
						const old_component = ${name};
						@transition_out(old_component.$$.fragment, 1, 0, () => {
							@destroy_component(old_component, 1);
							${has_css_custom_properties ? b$1`@detach(${update_mount_node})` : null}
						});
						@check_outros();
					}

					if (${switch_value}) {
						${update_insert}
						${name} = @construct_svelte_component(${switch_value}, ${switch_props}(#ctx, #dirty));

						${munged_bindings}
						${munged_handlers}

						@create_component(${name}.$$.fragment);
						@transition_in(${name}.$$.fragment, 1);
						@mount_component(${name}, ${update_mount_node}, ${anchor});
					} else {
						${name} = null;
					}
				} else if (${switch_value}) {
					${updates}
					${updates.length > 0 && b$1`${name}.$set(${name_changes});`}
				}
			`);
                block.chunks.intro.push(b$1`
				if (${name}) @transition_in(${name}.$$.fragment, #local);
			`);
                block.chunks.outro.push(b$1`if (${name}) @transition_out(${name}.$$.fragment, #local);`);
                block.chunks.destroy.push(b$1`if (${name}) @destroy_component(${name}, ${parent_node ? null : "detaching"});`);
            } else {
                const expression = this.node.name === "svelte:self" ? component.name : this.renderer.reference(string_to_member_expression(this.node.name));
                block.chunks.init.push(b$1`
				${(this.node.attributes.length > 0 || this.node.bindings.length > 0) && b$1`
				${props && b$1`let ${props} = ${attribute_object};`}`}
				${statements}
				${name} = new ${expression}(${component_opts});

				${munged_bindings}
				${munged_handlers}
			`);
                if (has_css_custom_properties) this.set_css_custom_properties(block, css_custom_properties_wrapper, css_custom_properties_wrapper_element, is_svg_namespace);
                block.chunks.create.push(b$1`@create_component(${name}.$$.fragment);`);
                if (css_custom_properties_wrapper) this.create_css_custom_properties_wrapper_mount_chunk(block, parent_node, css_custom_properties_wrapper);
                block.chunks.mount.push(b$1`@mount_component(${name}, ${mount_target}, ${mount_anchor});`);
                if (to_claim) {
                    if (css_custom_properties_wrapper) claim_nodes = this.create_css_custom_properties_wrapper_claim_chunk(block, claim_nodes, css_custom_properties_wrapper, css_custom_properties_wrapper_element, is_svg_namespace);
                    block.chunks.claim.push(b$1`@claim_component(${name}.$$.fragment, ${claim_nodes});`);
                }
                block.chunks.intro.push(b$1`
				@transition_in(${name}.$$.fragment, #local);
			`);
                if (updates.length) block.chunks.update.push(b$1`
					${updates}
					${name}.$set(${name_changes});
				`);
                block.chunks.destroy.push(b$1`
				@destroy_component(${name}, ${parent_node ? null : "detaching"});
			`);
                block.chunks.outro.push(b$1`@transition_out(${name}.$$.fragment, #local);`);
            }
        }
        /**
	 * @private
	 * @param {import('../../Block.js').default} block
	 * @param {import('estree').Identifier} parent_node
	 * @param {import('estree').Identifier | null} css_custom_properties_wrapper
	 */ create_css_custom_properties_wrapper_mount_chunk(block, parent_node, css_custom_properties_wrapper) {
            if (parent_node) {
                block.chunks.mount.push(b$1`@append(${parent_node}, ${css_custom_properties_wrapper})`);
                if (is_head(parent_node)) block.chunks.destroy.push(b$1`@detach(${css_custom_properties_wrapper});`);
            } else {
                block.chunks.mount.push(b$1`@insert(#target, ${css_custom_properties_wrapper}, #anchor);`);
                // TODO we eventually need to consider what happens to elements
                // that belong to the same outgroup as an outroing element...
                block.chunks.destroy.push(b$1`if (detaching && ${this.var}) @detach(${css_custom_properties_wrapper});`);
            }
        }
        /**
	 * @private
	 * @param {import('../../Block.js').default} block
	 * @param {import('estree').Identifier} parent_nodes
	 * @param {import('estree').Identifier | null} css_custom_properties_wrapper
	 * @param {string} css_custom_properties_wrapper_element
	 * @param {boolean} is_svg_namespace
	 */ create_css_custom_properties_wrapper_claim_chunk(block, parent_nodes, css_custom_properties_wrapper, css_custom_properties_wrapper_element, is_svg_namespace) {
            const nodes = block.get_unique_name(`${css_custom_properties_wrapper.name}_nodes`);
            const claim_element = is_svg_namespace ? x$1`@claim_svg_element` : x$1`@claim_element`;
            block.chunks.claim.push(b$1`
			${css_custom_properties_wrapper} = ${claim_element}(${parent_nodes}, "${css_custom_properties_wrapper_element.toUpperCase()}", { style: true })
			var ${nodes} = @children(${css_custom_properties_wrapper});
		`);
            return nodes;
        }
        /**
	 * @private
	 * @param {import('../../Block.js').default} block
	 * @param {import('estree').Identifier} css_custom_properties_wrapper
	 * @param {string} css_custom_properties_wrapper_element
	 * @param {boolean} is_svg_namespace
	 */ set_css_custom_properties(block, css_custom_properties_wrapper, css_custom_properties_wrapper_element, is_svg_namespace) {
            const element = is_svg_namespace ? x$1`@svg_element` : x$1`@element`;
            block.chunks.create.push(b$1`${css_custom_properties_wrapper} = ${element}("${css_custom_properties_wrapper_element}");`);
            if (!is_svg_namespace) block.chunks.hydrate.push(b$1`@set_style(${css_custom_properties_wrapper}, "display", "contents");`);
            this.node.css_custom_properties.forEach((attr)=>{
                const dependencies = attr.get_dependencies();
                const should_cache = attr.should_cache();
                const last = should_cache && block.get_unique_name(`${attr.name.replace(regex_invalid_variable_identifier_characters, "_")}_last`);
                if (should_cache) block.add_variable(last);
                const value = attr.get_value(block);
                const init = should_cache ? x$1`${last} = ${value}` : value;
                block.chunks.hydrate.push(b$1`@set_style(${css_custom_properties_wrapper}, "${attr.name}", ${init});`);
                if (dependencies.length > 0) {
                    let condition = block.renderer.dirty(dependencies);
                    if (should_cache) condition = x$1`${condition} && (${last} !== (${last} = ${value}))`;
                    block.chunks.update.push(b$1`
					if (${condition}) {
						@set_style(${css_custom_properties_wrapper}, "${attr.name}", ${should_cache ? last : value});
					}
				`);
                }
            });
        }
    }
    /**
 * @param {Map<string, import('../nodes/Attribute.js').default>} values
 * @param {import('../render_dom/Block.js').default} block
 */ function get_slot_data(values, block = null) {
        return {
            type: "ObjectExpression",
            properties: Array.from(values.values()).filter((attribute)=>attribute.name !== "name").map((attribute)=>{
                if (attribute.is_spread) {
                    const argument = get_spread_value(block, attribute);
                    return {
                        type: "SpreadElement",
                        argument: argument
                    };
                }
                const value = get_value(block, attribute);
                return p`${attribute.name}: ${value}`;
            })
        };
    }
    /**
 * @param {import('../render_dom/Block.js').default} block
 * @param {import('../nodes/Attribute.js').default} attribute
 */ function get_value(block, attribute) {
        if (attribute.is_true) return x$1`true`;
        if (attribute.chunks.length === 0) return x$1`""`;
        let value = attribute.chunks.map((chunk)=>chunk.type === "Text" ? string_literal(chunk.data) : block ? chunk.manipulate(block) : chunk.node).reduce((lhs, rhs)=>x$1`${lhs} + ${rhs}`);
        if (attribute.chunks.length > 1 && attribute.chunks[0].type !== "Text") value = x$1`"" + ${value}`;
        return value;
    }
    /**
 * @param {import('../render_dom/Block.js').default} block
 * @param {import('../nodes/Attribute.js').default} attribute
 */ function get_spread_value(block, attribute) {
        return block ? attribute.expression.manipulate(block) : attribute.expression.node;
    }
    /** @extends Wrapper<import('../../nodes/Slot.js').default> */ class SlotWrapper extends Wrapper {
        /** @type {import('./Fragment.js').default} */ fragment;
        /** @type {import('../Block.js').default | null} */ fallback = null;
        /** @type {import('../Block.js').default} */ slot_block;
        /** @type {import('estree').Identifier} */ var = {
            type: "Identifier",
            name: "slot"
        };
        /** @type {Set<string>} */ dependencies = new Set([
            "$$scope"
        ]);
        /**
	 * @param {import('../Renderer.js').default} renderer
	 * @param {import('../Block.js').default} block
	 * @param {import('./shared/Wrapper.js').default} parent
	 * @param {import('../../nodes/Slot.js').default} node
	 * @param {boolean} strip_whitespace
	 * @param {import('./shared/Wrapper.js').default} next_sibling
	 */ constructor(renderer, block, parent, node, strip_whitespace, next_sibling){
            super(renderer, block, parent, node);
            if (this.node.children.length) {
                this.fallback = block.child({
                    comment: create_debugging_comment(this.node.children[0], this.renderer.component),
                    name: this.renderer.component.get_unique_name("fallback_block"),
                    type: "fallback"
                });
                renderer.blocks.push(this.fallback);
            }
            this.fragment = new FragmentWrapper(renderer, this.fallback, node.children, this, strip_whitespace, next_sibling);
            this.node.values.forEach((attribute)=>{
                add_to_set(this.dependencies, attribute.dependencies);
            });
            block.add_dependencies(this.dependencies);
            // we have to do this, just in case
            block.add_intro();
            block.add_outro();
        }
        /**
	 * @param {import('../Block.js').default} block
	 * @param {import('estree').Identifier} parent_node
	 * @param {import('estree').Identifier} parent_nodes
	 */ render(block, parent_node, parent_nodes) {
            const { renderer: renderer } = this;
            const { slot_name: slot_name } = this.node;
            if (this.slot_block) block = this.slot_block;
            /** @type {import('estree').Identifier | 'null'} */ let get_slot_changes_fn;
            /** @type {import('estree').Identifier | undefined} */ let get_slot_spread_changes_fn;
            /** @type {import('estree').Identifier | 'null'} */ let get_slot_context_fn;
            if (this.node.values.size > 0) {
                get_slot_changes_fn = renderer.component.get_unique_name(`get_${sanitize(slot_name)}_slot_changes`);
                get_slot_context_fn = renderer.component.get_unique_name(`get_${sanitize(slot_name)}_slot_context`);
                const changes = /** @type {import('estree').ObjectExpression} */ x$1`{}`;
                const spread_dynamic_dependencies = new Set();
                this.node.values.forEach((attribute)=>{
                    if (attribute.type === "Spread") add_to_set(spread_dynamic_dependencies, Array.from(attribute.dependencies).filter((name)=>this.is_dependency_dynamic(name)));
                    else {
                        const dynamic_dependencies = Array.from(attribute.dependencies).filter((name)=>this.is_dependency_dynamic(name));
                        if (dynamic_dependencies.length > 0) changes.properties.push(p`${attribute.name}: ${renderer.dirty(dynamic_dependencies)}`);
                    }
                });
                renderer.blocks.push(b$1`
				const ${get_slot_changes_fn} = #dirty => ${changes};
				const ${get_slot_context_fn} = #ctx => ${get_slot_data(this.node.values, block)};
			`);
                if (spread_dynamic_dependencies.size) {
                    get_slot_spread_changes_fn = renderer.component.get_unique_name(`get_${sanitize(slot_name)}_slot_spread_changes`);
                    renderer.blocks.push(b$1`
					const ${get_slot_spread_changes_fn} = #dirty => ${renderer.dirty(Array.from(spread_dynamic_dependencies))};
				`);
                }
            } else {
                get_slot_changes_fn = "null";
                get_slot_context_fn = "null";
            }
            let has_fallback = !!this.fallback;
            if (this.fallback) {
                this.fragment.render(this.fallback, null, /** @type {import('estree').Identifier} */ x$1`#nodes`);
                has_fallback = this.fallback.has_content();
                if (!has_fallback) renderer.remove_block(this.fallback);
            }
            const slot = block.get_unique_name(`${sanitize(slot_name)}_slot`);
            const slot_definition = block.get_unique_name(`${sanitize(slot_name)}_slot_template`);
            const slot_or_fallback = has_fallback ? block.get_unique_name(`${sanitize(slot_name)}_slot_or_fallback`) : slot;
            block.chunks.init.push(b$1`
			const ${slot_definition} = ${renderer.reference("#slots")}.${slot_name};
			const ${slot} = @create_slot(${slot_definition}, #ctx, ${renderer.reference("$$scope")}, ${get_slot_context_fn});
			${has_fallback ? b$1`const ${slot_or_fallback} = ${slot} || ${this.fallback.name}(#ctx);` : null}
		`);
            block.chunks.create.push(b$1`if (${slot_or_fallback}) ${slot_or_fallback}.c();`);
            if (renderer.options.hydratable) block.chunks.claim.push(b$1`if (${slot_or_fallback}) ${slot_or_fallback}.l(${parent_nodes});`);
            block.chunks.mount.push(b$1`
			if (${slot_or_fallback}) {
				${slot_or_fallback}.m(${parent_node || "#target"}, ${parent_node ? "null" : "#anchor"});
			}
		`);
            block.chunks.intro.push(b$1`@transition_in(${slot_or_fallback}, #local);`);
            block.chunks.outro.push(b$1`@transition_out(${slot_or_fallback}, #local);`);
            const dynamic_dependencies = Array.from(this.dependencies).filter((name)=>this.is_dependency_dynamic(name));
            const fallback_dynamic_dependencies = has_fallback ? Array.from(this.fallback.dependencies).filter((name)=>this.is_dependency_dynamic(name)) : [];
            let condition = renderer.dirty(dynamic_dependencies);
            if (block.has_outros) condition = x$1`!#current || ${condition}`;
            // conditions to treat everything as dirty
            const all_dirty_conditions = [
                get_slot_spread_changes_fn ? x$1`${get_slot_spread_changes_fn}(#dirty)` : null,
                block.has_outros ? x$1`!#current` : null
            ].filter(Boolean);
            const all_dirty_condition = all_dirty_conditions.length ? all_dirty_conditions.reduce((condition1, condition2)=>x$1`${condition1} || ${condition2}`) : null;
            /** @type {import('estree').Node[]} */ let slot_update;
            if (all_dirty_condition) {
                const dirty = x$1`${all_dirty_condition} ? @get_all_dirty_from_scope(${renderer.reference("$$scope")}) : @get_slot_changes(${slot_definition}, ${renderer.reference("$$scope")}, #dirty, ${get_slot_changes_fn})`;
                slot_update = b$1`
				if (${slot}.p && ${condition}) {
					@update_slot_base(${slot}, ${slot_definition}, #ctx, ${renderer.reference("$$scope")}, ${dirty}, ${get_slot_context_fn});
				}
			`;
            } else slot_update = b$1`
				if (${slot}.p && ${condition}) {
					@update_slot(${slot}, ${slot_definition}, #ctx, ${renderer.reference("$$scope")}, #dirty, ${get_slot_changes_fn}, ${get_slot_context_fn});
				}
			`;
            let fallback_condition = renderer.dirty(fallback_dynamic_dependencies);
            let fallback_dirty = x$1`#dirty`;
            if (block.has_outros) {
                fallback_condition = x$1`!#current || ${fallback_condition}`;
                fallback_dirty = x$1`!#current ? ${renderer.get_initial_dirty()} : ${fallback_dirty}`;
            }
            const fallback_update = has_fallback && fallback_dynamic_dependencies.length > 0 && b$1`
			if (${slot_or_fallback} && ${slot_or_fallback}.p && ${fallback_condition}) {
				${slot_or_fallback}.p(#ctx, ${fallback_dirty});
			}
		`;
            if (fallback_update) block.chunks.update.push(b$1`
				if (${slot}) {
					${slot_update}
				} else {
					${fallback_update}
				}
			`);
            else block.chunks.update.push(b$1`
				if (${slot}) {
					${slot_update}
				}
			`);
            block.chunks.destroy.push(b$1`if (${slot_or_fallback}) ${slot_or_fallback}.d(detaching);`);
        }
        /** @param {string} name */ is_dependency_dynamic(name) {
            if (name === "$$scope") return true;
            if (this.node.scope.is_let(name)) return true;
            if (is_reserved_keyword(name)) return true;
            const variable = this.renderer.component.var_lookup.get(name);
            return is_dynamic$1(variable);
        }
    }
    /** @extends Wrapper<import('../../nodes/Title.js').default> */ class TitleWrapper extends Wrapper {
        /**
	 * @param {import('../Renderer.js').default} renderer
	 * @param {import('../Block.js').default} block
	 * @param {import('./shared/Wrapper.js').default} parent
	 * @param {import('../../nodes/Title.js').default} node
	 * @param {boolean} _strip_whitespace
	 * @param {import('./shared/Wrapper.js').default} _next_sibling
	 */ constructor(renderer, block, parent, node, _strip_whitespace, _next_sibling){
            super(renderer, block, parent, node);
        }
        /**
	 * @param {import('../Block.js').default} block
	 * @param {import('estree').Identifier} _parent_node
	 * @param {import('estree').Identifier} _parent_nodes
	 */ render(block, _parent_node, _parent_nodes) {
            const is_dynamic = !!this.node.children.find((node)=>node.type !== "Text");
            if (is_dynamic) {
                let value;
                /** @type {Set<string>} */ const all_dependencies = new Set();
                // TODO some of this code is repeated in Tag.ts — would be good to
                // DRY it out if that's possible without introducing crazy indirection
                if (this.node.children.length === 1) {
                    // single {tag} — may be a non-string
                    // @ts-ignore todo: check this
                    const { expression: expression } = this.node.children[0];
                    value = expression.manipulate(block);
                    add_to_set(all_dependencies, expression.dependencies);
                } else {
                    // '{foo} {bar}' — treat as string concatenation
                    value = this.node.children.map((chunk)=>{
                        if (chunk.type === "Text") return string_literal(chunk.data);
                        /** @type {import('../../nodes/MustacheTag.js').default} */ chunk.expression.dependencies.forEach((d)=>{
                            all_dependencies.add(d);
                        });
                        return /** @type {import('../../nodes/MustacheTag.js').default} */ chunk.expression.manipulate(block);
                    }).reduce((lhs, rhs)=>x$1`${lhs} + ${rhs}`);
                    if (this.node.children[0].type !== "Text") value = x$1`"" + ${value}`;
                }
                const last = this.node.should_cache && block.get_unique_name("title_value");
                if (this.node.should_cache) block.add_variable(last);
                const init = this.node.should_cache ? x$1`${last} = ${value}` : value;
                block.chunks.init.push(b$1`@_document.title = ${init};`);
                const updater = b$1`@_document.title = ${this.node.should_cache ? last : value};`;
                if (all_dependencies.size) {
                    const dependencies = Array.from(all_dependencies);
                    let condition = block.renderer.dirty(dependencies);
                    if (block.has_outros) condition = x$1`!#current || ${condition}`;
                    if (this.node.should_cache) condition = x$1`${condition} && (${last} !== (${last} = ${value}))`;
                    block.chunks.update.push(b$1`
					if (${condition}) {
						${updater}
					}`);
                }
            } else {
                const value = this.node.children.length > 0 ? string_literal(/** @type {import('../../nodes/Text.js').default} */ this.node.children[0].data) : x$1`""`;
                block.chunks.hydrate.push(b$1`@_document.title = ${value};`);
            }
        }
    }
    const associated_events = {
        innerWidth: "resize",
        innerHeight: "resize",
        outerWidth: "resize",
        outerHeight: "resize",
        devicePixelRatio: "resize",
        scrollX: "scroll",
        scrollY: "scroll"
    };
    const properties = {
        scrollX: "pageXOffset",
        scrollY: "pageYOffset"
    };
    const readonly = new Set([
        "innerWidth",
        "innerHeight",
        "outerWidth",
        "outerHeight",
        "devicePixelRatio",
        "online"
    ]);
    /** @extends Wrapper<import('../../nodes/Window.js').default> */ class WindowWrapper extends Wrapper {
        /** @type {import('./Element/EventHandler.js').default[]} */ handlers;
        /**
	 * @param {import('../Renderer.js').default} renderer
	 * @param {import('../Block.js').default} block
	 * @param {import('./shared/Wrapper.js').default} parent
	 * @param {import('../../nodes/Window.js').default} node
	 */ constructor(renderer, block, parent, node){
            super(renderer, block, parent, node);
            this.handlers = this.node.handlers.map((handler)=>new EventHandlerWrapper(handler, this));
        }
        /**
	 * @param {import('../Block.js').default} block
	 * @param {import('estree').Identifier} _parent_node
	 * @param {import('estree').Identifier} _parent_nodes
	 */ render(block, _parent_node, _parent_nodes) {
            const { renderer: renderer } = this;
            const { component: component } = renderer;
            /** @type {Record<string, Array<{ name: string; value: string }>>} */ const events = {};
            /** @type {Record<string, string>} */ const bindings = {};
            add_actions(block, "@_window", this.node.actions);
            add_event_handlers(block, "@_window", this.handlers);
            this.node.bindings.forEach((binding)=>{
                // TODO: what if it's a MemberExpression?
                const binding_name = /** @type {import('estree').Identifier} */ binding.expression.node.name;
                // in dev mode, throw if read-only values are written to
                if (readonly.has(binding.name)) renderer.readonly.add(binding_name);
                bindings[binding.name] = binding_name;
                // bind:online is a special case, we need to listen for two separate events
                if (binding.name === "online") return;
                const associated_event = associated_events[binding.name];
                const property = properties[binding.name] || binding.name;
                if (!events[associated_event]) events[associated_event] = [];
                events[associated_event].push({
                    name: binding_name,
                    value: property
                });
            });
            const scrolling = block.get_unique_name("scrolling");
            const clear_scrolling = block.get_unique_name("clear_scrolling");
            const scrolling_timeout = block.get_unique_name("scrolling_timeout");
            Object.keys(events).forEach((event)=>{
                const id = block.get_unique_name(`onwindow${event}`);
                const props = events[event];
                renderer.add_to_context(id.name);
                const fn = renderer.reference(id.name);
                if (event === "scroll") {
                    // TODO other bidirectional bindings...
                    block.add_variable(scrolling, x$1`false`);
                    block.add_variable(clear_scrolling, x$1`() => { ${scrolling} = false }`);
                    block.add_variable(scrolling_timeout);
                    const condition = bindings.scrollX && bindings.scrollY ? x$1`"${bindings.scrollX}" in this._state || "${bindings.scrollY}" in this._state` : x$1`"${bindings.scrollX || bindings.scrollY}" in this._state`;
                    const scroll_x = bindings.scrollX && x$1`this._state.${bindings.scrollX}`;
                    const scroll_y = bindings.scrollY && x$1`this._state.${bindings.scrollY}`;
                    renderer.meta_bindings.push(b$1`
					if (${condition}) {
						@_scrollTo(${scroll_x || "@_window.pageXOffset"}, ${scroll_y || "@_window.pageYOffset"});
					}
					${scroll_x && `${scroll_x} = @_window.pageXOffset;`}
					${scroll_y && `${scroll_y} = @_window.pageYOffset;`}
				`);
                    block.event_listeners.push(x$1`
					@listen(@_window, "${event}", () => {
						${scrolling} = true;
						@_clearTimeout(${scrolling_timeout});
						${scrolling_timeout} = @_setTimeout(${clear_scrolling}, 100);
						${fn}();
					})
				`);
                } else {
                    props.forEach((prop)=>{
                        renderer.meta_bindings.push(b$1`this._state.${prop.name} = @_window.${prop.value};`);
                    });
                    block.event_listeners.push(x$1`
					@listen(@_window, "${event}", ${fn})
				`);
                }
                component.partly_hoisted.push(b$1`
				function ${id}() {
					${props.map((prop)=>renderer.invalidate(prop.name, x$1`${prop.name} = @_window.${prop.value}`))}
				}
			`);
                block.chunks.init.push(b$1`
				@add_render_callback(${fn});
			`);
                component.has_reactive_assignments = true;
            });
            // special case... might need to abstract this out if we add more special cases
            if (bindings.scrollX || bindings.scrollY) {
                const condition = renderer.dirty([
                    bindings.scrollX,
                    bindings.scrollY
                ].filter(Boolean));
                const scroll_x = bindings.scrollX ? renderer.reference(bindings.scrollX) : x$1`@_window.pageXOffset`;
                const scroll_y = bindings.scrollY ? renderer.reference(bindings.scrollY) : x$1`@_window.pageYOffset`;
                block.chunks.update.push(b$1`
				if (${condition} && !${scrolling}) {
					${scrolling} = true;
					@_clearTimeout(${scrolling_timeout});
					@_scrollTo(${scroll_x}, ${scroll_y});
					${scrolling_timeout} = @_setTimeout(${clear_scrolling}, 100);
				}
			`);
            }
            // another special case. (I'm starting to think these are all special cases.)
            if (bindings.online) {
                const id = block.get_unique_name("onlinestatuschanged");
                const name = bindings.online;
                renderer.add_to_context(id.name);
                const reference = renderer.reference(id.name);
                component.partly_hoisted.push(b$1`
				function ${id}() {
					${renderer.invalidate(name, x$1`${name} = @_navigator.onLine`)}
				}
			`);
                block.chunks.init.push(b$1`
				@add_render_callback(${reference});
			`);
                block.event_listeners.push(x$1`@listen(@_window, "online", ${reference})`, x$1`@listen(@_window, "offline", ${reference})`);
                component.has_reactive_assignments = true;
            }
        }
    }
    /**
 * @template {{ next?: T; prev?: T }} T
 * @param {T} next
 * @param {T} prev
 */ function link(next, prev) {
        prev.next = next;
        if (next) next.prev = prev;
    }
    const wrappers = {
        AwaitBlock: AwaitBlockWrapper,
        Body: BodyWrapper,
        Comment: CommentWrapper,
        DebugTag: DebugTagWrapper,
        Document: DocumentWrapper,
        EachBlock: EachBlockWrapper,
        Element: ElementWrapper,
        Head: HeadWrapper,
        IfBlock: IfBlockWrapper,
        InlineComponent: InlineComponentWrapper,
        KeyBlock: KeyBlockWrapper,
        MustacheTag: MustacheTagWrapper,
        Options: null,
        RawMustacheTag: RawMustacheTagWrapper,
        Slot: SlotWrapper,
        SlotTemplate: SlotTemplateWrapper,
        Text: TextWrapper,
        Title: TitleWrapper,
        Window: WindowWrapper
    };
    /**
 * @param {import('../../nodes/interfaces.js').INode} child
 * @param {import('./shared/Wrapper.js').default} next_sibling
 * @returns {boolean}
 */ function trimmable_at$1(child, next_sibling) {
        // Whitespace is trimmable if one of the following is true:
        // The child and its sibling share a common nearest each block (not at an each block boundary)
        // The next sibling's previous node is an each block
        return next_sibling.node.find_nearest(/EachBlock/) === child.find_nearest(/EachBlock/) || next_sibling.node.prev.type === "EachBlock";
    }
    class FragmentWrapper {
        /** @type {import('./shared/Wrapper.js').default[]} */ nodes;
        /**
	 * @param {import('../Renderer.js').default} renderer
	 * @param {import('../Block.js').default} block
	 * @param {import('../../nodes/interfaces.js').INode[]} nodes
	 * @param {import('./shared/Wrapper.js').default} parent
	 * @param {boolean} strip_whitespace
	 * @param {import('./shared/Wrapper.js').default} next_sibling
	 */ constructor(renderer, block, nodes, parent, strip_whitespace, next_sibling){
            this.nodes = [];
            /** @type {import('./shared/Wrapper.js').default} */ let last_child;
            /** @type {import('./Window.js').default | undefined} */ let window_wrapper;
            let i = nodes.length;
            while(i--){
                const child = nodes[i];
                if (!child.type) throw new Error("missing type");
                if (!(child.type in wrappers)) throw new Error(`TODO implement ${child.type}`);
                // special case — this is an easy way to remove whitespace surrounding
                // <svelte:window/>. lil hacky but it works
                if (child.type === "Window") {
                    window_wrapper = new WindowWrapper(renderer, block, parent, child);
                    continue;
                }
                if (child.type === "Text") {
                    let { data: data } = child;
                    // We want to remove trailing whitespace inside an element/component/block,
                    // *unless* there is no whitespace between this node and its next sibling
                    if (this.nodes.length === 0) {
                        const should_trim = next_sibling ? next_sibling.node.type === "Text" && regex_starts_with_whitespace.test(next_sibling.node.data) && trimmable_at$1(child, next_sibling) : !child.has_ancestor("EachBlock");
                        if (should_trim && !child.keep_space()) {
                            data = trim_end(data);
                            if (!data) continue;
                        }
                    }
                    // glue text nodes (which could e.g. be separated by comments) together
                    if (last_child && last_child.node.type === "Text") {
                        /** @type {import('./Text.js').default} */ last_child.data = data + /** @type {import('./Text.js').default} */ last_child.data;
                        continue;
                    }
                    const wrapper = new TextWrapper(renderer, block, parent, child, data);
                    if (wrapper.skip) continue;
                    this.nodes.unshift(wrapper);
                    link(last_child, last_child = wrapper);
                } else {
                    const Wrapper = wrappers[child.type];
                    if (!Wrapper || child.type === "Comment" && !renderer.options.preserveComments) continue;
                    const wrapper = new Wrapper(renderer, block, parent, child, strip_whitespace, last_child || next_sibling);
                    this.nodes.unshift(wrapper);
                    link(last_child, last_child = wrapper);
                }
            }
            if (strip_whitespace) {
                const first = /** @type {import('./Text.js').default} */ this.nodes[0];
                if (first && first.node.type === "Text" && !first.node.keep_space()) {
                    first.data = trim_start(first.data);
                    if (!first.data) {
                        first.var = null;
                        this.nodes.shift();
                        if (this.nodes[0]) this.nodes[0].prev = null;
                    }
                }
            }
            if (window_wrapper) {
                this.nodes.unshift(window_wrapper);
                link(last_child, window_wrapper);
            }
        }
        /**
	 * @param {import('../Block.js').default} block
	 * @param {import('estree').Identifier} parent_node
	 * @param {import('estree').Identifier} parent_nodes
	 */ render(block, parent_node, parent_nodes) {
            for(let i = 0; i < this.nodes.length; i += 1)this.nodes[i].render(block, parent_node, parent_nodes);
        }
    }
    let Renderer$1 = class Renderer {
        /**
	 * @typedef {Object} ContextMember
	 * @property {string} name
	 * @property {import('estree').Literal} index
	 * @property {boolean} is_contextual
	 * @property {boolean} is_non_contextual
	 * @property {import('../../interfaces.js').Var} variable
	 * @property {number} priority
	 */ /**
	 * @typedef {Array<{
	 * 	n: number;
	 * 	names: string[];
	 * }>} BitMasks
	 */ /** @type {import('../Component.js').default} */ component;
        /** @type {import('../../interfaces.js').CompileOptions} */ options;
        /** @type {ContextMember[]} */ context = [];
        /** @type {ContextMember[]} */ initial_context = [];
        /** @type {Map<string, ContextMember>} */ context_lookup = new Map();
        /** @type {boolean} */ context_overflow;
        /** @type {Array<import('./Block.js').default | import('estree').Node | import('estree').Node[]>} */ blocks = [];
        /** @type {Set<string>} */ readonly = new Set();
        /** @type {Array<import('estree').Node | import('estree').Node[]>} */ meta_bindings = [];
        /** @type {Map<string, BindingGroup>} */ binding_groups = new Map();
        /** @type {import('./Block.js').default} */ block;
        /** @type {import('./wrappers/Fragment.js').default} */ fragment;
        /** @type {import('estree').Identifier} */ file_var;
        /**
	 * Use this for stack traces. It is 1-based and acts on pre-processed sources.
	 * Use `meta_locate` for metadata on DOM elements.
	 * @type {(c: number) => { line: number; column: number }}
	 */ locate;
        /**
	 * Use this for metadata on DOM elements. It is 1-based and acts on sources that have not been pre-processed.
	 * Use `locate` for source mappings.
	 * @type {(c: number) => { line: number; column: number }}
	 */ meta_locate;
        /**
	 * @param {import('../Component.js').default} component
	 * @param {import('../../interfaces.js').CompileOptions} options
	 */ constructor(component, options){
            this.component = component;
            this.options = options;
            this.locate = component.locate; // TODO messy
            this.meta_locate = component.meta_locate; // TODO messy
            this.file_var = options.dev && this.component.get_unique_name("file");
            component.vars.filter((v)=>!v.hoistable || v.export_name && !v.module).forEach((v)=>this.add_to_context(v.name));
            // ensure store values are included in context
            component.vars.filter((v)=>v.subscribable).forEach((v)=>this.add_to_context(`$${v.name}`));
            reserved_keywords.forEach((keyword)=>{
                if (component.var_lookup.has(keyword)) this.add_to_context(keyword);
            });
            if (component.slots.size > 0) {
                this.add_to_context("$$scope");
                this.add_to_context("#slots");
            }
            // main block
            this.block = new Block$1({
                renderer: this,
                name: null,
                type: "component",
                key: null,
                bindings: new Map(),
                dependencies: new Set()
            });
            this.block.has_update_method = true;
            this.fragment = new FragmentWrapper(this, this.block, component.fragment.children, null, true, null);
            // TODO messy
            this.blocks.forEach((block)=>{
                if (block instanceof Block$1) block.assign_variable_names();
            });
            this.block.assign_variable_names();
            this.fragment.render(this.block, null, /** @type {import('estree').Identifier} */ x$1`#nodes`);
            this.context_overflow = this.context.length > 31;
            this.context.forEach((member)=>{
                const { variable: variable } = member;
                if (variable) {
                    member.priority += 2;
                    if (variable.mutated || variable.reassigned) member.priority += 4;
                    // these determine whether variable is included in initial context
                    // array, so must have the highest priority
                    if (variable.is_reactive_dependency && (variable.mutated || variable.reassigned)) member.priority += 16;
                    if (variable.export_name) member.priority += 32;
                    if (variable.referenced) member.priority += 64;
                } else if (member.is_non_contextual) // determine whether variable is included in initial context
                // array, so must have the highest priority
                member.priority += 8;
                if (!member.is_contextual) member.priority += 1;
            });
            this.context.sort((a, b)=>b.priority - a.priority || /** @type {number} */ a.index.value - /** @type {number} */ b.index.value);
            this.context.forEach((member, i)=>member.index.value = i);
            let i = this.context.length;
            while(i--){
                const member = this.context[i];
                if (member.variable) {
                    if (member.variable.referenced || member.variable.export_name || member.variable.is_reactive_dependency && (member.variable.mutated || member.variable.reassigned)) break;
                } else if (member.is_non_contextual) break;
            }
            this.initial_context = this.context.slice(0, i + 1);
        }
        /**
	 * @param {string} name
	 * @param {any} contextual
	 */ add_to_context(name, contextual = false) {
            if (!this.context_lookup.has(name)) {
                /** @type {ContextMember} */ const member = {
                    name: name,
                    index: {
                        type: "Literal",
                        value: this.context.length
                    },
                    is_contextual: false,
                    is_non_contextual: false,
                    variable: null,
                    priority: 0
                };
                this.context_lookup.set(name, member);
                this.context.push(member);
            }
            const member = this.context_lookup.get(name);
            if (contextual) member.is_contextual = true;
            else {
                member.is_non_contextual = true;
                member.variable = this.component.var_lookup.get(name);
            }
            return member;
        }
        /**
	 * @param {string} name
	 * @param {unknown} [value]
	 * @param {boolean} main_execution_context
	 */ invalidate(name, value, main_execution_context = false) {
            return renderer_invalidate(this, name, value, main_execution_context);
        }
        /**
	 * @param {string[]} names
	 * @param {any} is_reactive_declaration
	 * @returns {import('estree').Expression}
	 */ dirty(names, is_reactive_declaration = false) {
            const renderer = this;
            const dirty = /** @type {| import('estree').Identifier
                    | import('estree').MemberExpression} */ is_reactive_declaration ? x$1`$$self.$$.dirty` : x$1`#dirty`;
            const get_bitmask = ()=>{
                /** @type {BitMasks} */ const bitmask = [];
                names.forEach((name)=>{
                    const member = renderer.context_lookup.get(name);
                    if (!member) return;
                    if (member.index.value === -1) throw new Error("unset index");
                    const value = /** @type {number} */ member.index.value;
                    const i = value / 31 | 0;
                    const n = 1 << value % 31;
                    if (!bitmask[i]) bitmask[i] = {
                        n: 0,
                        names: []
                    };
                    bitmask[i].n |= n;
                    bitmask[i].names.push(name);
                });
                return bitmask;
            };
            // TODO: context-overflow make it less gross
            return /** @type {any} */ {
                // Using a ParenthesizedExpression allows us to create
                // the expression lazily. TODO would be better if
                // context was determined before rendering, so that
                // this indirection was unnecessary
                type: "ParenthesizedExpression",
                get expression () {
                    const bitmask = get_bitmask();
                    if (!bitmask.length) return /** @type {import('estree').BinaryExpression} */ x$1`${dirty} & /*${names.join(", ")}*/ 0`;
                    if (renderer.context_overflow) return bitmask.map((b, i)=>({
                            b: b,
                            i: i
                        })).filter(({ b: b })=>b).map(({ b: b, i: i })=>x$1`${dirty}[${i}] & /*${b.names.join(", ")}*/ ${b.n}`).reduce((lhs, rhs)=>x$1`${lhs} | ${rhs}`);
                    return /** @type {import('estree').BinaryExpression} */ x$1`${dirty} & /*${names.join(", ")}*/ ${bitmask[0].n}`;
                }
            };
        }
        // NOTE: this method may be called before this.context_overflow / this.context is fully defined
        // therefore, they can only be evaluated later in a getter function
        /** @returns {import('estree').UnaryExpression | import('estree').ArrayExpression} */ get_initial_dirty() {
            const _this = this;
            // TODO: context-overflow make it less gross
            /** @type {import('estree').UnaryExpression} */ const val = /** @type {import('estree').UnaryExpression} */ x$1`-1`;
            return {
                get type () {
                    return _this.context_overflow ? "ArrayExpression" : "UnaryExpression";
                },
                // as [-1]
                get elements () {
                    const elements = [];
                    for(let i = 0; i < _this.context.length; i += 31)elements.push(val);
                    return elements;
                },
                // as -1
                operator: val.operator,
                prefix: val.prefix,
                argument: val.argument
            };
        }
        /**
	 * @param {string | import('estree').Identifier | import('estree').MemberExpression} node
	 * @param {string | void} ctx
	 */ reference(node, ctx = "#ctx") {
            if (typeof node === "string") node = {
                type: "Identifier",
                name: node
            };
            const { name: name, nodes: nodes } = flatten_reference(node);
            const member = this.context_lookup.get(name);
            // TODO is this correct?
            if (this.component.var_lookup.get(name)) this.component.add_reference(node, name);
            if (member !== undefined) {
                const replacement = /** @type {import('estree').MemberExpression} */ x$1`/*${member.name}*/ ${ctx}[${member.index}]`;
                if (nodes[0].loc) replacement.object.loc = nodes[0].loc;
                nodes[0] = replacement;
                return nodes.reduce((lhs, rhs)=>x$1`${lhs}.${rhs}`);
            }
            return node;
        }
        /** @param {import('./Block.js').default | import('estree').Node | import('estree').Node[]} block */ remove_block(block) {
            this.blocks.splice(this.blocks.indexOf(block), 1);
        }
    };
    /**
 * @typedef {Object} BindingGroup
 * @property {(to_reference?:boolean)=>import('estree').Node} binding_group
 * @property {string[]} contexts
 * @property {Set<string>} list_dependencies
 * @property {string} keypath
 * @property {(block:Block,element:import('estree').PrivateIdentifier) => void} add_element
 * @property {(block:Block)=>void} render
 */ // Matches the scheme of a URL, eg "http://"
    const schemeRegex = /^[\w+.-]+:\/\//;
    /**
 * Matches the parts of a URL:
 * 1. Scheme, including ":", guaranteed.
 * 2. User/password, including "@", optional.
 * 3. Host, guaranteed.
 * 4. Port, including ":", optional.
 * 5. Path, including "/", optional.
 * 6. Query, including "?", optional.
 * 7. Hash, including "#", optional.
 */ const urlRegex = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/;
    /**
 * File URLs are weird. They dont' need the regular `//` in the scheme, they may or may not start
 * with a leading `/`, they can have a domain (but only if they don't start with a Windows drive).
 *
 * 1. Host, optional.
 * 2. Path, which may include "/", guaranteed.
 * 3. Query, including "?", optional.
 * 4. Hash, including "#", optional.
 */ const fileRegex = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
    var UrlType;
    (function(UrlType) {
        UrlType[UrlType["Empty"] = 1] = "Empty";
        UrlType[UrlType["Hash"] = 2] = "Hash";
        UrlType[UrlType["Query"] = 3] = "Query";
        UrlType[UrlType["RelativePath"] = 4] = "RelativePath";
        UrlType[UrlType["AbsolutePath"] = 5] = "AbsolutePath";
        UrlType[UrlType["SchemeRelative"] = 6] = "SchemeRelative";
        UrlType[UrlType["Absolute"] = 7] = "Absolute";
    })(UrlType || (UrlType = {}));
    function isAbsoluteUrl(input) {
        return schemeRegex.test(input);
    }
    function isSchemeRelativeUrl(input) {
        return input.startsWith("//");
    }
    function isAbsolutePath(input) {
        return input.startsWith("/");
    }
    function isFileUrl(input) {
        return input.startsWith("file:");
    }
    function isRelative(input) {
        return /^[.?#]/.test(input);
    }
    function parseAbsoluteUrl(input) {
        const match = urlRegex.exec(input);
        return makeUrl(match[1], match[2] || "", match[3], match[4] || "", match[5] || "/", match[6] || "", match[7] || "");
    }
    function parseFileUrl(input) {
        const match = fileRegex.exec(input);
        const path = match[2];
        return makeUrl("file:", "", match[1] || "", "", isAbsolutePath(path) ? path : "/" + path, match[3] || "", match[4] || "");
    }
    function makeUrl(scheme, user, host, port, path, query, hash) {
        return {
            scheme: scheme,
            user: user,
            host: host,
            port: port,
            path: path,
            query: query,
            hash: hash,
            type: UrlType.Absolute
        };
    }
    function parseUrl(input) {
        if (isSchemeRelativeUrl(input)) {
            const url = parseAbsoluteUrl("http:" + input);
            url.scheme = "";
            url.type = UrlType.SchemeRelative;
            return url;
        }
        if (isAbsolutePath(input)) {
            const url = parseAbsoluteUrl("http://foo.com" + input);
            url.scheme = "";
            url.host = "";
            url.type = UrlType.AbsolutePath;
            return url;
        }
        if (isFileUrl(input)) return parseFileUrl(input);
        if (isAbsoluteUrl(input)) return parseAbsoluteUrl(input);
        const url = parseAbsoluteUrl("http://foo.com/" + input);
        url.scheme = "";
        url.host = "";
        url.type = input ? input.startsWith("?") ? UrlType.Query : input.startsWith("#") ? UrlType.Hash : UrlType.RelativePath : UrlType.Empty;
        return url;
    }
    function stripPathFilename(path) {
        // If a path ends with a parent directory "..", then it's a relative path with excess parent
        // paths. It's not a file, so we can't strip it.
        if (path.endsWith("/..")) return path;
        const index = path.lastIndexOf("/");
        return path.slice(0, index + 1);
    }
    function mergePaths(url, base) {
        normalizePath(base, base.type);
        // If the path is just a "/", then it was an empty path to begin with (remember, we're a relative
        // path).
        if (url.path === "/") url.path = base.path;
        else // Resolution happens relative to the base path's directory, not the file.
        url.path = stripPathFilename(base.path) + url.path;
    }
    /**
 * The path can have empty directories "//", unneeded parents "foo/..", or current directory
 * "foo/.". We need to normalize to a standard representation.
 */ function normalizePath(url, type) {
        const rel = type <= UrlType.RelativePath;
        const pieces = url.path.split("/");
        // We need to preserve the first piece always, so that we output a leading slash. The item at
        // pieces[0] is an empty string.
        let pointer = 1;
        // Positive is the number of real directories we've output, used for popping a parent directory.
        // Eg, "foo/bar/.." will have a positive 2, and we can decrement to be left with just "foo".
        let positive = 0;
        // We need to keep a trailing slash if we encounter an empty directory (eg, splitting "foo/" will
        // generate `["foo", ""]` pieces). And, if we pop a parent directory. But once we encounter a
        // real directory, we won't need to append, unless the other conditions happen again.
        let addTrailingSlash = false;
        for(let i = 1; i < pieces.length; i++){
            const piece = pieces[i];
            // An empty directory, could be a trailing slash, or just a double "//" in the path.
            if (!piece) {
                addTrailingSlash = true;
                continue;
            }
            // If we encounter a real directory, then we don't need to append anymore.
            addTrailingSlash = false;
            // A current directory, which we can always drop.
            if (piece === ".") continue;
            // A parent directory, we need to see if there are any real directories we can pop. Else, we
            // have an excess of parents, and we'll need to keep the "..".
            if (piece === "..") {
                if (positive) {
                    addTrailingSlash = true;
                    positive--;
                    pointer--;
                } else if (rel) // If we're in a relativePath, then we need to keep the excess parents. Else, in an absolute
                // URL, protocol relative URL, or an absolute path, we don't need to keep excess.
                pieces[pointer++] = piece;
                continue;
            }
            // We've encountered a real directory. Move it to the next insertion pointer, which accounts for
            // any popped or dropped directories.
            pieces[pointer++] = piece;
            positive++;
        }
        let path = "";
        for(let i = 1; i < pointer; i++)path += "/" + pieces[i];
        if (!path || addTrailingSlash && !path.endsWith("/..")) path += "/";
        url.path = path;
    }
    /**
 * Attempts to resolve `input` URL/path relative to `base`.
 */ function resolve$1(input, base) {
        if (!input && !base) return "";
        const url = parseUrl(input);
        let inputType = url.type;
        if (base && inputType !== UrlType.Absolute) {
            const baseUrl = parseUrl(base);
            const baseType = baseUrl.type;
            switch(inputType){
                case UrlType.Empty:
                    url.hash = baseUrl.hash;
                // fall through
                case UrlType.Hash:
                    url.query = baseUrl.query;
                // fall through
                case UrlType.Query:
                case UrlType.RelativePath:
                    mergePaths(url, baseUrl);
                // fall through
                case UrlType.AbsolutePath:
                    // The host, user, and port are joined, you can't copy one without the others.
                    url.user = baseUrl.user;
                    url.host = baseUrl.host;
                    url.port = baseUrl.port;
                // fall through
                case UrlType.SchemeRelative:
                    // The input doesn't have a schema at least, so we need to copy at least that over.
                    url.scheme = baseUrl.scheme;
            }
            if (baseType > inputType) inputType = baseType;
        }
        normalizePath(url, inputType);
        const queryHash = url.query + url.hash;
        switch(inputType){
            // This is impossible, because of the empty checks at the start of the function.
            // case UrlType.Empty:
            case UrlType.Hash:
            case UrlType.Query:
                return queryHash;
            case UrlType.RelativePath:
                {
                    // The first char is always a "/", and we need it to be relative.
                    const path = url.path.slice(1);
                    if (!path) return queryHash || ".";
                    if (isRelative(base || input) && !isRelative(path)) // If base started with a leading ".", or there is no base and input started with a ".",
                    // then we need to ensure that the relative path starts with a ".". We don't know if
                    // relative starts with a "..", though, so check before prepending.
                    return "./" + path + queryHash;
                    return path + queryHash;
                }
            case UrlType.AbsolutePath:
                return url.path + queryHash;
            default:
                return url.scheme + "//" + url.user + url.host + url.port + url.path + queryHash;
        }
    }
    function resolve(input, base) {
        // The base is always treated as a directory, if it's not empty.
        // https://github.com/mozilla/source-map/blob/8cb3ee57/lib/util.js#L327
        // https://github.com/chromium/chromium/blob/da4adbb3/third_party/blink/renderer/devtools/front_end/sdk/SourceMap.js#L400-L401
        if (base && !base.endsWith("/")) base += "/";
        return resolve$1(input, base);
    }
    /**
 * Removes everything after the last "/", but leaves the slash.
 */ function stripFilename(path) {
        if (!path) return "";
        const index = path.lastIndexOf("/");
        return path.slice(0, index + 1);
    }
    const COLUMN$1 = 0;
    const SOURCES_INDEX$1 = 1;
    const SOURCE_LINE$1 = 2;
    const SOURCE_COLUMN$1 = 3;
    const NAMES_INDEX$1 = 4;
    function maybeSort(mappings, owned) {
        const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);
        if (unsortedIndex === mappings.length) return mappings;
        // If we own the array (meaning we parsed it from JSON), then we're free to directly mutate it. If
        // not, we do not want to modify the consumer's input array.
        if (!owned) mappings = mappings.slice();
        for(let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1))mappings[i] = sortSegments(mappings[i], owned);
        return mappings;
    }
    function nextUnsortedSegmentLine(mappings, start) {
        for(let i = start; i < mappings.length; i++){
            if (!isSorted(mappings[i])) return i;
        }
        return mappings.length;
    }
    function isSorted(line) {
        for(let j = 1; j < line.length; j++){
            if (line[j][COLUMN$1] < line[j - 1][COLUMN$1]) return false;
        }
        return true;
    }
    function sortSegments(line, owned) {
        if (!owned) line = line.slice();
        return line.sort(sortComparator);
    }
    function sortComparator(a, b) {
        return a[COLUMN$1] - b[COLUMN$1];
    }
    let found = false;
    /**
 * A binary search implementation that returns the index if a match is found.
 * If no match is found, then the left-index (the index associated with the item that comes just
 * before the desired index) is returned. To maintain proper sort order, a splice would happen at
 * the next index:
 *
 * ```js
 * const array = [1, 3];
 * const needle = 2;
 * const index = binarySearch(array, needle, (item, needle) => item - needle);
 *
 * assert.equal(index, 0);
 * array.splice(index + 1, 0, needle);
 * assert.deepEqual(array, [1, 2, 3]);
 * ```
 */ function binarySearch(haystack, needle, low, high) {
        while(low <= high){
            const mid = low + (high - low >> 1);
            const cmp = haystack[mid][COLUMN$1] - needle;
            if (cmp === 0) {
                found = true;
                return mid;
            }
            if (cmp < 0) low = mid + 1;
            else high = mid - 1;
        }
        found = false;
        return low - 1;
    }
    function upperBound(haystack, needle, index) {
        for(let i = index + 1; i < haystack.length; index = i++){
            if (haystack[i][COLUMN$1] !== needle) break;
        }
        return index;
    }
    function lowerBound(haystack, needle, index) {
        for(let i = index - 1; i >= 0; index = i--){
            if (haystack[i][COLUMN$1] !== needle) break;
        }
        return index;
    }
    function memoizedState() {
        return {
            lastKey: -1,
            lastNeedle: -1,
            lastIndex: -1
        };
    }
    /**
 * This overly complicated beast is just to record the last tested line/column and the resulting
 * index, allowing us to skip a few tests if mappings are monotonically increasing.
 */ function memoizedBinarySearch(haystack, needle, state, key) {
        const { lastKey: lastKey, lastNeedle: lastNeedle, lastIndex: lastIndex } = state;
        let low = 0;
        let high = haystack.length - 1;
        if (key === lastKey) {
            if (needle === lastNeedle) {
                found = lastIndex !== -1 && haystack[lastIndex][COLUMN$1] === needle;
                return lastIndex;
            }
            if (needle >= lastNeedle) // lastIndex may be -1 if the previous needle was not found.
            low = lastIndex === -1 ? 0 : lastIndex;
            else high = lastIndex;
        }
        state.lastKey = key;
        state.lastNeedle = needle;
        return state.lastIndex = binarySearch(haystack, needle, low, high);
    }
    const LINE_GTR_ZERO = "`line` must be greater than 0 (lines start at line 1)";
    const COL_GTR_EQ_ZERO = "`column` must be greater than or equal to 0 (columns start at column 0)";
    const LEAST_UPPER_BOUND = -1;
    const GREATEST_LOWER_BOUND = 1;
    /**
 * Returns the decoded (array of lines of segments) form of the SourceMap's mappings field.
 */ let decodedMappings;
    /**
 * A low-level API to find the segment associated with a generated line/column (think, from a
 * stack trace). Line and column here are 0-based, unlike `originalPositionFor`.
 */ let traceSegment;
    /**
 * A higher-level API to find the source/line/column associated with a generated line/column
 * (think, from a stack trace). Line is 1-based, but column is 0-based, due to legacy behavior in
 * `source-map` library.
 */ let originalPositionFor$1;
    class TraceMap {
        constructor(map, mapUrl){
            const isString = typeof map === "string";
            if (!isString && map._decodedMemo) return map;
            const parsed = isString ? JSON.parse(map) : map;
            const { version: version, file: file, names: names, sourceRoot: sourceRoot, sources: sources, sourcesContent: sourcesContent } = parsed;
            this.version = version;
            this.file = file;
            this.names = names || [];
            this.sourceRoot = sourceRoot;
            this.sources = sources;
            this.sourcesContent = sourcesContent;
            const from = resolve(sourceRoot || "", stripFilename(mapUrl));
            this.resolvedSources = sources.map((s)=>resolve(s || "", from));
            const { mappings: mappings } = parsed;
            if (typeof mappings === "string") {
                this._encoded = mappings;
                this._decoded = undefined;
            } else {
                this._encoded = undefined;
                this._decoded = maybeSort(mappings, isString);
            }
            this._decodedMemo = memoizedState();
            this._bySources = undefined;
            this._bySourceMemos = undefined;
        }
    }
    (()=>{
        decodedMappings = (map)=>{
            return map._decoded || (map._decoded = decode(map._encoded));
        };
        traceSegment = (map, line, column)=>{
            const decoded = decodedMappings(map);
            // It's common for parent source maps to have pointers to lines that have no
            // mapping (like a "//# sourceMappingURL=") at the end of the child file.
            if (line >= decoded.length) return null;
            const segments = decoded[line];
            const index = traceSegmentInternal(segments, map._decodedMemo, line, column, GREATEST_LOWER_BOUND);
            return index === -1 ? null : segments[index];
        };
        originalPositionFor$1 = (map, { line: line, column: column, bias: bias })=>{
            line--;
            if (line < 0) throw new Error(LINE_GTR_ZERO);
            if (column < 0) throw new Error(COL_GTR_EQ_ZERO);
            const decoded = decodedMappings(map);
            // It's common for parent source maps to have pointers to lines that have no
            // mapping (like a "//# sourceMappingURL=") at the end of the child file.
            if (line >= decoded.length) return OMapping(null, null, null, null);
            const segments = decoded[line];
            const index = traceSegmentInternal(segments, map._decodedMemo, line, column, bias || GREATEST_LOWER_BOUND);
            if (index === -1) return OMapping(null, null, null, null);
            const segment = segments[index];
            if (segment.length === 1) return OMapping(null, null, null, null);
            const { names: names, resolvedSources: resolvedSources } = map;
            return OMapping(resolvedSources[segment[SOURCES_INDEX$1]], segment[SOURCE_LINE$1] + 1, segment[SOURCE_COLUMN$1], segment.length === 5 ? names[segment[NAMES_INDEX$1]] : null);
        };
    })();
    function OMapping(source, line, column, name) {
        return {
            source: source,
            line: line,
            column: column,
            name: name
        };
    }
    function traceSegmentInternal(segments, memo, line, column, bias) {
        let index = memoizedBinarySearch(segments, column, memo, line);
        if (found) index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);
        else if (bias === LEAST_UPPER_BOUND) index++;
        if (index === -1 || index === segments.length) return -1;
        return index;
    }
    /**
 * Gets the index associated with `key` in the backing array, if it is already present.
 */ let get;
    /**
 * Puts `key` into the backing array, if it is not already present. Returns
 * the index of the `key` in the backing array.
 */ let put;
    /**
 * SetArray acts like a `Set` (allowing only one occurrence of a string `key`), but provides the
 * index of the `key` in the backing array.
 *
 * This is designed to allow synchronizing a second array with the contents of the backing array,
 * like how in a sourcemap `sourcesContent[i]` is the source content associated with `source[i]`,
 * and there are never duplicates.
 */ class SetArray {
        constructor(){
            this._indexes = {
                __proto__: null
            };
            this.array = [];
        }
    }
    (()=>{
        get = (strarr, key)=>strarr._indexes[key];
        put = (strarr, key)=>{
            // The key may or may not be present. If it is present, it's a number.
            const index = get(strarr, key);
            if (index !== undefined) return index;
            const { array: array, _indexes: indexes } = strarr;
            return indexes[key] = array.push(key) - 1;
        };
    })();
    const COLUMN = 0;
    const SOURCES_INDEX = 1;
    const SOURCE_LINE = 2;
    const SOURCE_COLUMN = 3;
    const NAMES_INDEX = 4;
    const NO_NAME = -1;
    /**
 * Same as `addSegment`, but will only add the segment if it generates useful information in the
 * resulting map. This only works correctly if segments are added **in order**, meaning you should
 * not add a segment with a lower generated line/column than one that came before.
 */ let maybeAddSegment;
    /**
 * Adds/removes the content of the source file to the source map.
 */ let setSourceContent;
    /**
 * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects
 * a sourcemap, or to JSON.stringify.
 */ let toDecodedMap;
    /**
 * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects
 * a sourcemap, or to JSON.stringify.
 */ let toEncodedMap;
    // This split declaration is only so that terser can elminiate the static initialization block.
    let addSegmentInternal;
    /**
 * Provides the state to generate a sourcemap.
 */ class GenMapping {
        constructor({ file: file, sourceRoot: sourceRoot } = {}){
            this._names = new SetArray();
            this._sources = new SetArray();
            this._sourcesContent = [];
            this._mappings = [];
            this.file = file;
            this.sourceRoot = sourceRoot;
        }
    }
    (()=>{
        maybeAddSegment = (map, genLine, genColumn, source, sourceLine, sourceColumn, name, content)=>{
            return addSegmentInternal(true, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content);
        };
        setSourceContent = (map, source, content)=>{
            const { _sources: sources, _sourcesContent: sourcesContent } = map;
            sourcesContent[put(sources, source)] = content;
        };
        toDecodedMap = (map)=>{
            const { file: file, sourceRoot: sourceRoot, _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names } = map;
            removeEmptyFinalLines(mappings);
            return {
                version: 3,
                file: file || undefined,
                names: names.array,
                sourceRoot: sourceRoot || undefined,
                sources: sources.array,
                sourcesContent: sourcesContent,
                mappings: mappings
            };
        };
        toEncodedMap = (map)=>{
            const decoded = toDecodedMap(map);
            return Object.assign(Object.assign({}, decoded), {
                mappings: encode(decoded.mappings)
            });
        };
        // Internal helpers
        addSegmentInternal = (skipable, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content)=>{
            const { _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names } = map;
            const line = getLine(mappings, genLine);
            const index = getColumnIndex(line, genColumn);
            if (!source) {
                if (skipable && skipSourceless(line, index)) return;
                return insert(line, index, [
                    genColumn
                ]);
            }
            const sourcesIndex = put(sources, source);
            const namesIndex = name ? put(names, name) : NO_NAME;
            if (sourcesIndex === sourcesContent.length) sourcesContent[sourcesIndex] = content !== null && content !== void 0 ? content : null;
            if (skipable && skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex)) return;
            return insert(line, index, name ? [
                genColumn,
                sourcesIndex,
                sourceLine,
                sourceColumn,
                namesIndex
            ] : [
                genColumn,
                sourcesIndex,
                sourceLine,
                sourceColumn
            ]);
        };
    })();
    function getLine(mappings, index) {
        for(let i = mappings.length; i <= index; i++)mappings[i] = [];
        return mappings[index];
    }
    function getColumnIndex(line, genColumn) {
        let index = line.length;
        for(let i = index - 1; i >= 0; index = i--){
            const current = line[i];
            if (genColumn >= current[COLUMN]) break;
        }
        return index;
    }
    function insert(array, index, value) {
        for(let i = array.length; i > index; i--)array[i] = array[i - 1];
        array[index] = value;
    }
    function removeEmptyFinalLines(mappings) {
        const { length: length } = mappings;
        let len = length;
        for(let i = len - 1; i >= 0; len = i, i--){
            if (mappings[i].length > 0) break;
        }
        if (len < length) mappings.length = len;
    }
    function skipSourceless(line, index) {
        // The start of a line is already sourceless, so adding a sourceless segment to the beginning
        // doesn't generate any useful information.
        if (index === 0) return true;
        const prev = line[index - 1];
        // If the previous segment is also sourceless, then adding another sourceless segment doesn't
        // genrate any new information. Else, this segment will end the source/named segment and point to
        // a sourceless position, which is useful.
        return prev.length === 1;
    }
    function skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex) {
        // A source/named segment at the start of a line gives position at that genColumn
        if (index === 0) return false;
        const prev = line[index - 1];
        // If the previous segment is sourceless, then we're transitioning to a source.
        if (prev.length === 1) return false;
        // If the previous segment maps to the exact same source position, then this segment doesn't
        // provide any new position information.
        return sourcesIndex === prev[SOURCES_INDEX] && sourceLine === prev[SOURCE_LINE] && sourceColumn === prev[SOURCE_COLUMN] && namesIndex === (prev.length === 5 ? prev[NAMES_INDEX] : NO_NAME);
    }
    const SOURCELESS_MAPPING = /* #__PURE__ */ SegmentObject("", -1, -1, "", null);
    const EMPTY_SOURCES = [];
    function SegmentObject(source, line, column, name, content) {
        return {
            source: source,
            line: line,
            column: column,
            name: name,
            content: content
        };
    }
    function Source(map, sources, source, content) {
        return {
            map: map,
            sources: sources,
            source: source,
            content: content
        };
    }
    /**
 * MapSource represents a single sourcemap, with the ability to trace mappings into its child nodes
 * (which may themselves be SourceMapTrees).
 */ function MapSource(map, sources) {
        return Source(map, sources, "", null);
    }
    /**
 * A "leaf" node in the sourcemap tree, representing an original, unmodified source file. Recursive
 * segment tracing ends at the `OriginalSource`.
 */ function OriginalSource(source, content) {
        return Source(null, EMPTY_SOURCES, source, content);
    }
    /**
 * traceMappings is only called on the root level SourceMapTree, and begins the process of
 * resolving each mapping in terms of the original source files.
 */ function traceMappings(tree) {
        // TODO: Eventually support sourceRoot, which has to be removed because the sources are already
        // fully resolved. We'll need to make sources relative to the sourceRoot before adding them.
        const gen = new GenMapping({
            file: tree.map.file
        });
        const { sources: rootSources, map: map } = tree;
        const rootNames = map.names;
        const rootMappings = decodedMappings(map);
        for(let i = 0; i < rootMappings.length; i++){
            const segments = rootMappings[i];
            for(let j = 0; j < segments.length; j++){
                const segment = segments[j];
                const genCol = segment[0];
                let traced = SOURCELESS_MAPPING;
                // 1-length segments only move the current generated column, there's no source information
                // to gather from it.
                if (segment.length !== 1) {
                    const source = rootSources[segment[1]];
                    traced = originalPositionFor(source, segment[2], segment[3], segment.length === 5 ? rootNames[segment[4]] : "");
                    // If the trace is invalid, then the trace ran into a sourcemap that doesn't contain a
                    // respective segment into an original source.
                    if (traced == null) continue;
                }
                const { column: column, line: line, name: name, content: content, source: source } = traced;
                maybeAddSegment(gen, i, genCol, source, line, column, name);
                if (source && content != null) setSourceContent(gen, source, content);
            }
        }
        return gen;
    }
    /**
 * originalPositionFor is only called on children SourceMapTrees. It recurses down into its own
 * child SourceMapTrees, until we find the original source map.
 */ function originalPositionFor(source, line, column, name) {
        if (!source.map) return SegmentObject(source.source, line, column, name, source.content);
        const segment = traceSegment(source.map, line, column);
        // If we couldn't find a segment, then this doesn't exist in the sourcemap.
        if (segment == null) return null;
        // 1-length segments only move the current generated column, there's no source information
        // to gather from it.
        if (segment.length === 1) return SOURCELESS_MAPPING;
        return originalPositionFor(source.sources[segment[1]], segment[2], segment[3], segment.length === 5 ? source.map.names[segment[4]] : name);
    }
    function asArray(value) {
        if (Array.isArray(value)) return value;
        return [
            value
        ];
    }
    /**
 * Recursively builds a tree structure out of sourcemap files, with each node
 * being either an `OriginalSource` "leaf" or a `SourceMapTree` composed of
 * `OriginalSource`s and `SourceMapTree`s.
 *
 * Every sourcemap is composed of a collection of source files and mappings
 * into locations of those source files. When we generate a `SourceMapTree` for
 * the sourcemap, we attempt to load each source file's own sourcemap. If it
 * does not have an associated sourcemap, it is considered an original,
 * unmodified source file.
 */ function buildSourceMapTree(input, loader) {
        const maps = asArray(input).map((m)=>new TraceMap(m, ""));
        const map = maps.pop();
        for(let i = 0; i < maps.length; i++){
            if (maps[i].sources.length > 1) throw new Error(`Transformation map ${i} must have exactly one source file.\n` + "Did you specify these with the most recent transformation maps first?");
        }
        let tree = build(map, loader, "", 0);
        for(let i = maps.length - 1; i >= 0; i--)tree = MapSource(maps[i], [
            tree
        ]);
        return tree;
    }
    function build(map, loader, importer, importerDepth) {
        const { resolvedSources: resolvedSources, sourcesContent: sourcesContent } = map;
        const depth = importerDepth + 1;
        const children = resolvedSources.map((sourceFile, i)=>{
            // The loading context gives the loader more information about why this file is being loaded
            // (eg, from which importer). It also allows the loader to override the location of the loaded
            // sourcemap/original source, or to override the content in the sourcesContent field if it's
            // an unmodified source file.
            const ctx = {
                importer: importer,
                depth: depth,
                source: sourceFile || "",
                content: undefined
            };
            // Use the provided loader callback to retrieve the file's sourcemap.
            // TODO: We should eventually support async loading of sourcemap files.
            const sourceMap = loader(ctx.source, ctx);
            const { source: source, content: content } = ctx;
            // If there is a sourcemap, then we need to recurse into it to load its source files.
            if (sourceMap) return build(new TraceMap(sourceMap, source), loader, source, depth);
            // Else, it's an an unmodified source file.
            // The contents of this unmodified source file can be overridden via the loader context,
            // allowing it to be explicitly null or a string. If it remains undefined, we fall back to
            // the importing sourcemap's `sourcesContent` field.
            const sourceContent = content !== undefined ? content : sourcesContent ? sourcesContent[i] : null;
            return OriginalSource(source, sourceContent);
        });
        return MapSource(map, children);
    }
    /**
 * A SourceMap v3 compatible sourcemap, which only includes fields that were
 * provided to it.
 */ let SourceMap$1 = class SourceMap {
        constructor(map, options){
            const out = options.decodedMappings ? toDecodedMap(map) : toEncodedMap(map);
            this.version = out.version; // SourceMap spec says this should be first.
            this.file = out.file;
            this.mappings = out.mappings;
            this.names = out.names;
            this.sourceRoot = out.sourceRoot;
            this.sources = out.sources;
            if (!options.excludeContent) this.sourcesContent = out.sourcesContent;
        }
        toString() {
            return JSON.stringify(this);
        }
    };
    /**
 * Traces through all the mappings in the root sourcemap, through the sources
 * (and their sourcemaps), all the way back to the original source location.
 *
 * `loader` will be called every time we encounter a source file. If it returns
 * a sourcemap, we will recurse into that sourcemap to continue the trace. If
 * it returns a falsey value, that source file is treated as an original,
 * unmodified source file.
 *
 * Pass `excludeContent` to exclude any self-containing source file content
 * from the output sourcemap.
 *
 * Pass `decodedMappings` to receive a SourceMap with decoded (instead of
 * VLQ encoded) mappings.
 */ function remapping(input, loader, options) {
        const opts = typeof options === "object" ? options : {
            excludeContent: !!options,
            decodedMappings: false
        };
        const tree = buildSourceMapTree(input, loader);
        return new SourceMap$1(traceMappings(tree), opts);
    }
    /**
 * @param {string} s
 */ function last_line_length(s) {
        return s.length - s.lastIndexOf("\n") - 1;
    }
    // mutate map in-place
    /**
 * @param {import('@ampproject/remapping').DecodedSourceMap} map
 * @param {{ line: number; column: number; }} offset
 * @param {number} source_index
 */ function sourcemap_add_offset(map, offset, source_index) {
        if (map.mappings.length == 0) return;
        for(let line = 0; line < map.mappings.length; line++){
            const segment_list = map.mappings[line];
            for(let segment = 0; segment < segment_list.length; segment++){
                const seg = segment_list[segment];
                // shift only segments that belong to component source file
                if (seg[1] === source_index) {
                    // also ensures that seg.length >= 4
                    // shift column if it points at the first line
                    if (seg[2] === 0) seg[3] += offset.column;
                    // shift line
                    seg[2] += offset.line;
                }
            }
        }
    }
    /**
 * @template T
 * @param {T[]} this_table
 * @param {T[]} other_table
 * @returns {[T[], number[], boolean, boolean]}
 */ function merge_tables(this_table, other_table) {
        const new_table = this_table.slice();
        const idx_map = [];
        other_table = other_table || [];
        let val_changed = false;
        for (const [other_idx, other_val] of other_table.entries()){
            const this_idx = this_table.indexOf(other_val);
            if (this_idx >= 0) idx_map[other_idx] = this_idx;
            else {
                const new_idx = new_table.length;
                new_table[new_idx] = other_val;
                idx_map[other_idx] = new_idx;
                val_changed = true;
            }
        }
        let idx_changed = val_changed;
        if (val_changed) {
            if (idx_map.find((val, idx)=>val != idx) === undefined) // idx_map is identity map [0, 1, 2, 3, 4, ....]
            idx_changed = false;
        }
        return [
            new_table,
            idx_map,
            val_changed,
            idx_changed
        ];
    }
    const regex_line_token = /([^\d\w\s]|\s+)/g;
    /** */ class MappedCode {
        /**
	 * @type {string}
	 */ string = undefined;
        /**
	 * @type {import('@ampproject/remapping').DecodedSourceMap}
	 */ map = undefined;
        constructor(string = "", map = null){
            this.string = string;
            if (map) this.map = map;
            else this.map = {
                version: 3,
                mappings: [],
                sources: [],
                names: []
            };
        }
        /**
	 * concat in-place (mutable), return this (chainable)
	 * will also mutate the `other` object
	 * @param {MappedCode} other
	 * @returns {MappedCode}
	 */ concat(other) {
            // noop: if one is empty, return the other
            if (other.string == "") return this;
            if (this.string == "") {
                this.string = other.string;
                this.map = other.map;
                return this;
            }
            // compute last line length before mutating
            const column_offset = last_line_length(this.string);
            this.string += other.string;
            const m1 = this.map;
            const m2 = other.map;
            if (m2.mappings.length == 0) return this;
            // combine sources and names
            const [sources, new_source_idx, sources_changed, sources_idx_changed] = merge_tables(m1.sources, m2.sources);
            const [names, new_name_idx, names_changed, names_idx_changed] = merge_tables(m1.names, m2.names);
            if (sources_changed) m1.sources = sources;
            if (names_changed) m1.names = names;
            // unswitched loops are faster
            if (sources_idx_changed && names_idx_changed) for(let line = 0; line < m2.mappings.length; line++){
                const segment_list = m2.mappings[line];
                for(let segment = 0; segment < segment_list.length; segment++){
                    const seg = segment_list[segment];
                    if (seg[1] >= 0) seg[1] = new_source_idx[seg[1]];
                    if (seg[4] >= 0) seg[4] = new_name_idx[seg[4]];
                }
            }
            else if (sources_idx_changed) for(let line = 0; line < m2.mappings.length; line++){
                const segment_list = m2.mappings[line];
                for(let segment = 0; segment < segment_list.length; segment++){
                    const seg = segment_list[segment];
                    if (seg[1] >= 0) seg[1] = new_source_idx[seg[1]];
                }
            }
            else if (names_idx_changed) for(let line = 0; line < m2.mappings.length; line++){
                const segment_list = m2.mappings[line];
                for(let segment = 0; segment < segment_list.length; segment++){
                    const seg = segment_list[segment];
                    if (seg[4] >= 0) seg[4] = new_name_idx[seg[4]];
                }
            }
            // combine the mappings
            // combine
            // 1. last line of first map
            // 2. first line of second map
            // columns of 2 must be shifted
            if (m2.mappings.length > 0 && column_offset > 0) {
                const first_line = m2.mappings[0];
                for(let i = 0; i < first_line.length; i++)first_line[i][0] += column_offset;
            }
            // combine last line + first line
            push_array(m1.mappings[m1.mappings.length - 1], m2.mappings.shift());
            // append other lines
            push_array(m1.mappings, m2.mappings);
            return this;
        }
        /**
	 * @static
	 * @param {string} string
	 * @param {import('@ampproject/remapping').DecodedSourceMap} [map]
	 * @returns {MappedCode}
	 */ static from_processed(string, map) {
            const line_count = string.split("\n").length;
            if (map) {
                // ensure that count of source map mappings lines
                // is equal to count of generated code lines
                // (some tools may produce less)
                const missing_lines = line_count - map.mappings.length;
                for(let i = 0; i < missing_lines; i++)map.mappings.push([]);
                return new MappedCode(string, map);
            }
            if (string == "") return new MappedCode();
            map = {
                version: 3,
                names: [],
                sources: [],
                mappings: []
            };
            // add empty SourceMapSegment[] for every line
            for(let i = 0; i < line_count; i++)map.mappings.push([]);
            return new MappedCode(string, map);
        }
        /**
	 * @static
	 * @param {import('../preprocess/private.js').Source} opts
	 * @returns {MappedCode}
	 */ static from_source({ source: source, file_basename: file_basename, get_location: get_location }) {
            /**
		 * @type {{ line: number; column: number; }}
		 */ let offset = get_location(0);
            if (!offset) offset = {
                line: 0,
                column: 0
            };
            /**
		 * @type {import('@ampproject/remapping').DecodedSourceMap}
		 */ const map = {
                version: 3,
                names: [],
                sources: [
                    file_basename
                ],
                mappings: []
            };
            if (source == "") return new MappedCode(source, map);
            // we create a high resolution identity map here,
            // we know that it will eventually be merged with svelte's map,
            // at which stage the resolution will decrease.
            const line_list = source.split("\n");
            for(let line = 0; line < line_list.length; line++){
                map.mappings.push([]);
                const token_list = line_list[line].split(regex_line_token);
                for(let token = 0, column = 0; token < token_list.length; token++){
                    if (token_list[token] == "") continue;
                    map.mappings[line].push([
                        column,
                        0,
                        offset.line + line,
                        column
                    ]);
                    column += token_list[token].length;
                }
            }
            // shift columns in first line
            const segment_list = map.mappings[0];
            for(let segment = 0; segment < segment_list.length; segment++)segment_list[segment][3] += offset.column;
            return new MappedCode(source, map);
        }
    }
    /**
 * @param {string} filename
 * @param {Array<import('@ampproject/remapping').DecodedSourceMap | import('@ampproject/remapping').RawSourceMap>} sourcemap_list
 */ function combine_sourcemaps(filename, sourcemap_list) {
        if (sourcemap_list.length == 0) return null;
        let map_idx = 1;
        const map = sourcemap_list.slice(0, -1).find((m)=>m.sources.length !== 1) === undefined ? remapping(// use array interface
        // only the oldest sourcemap can have multiple sources
        sourcemap_list, ()=>null, true // skip optional field `sourcesContent`
        ) : remapping(// use loader interface
        sourcemap_list[0], (sourcefile)=>{
            if (sourcefile === filename && sourcemap_list[map_idx]) return sourcemap_list[map_idx++]; // idx 1, 2, ...
            else return null; // source file = leaf node
        }, true);
        if (!map.file) delete map.file; // skip optional field `file`
        // When source maps are combined and the leading map is empty, sources is not set.
        // Add the filename to the empty array in this case.
        // Further improvements to remapping may help address this as well https://github.com/ampproject/remapping/issues/116
        if (!map.sources.length) map.sources = [
            filename
        ];
        return map;
    }
    /**
 * @param {string} filename
 * @param {import('magic-string').SourceMap} svelte_map
 * @param {string | import('@ampproject/remapping').DecodedSourceMap | import('@ampproject/remapping').RawSourceMap} preprocessor_map_input
 * @returns {import('magic-string').SourceMap}
 */ function apply_preprocessor_sourcemap(filename, svelte_map, preprocessor_map_input) {
        if (!svelte_map || !preprocessor_map_input) return svelte_map;
        const preprocessor_map = typeof preprocessor_map_input === "string" ? JSON.parse(preprocessor_map_input) : preprocessor_map_input;
        const result_map = combine_sourcemaps(filename, [
            svelte_map,
            preprocessor_map
        ]);
        // Svelte expects a SourceMap which includes toUrl and toString. Instead of wrapping our output in a class,
        // we just tack on the extra properties.
        Object.defineProperties(result_map, {
            toString: {
                enumerable: false,
                value: function toString() {
                    return JSON.stringify(this);
                }
            },
            toUrl: {
                enumerable: false,
                value: function toUrl() {
                    let b64 = "";
                    if (typeof window !== "undefined" && window.btoa) // btoa doesn't support multi-byte characters
                    b64 = window.btoa(unescape(encodeURIComponent(this.toString())));
                    else if (typeof Buffer !== "undefined") b64 = Buffer.from(this.toString(), "utf8").toString("base64");
                    else throw new Error("Unsupported environment: `window.btoa` or `Buffer` should be present to use toUrl.");
                    return "data:application/json;charset=utf-8;base64," + b64;
                }
            }
        });
        return /** @type {import('magic-string').SourceMap} */ result_map;
    }
    const regex_data_uri = /data:(?:application|text)\/json;(?:charset[:=]\S+?;)?base64,(\S*)/;
    // parse attached sourcemap in processed.code
    /**
 * @param {import('../preprocess/public.js').Processed} processed
 * @param {'script' | 'style'} tag_name
 * @returns {void}
 */ function parse_attached_sourcemap(processed, tag_name) {
        const r_in = "[#@]\\s*sourceMappingURL\\s*=\\s*(\\S*)";
        const regex = tag_name == "script" ? new RegExp("(?://" + r_in + ")|(?:/\\*" + r_in + "\\s*\\*/)$") : new RegExp("/\\*" + r_in + "\\s*\\*/$");
        /**
	 * @param {any} message
	 */ function log_warning(message) {
            // code_start: help to find preprocessor
            const code_start = processed.code.length < 100 ? processed.code : processed.code.slice(0, 100) + " [...]";
            console.warn(`warning: ${message}. processed.code = ${JSON.stringify(code_start)}`);
        }
        processed.code = processed.code.replace(regex, (_, match1, match2)=>{
            const map_url = tag_name == "script" ? match1 || match2 : match1;
            const map_data = (map_url.match(regex_data_uri) || [])[1];
            if (map_data) {
                // sourceMappingURL is data URL
                if (processed.map) {
                    log_warning("Not implemented. Found sourcemap in both processed.code and processed.map. Please update your preprocessor to return only one sourcemap.");
                    // ignore attached sourcemap
                    return "";
                }
                processed.map = atob(map_data); // use attached sourcemap
                return ""; // remove from processed.code
            }
            // sourceMappingURL is path or URL
            if (!processed.map) log_warning(`Found sourcemap path ${JSON.stringify(map_url)} in processed.code, but no sourcemap data. ` + "Please update your preprocessor to return sourcemap data directly.");
            // ignore sourcemap path
            return ""; // remove from processed.code
        });
    }
    /**
 * @param {import("../../interfaces.js").EnableSourcemap} enable_sourcemap
 * @param {keyof Exclude<import("../../interfaces.js").EnableSourcemap, boolean>} namespace
 */ function check_enable_sourcemap(enable_sourcemap, namespace) {
        return typeof enable_sourcemap === "boolean" ? enable_sourcemap : enable_sourcemap[namespace];
    }
    /**
 * @param {import('../Component.js').default} component
 * @param {import('../../interfaces.js').CompileOptions} options
 * @returns {{ js: import('estree').Node[]; css: import('../../interfaces.js').CssResult; }}
 */ function dom(component, options) {
        const { name: name } = component;
        const renderer = new Renderer$1(component, options);
        const { block: block } = renderer;
        block.has_outro_method = true;
        /** @type {import('estree').Node[][]} */ const body = [];
        if (renderer.file_var) {
            const file = component.file ? x$1`"${component.file}"` : x$1`undefined`;
            body.push(b$1`const ${renderer.file_var} = ${file};`);
        }
        const css = component.stylesheet.render(options.filename);
        const css_sourcemap_enabled = check_enable_sourcemap(options.enableSourcemap, "css");
        if (css_sourcemap_enabled) css.map = apply_preprocessor_sourcemap(options.filename, css.map, /** @type {string | import('@ampproject/remapping').RawSourceMap | import('@ampproject/remapping').DecodedSourceMap} */ options.sourcemap);
        else css.map = null;
        const styles = css_sourcemap_enabled && component.stylesheet.has_styles && options.dev ? `${css.code}\n/*# sourceMappingURL=${css.map.toUrl()} */` : css.code;
        const add_css = component.get_unique_name("add_css");
        const should_add_css = !!styles && (options.customElement || options.css === "injected");
        if (should_add_css) body.push(b$1`
			function ${add_css}(target) {
				@append_styles(target, "${component.stylesheet.id}", "${styles}");
			}
		`);
        // fix order
        // TODO the deconflicted names of blocks are reversed... should set them here
        const blocks = renderer.blocks.slice().reverse();
        push_array(body, blocks.map((block)=>{
            // TODO this is a horrible mess — renderer.blocks
            // contains a mixture of Blocks and Nodes
            if (/** @type {import('./Block.js').default} */ block.render) return /** @type {import('./Block.js').default} */ block.render();
            return block;
        }));
        if (options.dev && !options.hydratable) block.chunks.claim.push(b$1`throw new @_Error("options.hydrate only works if the component was compiled with the \`hydratable: true\` option");`);
        const uses_slots = component.var_lookup.has("$$slots");
        /** @type {import('estree').Node[] | undefined} */ let compute_slots;
        if (uses_slots) compute_slots = b$1`
			const $$slots = @compute_slots(#slots);
		`;
        const uses_props = component.var_lookup.has("$$props");
        const uses_rest = component.var_lookup.has("$$restProps");
        const $$props = uses_props || uses_rest ? "$$new_props" : "$$props";
        const props = component.vars.filter((variable)=>!variable.module && variable.export_name);
        const writable_props = props.filter((variable)=>variable.writable);
        const omit_props_names = component.get_unique_name("omit_props_names");
        const compute_rest = x$1`@compute_rest_props($$props, ${omit_props_names.name})`;
        const rest = uses_rest ? b$1`
		const ${omit_props_names.name} = [${props.map((prop)=>`"${prop.export_name}"`).join(",")}];
		let $$restProps = ${compute_rest};
	` : null;
        const set = uses_props || uses_rest || writable_props.length > 0 || component.slots.size > 0 ? x$1`
			${$$props} => {
				${uses_props && renderer.invalidate("$$props", x$1`$$props = @assign(@assign({}, $$props), @exclude_internal_props($$new_props))`)}
				${uses_rest && !uses_props && x$1`$$props = @assign(@assign({}, $$props), @exclude_internal_props($$new_props))`}
				${uses_rest && renderer.invalidate("$$restProps", x$1`$$restProps = ${compute_rest}`)}
				${writable_props.map((prop)=>b$1`if ('${prop.export_name}' in ${$$props}) ${renderer.invalidate(prop.name, x$1`${prop.name} = ${$$props}.${prop.export_name}`)};`)}
				${component.slots.size > 0 && b$1`if ('$$scope' in ${$$props}) ${renderer.invalidate("$$scope", x$1`$$scope = ${$$props}.$$scope`)};`}
			}
		` : null;
        const accessors = [];
        const not_equal = component.component_options.immutable ? x$1`@not_equal` : x$1`@safe_not_equal`;
        /** @type {import('estree').Node[] | import('estree').Node} */ let missing_props_check;
        /** @type {import('estree').Expression} */ let inject_state;
        /** @type {import('estree').Expression} */ let capture_state;
        /** @type {import('estree').Node[] | import('estree').Node} */ let props_inject;
        props.forEach((prop)=>{
            const variable = component.var_lookup.get(prop.name);
            if (!variable.writable || component.component_options.accessors) accessors.push({
                type: "MethodDefinition",
                kind: "get",
                key: {
                    type: "Identifier",
                    name: prop.export_name
                },
                value: x$1`function() {
					return ${prop.hoistable ? prop.name : x$1`this.$$.ctx[${renderer.context_lookup.get(prop.name).index}]`}
				}`
            });
            else if (component.compile_options.dev) accessors.push({
                type: "MethodDefinition",
                kind: "get",
                key: {
                    type: "Identifier",
                    name: prop.export_name
                },
                value: x$1`function() {
					throw new @_Error("<${component.tag}>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
				}`
            });
            if (component.component_options.accessors) {
                if (variable.writable && !renderer.readonly.has(prop.name)) accessors.push({
                    type: "MethodDefinition",
                    kind: "set",
                    key: {
                        type: "Identifier",
                        name: prop.export_name
                    },
                    value: x$1`function(${prop.name}) {
						this.$$set({ ${prop.export_name}: ${prop.name} });
						@flush();
					}`
                });
                else if (component.compile_options.dev) accessors.push({
                    type: "MethodDefinition",
                    kind: "set",
                    key: {
                        type: "Identifier",
                        name: prop.export_name
                    },
                    value: x$1`function(value) {
						throw new @_Error("<${component.tag}>: Cannot set read-only property '${prop.export_name}'");
					}`
                });
            } else if (component.compile_options.dev) accessors.push({
                type: "MethodDefinition",
                kind: "set",
                key: {
                    type: "Identifier",
                    name: prop.export_name
                },
                value: x$1`function(value) {
					throw new @_Error("<${component.tag}>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
				}`
            });
        });
        component.instance_exports_from.forEach((exports_from)=>{
            const import_declaration = {
                ...exports_from,
                type: "ImportDeclaration",
                specifiers: [],
                source: exports_from.source
            };
            component.imports.push(/** @type {import('estree').ImportDeclaration} */ import_declaration);
            exports_from.specifiers.forEach((specifier)=>{
                if (component.component_options.accessors) {
                    const name = component.get_unique_name(specifier.exported.name);
                    import_declaration.specifiers.push({
                        ...specifier,
                        type: "ImportSpecifier",
                        imported: specifier.local,
                        local: name
                    });
                    accessors.push({
                        type: "MethodDefinition",
                        kind: "get",
                        key: {
                            type: "Identifier",
                            name: specifier.exported.name
                        },
                        value: x$1`function() {
						return ${name}
					}`
                    });
                } else if (component.compile_options.dev) accessors.push({
                    type: "MethodDefinition",
                    kind: "get",
                    key: {
                        type: "Identifier",
                        name: specifier.exported.name
                    },
                    value: x$1`function() {
						throw new @_Error("<${component.tag}>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
					}`
                });
            });
        });
        if (component.compile_options.dev) {
            // checking that expected ones were passed
            const expected = props.filter((prop)=>prop.writable && !prop.initialised);
            if (expected.length) missing_props_check = b$1`
				$$self.$$.on_mount.push(function () {
					${expected.map((prop)=>b$1`
					if (${prop.name} === undefined && !(('${prop.export_name}' in $$props) || $$self.$$.bound[$$self.$$.props['${prop.export_name}']])) {
						@_console.warn("<${component.tag}> was created without expected prop '${prop.export_name}'");
					}`)}
				});
			`;
            const capturable_vars = component.vars.filter((v)=>!v.internal && !v.global && !v.name.startsWith("$$"));
            if (capturable_vars.length > 0) capture_state = x$1`() => ({ ${capturable_vars.map((prop)=>p`${prop.name}`)} })`;
            const injectable_vars = capturable_vars.filter((v)=>!v.module && v.writable && v.name[0] !== "$");
            if (uses_props || injectable_vars.length > 0) {
                inject_state = x$1`
				${$$props} => {
					${uses_props && renderer.invalidate("$$props", x$1`$$props = @assign(@assign({}, $$props), $$new_props)`)}
					${injectable_vars.map((v)=>b$1`if ('${v.name}' in $$props) ${renderer.invalidate(v.name, x$1`${v.name} = ${$$props}.${v.name}`)};`)}
				}
			`;
                props_inject = b$1`
				if ($$props && "$$inject" in $$props) {
					$$self.$inject_state($$props.$$inject);
				}
			`;
            }
        }
        // instrument assignments
        if (component.ast.instance) {
            let scope = component.instance_scope;
            const map = component.instance_scope_map;
            /** @type {import('estree').Node | null} */ let execution_context = null;
            walk(component.ast.instance.content, {
                enter (node) {
                    if (map.has(node)) {
                        scope = /** @type {import('periscopic').Scope} */ map.get(node);
                        if (!execution_context && !scope.block) execution_context = node;
                    } else if (!execution_context && node.type === "LabeledStatement" && node.label.name === "$") execution_context = node;
                },
                leave (node) {
                    if (map.has(node)) scope = scope.parent;
                    if (execution_context === node) execution_context = null;
                    if (node.type === "AssignmentExpression" || node.type === "UpdateExpression") {
                        const assignee = node.type === "AssignmentExpression" ? node.left : node.argument;
                        // normally (`a = 1`, `b.c = 2`), there'll be a single name
                        // (a or b). In destructuring cases (`[d, e] = [e, d]`) there
                        // may be more, in which case we need to tack the extra ones
                        // onto the initial function call
                        const names = new Set(extract_names(/** @type {import('estree').Node} */ assignee));
                        this.replace(invalidate(renderer, scope, node, names, execution_context === null));
                    }
                }
            });
            component.rewrite_props(({ name: name, reassigned: reassigned, export_name: export_name })=>{
                const value = `$${name}`;
                const i = renderer.context_lookup.get(`$${name}`).index;
                const insert = reassigned || export_name ? b$1`${`$$subscribe_${name}`}()` : b$1`@component_subscribe($$self, ${name}, #value => $$invalidate(${i}, ${value} = #value))`;
                if (component.compile_options.dev) return b$1`@validate_store(${name}, '${name}'); ${insert}`;
                return insert;
            });
        }
        const args = [
            x$1`$$self`
        ];
        const has_invalidate = props.length > 0 || component.has_reactive_assignments || component.slots.size > 0 || capture_state || inject_state;
        if (has_invalidate) args.push(x$1`$$props`, x$1`$$invalidate`);
        else if (component.compile_options.dev) // $$props arg is still needed for unknown prop check
        args.push(x$1`$$props`);
        // has_create_fragment is intentionally to be true in dev mode.
        const has_create_fragment = component.compile_options.dev || block.has_content();
        if (has_create_fragment) body.push(b$1`
			function create_fragment(#ctx) {
				${block.get_contents()}
			}
		`);
        body.push(b$1`
		${component.extract_javascript(component.ast.module)}

		${component.fully_hoisted}
	`);
        const filtered_props = props.filter((prop)=>{
            const variable = component.var_lookup.get(prop.name);
            if (variable.hoistable) return false;
            return prop.name[0] !== "$";
        });
        const reactive_stores = component.vars.filter((variable)=>variable.name[0] === "$" && variable.name[1] !== "$");
        const instance_javascript = component.extract_javascript(component.ast.instance);
        const has_definition = component.compile_options.dev || instance_javascript && instance_javascript.length > 0 || filtered_props.length > 0 || uses_props || component.partly_hoisted.length > 0 || renderer.initial_context.length > 0 || component.reactive_declarations.length > 0 || capture_state || inject_state;
        const definition = has_definition ? component.alias("instance") : {
            type: "Literal",
            value: null
        };
        const reactive_store_subscriptions = reactive_stores.filter((store)=>{
            const variable = component.var_lookup.get(store.name.slice(1));
            return !variable || variable.hoistable;
        }).map(({ name: name })=>b$1`
			${component.compile_options.dev && b$1`@validate_store(${name.slice(1)}, '${name.slice(1)}');`}
			@component_subscribe($$self, ${name.slice(1)}, $$value => $$invalidate(${renderer.context_lookup.get(name).index}, ${name} = $$value));
		`);
        const resubscribable_reactive_store_unsubscribers = reactive_stores.filter((store)=>{
            const variable = component.var_lookup.get(store.name.slice(1));
            return variable && (variable.reassigned || variable.export_name);
        }).map(({ name: name })=>b$1`$$self.$$.on_destroy.push(() => ${`$$unsubscribe_${name.slice(1)}`}());`);
        if (has_definition) {
            /** @type {import('estree').Node | import('estree').Node[]} */ const reactive_declarations = [];
            /** @type {import('estree').Node[]} */ const fixed_reactive_declarations = []; // not really 'reactive' but whatever
            component.reactive_declarations.forEach((d)=>{
                const dependencies = Array.from(d.dependencies);
                const uses_rest_or_props = !!dependencies.find((n)=>n === "$$props" || n === "$$restProps");
                const writable = dependencies.filter((n)=>{
                    const variable = component.var_lookup.get(n);
                    return variable && (variable.export_name || variable.mutated || variable.reassigned);
                });
                const condition = !uses_rest_or_props && writable.length > 0 && renderer.dirty(writable, true);
                let statement = d.node; // TODO remove label (use d.node.body) if it's not referenced
                if (condition) statement = /** @type {import('estree').Statement} */ b$1`if (${condition}) { ${statement} }`[0];
                if (condition || uses_rest_or_props) reactive_declarations.push(statement);
                else fixed_reactive_declarations.push(statement);
            });
            const injected = Array.from(component.injected_reactive_declaration_vars).filter((name)=>{
                const variable = component.var_lookup.get(name);
                return variable.injected && variable.name[0] !== "$";
            });
            const reactive_store_declarations = reactive_stores.map((variable)=>{
                const $name = variable.name;
                const name = $name.slice(1);
                const store = component.var_lookup.get(name);
                if (store && (store.reassigned || store.export_name)) {
                    const unsubscribe = `$$unsubscribe_${name}`;
                    const subscribe = `$$subscribe_${name}`;
                    const i = renderer.context_lookup.get($name).index;
                    return b$1`let ${$name}, ${unsubscribe} = @noop, ${subscribe} = () => (${unsubscribe}(), ${unsubscribe} = @subscribe(${name}, $$value => $$invalidate(${i}, ${$name} = $$value)), ${name})`;
                }
                return b$1`let ${$name};`;
            });
            /** @type {import('estree').Node[] | undefined} */ let unknown_props_check;
            if (component.compile_options.dev && !(uses_props || uses_rest)) unknown_props_check = b$1`
				const writable_props = [${writable_props.map((prop)=>x$1`'${prop.export_name}'`)}];
				@_Object.keys($$props).forEach(key => {
					if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') @_console.warn(\`<${component.tag}> was created with unknown prop '\${key}'\`);
				});
			`;
            const return_value = {
                type: "ArrayExpression",
                elements: renderer.initial_context.map((member)=>/** @type {import('estree').Expression} */ ({
                        type: "Identifier",
                        name: member.name
                    }))
            };
            body.push(b$1`
			function ${definition}(${args}) {
				${injected.map((name)=>b$1`let ${name};`)}

				${rest}

				${reactive_store_declarations}

				${reactive_store_subscriptions}

				${resubscribable_reactive_store_unsubscribers}

				${component.slots.size || component.compile_options.dev || uses_slots ? b$1`let { $$slots: #slots = {}, $$scope } = $$props;` : null}
				${component.compile_options.dev && b$1`@validate_slots('${component.tag}', #slots, [${[
                ...component.slots.keys()
            ].map((key)=>`'${key}'`).join(",")}]);`}
				${compute_slots}

				${instance_javascript}

				${missing_props_check}
				${unknown_props_check}

				${renderer.binding_groups.size > 0 && b$1`const $$binding_groups = [${[
                ...renderer.binding_groups.keys()
            ].map((_)=>x$1`[]`)}];`}

				${component.partly_hoisted}

				${set && b$1`$$self.$$set = ${set};`}

				${capture_state && b$1`$$self.$capture_state = ${capture_state};`}

				${inject_state && b$1`$$self.$inject_state = ${inject_state};`}

				${props_inject}

				${reactive_declarations.length > 0 && b$1`
				$$self.$$.update = () => {
					${reactive_declarations}
				};
				`}

				${fixed_reactive_declarations}

				${uses_props && b$1`$$props = @exclude_internal_props($$props);`}

				return ${return_value};
			}
		`);
        }
        const prop_indexes = /** @type {import('estree').ObjectExpression} */ x$1`{
		${props.filter((v)=>v.export_name && !v.module).map((v)=>p`${v.export_name}: ${renderer.context_lookup.get(v.name).index}`)}
	}`;
        let dirty;
        if (renderer.context_overflow) {
            dirty = x$1`[]`;
            for(let i = 0; i < renderer.context.length; i += 31)/** @type {any} */ dirty.elements.push(x$1`-1`);
        }
        const superclass = {
            type: "Identifier",
            name: options.dev ? "@SvelteComponentDev" : "@SvelteComponent"
        };
        const optional_parameters = [];
        if (should_add_css) optional_parameters.push(add_css);
        else if (dirty) optional_parameters.push(x$1`null`);
        if (dirty) optional_parameters.push(dirty);
        const declaration = /** @type {import('estree').ClassDeclaration} */ b$1`
		class ${name} extends ${superclass} {
			constructor(options) {
				super(${options.dev && "options"});
				@init(this, options, ${definition}, ${has_create_fragment ? "create_fragment" : "null"}, ${not_equal}, ${prop_indexes}, ${optional_parameters});
				${options.dev && b$1`@dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "${name.name}", options, id: create_fragment.name });`}
			}
		}
	`[0];
        push_array(declaration.body.body, accessors);
        body.push(/** @type {any} */ declaration);
        if (options.customElement) {
            const props_str = writable_props.reduce((def, prop)=>{
                def[prop.export_name] = component.component_options.customElement?.props?.[prop.export_name] || {};
                if (prop.is_boolean && !def[prop.export_name].type) def[prop.export_name].type = "Boolean";
                return def;
            }, {});
            const slots_str = [
                ...component.slots.keys()
            ].map((key)=>`"${key}"`).join(",");
            const accessors_str = accessors.filter((accessor)=>accessor.kind === "get" && !writable_props.some((prop)=>prop.export_name === accessor.key.name)).map((accessor)=>`"${accessor.key.name}"`).join(",");
            const use_shadow_dom = component.component_options.customElement?.shadow !== "none" ? "true" : "false";
            const create_ce = x$1`@create_custom_element(${name}, ${JSON.stringify(props_str)}, [${slots_str}], [${accessors_str}], ${use_shadow_dom}, ${component.component_options.customElement?.extend})`;
            if (component.component_options.customElement?.tag) body.push(b$1`@_customElements.define("${component.component_options.customElement.tag}", ${create_ce});`);
            else body.push(b$1`${create_ce}`);
        }
        if (options.discloseVersion === true) component.imports.unshift({
            type: "ImportDeclaration",
            specifiers: [],
            source: {
                type: "Literal",
                value: `${options.sveltePath ?? "svelte"}/internal/disclose-version`
            }
        });
        return {
            js: flatten$1(body),
            css: css
        };
    }
    /** @param {import('../../../nodes/ConstTag.js').default[]} const_tags */ function get_const_tags(const_tags) {
        if (const_tags.length === 0) return null;
        return {
            type: "VariableDeclaration",
            kind: "let",
            declarations: const_tags.map((const_tag)=>{
                const assignment = const_tag.node.expression;
                return {
                    type: "VariableDeclarator",
                    id: assignment.left,
                    init: assignment.right
                };
            })
        };
    }
    /**
 * @param {import('../../nodes/AwaitBlock.js').default} node
 * @param {import('../Renderer.js').default} renderer
 * @param {import('../private.js').RenderOptions} options
 */ function AwaitBlock(node, renderer, options) {
        renderer.push();
        renderer.render(node.pending.children, options);
        const pending = renderer.pop();
        renderer.push();
        renderer.render(node.then.children, options);
        const then = renderer.pop();
        renderer.add_expression(x$1`
		function(__value) {
			if (@is_promise(__value)) {
				__value.then(null, @noop);
				return ${pending};
			}
			return (function(${node.then_node ? node.then_node : ""}) { ${get_const_tags(node.then.const_tags)}; return ${then}; }(__value));
		}(${node.expression.node})
	`);
    }
    /**
 * @param {import('../../nodes/Comment.js').default} node
 * @param {import('../Renderer.js').default} renderer
 * @param {import('../private.js').RenderOptions} options
 */ function Comment(node, renderer, options) {
        if (options.preserveComments) renderer.add_string(`<!--${node.data}-->`);
    }
    /**
 * @param {import('../../nodes/DebugTag.js').default} node
 * @param {import('../Renderer.js').default} renderer
 * @param {import('../private.js').RenderOptions} options
 */ function DebugTag(node, renderer, options) {
        if (!options.dev) return;
        const filename = options.filename || null;
        const { line: line, column: column } = options.locate(node.start + 1);
        const obj = x$1`{
		${node.expressions.map((e)=>p`${e.node.name}`)}
	}`;
        renderer.add_expression(x$1`@debug(${filename ? x$1`"${filename}"` : x$1`null`}, ${line - 1}, ${column}, ${obj})`);
    }
    /**
 * @param {import('../../nodes/EachBlock.js').default} node
 * @param {import('../Renderer.js').default} renderer
 * @param {import('../private.js').RenderOptions} options
 */ function EachBlock(node, renderer, options) {
        const args = [
            node.context_node
        ];
        if (node.index) args.push({
            type: "Identifier",
            name: node.index
        });
        renderer.push();
        renderer.render(node.children, options);
        const result = renderer.pop();
        const consequent = x$1`@each(${node.expression.node}, (${args}) => { ${get_const_tags(node.const_tags)}; return ${result} })`;
        if (node.else) {
            renderer.push();
            renderer.render(node.else.children, options);
            /** @type {import('estree').Node} */ let alternate = renderer.pop();
            if (node.else.const_tags.length > 0) alternate = x$1`(() => { ${get_const_tags(node.else.const_tags)}; return ${alternate} })()`;
            renderer.add_expression(x$1`${node.expression.node}.length ? ${consequent} : ${alternate}`);
        } else renderer.add_expression(consequent);
    }
    const ATTR_REGEX = /[&"<]/g;
    const CONTENT_REGEX = /[&<]/g;
    /**
 * Note: this method is performance sensitive and has been optimized
 * https://github.com/sveltejs/svelte/pull/5701
 * @param {unknown} value
 * @returns {string}
 */ function escape(value, is_attr = false) {
        const str = String(value);
        const pattern = is_attr ? ATTR_REGEX : CONTENT_REGEX;
        pattern.lastIndex = 0;
        let escaped = "";
        let last = 0;
        while(pattern.test(str)){
            const i = pattern.lastIndex - 1;
            const ch = str[i];
            escaped += str.substring(last, i) + (ch === "&" ? "&amp;" : ch === '"' ? "&quot;" : "&lt;");
            last = i + 1;
        }
        return escaped + str.substring(last);
    }
    /**
 * @param {import('../../../nodes/Attribute.js').default} attribute
 * @returns {import('estree').Expression}
 */ function get_class_attribute_value(attribute) {
        // handle special case — `class={possiblyUndefined}` with scoped CSS
        if (attribute.chunks.length === 2 && /** @type {import('../../../nodes/Text.js').default} */ attribute.chunks[1].synthetic) {
            const value = /** @type {import('../../../nodes/shared/Expression.js').default} */ attribute.chunks[0].node;
            return x$1`@escape(@null_to_empty(${value}), true) + "${/** @type {import('../../../nodes/Text.js').default} */ attribute.chunks[1].data}"`;
        }
        return get_attribute_value(attribute);
    }
    /**
 * @param {import('../../../nodes/Attribute.js').default} attribute
 * @returns {import('estree').Expression}
 */ function get_attribute_value(attribute) {
        if (attribute.chunks.length === 0) return x$1`""`;
        /**
	 * For value attribute of textarea, it will render as child node of `<textarea>` element.
	 * Therefore, we need to escape as content (not attribute).
	 */ const is_textarea_value = attribute.parent.name.toLowerCase() === "textarea" && attribute.name.toLowerCase() === "value";
        return attribute.chunks.map((chunk)=>{
            return chunk.type === "Text" ? /** @type {import('estree').Expression} */ string_literal(escape(chunk.data, true)) : x$1`@escape(${chunk.node}, ${is_textarea_value ? "false" : "true"})`;
        }).reduce((lhs, rhs)=>x$1`${lhs} + ${rhs}`);
    }
    /**
 * @param {import('../../../nodes/Attribute.js').default} attribute
 * @returns {import('estree').Expression}
 */ function get_attribute_expression(attribute) {
        if (attribute.chunks.length === 1 && attribute.chunks[0].type === "Expression") return /** @type {import('estree').Expression} */ /** @type {import('../../../nodes/shared/Expression.js').default} */ attribute.chunks[0].node;
        return get_attribute_value(attribute);
    }
    // similar logic from `compile/render_dom/wrappers/Fragment`
    // We want to remove trailing whitespace inside an element/component/block,
    // *unless* there is no whitespace between this node and its next sibling
    /**
 * @param {import('../../../nodes/interfaces.js').INode[]} children
 * @param {import('../../../nodes/interfaces.js').INode} [next]
 * @returns {import('../../../nodes/interfaces.js').INode[]}
 */ function remove_whitespace_children(children, next) {
        /** @type {import('../../../nodes/interfaces.js').INode[]} */ const nodes = [];
        /** @type {import('../../../nodes/interfaces.js').INode} */ let last_child;
        let i = children.length;
        while(i--){
            const child = children[i];
            if (child.type === "Text") {
                if (child.should_skip()) continue;
                let { data: data } = child;
                if (nodes.length === 0) {
                    const should_trim = next ? next.type === "Text" && regex_starts_with_whitespace.test(next.data) && trimmable_at(child, next) : !child.has_ancestor("EachBlock");
                    if (should_trim && !child.keep_space()) {
                        data = trim_end(data);
                        if (!data) continue;
                    }
                }
                // glue text nodes (which could e.g. be separated by comments) together
                if (last_child && last_child.type === "Text") {
                    last_child.data = data + last_child.data;
                    continue;
                }
                child.data = data;
                nodes.unshift(child);
                link(last_child, last_child = child);
            } else {
                nodes.unshift(child);
                link(last_child, last_child = child);
            }
        }
        const first = nodes[0];
        if (first && first.type === "Text" && !first.keep_space()) {
            first.data = trim_start(first.data);
            if (!first.data) {
                first.var = null;
                nodes.shift();
                if (nodes[0]) nodes[0].prev = null;
            }
        }
        return nodes;
    }
    /**
 * @param {import('../../../nodes/interfaces.js').INode} child
 * @param {import('../../../nodes/interfaces.js').INode} next_sibling
 * @returns {boolean}
 */ function trimmable_at(child, next_sibling) {
        // Whitespace is trimmable if one of the following is true:
        // The child and its sibling share a common nearest each block (not at an each block boundary)
        // The next sibling's previous node is an each block
        return next_sibling.find_nearest(/EachBlock/) === child.find_nearest(/EachBlock/) || next_sibling.prev.type === "EachBlock";
    }
    /**
 * @param {import('../../nodes/Element.js').default} node
 * @param {import('../Renderer.js').default} renderer
 * @param {import('../private.js').RenderOptions} options
 */ function Element(node, renderer, options) {
        const children = remove_whitespace_children(node.children, node.next);
        // awkward special case
        let node_contents;
        const contenteditable = is_contenteditable(node);
        if (node.is_dynamic_element) renderer.push();
        renderer.add_string("<");
        add_tag_name();
        const class_expression_list = node.classes.map((class_directive)=>{
            const { expression: expression, name: name } = class_directive;
            const snippet = expression ? expression.node : x$1`#ctx.${name}`; // TODO is this right?
            return x$1`${snippet} ? "${name}" : ""`;
        });
        if (node.needs_manual_style_scoping) class_expression_list.push(x$1`"${node.component.stylesheet.id}"`);
        const class_expression = class_expression_list.length > 0 && class_expression_list.reduce((lhs, rhs)=>x$1`${lhs} + ' ' + ${rhs}`);
        const style_expression_list = node.styles.map((style_directive)=>{
            let { name: name, important: important, expression: { node: expression } } = style_directive;
            if (important) expression = x$1`${expression} + ' !important'`;
            return p`"${name}": ${expression}`;
        });
        const style_expression = style_expression_list.length > 0 && x$1`{ ${style_expression_list} }`;
        if (node.attributes.some((attr)=>attr.is_spread)) {
            // TODO dry this out
            const args = [];
            node.attributes.forEach((attribute)=>{
                if (attribute.is_spread) args.push(x$1`@escape_object(${attribute.expression.node})`);
                else {
                    const attr_name = node.namespace === namespaces.foreign ? attribute.name : fix_attribute_casing(attribute.name);
                    const name = attribute.name.toLowerCase();
                    if (name === "value" && node.name.toLowerCase() === "textarea") node_contents = get_attribute_value(attribute);
                    else if (attribute.is_true) args.push(x$1`{ ${attr_name}: true }`);
                    else if (boolean_attributes.has(name) && attribute.chunks.length === 1 && attribute.chunks[0].type !== "Text") // a boolean attribute with one non-Text chunk
                    args.push(x$1`{ ${attr_name}: ${/** @type {import('../../nodes/shared/Expression.js').default} */ attribute.chunks[0].node} || null }`);
                    else if (attribute.chunks.length === 1 && attribute.chunks[0].type !== "Text") {
                        const snippet = /** @type {import('../../nodes/shared/Expression.js').default} */ attribute.chunks[0].node;
                        args.push(x$1`{ ${attr_name}: @escape_attribute_value(${snippet}) }`);
                    } else args.push(x$1`{ ${attr_name}: ${get_attribute_value(attribute)} }`);
                }
            });
            renderer.add_expression(x$1`@spread([${args}], { classes: ${class_expression}, styles: ${style_expression} })`);
        } else {
            let add_class_attribute = !!class_expression;
            let add_style_attribute = !!style_expression;
            node.attributes.forEach((attribute)=>{
                const name = attribute.name.toLowerCase();
                const attr_name = node.namespace === namespaces.foreign ? attribute.name : fix_attribute_casing(attribute.name);
                if (name === "value" && node.name.toLowerCase() === "textarea") node_contents = get_attribute_value(attribute);
                else if (attribute.is_true) renderer.add_string(` ${attr_name}`);
                else if (boolean_attributes.has(name) && attribute.chunks.length === 1 && attribute.chunks[0].type !== "Text") {
                    // a boolean attribute with one non-Text chunk
                    renderer.add_string(" ");
                    renderer.add_expression(x$1`${/** @type {import('../../nodes/shared/Expression.js').default} */ attribute.chunks[0].node} ? "${attr_name}" : ""`);
                } else if (name === "class" && class_expression) {
                    add_class_attribute = false;
                    renderer.add_string(` ${attr_name}="`);
                    renderer.add_expression(x$1`[${get_class_attribute_value(attribute)}, ${class_expression}].join(' ').trim()`);
                    renderer.add_string('"');
                } else if (name === "style" && style_expression) {
                    add_style_attribute = false;
                    renderer.add_expression(x$1`@add_styles(@merge_ssr_styles(${get_attribute_value(attribute)}, ${style_expression}))`);
                } else if (attribute.chunks.length === 1 && attribute.chunks[0].type !== "Text") {
                    const snippet = /** @type {import('../../nodes/shared/Expression.js').default} */ attribute.chunks[0].node;
                    renderer.add_expression(x$1`@add_attribute("${attr_name}", ${snippet}, ${boolean_attributes.has(name) ? 1 : 0})`);
                } else {
                    renderer.add_string(` ${attr_name}="`);
                    renderer.add_expression((name === "class" ? get_class_attribute_value : get_attribute_value)(attribute));
                    renderer.add_string('"');
                }
            });
            if (add_class_attribute) renderer.add_expression(x$1`@add_classes((${class_expression}).trim())`);
            if (add_style_attribute) renderer.add_expression(x$1`@add_styles(${style_expression})`);
        }
        node.bindings.forEach((binding)=>{
            const { name: name, expression: expression } = binding;
            if (binding.is_readonly) return;
            if (name === "group") {
                const value_attribute = node.attributes.find(({ name: name })=>name === "value");
                if (value_attribute) {
                    const value = get_attribute_expression(value_attribute);
                    const type = node.get_static_attribute_value("type");
                    const bound = expression.node;
                    const condition = type === "checkbox" ? x$1`~${bound}.indexOf(${value})` : x$1`${value} === ${bound}`;
                    renderer.add_expression(x$1`${condition} ? @add_attribute("checked", true, 1) : ""`);
                }
            } else if (contenteditable && is_name_contenteditable(name)) node_contents = expression.node;
            else if (binding.name === "value" && node.name === "textarea") {
                const snippet = expression.node;
                node_contents = x$1`@escape(${snippet} || "")`;
            } else if (binding.name === "value" && node.name === "select") ;
            else {
                const snippet = expression.node;
                renderer.add_expression(x$1`@add_attribute("${name}", ${snippet}, ${boolean_attributes.has(name) ? 1 : 0})`);
            }
        });
        if (options.hydratable) {
            if (node.can_optimise_hydration && !options.has_added_svelte_hash) {
                renderer.add_string(` data-svelte-h="${node.hash()}"`);
                options = {
                    ...options,
                    has_added_svelte_hash: true
                };
            }
        }
        renderer.add_string(">");
        if (node_contents !== undefined) {
            if (contenteditable) {
                renderer.push();
                renderer.render(children, options);
                const result = renderer.pop();
                renderer.add_expression(x$1`($$value => $$value === void 0 ? ${result} : $$value)(${node_contents})`);
            } else {
                if (node.name === "textarea") {
                    // Two or more leading newlines are required to restore the leading newline immediately after `<textarea>`.
                    // see https://html.spec.whatwg.org/multipage/syntax.html#element-restrictions
                    const value_attribute = node.attributes.find(({ name: name })=>name === "value");
                    if (value_attribute) {
                        const first = value_attribute.chunks[0];
                        if (first && first.type === "Text" && regex_starts_with_newline.test(first.data)) renderer.add_string("\n");
                    }
                }
                renderer.add_expression(node_contents);
            }
            add_close_tag();
        } else {
            if (node.name === "pre") {
                // Two or more leading newlines are required to restore the leading newline immediately after `<pre>`.
                // see https://html.spec.whatwg.org/multipage/grouping-content.html#the-pre-element
                // see https://html.spec.whatwg.org/multipage/syntax.html#element-restrictions
                const first = children[0];
                if (first && first.type === "Text" && regex_starts_with_newline.test(first.data)) renderer.add_string("\n");
            }
            if (node.is_dynamic_element) renderer.push();
            renderer.render(children, options);
            if (node.is_dynamic_element) {
                const children = renderer.pop();
                renderer.add_expression(x$1`@is_void(#tag) ? '' : ${children}`);
            }
            add_close_tag();
        }
        if (node.is_dynamic_element) {
            /** @type {import('estree').Node} */ let content = renderer.pop();
            if (options.dev && node.children.length > 0) content = x$1`(() => { @validate_void_dynamic_element(#tag); return ${content}; })()`;
            renderer.add_expression(x$1`((#tag) => {
			${options.dev && x$1`@validate_dynamic_element(#tag)`}
			return #tag ? ${content} : '';
		})(${node.tag_expr.node})`);
        }
        function add_close_tag() {
            if (node.tag_expr.node.type === "Literal") {
                if (!is_void(/** @type {string} */ node.tag_expr.node.value)) {
                    renderer.add_string("</");
                    add_tag_name();
                    renderer.add_string(">");
                }
                return;
            }
            renderer.add_expression(x$1`@is_void(#tag) ? '' : \`</\${#tag}>\``);
        }
        function add_tag_name() {
            if (node.tag_expr.node.type === "Literal") renderer.add_string(/** @type {string} */ node.tag_expr.node.value);
            else renderer.add_expression(/** @type {import('estree').Expression} */ node.tag_expr.node);
        }
    }
    /**
 * @param {import('../../nodes/Head.js').default} node
 * @param {import('../Renderer.js').default} renderer
 * @param {import('../private.js').RenderOptions} options
 */ function Head(node, renderer, options) {
        const head_options = {
            ...options,
            head_id: node.id
        };
        renderer.push();
        renderer.render(node.children, head_options);
        const result = renderer.pop();
        /** @type {import('estree').Node} */ let expression = result;
        if (options.hydratable) {
            const start_comment = `HEAD_${node.id}_START`;
            const end_comment = `HEAD_${node.id}_END`;
            expression = x$1`'<!-- ${start_comment} -->' + ${expression} + '<!-- ${end_comment} -->'`;
        }
        renderer.add_expression(x$1`$$result.head += ${expression}, ""`);
    }
    /**
 * @param {import('../../nodes/RawMustacheTag.js').default} node
 * @param {import('../Renderer.js').default} renderer
 * @param {import('../private.js').RenderOptions} options
 */ function HtmlTag(node, renderer, options) {
        if (options.hydratable) renderer.add_string("<!-- HTML_TAG_START -->");
        renderer.add_expression(/** @type {import('estree').Expression} */ node.expression.node);
        if (options.hydratable) renderer.add_string("<!-- HTML_TAG_END -->");
    }
    /**
 * @param {import('../../nodes/IfBlock.js').default} node
 * @param {import('../Renderer.js').default} renderer
 * @param {import('../private.js').RenderOptions} options
 */ function IfBlock(node, renderer, options) {
        const condition = node.expression.node;
        renderer.push();
        renderer.render(node.children, options);
        /** @type {import('estree').Node} */ let consequent = renderer.pop();
        if (node.const_tags.length > 0) consequent = x$1`(() => { ${get_const_tags(node.const_tags)}; return ${consequent} })()`;
        renderer.push();
        if (node.else) renderer.render(node.else.children, options);
        /** @type {import('estree').Node} */ let alternate = renderer.pop();
        if (node.else && node.else.const_tags.length > 0) alternate = x$1`(() => { ${get_const_tags(node.else.const_tags)}; return ${alternate} })()`;
        renderer.add_expression(x$1`${condition} ? ${consequent} : ${alternate}`);
    }
    /** @param {any} attribute */ function get_prop_value(attribute) {
        if (attribute.is_true) return x$1`true`;
        if (attribute.chunks.length === 0) return x$1`''`;
        return attribute.chunks.map((chunk)=>{
            if (chunk.type === "Text") return string_literal(chunk.data);
            return chunk.node;
        }).reduce((lhs, rhs)=>x$1`${lhs} + ${rhs}`);
    }
    /**
 * @param {import('../../nodes/InlineComponent.js').default} node
 * @param {import('../Renderer.js').default} renderer
 * @param {import('../private.js').RenderOptions} options
 */ function InlineComponent(node, renderer, options) {
        const binding_props = [];
        const binding_fns = [];
        node.bindings.forEach((binding)=>{
            renderer.has_bindings = true;
            // TODO this probably won't work for contextual bindings
            const snippet = binding.expression.node;
            binding_props.push(p`${binding.name}: ${snippet}`);
            binding_fns.push(p`${binding.name}: $$value => { ${snippet} = $$value; $$settled = false }`);
        });
        const uses_spread = node.attributes.find((attr)=>attr.is_spread);
        let props;
        if (uses_spread) props = x$1`@_Object.assign({}, ${node.attributes.map((attribute)=>{
            if (attribute.is_spread) return attribute.expression.node;
            else return x$1`{ ${attribute.name}: ${get_prop_value(attribute)} }`;
        }).concat(binding_props.map((p)=>x$1`{ ${p} }`))})`;
        else props = x$1`{
			${node.attributes.map((attribute)=>p`${attribute.name}: ${get_prop_value(attribute)}`)},
			${binding_props}
		}`;
        const bindings = x$1`{
		${binding_fns}
	}`;
        const expression = node.name === "svelte:self" ? renderer.name : node.name === "svelte:component" ? x$1`(${node.expression.node}) || @missing_component` : node.name.split(".").reduce(/** @type {any} */ (lhs, rhs)=>x$1`${lhs}.${rhs}`);
        const slot_fns = [];
        const children = node.children;
        if (children.length) {
            const slot_scopes = new Map();
            renderer.render(children, Object.assign({}, options, {
                slot_scopes: slot_scopes
            }));
            slot_scopes.forEach(({ input: input, output: output, statements: statements }, name)=>{
                slot_fns.push(p`${name}: (${input}) => { ${statements}; return ${output}; }`);
            });
        }
        const slots = x$1`{
		${slot_fns}
	}`;
        if (node.css_custom_properties.length > 0) {
            if (node.namespace === namespaces.svg) renderer.add_string('<g style="');
            else renderer.add_string('<div style="display: contents; ');
            node.css_custom_properties.forEach((attr, index)=>{
                renderer.add_string(`${attr.name}:`);
                renderer.add_expression(get_attribute_value(attr));
                renderer.add_string(";");
                if (index < node.css_custom_properties.length - 1) renderer.add_string(" ");
            });
            renderer.add_string('">');
        }
        renderer.add_expression(x$1`@validate_component(${expression}, "${node.name}").$$render($$result, ${props}, ${bindings}, ${slots})`);
        if (node.css_custom_properties.length > 0) {
            if (node.namespace === namespaces.svg) renderer.add_string("</g>");
            else renderer.add_string("</div>");
        }
    }
    /**
 * @param {import('../../nodes/KeyBlock.js').default} node
 * @param {import('../Renderer.js').default} renderer
 * @param {import('../private.js').RenderOptions} options
 */ function KeyBlock(node, renderer, options) {
        renderer.render(node.children, options);
    }
    /**
 * @param {import('../../../nodes/Let.js').default[]} lets
 * @returns {import('estree').ObjectPattern}
 */ function get_slot_scope(lets) {
        if (lets.length === 0) return null;
        return {
            type: "ObjectPattern",
            properties: lets.map((l)=>{
                return {
                    type: "Property",
                    kind: "init",
                    method: false,
                    shorthand: false,
                    computed: false,
                    key: l.name,
                    value: l.value || l.name
                };
            })
        };
    }
    /**
 * @param {import('../../nodes/Slot.js').default} node
 * @param {import('../Renderer.js').default} renderer
 * @param {import('../private.js').RenderOptions & {
 * 		slot_scopes: Map<any, any>;
 * 	}} options
 */ function Slot(node, renderer, options) {
        const slot_data = get_slot_data(node.values);
        const slot = node.get_static_attribute_value("slot");
        const nearest_inline_component = node.find_nearest(/InlineComponent/);
        if (slot && nearest_inline_component) renderer.push();
        renderer.push();
        renderer.render(node.children, options);
        const result = renderer.pop();
        renderer.add_expression(x$1`
		#slots.${node.slot_name}
			? #slots.${node.slot_name}(${slot_data})
			: ${result}
	`);
        if (slot && nearest_inline_component) options.slot_scopes.set(slot, {
            input: get_slot_scope(node.lets),
            output: renderer.pop()
        });
    }
    /**
 * @param {import('../../nodes/SlotTemplate.js').default} node
 * @param {import('../Renderer.js').default} renderer
 * @param {import('../private.js').RenderOptions & {
 * 		slot_scopes: Map<any, any>;
 * 	}} options
 */ function SlotTemplate(node, renderer, options) {
        const parent_inline_component = /** @type {import('../../nodes/InlineComponent.js').default} */ node.parent;
        const children = remove_whitespace_children(node instanceof SlotTemplate$1 ? node.children : [
            node
        ], node.next);
        renderer.push();
        renderer.render(children, options);
        const slot_fragment_content = renderer.pop();
        if (!is_empty_template_literal(slot_fragment_content)) {
            if (options.slot_scopes.has(node.slot_template_name)) {
                if (node.slot_template_name === "default") throw new Error('Found elements without slot attribute when using slot="default"');
                throw new Error(`Duplicate slot name "${node.slot_template_name}" in <${parent_inline_component.name}>`);
            }
            options.slot_scopes.set(node.slot_template_name, {
                input: get_slot_scope(node.lets),
                output: slot_fragment_content,
                statements: get_const_tags(node.const_tags)
            });
        }
    }
    /** @param {any} template_literal */ function is_empty_template_literal(template_literal) {
        return template_literal.expressions.length === 0 && template_literal.quasis.length === 1 && template_literal.quasis[0].value.raw === "";
    }
    /**
 * @param {any} node
 * @param {import('../Renderer.js').default} renderer
 * @param {import('../private.js').RenderOptions} _options
 */ function Tag(node, renderer, _options) {
        const snippet = node.expression.node;
        renderer.add_expression(node.parent && node.parent.type === "Element" && node.parent.name === "style" ? snippet : x$1`@escape(${snippet})`);
    }
    /**
 * @param {import('../../nodes/Text.js').default} node
 * @param {import('../Renderer.js').default} renderer
 * @param {import('../private.js').RenderOptions} _options
 */ function Text(node, renderer, _options) {
        let text = node.data;
        if (node.use_space()) text = " ";
        else if (// prettier formats one of the type casts incorrectly, moving it outside the parens, therefore disable
        // prettier-ignore
        !node.parent || node.parent.type !== "Element" || /** @type {import('../../nodes/Element.js').default} */ node.parent.name !== "script" && /** @type {import('../../nodes/Element.js').default} */ node.parent.name !== "style") // unless this Text node is inside a <script> or <style> element, escape &,<,>
        text = escape_html(text);
        renderer.add_string(text);
    }
    /**
 * @param {import('../../nodes/Title.js').default} node
 * @param {import('../Renderer.js').default} renderer
 * @param {import('../private.js').RenderOptions} options
 */ function Title(node, renderer, options) {
        renderer.push();
        renderer.add_string("<title>");
        renderer.render(node.children, options);
        renderer.add_string("</title>");
        const result = renderer.pop();
        renderer.add_expression(x$1`$$result.title = ${result}, ""`);
    }
    /**
 * Collapse string literals together
 * @param {import('estree').TemplateLiteral} literal
 */ function collapse_template_literal(literal) {
        if (!literal.quasis.length) return;
        const collapsed_quasis = [];
        const collapsed_expressions = [];
        let cur_quasi = literal.quasis[0];
        // An expression always follows a quasi and vice versa, ending with a quasi
        for(let i = 0; i < literal.quasis.length; i++){
            const expr = literal.expressions[i];
            const next_quasi = literal.quasis[i + 1];
            // If an expression is a simple string literal, combine it with its preceding
            // and following quasi
            if (next_quasi && expr && expr.type === "Literal" && typeof expr.value === "string") cur_quasi.value.raw += escape_template(expr.value) + next_quasi.value.raw;
            else {
                if (expr) collapsed_expressions.push(expr);
                collapsed_quasis.push(cur_quasi);
                cur_quasi = next_quasi;
            }
        }
        literal.quasis = collapsed_quasis;
        literal.expressions = collapsed_expressions;
    }
    function noop() {}
    /** @type {Record<string, {(node: any, renderer: Renderer, options: import('../../interfaces.js').CompileOptions): void}>} */ const handlers = {
        AwaitBlock: AwaitBlock,
        Body: noop,
        Comment: Comment,
        DebugTag: DebugTag,
        Document: noop,
        EachBlock: EachBlock,
        Element: Element,
        Head: Head,
        IfBlock: IfBlock,
        InlineComponent: InlineComponent,
        KeyBlock: KeyBlock,
        MustacheTag: Tag,
        Options: noop,
        RawMustacheTag: HtmlTag,
        Slot: Slot,
        SlotTemplate: SlotTemplate,
        Text: Text,
        Title: Title,
        Window: noop
    };
    class Renderer {
        has_bindings = false;
        /** @type {import('estree').Identifier} */ name = undefined;
        /** @type {Array<{ current: { value: string }; literal: import('estree').TemplateLiteral }>} */ stack = [];
        /** @type {{ value: string }} */ current = undefined;
        /** @type {import('estree').TemplateLiteral} */ literal = undefined;
        /** @type {import('../../interfaces.js').AppendTarget[]} */ targets = [];
        constructor({ name: name }){
            this.name = name;
            this.push();
        }
        /** @param {string} str */ add_string(str) {
            this.current.value += escape_template(str);
        }
        /** @param {import('estree').Expression} node */ add_expression(node) {
            this.literal.quasis.push({
                type: "TemplateElement",
                value: {
                    raw: this.current.value,
                    cooked: null
                },
                tail: false
            });
            this.literal.expressions.push(node);
            this.current.value = "";
        }
        push() {
            const current = this.current = {
                value: ""
            };
            const literal = this.literal = {
                type: "TemplateLiteral",
                expressions: [],
                quasis: []
            };
            this.stack.push({
                current: current,
                literal: literal
            });
        }
        pop() {
            this.literal.quasis.push({
                type: "TemplateElement",
                value: {
                    raw: this.current.value,
                    cooked: null
                },
                tail: true
            });
            const popped = this.stack.pop();
            const last = this.stack[this.stack.length - 1];
            if (last) {
                this.literal = last.literal;
                this.current = last.current;
            }
            // Optimize the TemplateLiteral to remove unnecessary nodes
            collapse_template_literal(popped.literal);
            return popped.literal;
        }
        /**
	 * @param {import('../nodes/interfaces.js').INode[]} nodes
	 * @param {import('./private.js').RenderOptions} options
	 */ render(nodes, options) {
            nodes.forEach((node)=>{
                const handler = handlers[node.type];
                if (!handler) throw new Error(`No handler for '${node.type}' nodes`);
                handler(node, this, options);
            });
        }
    }
    /**
 * @param {import('../Component.js').default} component
 * @param {import('../../interfaces.js').CompileOptions} options
 * @returns {{ js: import('estree').Node[]; css: import('../../interfaces.js').CssResult; }}
 */ function ssr(component, options) {
        const renderer = new Renderer({
            name: component.name
        });
        const { name: name } = component;
        // create $$render function
        renderer.render(trim(component.fragment.children), Object.assign({
            locate: component.locate
        }, options));
        // TODO put this inside the Renderer class
        const literal = renderer.pop();
        // TODO concatenate CSS maps
        const css = options.customElement ? {
            code: null,
            map: null
        } : component.stylesheet.render(options.filename);
        const uses_rest = component.var_lookup.has("$$restProps");
        const props = component.vars.filter((variable)=>!variable.module && variable.export_name);
        const rest = uses_rest ? b$1`let $$restProps = @compute_rest_props($$props, [${props.map((prop)=>`"${prop.export_name}"`).join(",")}]);` : null;
        const uses_slots = component.var_lookup.has("$$slots");
        const slots = uses_slots ? b$1`let $$slots = @compute_slots(#slots);` : null;
        const reactive_stores = component.vars.filter((variable)=>variable.name[0] === "$" && variable.name[1] !== "$");
        const reactive_store_subscriptions = reactive_stores.filter((store)=>{
            const variable = component.var_lookup.get(store.name.slice(1));
            return !variable || variable.hoistable;
        }).map(({ name: name })=>{
            const store_name = name.slice(1);
            return b$1`
				${component.compile_options.dev && b$1`@validate_store(${store_name}, '${store_name}');`}
				${`$$unsubscribe_${store_name}`} = @subscribe(${store_name}, #value => ${name} = #value)
			`;
        });
        const reactive_store_unsubscriptions = reactive_stores.map(({ name: name })=>b$1`${`$$unsubscribe_${name.slice(1)}`}()`);
        const reactive_store_declarations = reactive_stores.map(({ name: name })=>{
            const store_name = name.slice(1);
            const store = component.var_lookup.get(store_name);
            if (store && store.reassigned) {
                const unsubscribe = `$$unsubscribe_${store_name}`;
                const subscribe = `$$subscribe_${store_name}`;
                return b$1`let ${name}, ${unsubscribe} = @noop, ${subscribe} = () => (${unsubscribe}(), ${unsubscribe} = @subscribe(${store_name}, $$value => ${name} = $$value), ${store_name})`;
            }
            return b$1`let ${name}, ${`$$unsubscribe_${store_name}`};`;
        });
        // instrument get/set store value
        if (component.ast.instance) {
            let scope = component.instance_scope;
            const map = component.instance_scope_map;
            walk(component.ast.instance.content, {
                enter (node) {
                    if (map.has(node)) scope = map.get(node);
                },
                leave (node) {
                    if (map.has(node)) scope = scope.parent;
                    if (node.type === "AssignmentExpression" || node.type === "UpdateExpression") {
                        const assignee = node.type === "AssignmentExpression" ? node.left : node.argument;
                        const names = new Set(extract_names(/** @type {import('estree').Node} */ assignee));
                        const to_invalidate = new Set();
                        for (const name of names){
                            const variable = component.var_lookup.get(name);
                            if (variable && !variable.hoistable && !variable.global && !variable.module && (variable.subscribable || variable.name[0] === "$")) to_invalidate.add(variable.name);
                        }
                        if (to_invalidate.size) this.replace(invalidate(/** @type {any} */ {
                            component: component
                        }, scope, node, to_invalidate, true));
                    }
                }
            });
        }
        component.rewrite_props(({ name: name, reassigned: reassigned })=>{
            const value = `$${name}`;
            let insert = reassigned ? b$1`${`$$subscribe_${name}`}()` : b$1`${`$$unsubscribe_${name}`} = @subscribe(${name}, #value => $${value} = #value)`;
            if (component.compile_options.dev) insert = b$1`@validate_store(${name}, '${name}'); ${insert}`;
            return insert;
        });
        const instance_javascript = component.extract_javascript(component.ast.instance);
        // TODO only do this for props with a default value
        const parent_bindings = instance_javascript ? component.vars.filter((variable)=>!variable.module && variable.export_name).map((prop)=>{
            return b$1`if ($$props.${prop.export_name} === void 0 && $$bindings.${prop.export_name} && ${prop.name} !== void 0) $$bindings.${prop.export_name}(${prop.name});`;
        }) : [];
        const injected = Array.from(component.injected_reactive_declaration_vars).filter((name)=>{
            const variable = component.var_lookup.get(name);
            return variable.injected;
        });
        const reactive_declarations = component.reactive_declarations.map((d)=>{
            const body = /** @type {import('estree').LabeledStatement} */ d.node.body;
            let statement = b$1`${body}`;
            if (!d.declaration) // TODO do not add label if it's not referenced
            statement = b$1`$: { ${statement} }`;
            return statement;
        });
        const main = renderer.has_bindings ? b$1`
			let $$settled;
			let $$rendered;
			let #previous_head = $$result.head;

			do {
				$$settled = true;
				// $$result.head is mutated by the literal expression
				// need to reset it if we're looping back to prevent duplication
				$$result.head = #previous_head;

				${reactive_declarations}

				$$rendered = ${literal};
			} while (!$$settled);

			${reactive_store_unsubscriptions}

			return $$rendered;
		` : b$1`
			${reactive_declarations}

			${reactive_store_unsubscriptions}

			return ${literal};`;
        const blocks = [
            ...injected.map((name)=>b$1`let ${name};`),
            rest,
            slots,
            ...reactive_store_declarations,
            ...reactive_store_subscriptions,
            instance_javascript,
            ...parent_bindings,
            css.code && b$1`$$result.css.add(#css);`,
            main
        ].filter(Boolean);
        const css_sourcemap_enabled = check_enable_sourcemap(options.enableSourcemap, "css");
        const js = b$1`
		${css.code ? b$1`
		const #css = {
			code: "${css.code}",
			map: ${css_sourcemap_enabled && css.map ? string_literal(css.map.toString()) : "null"}
		};` : null}

		${component.extract_javascript(component.ast.module)}

		${component.fully_hoisted}

		const ${name} = @create_ssr_component(($$result, $$props, $$bindings, #slots) => {
			${blocks}
		});
	`;
        return {
            js: js,
            css: css
        };
    }
    /** @param {import('../nodes/interfaces.js').INode[]} nodes */ function trim(nodes) {
        let start = 0;
        for(; start < nodes.length; start += 1){
            const node = /** @type {import('../nodes/Text.js').default} */ nodes[start];
            if (node.type !== "Text") break;
            node.data = node.data.replace(/^\s+/, "");
            if (node.data) break;
        }
        let end = nodes.length;
        for(; end > start; end -= 1){
            const node = /** @type {import('../nodes/Text.js').default} */ nodes[end - 1];
            if (node.type !== "Text") break;
            node.data = node.data.trimRight();
            if (node.data) break;
        }
        return nodes.slice(start, end);
    }
    /** ----------------------------------------------------------------------
This file is automatically generated by `scripts/globals-extractor.js`.
Generated At: 2023-08-11T04:11:50.562Z
---------------------------------------------------------------------- */ var globals = new Set([
        "AbortController",
        "AbortSignal",
        "AbstractRange",
        "ActiveXObject",
        "AggregateError",
        "AnalyserNode",
        "Animation",
        "AnimationEffect",
        "AnimationEvent",
        "AnimationPlaybackEvent",
        "AnimationTimeline",
        "Array",
        "ArrayBuffer",
        "Atomics",
        "Attr",
        "Audio",
        "AudioBuffer",
        "AudioBufferSourceNode",
        "AudioContext",
        "AudioDestinationNode",
        "AudioListener",
        "AudioNode",
        "AudioParam",
        "AudioParamMap",
        "AudioProcessingEvent",
        "AudioScheduledSourceNode",
        "AudioWorklet",
        "AudioWorkletNode",
        "AuthenticatorAssertionResponse",
        "AuthenticatorAttestationResponse",
        "AuthenticatorResponse",
        "BarProp",
        "BaseAudioContext",
        "BeforeUnloadEvent",
        "BigInt",
        "BigInt64Array",
        "BigUint64Array",
        "BiquadFilterNode",
        "Blob",
        "BlobEvent",
        "Boolean",
        "BroadcastChannel",
        "ByteLengthQueuingStrategy",
        "CDATASection",
        "CSS",
        "CSSAnimation",
        "CSSConditionRule",
        "CSSCounterStyleRule",
        "CSSFontFaceRule",
        "CSSGroupingRule",
        "CSSImportRule",
        "CSSKeyframeRule",
        "CSSKeyframesRule",
        "CSSMediaRule",
        "CSSNamespaceRule",
        "CSSPageRule",
        "CSSRule",
        "CSSRuleList",
        "CSSStyleDeclaration",
        "CSSStyleRule",
        "CSSStyleSheet",
        "CSSSupportsRule",
        "CSSTransition",
        "Cache",
        "CacheStorage",
        "CanvasCaptureMediaStreamTrack",
        "CanvasGradient",
        "CanvasPattern",
        "CanvasRenderingContext2D",
        "ChannelMergerNode",
        "ChannelSplitterNode",
        "CharacterData",
        "ClientRect",
        "Clipboard",
        "ClipboardEvent",
        "ClipboardItem",
        "CloseEvent",
        "Comment",
        "CompositionEvent",
        "ConstantSourceNode",
        "ConvolverNode",
        "CountQueuingStrategy",
        "Credential",
        "CredentialsContainer",
        "Crypto",
        "CryptoKey",
        "CustomElementRegistry",
        "CustomEvent",
        "DOMException",
        "DOMImplementation",
        "DOMMatrix",
        "DOMMatrixReadOnly",
        "DOMParser",
        "DOMPoint",
        "DOMPointReadOnly",
        "DOMQuad",
        "DOMRect",
        "DOMRectList",
        "DOMRectReadOnly",
        "DOMStringList",
        "DOMStringMap",
        "DOMTokenList",
        "DataTransfer",
        "DataTransferItem",
        "DataTransferItemList",
        "DataView",
        "Date",
        "DelayNode",
        "DeviceMotionEvent",
        "DeviceOrientationEvent",
        "Document",
        "DocumentFragment",
        "DocumentTimeline",
        "DocumentType",
        "DragEvent",
        "DynamicsCompressorNode",
        "Element",
        "ElementInternals",
        "Enumerator",
        "Error",
        "ErrorEvent",
        "EvalError",
        "Event",
        "EventCounts",
        "EventSource",
        "EventTarget",
        "External",
        "File",
        "FileList",
        "FileReader",
        "FileSystem",
        "FileSystemDirectoryEntry",
        "FileSystemDirectoryHandle",
        "FileSystemDirectoryReader",
        "FileSystemEntry",
        "FileSystemFileEntry",
        "FileSystemFileHandle",
        "FileSystemHandle",
        "FinalizationRegistry",
        "Float32Array",
        "Float64Array",
        "FocusEvent",
        "FontFace",
        "FontFaceSet",
        "FontFaceSetLoadEvent",
        "FormData",
        "FormDataEvent",
        "Function",
        "GainNode",
        "Gamepad",
        "GamepadButton",
        "GamepadEvent",
        "GamepadHapticActuator",
        "Geolocation",
        "GeolocationCoordinates",
        "GeolocationPosition",
        "GeolocationPositionError",
        "HTMLAllCollection",
        "HTMLAnchorElement",
        "HTMLAreaElement",
        "HTMLAudioElement",
        "HTMLBRElement",
        "HTMLBaseElement",
        "HTMLBodyElement",
        "HTMLButtonElement",
        "HTMLCanvasElement",
        "HTMLCollection",
        "HTMLDListElement",
        "HTMLDataElement",
        "HTMLDataListElement",
        "HTMLDetailsElement",
        "HTMLDialogElement",
        "HTMLDirectoryElement",
        "HTMLDivElement",
        "HTMLDocument",
        "HTMLElement",
        "HTMLEmbedElement",
        "HTMLFieldSetElement",
        "HTMLFontElement",
        "HTMLFormControlsCollection",
        "HTMLFormElement",
        "HTMLFrameElement",
        "HTMLFrameSetElement",
        "HTMLHRElement",
        "HTMLHeadElement",
        "HTMLHeadingElement",
        "HTMLHtmlElement",
        "HTMLIFrameElement",
        "HTMLImageElement",
        "HTMLInputElement",
        "HTMLLIElement",
        "HTMLLabelElement",
        "HTMLLegendElement",
        "HTMLLinkElement",
        "HTMLMapElement",
        "HTMLMarqueeElement",
        "HTMLMediaElement",
        "HTMLMenuElement",
        "HTMLMetaElement",
        "HTMLMeterElement",
        "HTMLModElement",
        "HTMLOListElement",
        "HTMLObjectElement",
        "HTMLOptGroupElement",
        "HTMLOptionElement",
        "HTMLOptionsCollection",
        "HTMLOutputElement",
        "HTMLParagraphElement",
        "HTMLParamElement",
        "HTMLPictureElement",
        "HTMLPreElement",
        "HTMLProgressElement",
        "HTMLQuoteElement",
        "HTMLScriptElement",
        "HTMLSelectElement",
        "HTMLSlotElement",
        "HTMLSourceElement",
        "HTMLSpanElement",
        "HTMLStyleElement",
        "HTMLTableCaptionElement",
        "HTMLTableCellElement",
        "HTMLTableColElement",
        "HTMLTableElement",
        "HTMLTableRowElement",
        "HTMLTableSectionElement",
        "HTMLTemplateElement",
        "HTMLTextAreaElement",
        "HTMLTimeElement",
        "HTMLTitleElement",
        "HTMLTrackElement",
        "HTMLUListElement",
        "HTMLUnknownElement",
        "HTMLVideoElement",
        "HashChangeEvent",
        "Headers",
        "History",
        "IDBCursor",
        "IDBCursorWithValue",
        "IDBDatabase",
        "IDBFactory",
        "IDBIndex",
        "IDBKeyRange",
        "IDBObjectStore",
        "IDBOpenDBRequest",
        "IDBRequest",
        "IDBTransaction",
        "IDBVersionChangeEvent",
        "IIRFilterNode",
        "IdleDeadline",
        "Image",
        "ImageBitmap",
        "ImageBitmapRenderingContext",
        "ImageData",
        "Infinity",
        "InputDeviceInfo",
        "InputEvent",
        "Int16Array",
        "Int32Array",
        "Int8Array",
        "InternalError",
        "IntersectionObserver",
        "IntersectionObserverEntry",
        "Intl",
        "JSON",
        "KeyboardEvent",
        "KeyframeEffect",
        "Location",
        "Lock",
        "LockManager",
        "Map",
        "Math",
        "MathMLElement",
        "MediaCapabilities",
        "MediaDeviceInfo",
        "MediaDevices",
        "MediaElementAudioSourceNode",
        "MediaEncryptedEvent",
        "MediaError",
        "MediaKeyMessageEvent",
        "MediaKeySession",
        "MediaKeyStatusMap",
        "MediaKeySystemAccess",
        "MediaKeys",
        "MediaList",
        "MediaMetadata",
        "MediaQueryList",
        "MediaQueryListEvent",
        "MediaRecorder",
        "MediaRecorderErrorEvent",
        "MediaSession",
        "MediaSource",
        "MediaStream",
        "MediaStreamAudioDestinationNode",
        "MediaStreamAudioSourceNode",
        "MediaStreamTrack",
        "MediaStreamTrackEvent",
        "MessageChannel",
        "MessageEvent",
        "MessagePort",
        "MimeType",
        "MimeTypeArray",
        "MouseEvent",
        "MutationEvent",
        "MutationObserver",
        "MutationRecord",
        "NaN",
        "NamedNodeMap",
        "NavigationPreloadManager",
        "Navigator",
        "NetworkInformation",
        "Node",
        "NodeFilter",
        "NodeIterator",
        "NodeList",
        "Notification",
        "Number",
        "Object",
        "OfflineAudioCompletionEvent",
        "OfflineAudioContext",
        "Option",
        "OscillatorNode",
        "OverconstrainedError",
        "PageTransitionEvent",
        "PannerNode",
        "Path2D",
        "PaymentAddress",
        "PaymentMethodChangeEvent",
        "PaymentRequest",
        "PaymentRequestUpdateEvent",
        "PaymentResponse",
        "Performance",
        "PerformanceEntry",
        "PerformanceEventTiming",
        "PerformanceMark",
        "PerformanceMeasure",
        "PerformanceNavigation",
        "PerformanceNavigationTiming",
        "PerformanceObserver",
        "PerformanceObserverEntryList",
        "PerformancePaintTiming",
        "PerformanceResourceTiming",
        "PerformanceServerTiming",
        "PerformanceTiming",
        "PeriodicWave",
        "PermissionStatus",
        "Permissions",
        "PictureInPictureWindow",
        "Plugin",
        "PluginArray",
        "PointerEvent",
        "PopStateEvent",
        "ProcessingInstruction",
        "ProgressEvent",
        "Promise",
        "PromiseRejectionEvent",
        "Proxy",
        "PublicKeyCredential",
        "PushManager",
        "PushSubscription",
        "PushSubscriptionOptions",
        "RTCCertificate",
        "RTCDTMFSender",
        "RTCDTMFToneChangeEvent",
        "RTCDataChannel",
        "RTCDataChannelEvent",
        "RTCDtlsTransport",
        "RTCEncodedAudioFrame",
        "RTCEncodedVideoFrame",
        "RTCError",
        "RTCErrorEvent",
        "RTCIceCandidate",
        "RTCIceTransport",
        "RTCPeerConnection",
        "RTCPeerConnectionIceErrorEvent",
        "RTCPeerConnectionIceEvent",
        "RTCRtpReceiver",
        "RTCRtpSender",
        "RTCRtpTransceiver",
        "RTCSctpTransport",
        "RTCSessionDescription",
        "RTCStatsReport",
        "RTCTrackEvent",
        "RadioNodeList",
        "Range",
        "RangeError",
        "ReadableByteStreamController",
        "ReadableStream",
        "ReadableStreamBYOBReader",
        "ReadableStreamBYOBRequest",
        "ReadableStreamDefaultController",
        "ReadableStreamDefaultReader",
        "ReferenceError",
        "Reflect",
        "RegExp",
        "RemotePlayback",
        "Request",
        "ResizeObserver",
        "ResizeObserverEntry",
        "ResizeObserverSize",
        "Response",
        "SVGAElement",
        "SVGAngle",
        "SVGAnimateElement",
        "SVGAnimateMotionElement",
        "SVGAnimateTransformElement",
        "SVGAnimatedAngle",
        "SVGAnimatedBoolean",
        "SVGAnimatedEnumeration",
        "SVGAnimatedInteger",
        "SVGAnimatedLength",
        "SVGAnimatedLengthList",
        "SVGAnimatedNumber",
        "SVGAnimatedNumberList",
        "SVGAnimatedPreserveAspectRatio",
        "SVGAnimatedRect",
        "SVGAnimatedString",
        "SVGAnimatedTransformList",
        "SVGAnimationElement",
        "SVGCircleElement",
        "SVGClipPathElement",
        "SVGComponentTransferFunctionElement",
        "SVGCursorElement",
        "SVGDefsElement",
        "SVGDescElement",
        "SVGElement",
        "SVGEllipseElement",
        "SVGFEBlendElement",
        "SVGFEColorMatrixElement",
        "SVGFEComponentTransferElement",
        "SVGFECompositeElement",
        "SVGFEConvolveMatrixElement",
        "SVGFEDiffuseLightingElement",
        "SVGFEDisplacementMapElement",
        "SVGFEDistantLightElement",
        "SVGFEDropShadowElement",
        "SVGFEFloodElement",
        "SVGFEFuncAElement",
        "SVGFEFuncBElement",
        "SVGFEFuncGElement",
        "SVGFEFuncRElement",
        "SVGFEGaussianBlurElement",
        "SVGFEImageElement",
        "SVGFEMergeElement",
        "SVGFEMergeNodeElement",
        "SVGFEMorphologyElement",
        "SVGFEOffsetElement",
        "SVGFEPointLightElement",
        "SVGFESpecularLightingElement",
        "SVGFESpotLightElement",
        "SVGFETileElement",
        "SVGFETurbulenceElement",
        "SVGFilterElement",
        "SVGForeignObjectElement",
        "SVGGElement",
        "SVGGeometryElement",
        "SVGGradientElement",
        "SVGGraphicsElement",
        "SVGImageElement",
        "SVGLength",
        "SVGLengthList",
        "SVGLineElement",
        "SVGLinearGradientElement",
        "SVGMPathElement",
        "SVGMarkerElement",
        "SVGMaskElement",
        "SVGMatrix",
        "SVGMetadataElement",
        "SVGNumber",
        "SVGNumberList",
        "SVGPathElement",
        "SVGPatternElement",
        "SVGPoint",
        "SVGPointList",
        "SVGPolygonElement",
        "SVGPolylineElement",
        "SVGPreserveAspectRatio",
        "SVGRadialGradientElement",
        "SVGRect",
        "SVGRectElement",
        "SVGSVGElement",
        "SVGScriptElement",
        "SVGSetElement",
        "SVGStopElement",
        "SVGStringList",
        "SVGStyleElement",
        "SVGSwitchElement",
        "SVGSymbolElement",
        "SVGTSpanElement",
        "SVGTextContentElement",
        "SVGTextElement",
        "SVGTextPathElement",
        "SVGTextPositioningElement",
        "SVGTitleElement",
        "SVGTransform",
        "SVGTransformList",
        "SVGUnitTypes",
        "SVGUseElement",
        "SVGViewElement",
        "SafeArray",
        "Screen",
        "ScreenOrientation",
        "ScriptProcessorNode",
        "SecurityPolicyViolationEvent",
        "Selection",
        "ServiceWorker",
        "ServiceWorkerContainer",
        "ServiceWorkerRegistration",
        "Set",
        "ShadowRoot",
        "SharedArrayBuffer",
        "SharedWorker",
        "SourceBuffer",
        "SourceBufferList",
        "SpeechRecognitionAlternative",
        "SpeechRecognitionErrorEvent",
        "SpeechRecognitionResult",
        "SpeechRecognitionResultList",
        "SpeechSynthesis",
        "SpeechSynthesisErrorEvent",
        "SpeechSynthesisEvent",
        "SpeechSynthesisUtterance",
        "SpeechSynthesisVoice",
        "StaticRange",
        "StereoPannerNode",
        "Storage",
        "StorageEvent",
        "StorageManager",
        "String",
        "StyleMedia",
        "StyleSheet",
        "StyleSheetList",
        "SubmitEvent",
        "SubtleCrypto",
        "Symbol",
        "SyntaxError",
        "Text",
        "TextDecoder",
        "TextDecoderStream",
        "TextEncoder",
        "TextEncoderStream",
        "TextMetrics",
        "TextTrack",
        "TextTrackCue",
        "TextTrackCueList",
        "TextTrackList",
        "TimeRanges",
        "Touch",
        "TouchEvent",
        "TouchList",
        "TrackEvent",
        "TransformStream",
        "TransformStreamDefaultController",
        "TransitionEvent",
        "TreeWalker",
        "TypeError",
        "UIEvent",
        "URIError",
        "URL",
        "URLSearchParams",
        "Uint16Array",
        "Uint32Array",
        "Uint8Array",
        "Uint8ClampedArray",
        "VBArray",
        "VTTCue",
        "VTTRegion",
        "ValidityState",
        "VarDate",
        "VideoColorSpace",
        "VideoPlaybackQuality",
        "VisualViewport",
        "WSH",
        "WScript",
        "WaveShaperNode",
        "WeakMap",
        "WeakRef",
        "WeakSet",
        "WebAssembly",
        "WebGL2RenderingContext",
        "WebGLActiveInfo",
        "WebGLBuffer",
        "WebGLContextEvent",
        "WebGLFramebuffer",
        "WebGLProgram",
        "WebGLQuery",
        "WebGLRenderbuffer",
        "WebGLRenderingContext",
        "WebGLSampler",
        "WebGLShader",
        "WebGLShaderPrecisionFormat",
        "WebGLSync",
        "WebGLTexture",
        "WebGLTransformFeedback",
        "WebGLUniformLocation",
        "WebGLVertexArrayObject",
        "WebKitCSSMatrix",
        "WebSocket",
        "WheelEvent",
        "Window",
        "Worker",
        "Worklet",
        "WritableStream",
        "WritableStreamDefaultController",
        "WritableStreamDefaultWriter",
        "XMLDocument",
        "XMLHttpRequest",
        "XMLHttpRequestEventTarget",
        "XMLHttpRequestUpload",
        "XMLSerializer",
        "XPathEvaluator",
        "XPathExpression",
        "XPathResult",
        "XSLTProcessor",
        "addEventListener",
        "alert",
        "atob",
        "blur",
        "btoa",
        "caches",
        "cancelAnimationFrame",
        "cancelIdleCallback",
        "captureEvents",
        "clearInterval",
        "clearTimeout",
        "clientInformation",
        "close",
        "closed",
        "confirm",
        "console",
        "createImageBitmap",
        "crossOriginIsolated",
        "crypto",
        "customElements",
        "decodeURI",
        "decodeURIComponent",
        "devicePixelRatio",
        "dispatchEvent",
        "document",
        "encodeURI",
        "encodeURIComponent",
        "escape",
        "eval",
        "event",
        "external",
        "fetch",
        "focus",
        "frameElement",
        "frames",
        "getComputedStyle",
        "getSelection",
        "global",
        "globalThis",
        "history",
        "importScripts",
        "indexedDB",
        "innerHeight",
        "innerWidth",
        "isFinite",
        "isNaN",
        "isSecureContext",
        "length",
        "localStorage",
        "location",
        "locationbar",
        "matchMedia",
        "menubar",
        "moveBy",
        "moveTo",
        "name",
        "navigator",
        "onabort",
        "onafterprint",
        "onanimationcancel",
        "onanimationend",
        "onanimationiteration",
        "onanimationstart",
        "onauxclick",
        "onbeforeprint",
        "onbeforeunload",
        "onblur",
        "oncanplay",
        "oncanplaythrough",
        "onchange",
        "onclick",
        "onclose",
        "oncontextmenu",
        "oncuechange",
        "ondblclick",
        "ondevicemotion",
        "ondeviceorientation",
        "ondrag",
        "ondragend",
        "ondragenter",
        "ondragleave",
        "ondragover",
        "ondragstart",
        "ondrop",
        "ondurationchange",
        "onemptied",
        "onended",
        "onerror",
        "onfocus",
        "onformdata",
        "ongamepadconnected",
        "ongamepaddisconnected",
        "ongotpointercapture",
        "onhashchange",
        "oninput",
        "oninvalid",
        "onkeydown",
        "onkeypress",
        "onkeyup",
        "onlanguagechange",
        "onload",
        "onloadeddata",
        "onloadedmetadata",
        "onloadstart",
        "onlostpointercapture",
        "onmessage",
        "onmessageerror",
        "onmousedown",
        "onmouseenter",
        "onmouseleave",
        "onmousemove",
        "onmouseout",
        "onmouseover",
        "onmouseup",
        "onoffline",
        "ononline",
        "onorientationchange",
        "onpagehide",
        "onpageshow",
        "onpause",
        "onplay",
        "onplaying",
        "onpointercancel",
        "onpointerdown",
        "onpointerenter",
        "onpointerleave",
        "onpointermove",
        "onpointerout",
        "onpointerover",
        "onpointerup",
        "onpopstate",
        "onprogress",
        "onratechange",
        "onrejectionhandled",
        "onreset",
        "onresize",
        "onscroll",
        "onsecuritypolicyviolation",
        "onseeked",
        "onseeking",
        "onselect",
        "onselectionchange",
        "onselectstart",
        "onslotchange",
        "onstalled",
        "onstorage",
        "onsubmit",
        "onsuspend",
        "ontimeupdate",
        "ontoggle",
        "ontouchcancel",
        "ontouchend",
        "ontouchmove",
        "ontouchstart",
        "ontransitioncancel",
        "ontransitionend",
        "ontransitionrun",
        "ontransitionstart",
        "onunhandledrejection",
        "onunload",
        "onvolumechange",
        "onwaiting",
        "onwebkitanimationend",
        "onwebkitanimationiteration",
        "onwebkitanimationstart",
        "onwebkittransitionend",
        "onwheel",
        "open",
        "opener",
        "orientation",
        "origin",
        "outerHeight",
        "outerWidth",
        "pageXOffset",
        "pageYOffset",
        "parent",
        "parseFloat",
        "parseInt",
        "performance",
        "personalbar",
        "postMessage",
        "print",
        "process",
        "prompt",
        "queueMicrotask",
        "releaseEvents",
        "removeEventListener",
        "reportError",
        "requestAnimationFrame",
        "requestIdleCallback",
        "resizeBy",
        "resizeTo",
        "screen",
        "screenLeft",
        "screenTop",
        "screenX",
        "screenY",
        "scroll",
        "scrollBy",
        "scrollTo",
        "scrollX",
        "scrollY",
        "scrollbars",
        "self",
        "sessionStorage",
        "setInterval",
        "setTimeout",
        "speechSynthesis",
        "status",
        "statusbar",
        "stop",
        "structuredClone",
        "toString",
        "toolbar",
        "top",
        "undefined",
        "unescape",
        "visualViewport",
        "webkitURL",
        "window"
    ]);
    /**
 * @param {any} program
 * @param {import('estree').Identifier} name
 * @param {string} banner
 * @param {any} svelte_path
 * @param {Array<{ name: string; alias: import('estree').Identifier }>} helpers
 * @param {Array<{ name: string; alias: import('estree').Identifier }>} globals
 * @param {import('estree').ImportDeclaration[]} imports
 * @param {Export[]} module_exports
 * @param {import('estree').ExportNamedDeclaration[]} exports_from
 */ function create_module(program, name, banner, svelte_path = "svelte", helpers, globals, imports, module_exports, exports_from) {
        const internal_path = `${svelte_path}/internal`;
        helpers.sort((a, b)=>a.name < b.name ? -1 : 1);
        globals.sort((a, b)=>a.name < b.name ? -1 : 1);
        return esm(program, name, banner, svelte_path, internal_path, helpers, globals, imports, module_exports, exports_from);
    }
    /**
 * @param {any} source
 * @param {any} svelte_path
 */ function edit_source(source, svelte_path) {
        return source === "svelte" || source.startsWith("svelte/") ? source.replace("svelte", svelte_path) : source;
    }
    /**
 * @param {Array<{ name: string; alias: import('estree').Identifier }>} globals
 * @param {Array<{ name: string; alias: import('estree').Identifier }>} helpers
 */ function get_internal_globals(globals, helpers) {
        return globals.length > 0 && {
            type: "VariableDeclaration",
            kind: "const",
            declarations: [
                {
                    type: "VariableDeclarator",
                    id: {
                        type: "ObjectPattern",
                        properties: globals.map((g)=>({
                                type: "Property",
                                method: false,
                                shorthand: false,
                                computed: false,
                                key: {
                                    type: "Identifier",
                                    name: g.name
                                },
                                value: g.alias,
                                kind: "init"
                            }))
                    },
                    init: helpers.find(({ name: name })=>name === "globals").alias
                }
            ]
        };
    }
    /**
 * @param {any} program
 * @param {import('estree').Identifier} name
 * @param {string} banner
 * @param {string} svelte_path
 * @param {string} internal_path
 * @param {Array<{ name: string; alias: import('estree').Identifier }>} helpers
 * @param {Array<{ name: string; alias: import('estree').Identifier }>} globals
 * @param {import('estree').ImportDeclaration[]} imports
 * @param {Export[]} module_exports
 * @param {import('estree').ExportNamedDeclaration[]} exports_from
 */ function esm(program, name, banner, svelte_path, internal_path, helpers, globals, imports, module_exports, exports_from) {
        const import_declaration = {
            type: "ImportDeclaration",
            specifiers: helpers.map((h)=>({
                    type: "ImportSpecifier",
                    local: h.alias,
                    imported: {
                        type: "Identifier",
                        name: h.name
                    }
                })),
            source: {
                type: "Literal",
                value: internal_path
            }
        };
        const internal_globals = get_internal_globals(globals, helpers);
        // edit user imports
        /** @param {any} node */ function rewrite_import(node) {
            const value = edit_source(node.source.value, svelte_path);
            if (node.source.value !== value) {
                node.source.value = value;
                node.source.raw = null;
            }
        }
        imports.forEach(rewrite_import);
        exports_from.forEach(rewrite_import);
        const exports1 = module_exports.length > 0 && {
            type: "ExportNamedDeclaration",
            specifiers: module_exports.map((x)=>({
                    type: "Specifier",
                    local: {
                        type: "Identifier",
                        name: x.name
                    },
                    exported: {
                        type: "Identifier",
                        name: x.as
                    }
                }))
        };
        program.body = b$1`
		/* ${banner} */

		${import_declaration}
		${internal_globals}
		${imports}
		${exports_from}

		${program.body}

		export default ${name};
		${exports1}
	`;
    }
    /**
 * @typedef {Object} Export
 * @property {string} name
 * @property {string} as
 */ class BitSet {
        constructor(arg){
            this.bits = arg instanceof BitSet ? arg.bits.slice() : [];
        }
        add(n) {
            this.bits[n >> 5] |= 1 << (n & 31);
        }
        has(n) {
            return !!(this.bits[n >> 5] & 1 << (n & 31));
        }
    }
    class Chunk {
        constructor(start, end, content){
            this.start = start;
            this.end = end;
            this.original = content;
            this.intro = "";
            this.outro = "";
            this.content = content;
            this.storeName = false;
            this.edited = false;
            this.previous = null;
            this.next = null;
        }
        appendLeft(content) {
            this.outro += content;
        }
        appendRight(content) {
            this.intro = this.intro + content;
        }
        clone() {
            const chunk = new Chunk(this.start, this.end, this.original);
            chunk.intro = this.intro;
            chunk.outro = this.outro;
            chunk.content = this.content;
            chunk.storeName = this.storeName;
            chunk.edited = this.edited;
            return chunk;
        }
        contains(index) {
            return this.start < index && index < this.end;
        }
        eachNext(fn) {
            let chunk = this;
            while(chunk){
                fn(chunk);
                chunk = chunk.next;
            }
        }
        eachPrevious(fn) {
            let chunk = this;
            while(chunk){
                fn(chunk);
                chunk = chunk.previous;
            }
        }
        edit(content, storeName, contentOnly) {
            this.content = content;
            if (!contentOnly) {
                this.intro = "";
                this.outro = "";
            }
            this.storeName = storeName;
            this.edited = true;
            return this;
        }
        prependLeft(content) {
            this.outro = content + this.outro;
        }
        prependRight(content) {
            this.intro = content + this.intro;
        }
        split(index) {
            const sliceIndex = index - this.start;
            const originalBefore = this.original.slice(0, sliceIndex);
            const originalAfter = this.original.slice(sliceIndex);
            this.original = originalBefore;
            const newChunk = new Chunk(index, this.end, originalAfter);
            newChunk.outro = this.outro;
            this.outro = "";
            this.end = index;
            if (this.edited) {
                // after split we should save the edit content record into the correct chunk
                // to make sure sourcemap correct
                // For example:
                // '  test'.trim()
                //     split   -> '  ' + 'test'
                //   ✔️ edit    -> '' + 'test'
                //   ✖️ edit    -> 'test' + '' 
                // TODO is this block necessary?...
                newChunk.edit("", false);
                this.content = "";
            } else this.content = originalBefore;
            newChunk.next = this.next;
            if (newChunk.next) newChunk.next.previous = newChunk;
            newChunk.previous = this;
            this.next = newChunk;
            return newChunk;
        }
        toString() {
            return this.intro + this.content + this.outro;
        }
        trimEnd(rx) {
            this.outro = this.outro.replace(rx, "");
            if (this.outro.length) return true;
            const trimmed = this.content.replace(rx, "");
            if (trimmed.length) {
                if (trimmed !== this.content) {
                    this.split(this.start + trimmed.length).edit("", undefined, true);
                    if (this.edited) // save the change, if it has been edited
                    this.edit(trimmed, this.storeName, true);
                }
                return true;
            } else {
                this.edit("", undefined, true);
                this.intro = this.intro.replace(rx, "");
                if (this.intro.length) return true;
            }
        }
        trimStart(rx) {
            this.intro = this.intro.replace(rx, "");
            if (this.intro.length) return true;
            const trimmed = this.content.replace(rx, "");
            if (trimmed.length) {
                if (trimmed !== this.content) {
                    const newChunk = this.split(this.end - trimmed.length);
                    if (this.edited) // save the change, if it has been edited
                    newChunk.edit(trimmed, this.storeName, true);
                    this.edit("", undefined, true);
                }
                return true;
            } else {
                this.edit("", undefined, true);
                this.outro = this.outro.replace(rx, "");
                if (this.outro.length) return true;
            }
        }
    }
    function getBtoa() {
        if (typeof window !== "undefined" && typeof window.btoa === "function") return (str)=>window.btoa(unescape(encodeURIComponent(str)));
        else if (typeof Buffer === "function") return (str)=>Buffer.from(str, "utf-8").toString("base64");
        else return ()=>{
            throw new Error("Unsupported environment: `window.btoa` or `Buffer` should be supported.");
        };
    }
    const btoa = /*#__PURE__*/ getBtoa();
    class SourceMap {
        constructor(properties){
            this.version = 3;
            this.file = properties.file;
            this.sources = properties.sources;
            this.sourcesContent = properties.sourcesContent;
            this.names = properties.names;
            this.mappings = encode(properties.mappings);
            if (typeof properties.x_google_ignoreList !== "undefined") this.x_google_ignoreList = properties.x_google_ignoreList;
        }
        toString() {
            return JSON.stringify(this);
        }
        toUrl() {
            return "data:application/json;charset=utf-8;base64," + btoa(this.toString());
        }
    }
    function guessIndent(code) {
        const lines = code.split("\n");
        const tabbed = lines.filter((line)=>/^\t+/.test(line));
        const spaced = lines.filter((line)=>/^ {2,}/.test(line));
        if (tabbed.length === 0 && spaced.length === 0) return null;
        // More lines tabbed than spaced? Assume tabs, and
        // default to tabs in the case of a tie (or nothing
        // to go on)
        if (tabbed.length >= spaced.length) return "	";
        // Otherwise, we need to guess the multiple
        const min = spaced.reduce((previous, current)=>{
            const numSpaces = /^ +/.exec(current)[0].length;
            return Math.min(numSpaces, previous);
        }, Infinity);
        return new Array(min + 1).join(" ");
    }
    function getRelativePath(from, to) {
        const fromParts = from.split(/[/\\]/);
        const toParts = to.split(/[/\\]/);
        fromParts.pop(); // get dirname
        while(fromParts[0] === toParts[0]){
            fromParts.shift();
            toParts.shift();
        }
        if (fromParts.length) {
            let i = fromParts.length;
            while(i--)fromParts[i] = "..";
        }
        return fromParts.concat(toParts).join("/");
    }
    const toString = Object.prototype.toString;
    function isObject(thing) {
        return toString.call(thing) === "[object Object]";
    }
    function getLocator(source) {
        const originalLines = source.split("\n");
        const lineOffsets = [];
        for(let i = 0, pos = 0; i < originalLines.length; i++){
            lineOffsets.push(pos);
            pos += originalLines[i].length + 1;
        }
        return function locate(index) {
            let i = 0;
            let j = lineOffsets.length;
            while(i < j){
                const m = i + j >> 1;
                if (index < lineOffsets[m]) j = m;
                else i = m + 1;
            }
            const line = i - 1;
            const column = index - lineOffsets[line];
            return {
                line: line,
                column: column
            };
        };
    }
    const wordRegex = /\w/;
    class Mappings {
        constructor(hires){
            this.hires = hires;
            this.generatedCodeLine = 0;
            this.generatedCodeColumn = 0;
            this.raw = [];
            this.rawSegments = this.raw[this.generatedCodeLine] = [];
            this.pending = null;
        }
        addEdit(sourceIndex, content, loc, nameIndex) {
            if (content.length) {
                let contentLineEnd = content.indexOf("\n", 0);
                let previousContentLineEnd = -1;
                while(contentLineEnd >= 0){
                    const segment = [
                        this.generatedCodeColumn,
                        sourceIndex,
                        loc.line,
                        loc.column
                    ];
                    if (nameIndex >= 0) segment.push(nameIndex);
                    this.rawSegments.push(segment);
                    this.generatedCodeLine += 1;
                    this.raw[this.generatedCodeLine] = this.rawSegments = [];
                    this.generatedCodeColumn = 0;
                    previousContentLineEnd = contentLineEnd;
                    contentLineEnd = content.indexOf("\n", contentLineEnd + 1);
                }
                const segment = [
                    this.generatedCodeColumn,
                    sourceIndex,
                    loc.line,
                    loc.column
                ];
                if (nameIndex >= 0) segment.push(nameIndex);
                this.rawSegments.push(segment);
                this.advance(content.slice(previousContentLineEnd + 1));
            } else if (this.pending) {
                this.rawSegments.push(this.pending);
                this.advance(content);
            }
            this.pending = null;
        }
        addUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {
            let originalCharIndex = chunk.start;
            let first = true;
            // when iterating each char, check if it's in a word boundary
            let charInHiresBoundary = false;
            while(originalCharIndex < chunk.end){
                if (this.hires || first || sourcemapLocations.has(originalCharIndex)) {
                    const segment = [
                        this.generatedCodeColumn,
                        sourceIndex,
                        loc.line,
                        loc.column
                    ];
                    if (this.hires === "boundary") {
                        // in hires "boundary", group segments per word boundary than per char
                        if (wordRegex.test(original[originalCharIndex])) // for first char in the boundary found, start the boundary by pushing a segment
                        {
                            if (!charInHiresBoundary) {
                                this.rawSegments.push(segment);
                                charInHiresBoundary = true;
                            }
                        } else {
                            // for non-word char, end the boundary by pushing a segment
                            this.rawSegments.push(segment);
                            charInHiresBoundary = false;
                        }
                    } else this.rawSegments.push(segment);
                }
                if (original[originalCharIndex] === "\n") {
                    loc.line += 1;
                    loc.column = 0;
                    this.generatedCodeLine += 1;
                    this.raw[this.generatedCodeLine] = this.rawSegments = [];
                    this.generatedCodeColumn = 0;
                    first = true;
                } else {
                    loc.column += 1;
                    this.generatedCodeColumn += 1;
                    first = false;
                }
                originalCharIndex += 1;
            }
            this.pending = null;
        }
        advance(str) {
            if (!str) return;
            const lines = str.split("\n");
            if (lines.length > 1) {
                for(let i = 0; i < lines.length - 1; i++){
                    this.generatedCodeLine++;
                    this.raw[this.generatedCodeLine] = this.rawSegments = [];
                }
                this.generatedCodeColumn = 0;
            }
            this.generatedCodeColumn += lines[lines.length - 1].length;
        }
    }
    const n = "\n";
    const warned = {
        insertLeft: false,
        insertRight: false,
        storeName: false
    };
    class MagicString {
        constructor(string, options = {}){
            const chunk = new Chunk(0, string.length, string);
            Object.defineProperties(this, {
                original: {
                    writable: true,
                    value: string
                },
                outro: {
                    writable: true,
                    value: ""
                },
                intro: {
                    writable: true,
                    value: ""
                },
                firstChunk: {
                    writable: true,
                    value: chunk
                },
                lastChunk: {
                    writable: true,
                    value: chunk
                },
                lastSearchedChunk: {
                    writable: true,
                    value: chunk
                },
                byStart: {
                    writable: true,
                    value: {}
                },
                byEnd: {
                    writable: true,
                    value: {}
                },
                filename: {
                    writable: true,
                    value: options.filename
                },
                indentExclusionRanges: {
                    writable: true,
                    value: options.indentExclusionRanges
                },
                sourcemapLocations: {
                    writable: true,
                    value: new BitSet()
                },
                storedNames: {
                    writable: true,
                    value: {}
                },
                indentStr: {
                    writable: true,
                    value: undefined
                },
                ignoreList: {
                    writable: true,
                    value: options.ignoreList
                }
            });
            this.byStart[0] = chunk;
            this.byEnd[string.length] = chunk;
        }
        addSourcemapLocation(char) {
            this.sourcemapLocations.add(char);
        }
        append(content) {
            if (typeof content !== "string") throw new TypeError("outro content must be a string");
            this.outro += content;
            return this;
        }
        appendLeft(index, content) {
            if (typeof content !== "string") throw new TypeError("inserted content must be a string");
            this._split(index);
            const chunk = this.byEnd[index];
            if (chunk) chunk.appendLeft(content);
            else this.intro += content;
            return this;
        }
        appendRight(index, content) {
            if (typeof content !== "string") throw new TypeError("inserted content must be a string");
            this._split(index);
            const chunk = this.byStart[index];
            if (chunk) chunk.appendRight(content);
            else this.outro += content;
            return this;
        }
        clone() {
            const cloned = new MagicString(this.original, {
                filename: this.filename
            });
            let originalChunk = this.firstChunk;
            let clonedChunk = cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone();
            while(originalChunk){
                cloned.byStart[clonedChunk.start] = clonedChunk;
                cloned.byEnd[clonedChunk.end] = clonedChunk;
                const nextOriginalChunk = originalChunk.next;
                const nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();
                if (nextClonedChunk) {
                    clonedChunk.next = nextClonedChunk;
                    nextClonedChunk.previous = clonedChunk;
                    clonedChunk = nextClonedChunk;
                }
                originalChunk = nextOriginalChunk;
            }
            cloned.lastChunk = clonedChunk;
            if (this.indentExclusionRanges) cloned.indentExclusionRanges = this.indentExclusionRanges.slice();
            cloned.sourcemapLocations = new BitSet(this.sourcemapLocations);
            cloned.intro = this.intro;
            cloned.outro = this.outro;
            return cloned;
        }
        generateDecodedMap(options) {
            options = options || {};
            const sourceIndex = 0;
            const names = Object.keys(this.storedNames);
            const mappings = new Mappings(options.hires);
            const locate = getLocator(this.original);
            if (this.intro) mappings.advance(this.intro);
            this.firstChunk.eachNext((chunk)=>{
                const loc = locate(chunk.start);
                if (chunk.intro.length) mappings.advance(chunk.intro);
                if (chunk.edited) mappings.addEdit(sourceIndex, chunk.content, loc, chunk.storeName ? names.indexOf(chunk.original) : -1);
                else mappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);
                if (chunk.outro.length) mappings.advance(chunk.outro);
            });
            return {
                file: options.file ? options.file.split(/[/\\]/).pop() : undefined,
                sources: [
                    options.source ? getRelativePath(options.file || "", options.source) : options.file || ""
                ],
                sourcesContent: options.includeContent ? [
                    this.original
                ] : undefined,
                names: names,
                mappings: mappings.raw,
                x_google_ignoreList: this.ignoreList ? [
                    sourceIndex
                ] : undefined
            };
        }
        generateMap(options) {
            return new SourceMap(this.generateDecodedMap(options));
        }
        _ensureindentStr() {
            if (this.indentStr === undefined) this.indentStr = guessIndent(this.original);
        }
        _getRawIndentString() {
            this._ensureindentStr();
            return this.indentStr;
        }
        getIndentString() {
            this._ensureindentStr();
            return this.indentStr === null ? "	" : this.indentStr;
        }
        indent(indentStr, options) {
            const pattern = /^[^\r\n]/gm;
            if (isObject(indentStr)) {
                options = indentStr;
                indentStr = undefined;
            }
            if (indentStr === undefined) {
                this._ensureindentStr();
                indentStr = this.indentStr || "	";
            }
            if (indentStr === "") return this; // noop
            options = options || {};
            // Process exclusion ranges
            const isExcluded = {};
            if (options.exclude) {
                const exclusions = typeof options.exclude[0] === "number" ? [
                    options.exclude
                ] : options.exclude;
                exclusions.forEach((exclusion)=>{
                    for(let i = exclusion[0]; i < exclusion[1]; i += 1)isExcluded[i] = true;
                });
            }
            let shouldIndentNextCharacter = options.indentStart !== false;
            const replacer = (match)=>{
                if (shouldIndentNextCharacter) return `${indentStr}${match}`;
                shouldIndentNextCharacter = true;
                return match;
            };
            this.intro = this.intro.replace(pattern, replacer);
            let charIndex = 0;
            let chunk = this.firstChunk;
            while(chunk){
                const end = chunk.end;
                if (chunk.edited) {
                    if (!isExcluded[charIndex]) {
                        chunk.content = chunk.content.replace(pattern, replacer);
                        if (chunk.content.length) shouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === "\n";
                    }
                } else {
                    charIndex = chunk.start;
                    while(charIndex < end){
                        if (!isExcluded[charIndex]) {
                            const char = this.original[charIndex];
                            if (char === "\n") shouldIndentNextCharacter = true;
                            else if (char !== "\r" && shouldIndentNextCharacter) {
                                shouldIndentNextCharacter = false;
                                if (charIndex === chunk.start) chunk.prependRight(indentStr);
                                else {
                                    this._splitChunk(chunk, charIndex);
                                    chunk = chunk.next;
                                    chunk.prependRight(indentStr);
                                }
                            }
                        }
                        charIndex += 1;
                    }
                }
                charIndex = chunk.end;
                chunk = chunk.next;
            }
            this.outro = this.outro.replace(pattern, replacer);
            return this;
        }
        insert() {
            throw new Error("magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)");
        }
        insertLeft(index, content) {
            if (!warned.insertLeft) {
                console.warn("magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead"); // eslint-disable-line no-console
                warned.insertLeft = true;
            }
            return this.appendLeft(index, content);
        }
        insertRight(index, content) {
            if (!warned.insertRight) {
                console.warn("magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead"); // eslint-disable-line no-console
                warned.insertRight = true;
            }
            return this.prependRight(index, content);
        }
        move(start, end, index) {
            if (index >= start && index <= end) throw new Error("Cannot move a selection inside itself");
            this._split(start);
            this._split(end);
            this._split(index);
            const first = this.byStart[start];
            const last = this.byEnd[end];
            const oldLeft = first.previous;
            const oldRight = last.next;
            const newRight = this.byStart[index];
            if (!newRight && last === this.lastChunk) return this;
            const newLeft = newRight ? newRight.previous : this.lastChunk;
            if (oldLeft) oldLeft.next = oldRight;
            if (oldRight) oldRight.previous = oldLeft;
            if (newLeft) newLeft.next = first;
            if (newRight) newRight.previous = last;
            if (!first.previous) this.firstChunk = last.next;
            if (!last.next) {
                this.lastChunk = first.previous;
                this.lastChunk.next = null;
            }
            first.previous = newLeft;
            last.next = newRight || null;
            if (!newLeft) this.firstChunk = first;
            if (!newRight) this.lastChunk = last;
            return this;
        }
        overwrite(start, end, content, options) {
            options = options || {};
            return this.update(start, end, content, {
                ...options,
                overwrite: !options.contentOnly
            });
        }
        update(start, end, content, options) {
            if (typeof content !== "string") throw new TypeError("replacement content must be a string");
            while(start < 0)start += this.original.length;
            while(end < 0)end += this.original.length;
            if (end > this.original.length) throw new Error("end is out of bounds");
            if (start === end) throw new Error("Cannot overwrite a zero-length range \u2013 use appendLeft or prependRight instead");
            this._split(start);
            this._split(end);
            if (options === true) {
                if (!warned.storeName) {
                    console.warn("The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string"); // eslint-disable-line no-console
                    warned.storeName = true;
                }
                options = {
                    storeName: true
                };
            }
            const storeName = options !== undefined ? options.storeName : false;
            const overwrite = options !== undefined ? options.overwrite : false;
            if (storeName) {
                const original = this.original.slice(start, end);
                Object.defineProperty(this.storedNames, original, {
                    writable: true,
                    value: true,
                    enumerable: true
                });
            }
            const first = this.byStart[start];
            const last = this.byEnd[end];
            if (first) {
                let chunk = first;
                while(chunk !== last){
                    if (chunk.next !== this.byStart[chunk.end]) throw new Error("Cannot overwrite across a split point");
                    chunk = chunk.next;
                    chunk.edit("", false);
                }
                first.edit(content, storeName, !overwrite);
            } else {
                // must be inserting at the end
                const newChunk = new Chunk(start, end, "").edit(content, storeName);
                // TODO last chunk in the array may not be the last chunk, if it's moved...
                last.next = newChunk;
                newChunk.previous = last;
            }
            return this;
        }
        prepend(content) {
            if (typeof content !== "string") throw new TypeError("outro content must be a string");
            this.intro = content + this.intro;
            return this;
        }
        prependLeft(index, content) {
            if (typeof content !== "string") throw new TypeError("inserted content must be a string");
            this._split(index);
            const chunk = this.byEnd[index];
            if (chunk) chunk.prependLeft(content);
            else this.intro = content + this.intro;
            return this;
        }
        prependRight(index, content) {
            if (typeof content !== "string") throw new TypeError("inserted content must be a string");
            this._split(index);
            const chunk = this.byStart[index];
            if (chunk) chunk.prependRight(content);
            else this.outro = content + this.outro;
            return this;
        }
        remove(start, end) {
            while(start < 0)start += this.original.length;
            while(end < 0)end += this.original.length;
            if (start === end) return this;
            if (start < 0 || end > this.original.length) throw new Error("Character is out of bounds");
            if (start > end) throw new Error("end must be greater than start");
            this._split(start);
            this._split(end);
            let chunk = this.byStart[start];
            while(chunk){
                chunk.intro = "";
                chunk.outro = "";
                chunk.edit("");
                chunk = end > chunk.end ? this.byStart[chunk.end] : null;
            }
            return this;
        }
        lastChar() {
            if (this.outro.length) return this.outro[this.outro.length - 1];
            let chunk = this.lastChunk;
            do {
                if (chunk.outro.length) return chunk.outro[chunk.outro.length - 1];
                if (chunk.content.length) return chunk.content[chunk.content.length - 1];
                if (chunk.intro.length) return chunk.intro[chunk.intro.length - 1];
            }while (chunk = chunk.previous);
            if (this.intro.length) return this.intro[this.intro.length - 1];
            return "";
        }
        lastLine() {
            let lineIndex = this.outro.lastIndexOf(n);
            if (lineIndex !== -1) return this.outro.substr(lineIndex + 1);
            let lineStr = this.outro;
            let chunk = this.lastChunk;
            do {
                if (chunk.outro.length > 0) {
                    lineIndex = chunk.outro.lastIndexOf(n);
                    if (lineIndex !== -1) return chunk.outro.substr(lineIndex + 1) + lineStr;
                    lineStr = chunk.outro + lineStr;
                }
                if (chunk.content.length > 0) {
                    lineIndex = chunk.content.lastIndexOf(n);
                    if (lineIndex !== -1) return chunk.content.substr(lineIndex + 1) + lineStr;
                    lineStr = chunk.content + lineStr;
                }
                if (chunk.intro.length > 0) {
                    lineIndex = chunk.intro.lastIndexOf(n);
                    if (lineIndex !== -1) return chunk.intro.substr(lineIndex + 1) + lineStr;
                    lineStr = chunk.intro + lineStr;
                }
            }while (chunk = chunk.previous);
            lineIndex = this.intro.lastIndexOf(n);
            if (lineIndex !== -1) return this.intro.substr(lineIndex + 1) + lineStr;
            return this.intro + lineStr;
        }
        slice(start = 0, end = this.original.length) {
            while(start < 0)start += this.original.length;
            while(end < 0)end += this.original.length;
            let result = "";
            // find start chunk
            let chunk = this.firstChunk;
            while(chunk && (chunk.start > start || chunk.end <= start)){
                // found end chunk before start
                if (chunk.start < end && chunk.end >= end) return result;
                chunk = chunk.next;
            }
            if (chunk && chunk.edited && chunk.start !== start) throw new Error(`Cannot use replaced character ${start} as slice start anchor.`);
            const startChunk = chunk;
            while(chunk){
                if (chunk.intro && (startChunk !== chunk || chunk.start === start)) result += chunk.intro;
                const containsEnd = chunk.start < end && chunk.end >= end;
                if (containsEnd && chunk.edited && chunk.end !== end) throw new Error(`Cannot use replaced character ${end} as slice end anchor.`);
                const sliceStart = startChunk === chunk ? start - chunk.start : 0;
                const sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;
                result += chunk.content.slice(sliceStart, sliceEnd);
                if (chunk.outro && (!containsEnd || chunk.end === end)) result += chunk.outro;
                if (containsEnd) break;
                chunk = chunk.next;
            }
            return result;
        }
        // TODO deprecate this? not really very useful
        snip(start, end) {
            const clone = this.clone();
            clone.remove(0, start);
            clone.remove(end, clone.original.length);
            return clone;
        }
        _split(index) {
            if (this.byStart[index] || this.byEnd[index]) return;
            let chunk = this.lastSearchedChunk;
            const searchForward = index > chunk.end;
            while(chunk){
                if (chunk.contains(index)) return this._splitChunk(chunk, index);
                chunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];
            }
        }
        _splitChunk(chunk, index) {
            if (chunk.edited && chunk.content.length) {
                // zero-length edited chunks are a special case (overlapping replacements)
                const loc = getLocator(this.original)(index);
                throw new Error(`Cannot split a chunk that has already been edited (${loc.line}:${loc.column} \u{2013} "${chunk.original}")`);
            }
            const newChunk = chunk.split(index);
            this.byEnd[index] = chunk;
            this.byStart[index] = newChunk;
            this.byEnd[newChunk.end] = newChunk;
            if (chunk === this.lastChunk) this.lastChunk = newChunk;
            this.lastSearchedChunk = chunk;
            return true;
        }
        toString() {
            let str = this.intro;
            let chunk = this.firstChunk;
            while(chunk){
                str += chunk.toString();
                chunk = chunk.next;
            }
            return str + this.outro;
        }
        isEmpty() {
            let chunk = this.firstChunk;
            do {
                if (chunk.intro.length && chunk.intro.trim() || chunk.content.length && chunk.content.trim() || chunk.outro.length && chunk.outro.trim()) return false;
            }while (chunk = chunk.next);
            return true;
        }
        length() {
            let chunk = this.firstChunk;
            let length = 0;
            do length += chunk.intro.length + chunk.content.length + chunk.outro.length;
            while (chunk = chunk.next);
            return length;
        }
        trimLines() {
            return this.trim("[\\r\\n]");
        }
        trim(charType) {
            return this.trimStart(charType).trimEnd(charType);
        }
        trimEndAborted(charType) {
            const rx = new RegExp((charType || "\\s") + "+$");
            this.outro = this.outro.replace(rx, "");
            if (this.outro.length) return true;
            let chunk = this.lastChunk;
            do {
                const end = chunk.end;
                const aborted = chunk.trimEnd(rx);
                // if chunk was trimmed, we have a new lastChunk
                if (chunk.end !== end) {
                    if (this.lastChunk === chunk) this.lastChunk = chunk.next;
                    this.byEnd[chunk.end] = chunk;
                    this.byStart[chunk.next.start] = chunk.next;
                    this.byEnd[chunk.next.end] = chunk.next;
                }
                if (aborted) return true;
                chunk = chunk.previous;
            }while (chunk);
            return false;
        }
        trimEnd(charType) {
            this.trimEndAborted(charType);
            return this;
        }
        trimStartAborted(charType) {
            const rx = new RegExp("^" + (charType || "\\s") + "+");
            this.intro = this.intro.replace(rx, "");
            if (this.intro.length) return true;
            let chunk = this.firstChunk;
            do {
                const end = chunk.end;
                const aborted = chunk.trimStart(rx);
                if (chunk.end !== end) {
                    // special case...
                    if (chunk === this.lastChunk) this.lastChunk = chunk.next;
                    this.byEnd[chunk.end] = chunk;
                    this.byStart[chunk.next.start] = chunk.next;
                    this.byEnd[chunk.next.end] = chunk.next;
                }
                if (aborted) return true;
                chunk = chunk.next;
            }while (chunk);
            return false;
        }
        trimStart(charType) {
            this.trimStartAborted(charType);
            return this;
        }
        hasChanged() {
            return this.original !== this.toString();
        }
        _replaceRegexp(searchValue, replacement) {
            function getReplacement(match, str) {
                if (typeof replacement === "string") return replacement.replace(/\$(\$|&|\d+)/g, (_, i)=>{
                    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_string_as_a_parameter
                    if (i === "$") return "$";
                    if (i === "&") return match[0];
                    const num = +i;
                    if (num < match.length) return match[+i];
                    return `$${i}`;
                });
                else return replacement(...match, match.index, str, match.groups);
            }
            function matchAll(re, str) {
                let match;
                const matches = [];
                while(match = re.exec(str))matches.push(match);
                return matches;
            }
            if (searchValue.global) {
                const matches = matchAll(searchValue, this.original);
                matches.forEach((match)=>{
                    if (match.index != null) this.overwrite(match.index, match.index + match[0].length, getReplacement(match, this.original));
                });
            } else {
                const match = this.original.match(searchValue);
                if (match && match.index != null) this.overwrite(match.index, match.index + match[0].length, getReplacement(match, this.original));
            }
            return this;
        }
        _replaceString(string, replacement) {
            const { original: original } = this;
            const index = original.indexOf(string);
            if (index !== -1) this.overwrite(index, index + string.length, replacement);
            return this;
        }
        replace(searchValue, replacement) {
            if (typeof searchValue === "string") return this._replaceString(searchValue, replacement);
            return this._replaceRegexp(searchValue, replacement);
        }
        _replaceAllString(string, replacement) {
            const { original: original } = this;
            const stringLength = string.length;
            for(let index = original.indexOf(string); index !== -1; index = original.indexOf(string, index + stringLength))this.overwrite(index, index + stringLength, replacement);
            return this;
        }
        replaceAll(searchValue, replacement) {
            if (typeof searchValue === "string") return this._replaceAllString(searchValue, replacement);
            if (!searchValue.global) throw new TypeError("MagicString.prototype.replaceAll called with a non-global RegExp argument");
            return this._replaceRegexp(searchValue, replacement);
        }
    }
    const UNKNOWN = {};
    /**
 * @param {import("estree").Node} node
 * @param {Set<string | {}>} set
 */ function gather_possible_values(node, set) {
        if (node.type === "Literal") set.add(node.value);
        else if (node.type === "ConditionalExpression") {
            gather_possible_values(node.consequent, set);
            gather_possible_values(node.alternate, set);
        } else set.add(UNKNOWN);
    }
    const BlockAppliesToNode = /** @type {const} */ {
        NotPossible: 0,
        Possible: 1,
        UnknownSelectorType: 2
    };
    const NodeExist = /** @type {const} */ {
        Probably: 0,
        Definitely: 1
    };
    /** @typedef {typeof NodeExist[keyof typeof NodeExist]} NodeExistsValue */ const whitelist_attribute_selector = new Map([
        [
            "details",
            new Set([
                "open"
            ])
        ],
        [
            "dialog",
            new Set([
                "open"
            ])
        ]
    ]);
    const regex_is_single_css_selector = /[^\\],(?!([^([]+[^\\]|[^([\\])[)\]])/;
    class Selector {
        /** @type {import('./private.js').CssNode} */ node;
        /** @type {import('./Stylesheet.js').default} */ stylesheet;
        /** @type {Block[]} */ blocks;
        /** @type {Block[]} */ local_blocks;
        /** @type {boolean} */ used;
        /**
	 * @param {import('./private.js').CssNode} node
	 * @param {import('./Stylesheet.js').default} stylesheet
	 */ constructor(node, stylesheet){
            this.node = node;
            this.stylesheet = stylesheet;
            this.blocks = group_selectors(node);
            // take trailing :global(...) selectors out of consideration
            let i = this.blocks.length;
            while(i > 0){
                if (!this.blocks[i - 1].global) break;
                i -= 1;
            }
            this.local_blocks = this.blocks.slice(0, i);
            const host_only = this.blocks.length === 1 && this.blocks[0].host;
            const root_only = this.blocks.length === 1 && this.blocks[0].root;
            this.used = this.local_blocks.length === 0 || host_only || root_only;
        }
        /** @param {import('../nodes/Element.js').default} node */ apply(node) {
            /** @type {Array<{ node: import('../nodes/Element.js').default; block: Block }>} */ const to_encapsulate = [];
            apply_selector(this.local_blocks.slice(), node, to_encapsulate);
            if (to_encapsulate.length > 0) {
                to_encapsulate.forEach(({ node: node, block: block })=>{
                    this.stylesheet.nodes_with_css_class.add(node);
                    block.should_encapsulate = true;
                });
                this.used = true;
            }
        }
        /** @param {import('magic-string').default} code */ minify(code) {
            /** @type {number} */ let c = null;
            this.blocks.forEach((block, i)=>{
                if (i > 0) {
                    if (block.start - c > 1) code.update(c, block.start, block.combinator.name || " ");
                }
                c = block.end;
            });
        }
        /**
	 * @param {import('magic-string').default} code
	 * @param {string} attr
	 * @param {number} max_amount_class_specificity_increased
	 */ transform(code, attr, max_amount_class_specificity_increased) {
            const amount_class_specificity_to_increase = max_amount_class_specificity_increased - this.blocks.filter((block)=>block.should_encapsulate).length;
            /** @param {import('./private.js').CssNode} selector */ function remove_global_pseudo_class(selector) {
                const first = selector.children[0];
                const last = selector.children[selector.children.length - 1];
                code.remove(selector.start, first.start).remove(last.end, selector.end);
            }
            /**
		 * @param {Block} block
		 * @param {string} attr
		 */ function encapsulate_block(block, attr) {
                for (const selector of block.selectors)if (selector.type === "PseudoClassSelector" && selector.name === "global") remove_global_pseudo_class(selector);
                let i = block.selectors.length;
                while(i--){
                    const selector = block.selectors[i];
                    if (selector.type === "PseudoElementSelector" || selector.type === "PseudoClassSelector") {
                        if (selector.name !== "root" && selector.name !== "host") {
                            if (i === 0) code.prependRight(selector.start, attr);
                        }
                        continue;
                    }
                    if (selector.type === "TypeSelector" && selector.name === "*") code.update(selector.start, selector.end, attr);
                    else code.appendLeft(selector.end, attr);
                    break;
                }
            }
            this.blocks.forEach((block, index)=>{
                if (block.global) remove_global_pseudo_class(block.selectors[0]);
                if (block.should_encapsulate) encapsulate_block(block, index === this.blocks.length - 1 ? attr.repeat(amount_class_specificity_to_increase + 1) : attr);
            });
        }
        /** @param {import('../Component.js').default} component */ validate(component) {
            let start = 0;
            let end = this.blocks.length;
            for(; start < end; start += 1){
                if (!this.blocks[start].global) break;
            }
            for(; end > start; end -= 1){
                if (!this.blocks[end - 1].global) break;
            }
            for(let i = start; i < end; i += 1){
                if (this.blocks[i].global) return component.error(this.blocks[i].selectors[0], compiler_errors.css_invalid_global);
            }
            this.validate_global_with_multiple_selectors(component);
            this.validate_global_compound_selector(component);
            this.validate_invalid_combinator_without_selector(component);
        }
        /** @param {import('../Component.js').default} component */ validate_global_with_multiple_selectors(component) {
            if (this.blocks.length === 1 && this.blocks[0].selectors.length === 1) // standalone :global() with multiple selectors is OK
            return;
            for (const block of this.blocks)for (const selector of block.selectors){
                if (selector.type === "PseudoClassSelector" && selector.name === "global") {
                    if (regex_is_single_css_selector.test(selector.children[0].value)) component.error(selector, compiler_errors.css_invalid_global_selector);
                }
            }
        }
        /** @param {import('../Component.js').default} component */ validate_invalid_combinator_without_selector(component) {
            for(let i = 0; i < this.blocks.length; i++){
                const block = this.blocks[i];
                if (block.combinator && block.selectors.length === 0) component.error(this.node, compiler_errors.css_invalid_selector(component.source.slice(this.node.start, this.node.end)));
                if (!block.combinator && block.selectors.length === 0) component.error(this.node, compiler_errors.css_invalid_selector(component.source.slice(this.node.start, this.node.end)));
            }
        }
        /** @param {import('../Component.js').default} component */ validate_global_compound_selector(component) {
            for (const block of this.blocks)for(let index = 0; index < block.selectors.length; index++){
                const selector = block.selectors[index];
                if (selector.type === "PseudoClassSelector" && selector.name === "global" && index !== 0 && selector.children && selector.children.length > 0 && !/[.:#[\s]/.test(selector.children[0].value[0])) component.error(selector, compiler_errors.css_invalid_global_selector_position);
            }
        }
        get_amount_class_specificity_increased() {
            let count = 0;
            for (const block of this.blocks)if (block.should_encapsulate) count++;
            return count;
        }
    }
    /**
 * @param {Block[]} blocks
 * @param {import('../nodes/Element.js').default} node
 * @param {Array<{ node: import('../nodes/Element.js').default; block: Block }>} to_encapsulate
 * @returns {boolean}
 */ function apply_selector(blocks, node, to_encapsulate) {
        const block = blocks.pop();
        if (!block) return false;
        if (!node) return block.global && blocks.every((block)=>block.global) || block.host && blocks.length === 0;
        switch(block_might_apply_to_node(block, node)){
            case BlockAppliesToNode.NotPossible:
                return false;
            case BlockAppliesToNode.UnknownSelectorType:
                // bail. TODO figure out what these could be
                to_encapsulate.push({
                    node: node,
                    block: block
                });
                return true;
        }
        if (block.combinator) {
            if (block.combinator.type === "Combinator" && block.combinator.name === " ") {
                for (const ancestor_block of blocks){
                    if (ancestor_block.global) continue;
                    if (ancestor_block.host) {
                        to_encapsulate.push({
                            node: node,
                            block: block
                        });
                        return true;
                    }
                    let parent = node;
                    while(parent = get_element_parent(parent))if (block_might_apply_to_node(ancestor_block, parent) !== BlockAppliesToNode.NotPossible) to_encapsulate.push({
                        node: parent,
                        block: ancestor_block
                    });
                    if (to_encapsulate.length) {
                        to_encapsulate.push({
                            node: node,
                            block: block
                        });
                        return true;
                    }
                }
                if (blocks.every((block)=>block.global)) {
                    to_encapsulate.push({
                        node: node,
                        block: block
                    });
                    return true;
                }
                return false;
            } else if (block.combinator.name === ">") {
                const has_global_parent = blocks.every((block)=>block.global);
                if (has_global_parent || apply_selector(blocks, get_element_parent(node), to_encapsulate)) {
                    to_encapsulate.push({
                        node: node,
                        block: block
                    });
                    return true;
                }
                return false;
            } else if (block.combinator.name === "+" || block.combinator.name === "~") {
                const [siblings, has_slot_sibling] = get_possible_element_siblings(node, block.combinator.name === "+");
                let has_match = false;
                // NOTE: if we have :global(), we couldn't figure out what is selected within `:global` due to the
                // css-tree limitation that does not parse the inner selector of :global
                // so unless we are sure there will be no sibling to match, we will consider it as matched
                const has_global = blocks.some((block)=>block.global);
                if (has_global) {
                    if (siblings.size === 0 && get_element_parent(node) !== null && !has_slot_sibling) return false;
                    to_encapsulate.push({
                        node: node,
                        block: block
                    });
                    return true;
                }
                for (const possible_sibling of siblings.keys())if (apply_selector(blocks.slice(), possible_sibling, to_encapsulate)) {
                    to_encapsulate.push({
                        node: node,
                        block: block
                    });
                    has_match = true;
                }
                return has_match;
            }
            // TODO other combinators
            to_encapsulate.push({
                node: node,
                block: block
            });
            return true;
        }
        to_encapsulate.push({
            node: node,
            block: block
        });
        return true;
    }
    const regex_backslash_and_following_character = /\\(.)/g;
    /**
 * @param {Block} block
 * @param {import('../nodes/Element.js').default} node
 * @returns {typeof BlockAppliesToNode[keyof typeof BlockAppliesToNode]}
 */ function block_might_apply_to_node(block, node) {
        let i = block.selectors.length;
        while(i--){
            const selector = block.selectors[i];
            const name = typeof selector.name === "string" && selector.name.replace(regex_backslash_and_following_character, "$1");
            if (selector.type === "PseudoClassSelector" && (name === "host" || name === "root")) return BlockAppliesToNode.NotPossible;
            if (block.selectors.length === 1 && selector.type === "PseudoClassSelector" && name === "global") return BlockAppliesToNode.NotPossible;
            if (selector.type === "PseudoClassSelector" || selector.type === "PseudoElementSelector") continue;
            if (selector.type === "ClassSelector") {
                if (!attribute_matches(node, "class", name, "~=", false) && !node.classes.some((c)=>c.name === name)) return BlockAppliesToNode.NotPossible;
            } else if (selector.type === "IdSelector") {
                if (!attribute_matches(node, "id", name, "=", false)) return BlockAppliesToNode.NotPossible;
            } else if (selector.type === "AttributeSelector") {
                if (!(whitelist_attribute_selector.has(node.name.toLowerCase()) && whitelist_attribute_selector.get(node.name.toLowerCase()).has(selector.name.name.toLowerCase())) && !attribute_matches(node, selector.name.name, selector.value && unquote(selector.value), selector.matcher, selector.flags)) return BlockAppliesToNode.NotPossible;
            } else if (selector.type === "TypeSelector") {
                if (node.name.toLowerCase() !== name.toLowerCase() && name !== "*" && !node.is_dynamic_element) return BlockAppliesToNode.NotPossible;
            } else return BlockAppliesToNode.UnknownSelectorType;
        }
        return BlockAppliesToNode.Possible;
    }
    /**
 * @param {any} operator
 * @param {any} expected_value
 * @param {any} case_insensitive
 * @param {any} value
 */ function test_attribute(operator, expected_value, case_insensitive, value) {
        if (case_insensitive) {
            expected_value = expected_value.toLowerCase();
            value = value.toLowerCase();
        }
        switch(operator){
            case "=":
                return value === expected_value;
            case "~=":
                return value.split(/\s/).includes(expected_value);
            case "|=":
                return `${value}-`.startsWith(`${expected_value}-`);
            case "^=":
                return value.startsWith(expected_value);
            case "$=":
                return value.endsWith(expected_value);
            case "*=":
                return value.includes(expected_value);
            default:
                throw new Error("this shouldn't happen");
        }
    }
    /**
 * @param {import('./private.js').CssNode} node
 * @param {string} name
 * @param {string} expected_value
 * @param {string} operator
 * @param {boolean} case_insensitive
 */ function attribute_matches(node, name, expected_value, operator, case_insensitive) {
        const spread = node.attributes.find((attr)=>attr.type === "Spread");
        if (spread) return true;
        if (node.bindings.some((binding)=>binding.name === name)) return true;
        const attr = node.attributes.find((attr)=>attr.name === name);
        if (!attr) return false;
        if (attr.is_true) return operator === null;
        if (expected_value == null) return true;
        if (attr.chunks.length === 1) {
            const value = attr.chunks[0];
            if (!value) return false;
            if (value.type === "Text") return test_attribute(operator, expected_value, case_insensitive, value.data);
        }
        const possible_values = new Set();
        let prev_values = [];
        for (const chunk of attr.chunks){
            const current_possible_values = new Set();
            if (chunk.type === "Text") current_possible_values.add(chunk.data);
            else gather_possible_values(chunk.node, current_possible_values);
            // impossible to find out all combinations
            if (current_possible_values.has(UNKNOWN)) return true;
            if (prev_values.length > 0) {
                const start_with_space = [];
                const remaining = [];
                current_possible_values.forEach((current_possible_value)=>{
                    if (regex_starts_with_whitespace.test(current_possible_value)) start_with_space.push(current_possible_value);
                    else remaining.push(current_possible_value);
                });
                if (remaining.length > 0) {
                    if (start_with_space.length > 0) prev_values.forEach((prev_value)=>possible_values.add(prev_value));
                    const combined = [];
                    prev_values.forEach((prev_value)=>{
                        remaining.forEach((value)=>{
                            combined.push(prev_value + value);
                        });
                    });
                    prev_values = combined;
                    start_with_space.forEach((value)=>{
                        if (regex_ends_with_whitespace.test(value)) possible_values.add(value);
                        else prev_values.push(value);
                    });
                    continue;
                } else {
                    prev_values.forEach((prev_value)=>possible_values.add(prev_value));
                    prev_values = [];
                }
            }
            current_possible_values.forEach((current_possible_value)=>{
                if (regex_ends_with_whitespace.test(current_possible_value)) possible_values.add(current_possible_value);
                else prev_values.push(current_possible_value);
            });
            if (prev_values.length < current_possible_values.size) prev_values.push(" ");
            if (prev_values.length > 20) // might grow exponentially, bail out
            return true;
        }
        prev_values.forEach((prev_value)=>possible_values.add(prev_value));
        if (possible_values.has(UNKNOWN)) return true;
        for (const value of possible_values){
            if (test_attribute(operator, expected_value, case_insensitive, value)) return true;
        }
        return false;
    }
    /** @param {import('./private.js').CssNode} value */ function unquote(value) {
        if (value.type === "Identifier") return value.name;
        const str = value.value;
        if (str[0] === str[str.length - 1] && str[0] === "'" || str[0] === '"') return str.slice(1, str.length - 1);
        return str;
    }
    /**
 * @param {import('../nodes/Element.js').default} node
 * @returns {any}
 */ function get_element_parent(node) {
        /** @type {import('../nodes/interfaces.js').INode} */ let parent = node;
        while((parent = parent.parent) && parent.type !== "Element");
        return /** @type {import('../nodes/Element.js').default | null} */ parent;
    }
    /**
 * Finds the given node's previous sibling in the DOM
 *
 * The Svelte <slot> is just a placeholder and is not actually real. Any children nodes
 * in <slot> are 'flattened' and considered as the same level as the <slot>'s siblings
 *
 * e.g.
 * <h1>Heading 1</h1>
 * <slot>
 *   <h2>Heading 2</h2>
 * </slot>
 *
 * is considered to look like:
 * <h1>Heading 1</h1>
 * <h2>Heading 2</h2>
 * @param {import('../nodes/interfaces.js').INode} node
 * @returns {[import('../nodes/interfaces.js').INode, boolean]}
 */ function find_previous_sibling(node) {
        /** @type {import('../nodes/interfaces.js').INode} */ let current_node = node;
        let has_slot_sibling = false;
        do {
            if (current_node.type === "Slot") {
                has_slot_sibling = true;
                const slot_children = current_node.children;
                if (slot_children.length > 0) {
                    current_node = slot_children.slice(-1)[0]; // go to its last child first
                    continue;
                }
            }
            while(!current_node.prev && current_node.parent && current_node.parent.type === "Slot")current_node = current_node.parent;
            current_node = current_node.prev;
        }while (current_node && current_node.type === "Slot");
        return [
            current_node,
            has_slot_sibling
        ];
    }
    /**
 * @param {import('../nodes/interfaces.js').INode} node
 * @param {boolean} adjacent_only
 * @returns {[Map<import('../nodes/Element.js').default, NodeExistsValue>, boolean]}
 */ function get_possible_element_siblings(node, adjacent_only) {
        /** @type {Map<import('../nodes/Element.js').default, NodeExistsValue>} */ const result = new Map();
        /** @type {import('../nodes/interfaces.js').INode} */ let prev = node;
        let has_slot_sibling = false;
        let slot_sibling_found = false;
        while(([prev, slot_sibling_found] = find_previous_sibling(prev)) && prev){
            has_slot_sibling = has_slot_sibling || slot_sibling_found;
            if (prev.type === "Element") {
                if (!prev.attributes.find((attr)=>attr.type === "Attribute" && attr.name.toLowerCase() === "slot")) result.set(prev, NodeExist.Definitely);
                if (adjacent_only) break;
            } else if (prev.type === "EachBlock" || prev.type === "IfBlock" || prev.type === "AwaitBlock") {
                const possible_last_child = get_possible_last_child(prev, adjacent_only);
                add_to_map(possible_last_child, result);
                if (adjacent_only && has_definite_elements(possible_last_child)) return [
                    result,
                    has_slot_sibling
                ];
            }
        }
        if (!prev || !adjacent_only) {
            /** @type {import('../nodes/interfaces.js').INode} */ let parent = node;
            let skip_each_for_last_child = node.type === "ElseBlock";
            while((parent = parent.parent) && (parent.type === "EachBlock" || parent.type === "IfBlock" || parent.type === "ElseBlock" || parent.type === "AwaitBlock")){
                const [possible_siblings, slot_sibling_found] = get_possible_element_siblings(parent, adjacent_only);
                has_slot_sibling = has_slot_sibling || slot_sibling_found;
                add_to_map(possible_siblings, result);
                if (parent.type === "EachBlock") {
                    // first child of each block can select the last child of each block as previous sibling
                    if (skip_each_for_last_child) skip_each_for_last_child = false;
                    else add_to_map(get_possible_last_child(parent, adjacent_only), result);
                } else if (parent.type === "ElseBlock") {
                    skip_each_for_last_child = true;
                    parent = parent.parent;
                }
                if (adjacent_only && has_definite_elements(possible_siblings)) break;
            }
        }
        return [
            result,
            has_slot_sibling
        ];
    }
    /**
 * @param {import('../nodes/EachBlock.js').default | import('../nodes/IfBlock.js').default | import('../nodes/AwaitBlock.js').default} block
 * @param {boolean} adjacent_only
 * @returns {Map<import('../nodes/Element.js').default, NodeExistsValue>}
 */ function get_possible_last_child(block, adjacent_only) {
        /** @typedef {Map<import('../nodes/Element.js').default, NodeExistsValue>} NodeMap */ /** @type {NodeMap} */ const result = new Map();
        if (block.type === "EachBlock") {
            /** @type {NodeMap} */ const each_result = loop_child(block.children, adjacent_only);
            /** @type {NodeMap} */ const else_result = block.else ? loop_child(block.else.children, adjacent_only) : new Map();
            const not_exhaustive = !has_definite_elements(else_result);
            if (not_exhaustive) {
                mark_as_probably(each_result);
                mark_as_probably(else_result);
            }
            add_to_map(each_result, result);
            add_to_map(else_result, result);
        } else if (block.type === "IfBlock") {
            /** @type {NodeMap} */ const if_result = loop_child(block.children, adjacent_only);
            /** @type {NodeMap} */ const else_result = block.else ? loop_child(block.else.children, adjacent_only) : new Map();
            const not_exhaustive = !has_definite_elements(if_result) || !has_definite_elements(else_result);
            if (not_exhaustive) {
                mark_as_probably(if_result);
                mark_as_probably(else_result);
            }
            add_to_map(if_result, result);
            add_to_map(else_result, result);
        } else if (block.type === "AwaitBlock") {
            /** @type {NodeMap} */ const pending_result = block.pending ? loop_child(block.pending.children, adjacent_only) : new Map();
            /** @type {NodeMap} */ const then_result = block.then ? loop_child(block.then.children, adjacent_only) : new Map();
            /** @type {NodeMap} */ const catch_result = block.catch ? loop_child(block.catch.children, adjacent_only) : new Map();
            const not_exhaustive = !has_definite_elements(pending_result) || !has_definite_elements(then_result) || !has_definite_elements(catch_result);
            if (not_exhaustive) {
                mark_as_probably(pending_result);
                mark_as_probably(then_result);
                mark_as_probably(catch_result);
            }
            add_to_map(pending_result, result);
            add_to_map(then_result, result);
            add_to_map(catch_result, result);
        }
        return result;
    }
    /**
 * @param {Map<import('../nodes/Element.js').default, NodeExistsValue>} result
 * @returns {boolean}
 */ function has_definite_elements(result) {
        if (result.size === 0) return false;
        for (const exist of result.values()){
            if (exist === NodeExist.Definitely) return true;
        }
        return false;
    }
    /**
 * @param {Map<import('../nodes/Element.js').default, NodeExistsValue>} from
 * @param {Map<import('../nodes/Element.js').default, NodeExistsValue>} to
 * @returns {void}
 */ function add_to_map(from, to) {
        from.forEach((exist, element)=>{
            to.set(element, higher_existence(exist, to.get(element)));
        });
    }
    /**
 * @param {NodeExistsValue | null} exist1
 * @param {NodeExistsValue | null} exist2
 * @returns {NodeExistsValue}
 */ function higher_existence(exist1, exist2) {
        if (exist1 === undefined || exist2 === undefined) return exist1 || exist2;
        return exist1 > exist2 ? exist1 : exist2;
    }
    /** @param {Map<import('../nodes/Element.js').default, NodeExistsValue>} result */ function mark_as_probably(result) {
        for (const key of result.keys())result.set(key, NodeExist.Probably);
    }
    /**
 * @param {import('../nodes/interfaces.js').INode[]} children
 * @param {boolean} adjacent_only
 */ function loop_child(children, adjacent_only) {
        /** @type {Map<import('../nodes/Element.js').default, NodeExistsValue>} */ const result = new Map();
        for(let i = children.length - 1; i >= 0; i--){
            const child = children[i];
            if (child.type === "Element") {
                result.set(child, NodeExist.Definitely);
                if (adjacent_only) break;
            } else if (child.type === "EachBlock" || child.type === "IfBlock" || child.type === "AwaitBlock") {
                const child_result = get_possible_last_child(child, adjacent_only);
                add_to_map(child_result, result);
                if (adjacent_only && has_definite_elements(child_result)) break;
            }
        }
        return result;
    }
    class Block {
        /** @type {boolean} */ host;
        /** @type {boolean} */ root;
        /** @type {import('./private.js').CssNode} */ combinator;
        /** @type {import('./private.js').CssNode[]} */ selectors;
        /** @type {number} */ start;
        /** @type {number} */ end;
        /** @type {boolean} */ should_encapsulate;
        /** @param {import('./private.js').CssNode} combinator */ constructor(combinator){
            this.combinator = combinator;
            this.host = false;
            this.root = false;
            this.selectors = [];
            this.start = null;
            this.end = null;
            this.should_encapsulate = false;
        }
        /** @param {import('./private.js').CssNode} selector */ add(selector) {
            if (this.selectors.length === 0) {
                this.start = selector.start;
                this.host = selector.type === "PseudoClassSelector" && selector.name === "host";
            }
            this.root = this.root || selector.type === "PseudoClassSelector" && selector.name === "root";
            this.selectors.push(selector);
            this.end = selector.end;
        }
        get global() {
            return this.selectors.length >= 1 && this.selectors[0].type === "PseudoClassSelector" && this.selectors[0].name === "global" && this.selectors.every((selector)=>selector.type === "PseudoClassSelector" || selector.type === "PseudoElementSelector");
        }
    }
    /** @param {import('./private.js').CssNode} selector */ function group_selectors(selector) {
        /** @type {Block} */ let block = new Block(null);
        const blocks = [
            block
        ];
        selector.children.forEach((child)=>{
            if (child.type === "WhiteSpace" || child.type === "Combinator") {
                block = new Block(child);
                blocks.push(block);
            } else block.add(child);
        });
        return blocks;
    }
    const regex_css_browser_prefix = /^-((webkit)|(moz)|(o)|(ms))-/;
    /**
 * @param {string} name
 * @returns {string}
 */ function remove_css_prefix(name) {
        return name.replace(regex_css_browser_prefix, "");
    }
    /** @param {import('./private.js').CssNode} node */ const is_keyframes_node = (node)=>remove_css_prefix(node.name) === "keyframes";
    /**
 * @param {import('./private.js').CssNode} param
 * @returns {true}
 */ const at_rule_has_declaration = ({ block: block })=>block && block.children && block.children.find((node)=>node.type === "Declaration");
    /**
 * @param {import('magic-string').default} code
 * @param {number} start
 * @param {Declaration[]} declarations
 * @returns {number}
 */ function minify_declarations(code, start, declarations) {
        let c = start;
        declarations.forEach((declaration, i)=>{
            const separator = i > 0 ? ";" : "";
            if (declaration.node.start - c > separator.length) code.update(c, declaration.node.start, separator);
            declaration.minify(code);
            c = declaration.node.end;
        });
        return c;
    }
    class Rule {
        /** @type {import('./Selector.js').default[]} */ selectors;
        /** @type {Declaration[]} */ declarations;
        /** @type {import('./private.js').CssNode} */ node;
        /** @type {Atrule} */ parent;
        /**
	 * @param {import('./private.js').CssNode} node
	 * @param {any} stylesheet
	 * @param {Atrule} [parent]
	 */ constructor(node, stylesheet, parent){
            this.node = node;
            this.parent = parent;
            this.selectors = node.prelude.children.map((node)=>new Selector(node, stylesheet));
            this.declarations = node.block.children.map((node)=>new Declaration(node));
        }
        /** @param {import('../nodes/Element.js').default} node */ apply(node) {
            this.selectors.forEach((selector)=>selector.apply(node)); // TODO move the logic in here?
        }
        /** @param {boolean} dev */ is_used(dev) {
            if (this.parent && this.parent.node.type === "Atrule" && is_keyframes_node(this.parent.node)) return true;
            if (this.declarations.length === 0) return dev;
            return this.selectors.some((s)=>s.used);
        }
        /**
	 * @param {import('magic-string').default} code
	 * @param {boolean} _dev
	 */ minify(code, _dev) {
            let c = this.node.start;
            let started = false;
            this.selectors.forEach((selector)=>{
                if (selector.used) {
                    const separator = started ? "," : "";
                    if (selector.node.start - c > separator.length) code.update(c, selector.node.start, separator);
                    selector.minify(code);
                    c = selector.node.end;
                    started = true;
                }
            });
            code.remove(c, this.node.block.start);
            c = this.node.block.start + 1;
            c = minify_declarations(code, c, this.declarations);
            code.remove(c, this.node.block.end - 1);
        }
        /**
	 * @param {import('magic-string').default} code
	 * @param {string} id
	 * @param {Map<string, string>} keyframes
	 * @param {number} max_amount_class_specificity_increased
	 */ transform(code, id, keyframes, max_amount_class_specificity_increased) {
            if (this.parent && this.parent.node.type === "Atrule" && is_keyframes_node(this.parent.node)) return true;
            const attr = `.${id}`;
            this.selectors.forEach((selector)=>selector.transform(code, attr, max_amount_class_specificity_increased));
            this.declarations.forEach((declaration)=>declaration.transform(code, keyframes));
        }
        /** @param {import('../Component.js').default} component */ validate(component) {
            this.selectors.forEach((selector)=>{
                selector.validate(component);
            });
        }
        /** @param {(selector: import('./Selector.js').default) => void} handler */ warn_on_unused_selector(handler) {
            this.selectors.forEach((selector)=>{
                if (!selector.used) handler(selector);
            });
        }
        get_max_amount_class_specificity_increased() {
            return Math.max(...this.selectors.map((selector)=>selector.get_amount_class_specificity_increased()));
        }
    }
    class Declaration {
        /** @type {import('./private.js').CssNode} */ node;
        /** @param {import('./private.js').CssNode} node */ constructor(node){
            this.node = node;
        }
        /**
	 * @param {import('magic-string').default} code
	 * @param {Map<string, string>} keyframes
	 */ transform(code, keyframes) {
            const property = this.node.property && remove_css_prefix(this.node.property.toLowerCase());
            if (property === "animation" || property === "animation-name") this.node.value.children.forEach((block)=>{
                if (block.type === "Identifier") {
                    const name = block.name;
                    if (keyframes.has(name)) code.update(block.start, block.end, keyframes.get(name));
                }
            });
        }
        /** @param {import('magic-string').default} code */ minify(code) {
            if (!this.node.property) return; // @apply, and possibly other weird cases?
            const c = this.node.start + this.node.property.length;
            const first = this.node.value.children ? this.node.value.children[0] : this.node.value;
            // Don't minify whitespace in custom properties, since some browsers (Chromium < 99)
            // treat --foo: ; and --foo:; differently
            if (first.type === "Raw" && regex_only_whitespaces.test(first.value)) return;
            let start = first.start;
            while(regex_whitespace.test(code.original[start]))start += 1;
            if (start - c > 1) code.update(c, start, ":");
        }
    }
    class Atrule {
        /** @type {import('./private.js').CssNode} */ node;
        /** @type {Array<Atrule | Rule>} */ children;
        /** @type {Declaration[]} */ declarations;
        /** @param {import('./private.js').CssNode} node */ constructor(node){
            this.node = node;
            this.children = [];
            this.declarations = [];
        }
        /** @param {import('../nodes/Element.js').default} node */ apply(node) {
            if (this.node.name === "container" || this.node.name === "media" || this.node.name === "supports" || this.node.name === "layer") this.children.forEach((child)=>{
                child.apply(node);
            });
            else if (is_keyframes_node(this.node)) this.children.forEach((/** @type {Rule} */ rule)=>{
                rule.selectors.forEach((selector)=>{
                    selector.used = true;
                });
            });
        }
        /** @param {boolean} _dev */ is_used(_dev) {
            return true; // TODO
        }
        /**
	 * @param {import('magic-string').default} code
	 * @param {boolean} dev
	 */ minify(code, dev) {
            if (this.node.name === "media") {
                const expression_char = code.original[this.node.prelude.start];
                let c = this.node.start + (expression_char === "(" ? 6 : 7);
                if (this.node.prelude.start > c) code.remove(c, this.node.prelude.start);
                this.node.prelude.children.forEach((query)=>{
                    // TODO minify queries
                    c = query.end;
                });
                code.remove(c, this.node.block.start);
            } else if (this.node.name === "supports") {
                let c = this.node.start + 9;
                if (this.node.prelude.start - c > 1) code.update(c, this.node.prelude.start, " ");
                this.node.prelude.children.forEach((query)=>{
                    // TODO minify queries
                    c = query.end;
                });
                code.remove(c, this.node.block.start);
            } else {
                let c = this.node.start + this.node.name.length + 1;
                if (this.node.prelude) {
                    if (this.node.prelude.start - c > 1) code.update(c, this.node.prelude.start, " ");
                    c = this.node.prelude.end;
                }
                if (this.node.block && this.node.block.start - c > 0) code.remove(c, this.node.block.start);
            }
            // TODO other atrules
            if (this.node.block) {
                let c = this.node.block.start + 1;
                if (this.declarations.length) {
                    c = minify_declarations(code, c, this.declarations);
                    // if the atrule has children, leave the last declaration semicolon alone
                    if (this.children.length) c++;
                }
                this.children.forEach((child)=>{
                    if (child.is_used(dev)) {
                        code.remove(c, child.node.start);
                        child.minify(code, dev);
                        c = child.node.end;
                    }
                });
                code.remove(c, this.node.block.end - 1);
            }
        }
        /**
	 * @param {import('magic-string').default} code
	 * @param {string} id
	 * @param {Map<string, string>} keyframes
	 * @param {number} max_amount_class_specificity_increased
	 */ transform(code, id, keyframes, max_amount_class_specificity_increased) {
            if (is_keyframes_node(this.node)) this.node.prelude.children.forEach(({ type: type, name: name, start: start, end: end })=>{
                if (type === "Identifier") {
                    if (name.startsWith("-global-")) {
                        code.remove(start, start + 8);
                        this.children.forEach((/** @type {Rule} */ rule)=>{
                            rule.selectors.forEach((selector)=>{
                                selector.used = true;
                            });
                        });
                    } else code.update(start, end, keyframes.get(name));
                }
            });
            this.children.forEach((child)=>{
                child.transform(code, id, keyframes, max_amount_class_specificity_increased);
            });
        }
        /** @param {import('../Component.js').default} component */ validate(component) {
            this.children.forEach((child)=>{
                child.validate(component);
            });
        }
        /** @param {(selector: import('./Selector.js').default) => void} handler */ warn_on_unused_selector(handler) {
            if (this.node.name !== "media") return;
            this.children.forEach((child)=>{
                child.warn_on_unused_selector(handler);
            });
        }
        get_max_amount_class_specificity_increased() {
            return Math.max(...this.children.map((rule)=>rule.get_max_amount_class_specificity_increased()));
        }
    }
    /** @param {any} params */ const get_default_css_hash = ({ css: css, hash: hash })=>{
        return `svelte-${hash(css)}`;
    };
    class Stylesheet {
        /** @type {string} */ source;
        /** @type {import('../../interfaces.js').Ast} */ ast;
        /** @type {string} */ filename;
        /** @type {boolean} */ dev;
        /** @type {boolean} */ has_styles;
        /** @type {string} */ id;
        /** @type {Array<Rule | Atrule>} */ children = [];
        /** @type {Map<string, string>} */ keyframes = new Map();
        /** @type {Set<import('./private.js').CssNode>} */ nodes_with_css_class = new Set();
        /**
	 * @param {{
	 * 		source: string;
	 * 		ast: import('../../interfaces.js').Ast;
	 * 		filename: string | undefined;
	 * 		component_name: string | undefined;
	 * 		dev: boolean;
	 * 		get_css_hash: import('../../interfaces.js').CssHashGetter;
	 * 	}} params
	 */ constructor({ source: source, ast: ast, component_name: component_name, filename: filename, dev: dev, get_css_hash: get_css_hash = get_default_css_hash }){
            this.source = source;
            this.ast = ast;
            this.filename = filename;
            this.dev = dev;
            if (ast.css && ast.css.children.length) {
                this.id = get_css_hash({
                    filename: filename,
                    name: component_name,
                    css: ast.css.content.styles,
                    hash: hash
                });
                this.has_styles = true;
                /** @type {Atrule[]} */ const stack = [];
                let depth = 0;
                /** @type {Atrule} */ let current_atrule = null;
                walk(/** @type {any} */ ast.css, {
                    enter: (/** @type {any} */ node)=>{
                        if (node.type === "Atrule") {
                            const atrule = new Atrule(node);
                            stack.push(atrule);
                            if (current_atrule) current_atrule.children.push(atrule);
                            else if (depth <= 1) this.children.push(atrule);
                            if (is_keyframes_node(node)) node.prelude.children.forEach((expression)=>{
                                if (expression.type === "Identifier" && !expression.name.startsWith("-global-")) this.keyframes.set(expression.name, `${this.id}-${expression.name}`);
                            });
                            else if (at_rule_has_declaration(node)) {
                                const at_rule_declarations = node.block.children.filter((node)=>node.type === "Declaration").map((node)=>new Declaration(node));
                                push_array(atrule.declarations, at_rule_declarations);
                            }
                            current_atrule = atrule;
                        }
                        if (node.type === "Rule") {
                            const rule = new Rule(node, this, current_atrule);
                            if (current_atrule) current_atrule.children.push(rule);
                            else if (depth <= 1) this.children.push(rule);
                        }
                        depth += 1;
                    },
                    leave: (/** @type {any} */ node)=>{
                        if (node.type === "Atrule") {
                            stack.pop();
                            current_atrule = stack[stack.length - 1];
                        }
                        depth -= 1;
                    }
                });
            } else this.has_styles = false;
        }
        /** @param {import('../nodes/Element.js').default} node */ apply(node) {
            if (!this.has_styles) return;
            for(let i = 0; i < this.children.length; i += 1){
                const child = this.children[i];
                child.apply(node);
            }
        }
        reify() {
            this.nodes_with_css_class.forEach((node)=>{
                node.add_css_class();
            });
        }
        /** @param {string} file */ render(file) {
            if (!this.has_styles) return {
                code: null,
                map: null
            };
            const code = new MagicString(this.source);
            walk(/** @type {any} */ this.ast.css, {
                enter: (/** @type {any} */ node)=>{
                    code.addSourcemapLocation(node.start);
                    code.addSourcemapLocation(node.end);
                }
            });
            const max = Math.max(...this.children.map((rule)=>rule.get_max_amount_class_specificity_increased()));
            this.children.forEach((child)=>{
                child.transform(code, this.id, this.keyframes, max);
            });
            let c = 0;
            this.children.forEach((child)=>{
                if (child.is_used(this.dev)) {
                    code.remove(c, child.node.start);
                    child.minify(code, this.dev);
                    c = child.node.end;
                }
            });
            code.remove(c, this.source.length);
            return {
                code: code.toString(),
                map: code.generateMap({
                    includeContent: true,
                    source: this.filename,
                    file: file
                })
            };
        }
        /** @param {import('../Component.js').default} component */ validate(component) {
            this.children.forEach((child)=>{
                child.validate(component);
            });
        }
        /** @param {import('../Component.js').default} component */ warn_on_unused_selectors(component) {
            const ignores = !this.ast.css ? [] : extract_ignores_above_position(this.ast.css.start, this.ast.html.children);
            component.push_ignores(ignores);
            this.children.forEach((child)=>{
                child.warn_on_unused_selector((selector)=>{
                    component.warn(selector.node, compiler_warnings.css_unused_selector(this.source.slice(selector.node.start, selector.node.end)));
                });
            });
            component.pop_ignores();
        }
    }
    /** The scope of constructs within the Svelte template */ class TemplateScope {
        /**
	 * @typedef {import('../EachBlock').default
	 * 	| import('../ThenBlock').default
	 * 	| import('../CatchBlock').default
	 * 	| import('../InlineComponent').default
	 * 	| import('../Element').default
	 * 	| import('../SlotTemplate').default
	 * 	| import('../ConstTag').default} NodeWithScope
	 */ /** @type {Set<string>} */ names;
        /** @type {Map<string, Set<string>>} */ dependencies_for_name;
        /** @type {Map<string, NodeWithScope>} */ owners = new Map();
        /** @type {TemplateScope} */ parent;
        /** @param {TemplateScope} [parent]  undefined */ constructor(parent){
            this.parent = parent;
            this.names = new Set(parent ? parent.names : []);
            this.dependencies_for_name = new Map(parent ? parent.dependencies_for_name : []);
        }
        /**
	 * @param {any} name
	 * @param {Set<string>} dependencies
	 * @param {any} owner
	 */ add(name, dependencies, owner) {
            this.names.add(name);
            this.dependencies_for_name.set(name, dependencies);
            this.owners.set(name, owner);
            return this;
        }
        child() {
            const child = new TemplateScope(this);
            return child;
        }
        /** @param {string} name */ is_top_level(name) {
            return !this.parent || !this.names.has(name) && this.parent.is_top_level(name);
        }
        /**
	 * @param {string} name
	 * @returns {NodeWithScope}
	 */ get_owner(name) {
            return this.owners.get(name) || this.parent && this.parent.get_owner(name);
        }
        /** @param {string} name */ is_let(name) {
            const owner = this.get_owner(name);
            return owner && (owner.type === "Element" || owner.type === "InlineComponent" || owner.type === "SlotTemplate");
        }
        /** @param {string} name */ is_await(name) {
            const owner = this.get_owner(name);
            return owner && (owner.type === "ThenBlock" || owner.type === "CatchBlock");
        }
        /** @param {string} name */ is_const(name) {
            const owner = this.get_owner(name);
            return owner && owner.type === "ConstTag";
        }
    }
    /** @extends Node<'Fragment'> */ class Fragment extends Node {
        /** @type {import('../render_dom/Block.js').default} */ block;
        /** @type {import('./interfaces.js').INode[]} */ children;
        /** @type {import('./shared/TemplateScope.js').default} */ scope;
        /**
	 * @param {import('../Component.js').default} component
	 * @param {import('../../interfaces.js').TemplateNode} info
	 */ constructor(component, info){
            const scope = new TemplateScope();
            super(component, null, scope, info);
            this.scope = scope;
            this.children = map_children(component, this, scope, info.children);
        }
    }
    // This file is automatically generated
    var internal_exports = new Set([
        "HtmlTag",
        "HtmlTagHydration",
        "ResizeObserverSingleton",
        "SvelteComponent",
        "SvelteComponentDev",
        "SvelteComponentTyped",
        "SvelteElement",
        "action_destroyer",
        "add_attribute",
        "add_classes",
        "add_flush_callback",
        "add_iframe_resize_listener",
        "add_location",
        "add_render_callback",
        "add_styles",
        "add_transform",
        "afterUpdate",
        "append",
        "append_dev",
        "append_empty_stylesheet",
        "append_hydration",
        "append_hydration_dev",
        "append_styles",
        "assign",
        "attr",
        "attr_dev",
        "attribute_to_object",
        "beforeUpdate",
        "bind",
        "binding_callbacks",
        "blank_object",
        "bubble",
        "check_outros",
        "children",
        "claim_comment",
        "claim_component",
        "claim_element",
        "claim_html_tag",
        "claim_space",
        "claim_svg_element",
        "claim_text",
        "clear_loops",
        "comment",
        "component_subscribe",
        "compute_rest_props",
        "compute_slots",
        "construct_svelte_component",
        "construct_svelte_component_dev",
        "contenteditable_truthy_values",
        "createEventDispatcher",
        "create_animation",
        "create_bidirectional_transition",
        "create_component",
        "create_custom_element",
        "create_in_transition",
        "create_out_transition",
        "create_slot",
        "create_ssr_component",
        "current_component",
        "custom_event",
        "dataset_dev",
        "debug",
        "destroy_block",
        "destroy_component",
        "destroy_each",
        "detach",
        "detach_after_dev",
        "detach_before_dev",
        "detach_between_dev",
        "detach_dev",
        "dirty_components",
        "dispatch_dev",
        "each",
        "element",
        "element_is",
        "empty",
        "end_hydrating",
        "ensure_array_like",
        "ensure_array_like_dev",
        "escape",
        "escape_attribute_value",
        "escape_object",
        "exclude_internal_props",
        "fix_and_destroy_block",
        "fix_and_outro_and_destroy_block",
        "fix_position",
        "flush",
        "flush_render_callbacks",
        "getAllContexts",
        "getContext",
        "get_all_dirty_from_scope",
        "get_binding_group_value",
        "get_current_component",
        "get_custom_elements_slots",
        "get_root_for_style",
        "get_slot_changes",
        "get_spread_object",
        "get_spread_update",
        "get_store_value",
        "get_svelte_dataset",
        "globals",
        "group_outros",
        "handle_promise",
        "hasContext",
        "has_prop",
        "head_selector",
        "identity",
        "init",
        "init_binding_group",
        "init_binding_group_dynamic",
        "insert",
        "insert_dev",
        "insert_hydration",
        "insert_hydration_dev",
        "intros",
        "invalid_attribute_name_character",
        "is_client",
        "is_crossorigin",
        "is_empty",
        "is_function",
        "is_promise",
        "is_void",
        "listen",
        "listen_dev",
        "loop",
        "loop_guard",
        "merge_ssr_styles",
        "missing_component",
        "mount_component",
        "noop",
        "not_equal",
        "now",
        "null_to_empty",
        "object_without_properties",
        "onDestroy",
        "onMount",
        "once",
        "outro_and_destroy_block",
        "prevent_default",
        "prop_dev",
        "query_selector_all",
        "raf",
        "resize_observer_border_box",
        "resize_observer_content_box",
        "resize_observer_device_pixel_content_box",
        "run",
        "run_all",
        "safe_not_equal",
        "schedule_update",
        "select_multiple_value",
        "select_option",
        "select_options",
        "select_value",
        "self",
        "setContext",
        "set_attributes",
        "set_current_component",
        "set_custom_element_data",
        "set_custom_element_data_map",
        "set_data",
        "set_data_contenteditable",
        "set_data_contenteditable_dev",
        "set_data_dev",
        "set_data_maybe_contenteditable",
        "set_data_maybe_contenteditable_dev",
        "set_dynamic_element_data",
        "set_input_type",
        "set_input_value",
        "set_now",
        "set_raf",
        "set_store_value",
        "set_style",
        "set_svg_attributes",
        "space",
        "split_css_unit",
        "spread",
        "src_url_equal",
        "srcset_url_equal",
        "start_hydrating",
        "stop_immediate_propagation",
        "stop_propagation",
        "stringify_spread",
        "subscribe",
        "svg_element",
        "text",
        "tick",
        "time_ranges_to_array",
        "to_number",
        "toggle_class",
        "transition_in",
        "transition_out",
        "trusted",
        "update_await_block_branch",
        "update_keyed_each",
        "update_slot",
        "update_slot_base",
        "validate_component",
        "validate_dynamic_element",
        "validate_each_keys",
        "validate_slots",
        "validate_store",
        "validate_void_dynamic_element",
        "xlink_attr"
    ]);
    /**
 *
 * @param {import('estree').Node} node
 * @param {import('estree').Node} parent
 * @returns {boolean}
 */ function is_used_as_reference(node, parent) {
        if (!is_reference(/** @type {import('is-reference').NodeWithPropertyDefinition} */ node, /** @type {import('is-reference').NodeWithPropertyDefinition} */ parent)) return false;
        if (!parent) return true;
        /* eslint-disable no-fallthrough */ switch(parent.type){
            // disregard the `foo` in `const foo = bar`
            case "VariableDeclarator":
                return node !== parent.id;
            // disregard the `foo`, `bar` in `function foo(bar){}`
            case "FunctionDeclaration":
            // disregard the `foo` in `import { foo } from 'foo'`
            case "ImportSpecifier":
            // disregard the `foo` in `import foo from 'foo'`
            case "ImportDefaultSpecifier":
            // disregard the `foo` in `import * as foo from 'foo'`
            case "ImportNamespaceSpecifier":
            // disregard the `foo` in `export { foo }`
            case "ExportSpecifier":
                return false;
            default:
                return true;
        }
    }
    // generated during release, do not modify
    /**
 * The current version, as set in package.json.
 *
 * https://svelte.dev/docs/svelte-compiler#svelte-version
 * @type {string}
 */ const VERSION = "4.2.19";
    const regex_leading_directory_separator = /^[/\\]/;
    const regex_starts_with_term_export = /^Export/;
    const regex_contains_term_function = /Function/;
    class Component {
        /** @type {import('../Stats.js').default} */ stats;
        /** @type {import('../interfaces.js').Warning[]} */ warnings;
        /** @type {Set<string>} */ ignores;
        /** @type {Array<Set<string>>} */ ignore_stack = [];
        /** @type {import('../interfaces.js').Ast} */ ast;
        /** @type {import('../interfaces.js').Ast} */ original_ast;
        /** @type {string} */ source;
        /** @type {import('estree').Identifier} */ name;
        /** @type {import('../interfaces.js').CompileOptions} */ compile_options;
        /** @type {import('./nodes/Fragment.js').default} */ fragment;
        /** @type {import('./utils/scope.js').Scope} */ module_scope;
        /** @type {import('./utils/scope.js').Scope} */ instance_scope;
        /** @type {WeakMap<import('estree').Node, import('./utils/scope.js').Scope>} */ instance_scope_map;
        /** @type {ComponentOptions} */ component_options;
        /** @type {string} */ namespace;
        /** @type {string} */ tag;
        /** @type {boolean} */ accessors;
        /** @type {import('../interfaces.js').Var[]} */ vars = [];
        /** @type {Map<string, import('../interfaces.js').Var>} */ var_lookup = new Map();
        /** @type {import('estree').ImportDeclaration[]} */ imports = [];
        /** @type {import('estree').ExportNamedDeclaration[]} */ exports_from = [];
        /** @type {import('estree').ExportNamedDeclaration[]} */ instance_exports_from = [];
        /** @type {Set<import('estree').Node>} */ hoistable_nodes = new Set();
        /** @type {Map<string, import('estree').Node>} */ node_for_declaration = new Map();
        /** @type {Array<import('estree').Node | import('estree').Node[]>} */ partly_hoisted = [];
        /** @type {Array<import('estree').Node | import('estree').Node[]>} */ fully_hoisted = [];
        /**
	 * @type {Array<{
	 * 		assignees: Set<string>;
	 * 		dependencies: Set<string>;
	 * 		node: import('estree').Node;
	 * 		declaration: import('estree').Node;
	 * 	}>}
	 */ reactive_declarations = [];
        /** @type {Set<import('estree').Node>} */ reactive_declaration_nodes = new Set();
        /** */ has_reactive_assignments = false;
        /** @type {Set<string>} */ injected_reactive_declaration_vars = new Set();
        /** @type {Map<string, import('estree').Identifier>} */ helpers = new Map();
        /** @type {Map<string, import('estree').Identifier>} */ globals = new Map();
        /** @type {Map<string, Set<string>>} */ indirect_dependencies = new Map();
        /** @type {string} */ file;
        /**
	 * Use this for stack traces. It is 1-based and acts on pre-processed sources.
	 * Use `meta_locate` for metadata on DOM elements.
	 * @type {(c: number) => { line: number; column: number }}
	 */ locate;
        /**
	 * Use this for metadata on DOM elements. It is 1-based and acts on sources that have not been pre-processed.
	 * Use `locate` for source mappings.
	 * @type {(c: number) => { line: number; column: number }}
	 */ meta_locate;
        /** @type {import('./nodes/Element.js').default[]} */ elements = [];
        /** @type {import('./css/Stylesheet.js').default} */ stylesheet;
        /** @type {Map<string, import('estree').Identifier>} */ aliases = new Map();
        /** @type {Set<string>} */ used_names = new Set();
        /** @type {Set<string>} */ globally_used_names = new Set();
        /** @type {Map<string, import('./nodes/Slot.js').default>} */ slots = new Map();
        /** @type {Set<string>} */ slot_outlets = new Set();
        /** @type {import('./nodes/shared/Tag.js').default[]} */ tags = [];
        /**
	 * @param {import('../interfaces.js').Ast} ast
	 * @param {string} source
	 * @param {string} name
	 * @param {import('../interfaces.js').CompileOptions} compile_options
	 * @param {import('../Stats.js').default} stats
	 * @param {import('../interfaces.js').Warning[]} warnings
	 */ constructor(ast, source, name, compile_options, stats, warnings){
            this.name = {
                type: "Identifier",
                name: name
            };
            this.stats = stats;
            this.warnings = warnings;
            this.ast = ast;
            this.source = source;
            this.compile_options = compile_options;
            // the instance JS gets mutated, so we park
            // a copy here for later. TODO this feels gross
            this.original_ast = clone({
                html: ast.html,
                css: ast.css,
                instance: ast.instance,
                module: ast.module
            });
            this.file = compile_options.filename && (typeof process !== "undefined" ? compile_options.filename.replace(process.cwd(), "").replace(regex_leading_directory_separator, "") : compile_options.filename);
            // line numbers in stack trace frames are 1-based. source maps are 0-based
            this.locate = getLocator$1(this.source, {
                offsetLine: 1
            });
            /** @type {TraceMap | null | undefined} initialise lazy because only used in dev mode */ let tracer;
            this.meta_locate = (c)=>{
                /** @type {{ line: number, column: number }} */ let location = this.locate(c);
                if (tracer === undefined) // @ts-expect-error - fix the type of CompileOptions.sourcemap
                tracer = compile_options.sourcemap ? new TraceMap(compile_options.sourcemap) : null;
                if (tracer) // originalPositionFor returns 1-based lines like locator
                location = originalPositionFor$1(tracer, location);
                return location;
            };
            // styles
            this.stylesheet = new Stylesheet({
                source: source,
                ast: ast,
                filename: compile_options.filename,
                component_name: name,
                dev: compile_options.dev,
                get_css_hash: compile_options.cssHash
            });
            this.stylesheet.validate(this);
            this.component_options = process_component_options(this, this.ast.html.children);
            this.namespace = namespaces[this.component_options.namespace] || this.component_options.namespace;
            if (compile_options.customElement) this.tag = this.component_options.customElement?.tag || compile_options.tag || this.name.name;
            else this.tag = this.name.name;
            this.walk_module_js();
            this.push_ignores(this.ast.instance ? extract_ignores_above_position(this.ast.instance.start, this.ast.html.children) : []);
            this.walk_instance_js_pre_template();
            this.pop_ignores();
            this.fragment = new Fragment(this, ast.html);
            this.name = this.get_unique_name(name);
            this.push_ignores(this.ast.instance ? extract_ignores_above_position(this.ast.instance.start, this.ast.html.children) : []);
            this.walk_instance_js_post_template();
            this.pop_ignores();
            this.elements.forEach((element)=>this.stylesheet.apply(element));
            this.stylesheet.reify();
            this.stylesheet.warn_on_unused_selectors(this);
        }
        /**
	 * @param {import('estree').Node} node
	 * @param {import('../interfaces.js').Var} variable
	 * @param {any} add_to_lookup
	 */ add_var(node, variable, add_to_lookup = true) {
            this.vars.push(variable);
            if (add_to_lookup) {
                if (this.var_lookup.has(variable.name)) {
                    const exists_var = this.var_lookup.get(variable.name);
                    if (exists_var.module && exists_var.imported) this.error(/** @type {any} */ node, compiler_errors.illegal_variable_declaration);
                }
                this.var_lookup.set(variable.name, variable);
            }
        }
        /**
	 * @param {import('estree').Node} node
	 * @param {string} name
	 */ add_reference(node, name) {
            const variable = this.var_lookup.get(name);
            if (variable) variable.referenced = true;
            else if (is_reserved_keyword(name)) this.add_var(node, {
                name: name,
                injected: true,
                referenced: true
            });
            else if (name[0] === "$") {
                this.add_var(node, {
                    name: name,
                    injected: true,
                    referenced: true,
                    mutated: true,
                    writable: true
                });
                const subscribable_name = name.slice(1);
                const variable = this.var_lookup.get(subscribable_name);
                if (variable) {
                    variable.referenced = true;
                    variable.subscribable = true;
                }
            } else {
                if (this.compile_options.varsReport === "full") this.add_var(node, {
                    name: name,
                    referenced: true
                }, false);
                this.used_names.add(name);
            }
        }
        /** @param {string} name */ alias(name) {
            if (!this.aliases.has(name)) this.aliases.set(name, this.get_unique_name(name));
            return this.aliases.get(name);
        }
        /** @param {import('./nodes/Element.js').default} element */ apply_stylesheet(element) {
            this.elements.push(element);
        }
        /** @param {string} name */ global(name) {
            const alias = this.alias(name);
            this.globals.set(name, alias);
            return alias;
        }
        /**
	 * @param {{ js: import('estree').Node[]; css: import('../interfaces.js').CssResult }} [result]
	 * @returns {import('../interfaces.js').CompileResult}
	 */ generate(result) {
            let js = null;
            let css = null;
            if (result) {
                const { compile_options: compile_options, name: name } = this;
                const banner = `${this.file ? `${this.file} ` : ""}generated by Svelte v${VERSION}`;
                /** @type {any} */ const program = {
                    type: "Program",
                    body: result.js
                };
                walk(program, {
                    enter: /**
				 * @param {import('estree').Node} node
				 * @param {import('estree').Node} parent
				 * @param {any} key
				 */ (node, parent, key)=>{
                        if (node.type === "Identifier") {
                            if (node.name[0] === "@") {
                                if (node.name[1] === "_") {
                                    const alias = this.global(node.name.slice(2));
                                    node.name = alias.name;
                                } else {
                                    let name = node.name.slice(1);
                                    if (compile_options.hydratable) {
                                        if (internal_exports.has(`${name}_hydration`)) name += "_hydration";
                                        else if (internal_exports.has(`${name}Hydration`)) name += "Hydration";
                                    }
                                    if (compile_options.dev) {
                                        if (internal_exports.has(`${name}_dev`)) name += "_dev";
                                        else if (internal_exports.has(`${name}Dev`)) name += "Dev";
                                    }
                                    const alias = this.alias(name);
                                    this.helpers.set(name, alias);
                                    node.name = alias.name;
                                }
                            } else if (node.name[0] !== "#" && !is_valid(node.name)) {
                                // this hack allows x`foo.${bar}` where bar could be invalid
                                /** @type {import('estree').Literal} */ const literal = {
                                    type: "Literal",
                                    value: node.name
                                };
                                if (parent.type === "Property" && key === "key") parent.key = literal;
                                else if (parent.type === "MemberExpression" && key === "property") {
                                    parent.property = literal;
                                    parent.computed = true;
                                }
                            }
                        }
                    }
                });
                const referenced_globals = Array.from(this.globals, ([name, alias])=>name !== alias.name && {
                        name: name,
                        alias: alias
                    }).filter(Boolean);
                if (referenced_globals.length) this.helpers.set("globals", this.alias("globals"));
                const imported_helpers = Array.from(this.helpers, ([name, alias])=>({
                        name: name,
                        alias: alias
                    }));
                create_module(program, name, banner, compile_options.sveltePath, imported_helpers, referenced_globals, this.imports, this.vars.filter((variable)=>variable.module && variable.export_name).map((variable)=>({
                        name: variable.name,
                        as: variable.export_name
                    })), this.exports_from);
                css = compile_options.customElement ? {
                    code: null,
                    map: null
                } : result.css;
                const js_sourcemap_enabled = check_enable_sourcemap(compile_options.enableSourcemap, "js");
                if (!js_sourcemap_enabled) {
                    js = print(program);
                    js.map = null;
                } else {
                    const sourcemap_source_filename = get_sourcemap_source_filename(compile_options);
                    js = print(program, {
                        sourceMapSource: sourcemap_source_filename
                    });
                    js.map.sources = [
                        sourcemap_source_filename
                    ];
                    js.map.sourcesContent = [
                        this.source
                    ];
                    js.map = apply_preprocessor_sourcemap(sourcemap_source_filename, js.map, /** @type {string | import('@ampproject/remapping').RawSourceMap | import('@ampproject/remapping').DecodedSourceMap} */ compile_options.sourcemap);
                }
            }
            return {
                js: js,
                css: css,
                ast: this.original_ast,
                warnings: this.warnings,
                vars: this.get_vars_report(),
                stats: this.stats.render()
            };
        }
        /**
	 * @param {string} name
	 * @param {import('./utils/scope.js').Scope} [scope]
	 * @returns {import('estree').Identifier}
	 */ get_unique_name(name, scope) {
            let alias = name;
            for(let i = 1; reserved.has(alias) || this.var_lookup.has(alias) || this.used_names.has(alias) || this.globally_used_names.has(alias) || scope && scope.has(alias);)alias = `${name}_${i++}`;
            this.used_names.add(alias);
            return {
                type: "Identifier",
                name: alias
            };
        }
        get_unique_name_maker() {
            const local_used_names = new Set();
            /** @param {string} name */ function add(name) {
                local_used_names.add(name);
            }
            reserved.forEach(add);
            internal_exports.forEach(add);
            this.var_lookup.forEach((_value, key)=>add(key));
            /**
		 * @param {string} name
		 * @returns {import('estree').Identifier}
		 */ return (name)=>{
                let alias = name;
                for(let i = 1; this.used_names.has(alias) || local_used_names.has(alias); alias = `${name}_${i++}`);
                local_used_names.add(alias);
                this.globally_used_names.add(alias);
                return {
                    type: "Identifier",
                    name: alias
                };
            };
        }
        /** @returns {import('../interfaces.js').Var[]} */ get_vars_report() {
            const { compile_options: compile_options, vars: vars } = this;
            const vars_report = compile_options.varsReport === false ? [] : compile_options.varsReport === "full" ? vars : vars.filter((v)=>!v.global && !v.internal);
            return vars_report.map((v)=>({
                    name: v.name,
                    export_name: v.export_name || null,
                    injected: v.injected || false,
                    module: v.module || false,
                    mutated: v.mutated || false,
                    reassigned: v.reassigned || false,
                    referenced: v.referenced || false,
                    writable: v.writable || false,
                    referenced_from_script: v.referenced_from_script || false
                }));
        }
        /**
	 * @param {{
	 * 			start: number;
	 * 			end: number;
	 * 		}} pos
	 * @param {{
	 * 			code: string;
	 * 			message: string;
	 * 		}} e
	 */ error(pos, e) {
            if (this.compile_options.errorMode === "warn") this.warn(pos, e);
            else error(e.message, {
                name: "ValidationError",
                code: e.code,
                source: this.source,
                start: pos.start,
                end: pos.end,
                filename: this.compile_options.filename
            });
        }
        /**
	 * @param {{
	 * 			start: number;
	 * 			end: number;
	 * 		}} pos
	 * @param {{
	 * 			code: string;
	 * 			message: string;
	 * 		}} warning
	 */ warn(pos, warning) {
            if (this.ignores && this.ignores.has(warning.code)) return;
            const start = this.locate(pos.start);
            const end = this.locate(pos.end);
            const frame = get_code_frame(this.source, start.line - 1, start.column);
            this.warnings.push({
                code: warning.code,
                message: warning.message,
                frame: frame,
                start: start,
                end: end,
                pos: pos.start,
                filename: this.compile_options.filename,
                toString: ()=>`${warning.message} (${start.line}:${start.column})\n${frame}`
            });
        }
        /** @param {any} node */ extract_imports(node) {
            this.imports.push(node);
        }
        /**
	 * @param {any} node
	 * @param {any} module_script
	 */ extract_exports(node, module_script = false) {
            const ignores = extract_svelte_ignore_from_comments(node);
            if (ignores.length) this.push_ignores(ignores);
            const result = this._extract_exports(node, module_script);
            if (ignores.length) this.pop_ignores();
            return result;
        }
        /**
	 * @private
	 * @param {import('estree').ExportDefaultDeclaration | import('estree').ExportNamedDeclaration | import('estree').ExportAllDeclaration} node
	 * @param {boolean} module_script
	 */ _extract_exports(node, module_script) {
            if (node.type === "ExportDefaultDeclaration") return this.error(/** @type {any} */ node, compiler_errors.default_export);
            if (node.type === "ExportNamedDeclaration") {
                if (node.source) {
                    if (module_script) this.exports_from.push(node);
                    else this.instance_exports_from.push(node);
                    return null;
                }
                if (node.declaration) {
                    if (node.declaration.type === "VariableDeclaration") node.declaration.declarations.forEach((declarator)=>{
                        extract_names(declarator.id).forEach((name)=>{
                            const variable = this.var_lookup.get(name);
                            variable.export_name = name;
                            if (declarator.init?.type === "Literal" && typeof declarator.init.value === "boolean") variable.is_boolean = true;
                            if (!module_script && variable.writable && !(variable.referenced || variable.referenced_from_script || variable.subscribable)) this.warn(/** @type {any} */ declarator, compiler_warnings.unused_export_let(this.name.name, name));
                        });
                    });
                    else {
                        const { name: name } = node.declaration.id;
                        const variable = this.var_lookup.get(name);
                        variable.export_name = name;
                    }
                    return node.declaration;
                } else {
                    node.specifiers.forEach((specifier)=>{
                        const variable = this.var_lookup.get(specifier.local.name);
                        if (variable) {
                            variable.export_name = specifier.exported.name;
                            if (!module_script && variable.writable && !(variable.referenced || variable.referenced_from_script || variable.subscribable)) this.warn(/** @type {any} */ specifier, compiler_warnings.unused_export_let(this.name.name, specifier.exported.name));
                        }
                    });
                    return null;
                }
            }
        }
        /** @param {any} script */ extract_javascript(script) {
            if (!script) return null;
            return script.content.body.filter((node)=>{
                if (!node) return false;
                if (this.hoistable_nodes.has(node)) return false;
                if (this.reactive_declaration_nodes.has(node)) return false;
                if (node.type === "ImportDeclaration") return false;
                if (node.type === "ExportDeclaration" && node.specifiers.length > 0) return false;
                return true;
            });
        }
        walk_module_js() {
            const component = this;
            const script = this.ast.module;
            if (!script) return;
            walk(script.content, {
                /** @param {import('estree').Node} node */ enter (node) {
                    if (node.type === "LabeledStatement" && node.label.name === "$") component.warn(/** @type {any} */ node, compiler_warnings.module_script_reactive_declaration);
                }
            });
            const { scope: scope, globals: globals } = create_scopes(script.content);
            this.module_scope = scope;
            scope.declarations.forEach((node, name)=>{
                if (name[0] === "$") return this.error(/** @type {any} */ node, compiler_errors.illegal_declaration);
                const writable = node.type === "VariableDeclaration" && (node.kind === "var" || node.kind === "let");
                const imported = node.type.startsWith("Import");
                this.add_var(node, {
                    name: name,
                    module: true,
                    hoistable: true,
                    writable: writable,
                    imported: imported
                });
            });
            globals.forEach((node, name)=>{
                if (name[0] === "$") return this.error(/** @type {any} */ node, compiler_errors.illegal_subscription);
                else this.add_var(node, {
                    name: name,
                    global: true,
                    hoistable: true
                });
            });
            const { body: body } = script.content;
            let i = body.length;
            while(--i >= 0){
                const node = body[i];
                if (node.type === "ImportDeclaration") {
                    this.extract_imports(node);
                    body.splice(i, 1);
                }
                if (regex_starts_with_term_export.test(node.type)) {
                    const replacement = this.extract_exports(node, true);
                    if (replacement) body[i] = replacement;
                    else body.splice(i, 1);
                }
            }
        }
        walk_instance_js_pre_template() {
            const script = this.ast.instance;
            if (!script) return;
            // inject vars for reactive declarations
            script.content.body.forEach((node)=>{
                if (node.type !== "LabeledStatement") return;
                if (node.body.type !== "ExpressionStatement") return;
                const { expression: expression } = node.body;
                if (expression.type !== "AssignmentExpression") return;
                if (expression.left.type === "MemberExpression") return;
                extract_names(expression.left).forEach((name)=>{
                    if (!this.var_lookup.has(name) && name[0] !== "$") this.injected_reactive_declaration_vars.add(name);
                });
            });
            const { scope: instance_scope, map: map, globals: globals } = create_scopes(script.content);
            this.instance_scope = instance_scope;
            this.instance_scope_map = map;
            instance_scope.declarations.forEach((node, name)=>{
                if (name[0] === "$") return this.error(/** @type {any} */ node, compiler_errors.illegal_declaration);
                const { type: type } = node;
                this.add_var(node, {
                    name: name,
                    initialised: instance_scope.initialised_declarations.has(name),
                    imported: type.startsWith("Import"),
                    writable: type === "VariableDeclaration" && (node.kind === "var" || node.kind === "let")
                });
                this.node_for_declaration.set(name, node);
            });
            // NOTE: add store variable first, then only $store value
            // as `$store` will mark `store` variable as referenced and subscribable
            const global_keys = Array.from(globals.keys());
            const sorted_globals = [
                ...global_keys.filter((key)=>key[0] !== "$"),
                ...global_keys.filter((key)=>key[0] === "$")
            ];
            sorted_globals.forEach((name)=>{
                if (this.var_lookup.has(name)) return;
                const node = globals.get(name);
                if (this.injected_reactive_declaration_vars.has(name)) this.add_var(node, {
                    name: name,
                    injected: true,
                    writable: true,
                    reassigned: true,
                    initialised: true
                });
                else if (is_reserved_keyword(name)) this.add_var(node, {
                    name: name,
                    injected: true
                });
                else if (name[0] === "$") {
                    if (name === "$" || name[1] === "$") return this.error(/** @type {any} */ node, compiler_errors.illegal_global(name));
                    this.add_var(node, {
                        name: name,
                        injected: true,
                        mutated: true,
                        writable: true
                    });
                    this.add_reference(node, name.slice(1));
                    const variable = this.var_lookup.get(name.slice(1));
                    if (variable) {
                        variable.subscribable = true;
                        variable.referenced_from_script = true;
                    }
                } else this.add_var(node, {
                    name: name,
                    global: true,
                    hoistable: true
                });
            });
            this.track_references_and_mutations();
        }
        walk_instance_js_post_template() {
            const script = this.ast.instance;
            if (!script) return;
            this.post_template_walk();
            this.hoist_instance_declarations();
            this.extract_reactive_declarations();
            this.check_if_tags_content_dynamic();
        }
        post_template_walk() {
            const script = this.ast.instance;
            if (!script) return;
            const component = this;
            const { content: content } = script;
            const { instance_scope: instance_scope, instance_scope_map: map } = this;
            let scope = instance_scope;
            const to_remove = [];
            /**
		 * @param {any} parent
		 * @param {any} prop
		 * @param {any} index
		 */ const remove = (parent, prop, index)=>{
                to_remove.unshift([
                    parent,
                    prop,
                    index
                ]);
            };
            let scope_updated = false;
            const current_function_stack = [];
            /** @type {import('estree').FunctionDeclaration | import('estree').FunctionExpression} */ let current_function = null;
            walk(content, {
                /** @type {import('estree-walker').SyncHandler} */ enter (node, parent, prop, index) {
                    if (node.type === "FunctionDeclaration" || node.type === "FunctionExpression") current_function_stack.push(current_function = node);
                    if (map.has(node)) scope = map.get(node);
                    let deep = false;
                    /** @type {string[]} */ let names = [];
                    if (node.type === "AssignmentExpression") {
                        if (node.left.type === "ArrayPattern") walk(node.left, {
                            /**
							 * @param {import('estree').Node} node
							 * @param {import('estree').Node} parent
							 */ enter (node, parent) {
                                if (node.type === "Identifier" && parent.type !== "MemberExpression" && (parent.type !== "AssignmentPattern" || parent.right !== node)) names.push(node.name);
                            }
                        });
                        else {
                            deep = node.left.type === "MemberExpression";
                            names = deep ? [
                                get_object(node.left).name
                            ] : extract_names(node.left);
                        }
                    } else if (node.type === "UpdateExpression") {
                        deep = node.argument.type === "MemberExpression";
                        const { name: name } = get_object(node.argument);
                        names.push(name);
                    }
                    if (names.length > 0) names.forEach((name)=>{
                        let current_scope = scope;
                        let declaration;
                        while(current_scope){
                            if (current_scope.declarations.has(name)) {
                                declaration = current_scope.declarations.get(name);
                                break;
                            }
                            current_scope = current_scope.parent;
                        }
                        if (declaration && /** @type {import('estree').VariableDeclaration} */ declaration.kind === "const" && !deep) component.error(/** @type {any} */ node, {
                            code: "assignment-to-const",
                            message: "You are assigning to a const"
                        });
                    });
                    if (node.type === "ImportDeclaration") {
                        component.extract_imports(node);
                        // TODO: to use actual remove
                        remove(parent, prop, index);
                        return this.skip();
                    }
                    if (regex_starts_with_term_export.test(node.type)) {
                        const replacement = component.extract_exports(node);
                        if (replacement) this.replace(replacement);
                        else // TODO: to use actual remove
                        remove(parent, prop, index);
                        return this.skip();
                    }
                    component.warn_on_undefined_store_value_references(node, parent, prop, scope);
                },
                /** @param {import('estree').Node} node */ leave (node) {
                    if (node.type === "FunctionDeclaration" || node.type === "FunctionExpression") {
                        current_function_stack.pop();
                        current_function = current_function_stack[current_function_stack.length - 1];
                    }
                    // do it on leave, to prevent infinite loop
                    if (component.compile_options.dev && component.compile_options.loopGuardTimeout > 0 && (!current_function || !current_function.generator && !current_function.async)) {
                        const to_replace_for_loop_protect = component.loop_protect(node, scope, component.compile_options.loopGuardTimeout);
                        if (to_replace_for_loop_protect) {
                            this.replace(to_replace_for_loop_protect);
                            scope_updated = true;
                        }
                    }
                    if (map.has(node)) scope = scope.parent;
                }
            });
            for (const [parent, prop, index] of to_remove)if (parent) {
                if (index !== null) parent[prop].splice(index, 1);
                else delete parent[prop];
            }
            if (scope_updated) {
                const { scope: scope, map: map } = create_scopes(script.content);
                this.instance_scope = scope;
                this.instance_scope_map = map;
            }
        }
        track_references_and_mutations() {
            const script = this.ast.instance;
            if (!script) return;
            const component = this;
            const { content: content } = script;
            const { instance_scope: instance_scope, module_scope: module_scope, instance_scope_map: map } = this;
            let scope = instance_scope;
            walk(content, {
                /**
			 * @param {import('estree').Node} node
			 * @param {import('estree').Node} parent
			 */ enter (node, parent) {
                    if (map.has(node)) scope = map.get(node);
                    if (node.type === "AssignmentExpression" || node.type === "UpdateExpression") {
                        const assignee = node.type === "AssignmentExpression" ? node.left : node.argument;
                        const names = extract_names(/** @type {import('estree').Node} */ assignee);
                        const deep = assignee.type === "MemberExpression";
                        names.forEach((name)=>{
                            const scope_owner = scope.find_owner(name);
                            if (scope_owner !== null ? scope_owner === instance_scope : module_scope && module_scope.has(name)) {
                                const variable = component.var_lookup.get(name);
                                variable[deep ? "mutated" : "reassigned"] = true;
                            }
                        });
                    }
                    if (is_used_as_reference(node, parent)) {
                        const object = get_object(node);
                        if (scope.find_owner(object.name) === instance_scope) {
                            const variable = component.var_lookup.get(object.name);
                            variable.referenced_from_script = true;
                        }
                    }
                },
                /** @param {import('estree').Node} node */ leave (node) {
                    if (map.has(node)) scope = scope.parent;
                }
            });
        }
        /**
	 * @param {import('estree').Node} node
	 * @param {import('estree').Node} parent
	 * @param {string | number | symbol} prop
	 * @param {import('./utils/scope.js').Scope} scope
	 */ warn_on_undefined_store_value_references(node, parent, prop, scope) {
            if (node.type === "LabeledStatement" && node.label.name === "$" && parent.type !== "Program") this.warn(/** @type {any} */ node, compiler_warnings.non_top_level_reactive_declaration);
            if (is_reference(/** @type {import('is-reference').NodeWithPropertyDefinition} */ node, /** @type {import('is-reference').NodeWithPropertyDefinition} */ parent)) {
                const object = get_object(node);
                const { name: name } = object;
                if (name[0] === "$") {
                    if (!scope.has(name)) this.warn_if_undefined(name, object, null);
                    if (name[1] !== "$" && scope.has(name.slice(1)) && scope.find_owner(name.slice(1)) !== this.instance_scope) {
                        if (!(regex_contains_term_function.test(parent.type) && prop === "params" || parent.type === "VariableDeclarator" && prop === "id")) return this.error(/** @type {any} */ node, compiler_errors.contextual_store);
                    }
                }
            }
        }
        /**
	 * @param {any} node
	 * @param {import('./utils/scope.js').Scope} scope
	 * @param {number} timeout
	 * @returns {import('estree').Node}
	 */ loop_protect(node, scope, timeout) {
            if (node.type === "WhileStatement" || node.type === "ForStatement" || node.type === "DoWhileStatement") {
                const guard = this.get_unique_name("guard", scope);
                this.used_names.add(guard.name);
                const before = b$1`const ${guard} = @loop_guard(${timeout})`;
                const inside = b$1`${guard}();`;
                // wrap expression statement with BlockStatement
                if (node.body.type !== "BlockStatement") node.body = {
                    type: "BlockStatement",
                    body: [
                        node.body
                    ]
                };
                node.body.body.push(inside[0]);
                return {
                    type: "BlockStatement",
                    body: [
                        before[0],
                        node
                    ]
                };
            }
            return null;
        }
        /** @param {(variable: import('../interfaces.js').Var) => import('estree').Node[]} get_insert */ rewrite_props(get_insert) {
            if (!this.ast.instance) return;
            const component = this;
            const { instance_scope: instance_scope, instance_scope_map: map } = this;
            let scope = instance_scope;
            walk(this.ast.instance.content, {
                /** @param {import('estree').Node} node */ enter (node) {
                    if (regex_contains_term_function.test(node.type)) return this.skip();
                    if (map.has(node)) scope = map.get(node);
                    if (node.type === "ExportNamedDeclaration" && node.declaration) return this.replace(node.declaration);
                    if (node.type === "VariableDeclaration") // NOTE: `var` does not follow block scoping
                    {
                        if (node.kind === "var" || scope === instance_scope) {
                            const inserts = [];
                            const props = [];
                            /**
						 * @param {import('estree').Identifier} exported
						 * @param {import('estree').Pattern} local
						 * @param {import('estree').Expression} default_value
						 */ function add_new_props(exported, local, default_value) {
                                props.push({
                                    type: "Property",
                                    method: false,
                                    shorthand: false,
                                    computed: false,
                                    kind: "init",
                                    key: exported,
                                    value: default_value ? {
                                        type: "AssignmentPattern",
                                        left: local,
                                        right: default_value
                                    } : local
                                });
                            }
                            // transform
                            // ```
                            // export let { x, y = 123 } = OBJ, z = 456
                            // ```
                            // into
                            // ```
                            // let { x: x$, y: y$ = 123 } = OBJ;
                            // let { x = x$, y = y$, z = 456 } = $$props;
                            // ```
                            for(let index = 0; index < node.declarations.length; index++){
                                const declarator = node.declarations[index];
                                if (declarator.id.type !== "Identifier") {
                                    /**
								 * @param {import('estree').Identifier} local
								 * @returns {import('estree').Identifier}
								 */ function get_new_name(local) {
                                        const variable = component.var_lookup.get(local.name);
                                        if (variable.subscribable) inserts.push(get_insert(variable));
                                        if (variable.export_name && variable.writable) {
                                            const alias_name = component.get_unique_name(local.name);
                                            add_new_props({
                                                type: "Identifier",
                                                name: variable.export_name
                                            }, local, alias_name);
                                            return alias_name;
                                        }
                                        return local;
                                    }
                                    /** @param {import('estree').Pattern} param */ function rename_identifiers(param) {
                                        switch(param.type){
                                            case "ObjectPattern":
                                                {
                                                    /** @param {import('estree').Property | import('estree').RestElement} prop */ const handle_prop = (prop)=>{
                                                        if (prop.type === "RestElement") rename_identifiers(prop);
                                                        else if (prop.value.type === "Identifier") prop.value = get_new_name(prop.value);
                                                        else rename_identifiers(/** @type {import('estree').Pattern} */ prop.value);
                                                    };
                                                    param.properties.forEach(handle_prop);
                                                    break;
                                                }
                                            case "ArrayPattern":
                                                {
                                                    /**
											 * @param {import('estree').Pattern | null} element
											 * @param {number} index
											 * @param {Array<import('estree').Pattern | null>} array
											 */ const handle_element = (element, index, array)=>{
                                                        if (element) {
                                                            if (element.type === "Identifier") array[index] = get_new_name(element);
                                                            else rename_identifiers(element);
                                                        }
                                                    };
                                                    param.elements.forEach(handle_element);
                                                    break;
                                                }
                                            case "RestElement":
                                                if (param.argument.type === "Identifier") param.argument = get_new_name(param.argument);
                                                else rename_identifiers(param.argument);
                                                break;
                                            case "AssignmentPattern":
                                                if (param.left.type === "Identifier") param.left = get_new_name(param.left);
                                                else rename_identifiers(param.left);
                                                break;
                                        }
                                    }
                                    rename_identifiers(declarator.id);
                                } else {
                                    const { name: name } = declarator.id;
                                    const variable = component.var_lookup.get(name);
                                    const is_props = variable.export_name && variable.writable;
                                    if (is_props) {
                                        add_new_props({
                                            type: "Identifier",
                                            name: variable.export_name
                                        }, declarator.id, declarator.init);
                                        node.declarations.splice(index--, 1);
                                    }
                                    if (variable.subscribable && (is_props || declarator.init)) inserts.push(get_insert(variable));
                                }
                            }
                            this.replace(/** @type {any} */ b$1`
							${node.declarations.length ? node : null}
							${props.length > 0 && b$1`let { ${props} } = $$props;`}
							${inserts}
						`);
                            return this.skip();
                        }
                    }
                },
                /** @param {import('estree').Node} node */ leave (node) {
                    if (map.has(node)) scope = scope.parent;
                }
            });
        }
        hoist_instance_declarations() {
            // we can safely hoist variable declarations that are
            // initialised to literals, and functions that don't
            // reference instance variables other than other
            // hoistable functions. TODO others?
            const { hoistable_nodes: hoistable_nodes, var_lookup: var_lookup, injected_reactive_declaration_vars: injected_reactive_declaration_vars, imports: imports } = this;
            const top_level_function_declarations = new Map();
            const { body: body } = this.ast.instance.content;
            for(let i = 0; i < body.length; i += 1){
                const node = body[i];
                if (node.type === "VariableDeclaration") {
                    const all_hoistable = node.declarations.every((d)=>{
                        if (!d.init) return false;
                        if (d.init.type !== "Literal") return false;
                        // everything except const values can be changed by e.g. svelte devtools
                        // which means we can't hoist it
                        if (node.kind !== "const" && this.compile_options.dev) return false;
                        for (const name of extract_names(d.id)){
                            const v = this.var_lookup.get(name);
                            if (v.reassigned) return false;
                            if (v.export_name) return false;
                            if (this.vars.find((variable)=>variable.name === name && variable.module)) return false;
                        }
                        return true;
                    });
                    if (all_hoistable) {
                        node.declarations.forEach((d)=>{
                            for (const name of extract_names(d.id))this.var_lookup.get(name).hoistable = true;
                        });
                        hoistable_nodes.add(node);
                        body.splice(i--, 1);
                        this.fully_hoisted.push(node);
                    }
                }
                if (node.type === "ExportNamedDeclaration" && node.declaration && node.declaration.type === "FunctionDeclaration") top_level_function_declarations.set(node.declaration.id.name, node);
                if (node.type === "FunctionDeclaration") top_level_function_declarations.set(node.id.name, node);
            }
            const checked = new Set();
            const walking = new Set();
            /** @param {any} fn_declaration */ const is_hoistable = (fn_declaration)=>{
                if (fn_declaration.type === "ExportNamedDeclaration") fn_declaration = fn_declaration.declaration;
                const instance_scope = this.instance_scope;
                let scope = this.instance_scope;
                const map = this.instance_scope_map;
                let hoistable = true;
                // handle cycles
                walking.add(fn_declaration);
                walk(fn_declaration, {
                    /** @type {import('estree-walker').SyncHandler} */ enter (node, parent) {
                        if (!hoistable) return this.skip();
                        if (map.has(node)) scope = map.get(node);
                        if (is_reference(/** @type {import('is-reference').NodeWithPropertyDefinition} */ node, /** @type {import('is-reference').NodeWithPropertyDefinition} */ parent)) {
                            const { name: name } = flatten_reference(node);
                            const owner = scope.find_owner(name);
                            if (injected_reactive_declaration_vars.has(name)) hoistable = false;
                            else if (name[0] === "$" && !owner) hoistable = false;
                            else if (owner === instance_scope) {
                                const variable = var_lookup.get(name);
                                if (variable.reassigned || variable.mutated) hoistable = false;
                                if (name === fn_declaration.id.name) return;
                                if (variable.hoistable) return;
                                if (top_level_function_declarations.has(name)) {
                                    const other_declaration = top_level_function_declarations.get(name);
                                    if (walking.has(other_declaration)) hoistable = false;
                                    else if (other_declaration.type === "ExportNamedDeclaration" && walking.has(other_declaration.declaration)) hoistable = false;
                                    else if (!is_hoistable(other_declaration)) hoistable = false;
                                } else hoistable = false;
                            }
                            this.skip();
                        }
                    },
                    /** @param {import('estree').Node} node */ leave (node) {
                        if (map.has(node)) scope = scope.parent;
                    }
                });
                checked.add(fn_declaration);
                walking.delete(fn_declaration);
                return hoistable;
            };
            for (const [name, node] of top_level_function_declarations)if (is_hoistable(node)) {
                const variable = this.var_lookup.get(name);
                variable.hoistable = true;
                hoistable_nodes.add(node);
                const i = body.indexOf(node);
                body.splice(i, 1);
                this.fully_hoisted.push(node);
            }
            for (const { specifiers: specifiers } of imports)for (const specifier of specifiers){
                const variable = var_lookup.get(specifier.local.name);
                if (!variable.mutated || variable.subscribable) variable.hoistable = true;
            }
        }
        extract_reactive_declarations() {
            const component = this;
            /**
		 * @type {Array<{
		 * 			assignees: Set<string>;
		 * 			dependencies: Set<string>;
		 * 			node: import('estree').Node;
		 * 			declaration: import('estree').Node;
		 * 		}>}
		 */ const unsorted_reactive_declarations = [];
            this.ast.instance.content.body.forEach((node)=>{
                const ignores = extract_svelte_ignore_from_comments(node);
                if (ignores.length) this.push_ignores(ignores);
                if (node.type === "LabeledStatement" && node.label.name === "$") {
                    this.reactive_declaration_nodes.add(node);
                    const assignees = new Set();
                    const assignee_nodes = new Set();
                    const dependencies = new Set();
                    const module_dependencies = new Set();
                    let scope = this.instance_scope;
                    const { declarations: outset_scope_decalarations } = this.instance_scope;
                    const map = this.instance_scope_map;
                    walk(node.body, {
                        /** @type {import('estree-walker').SyncHandler} */ enter (node, parent) {
                            if (node.type === "VariableDeclaration" && node.kind === "var") {
                                const is_var_in_outset = node.declarations.some(/** @param {import('estree').VariableDeclarator} declaration */ (declaration)=>{
                                    /** @type {string[]} */ const names = extract_names(declaration.id);
                                    return !!names.find(/** @param {string} name */ (name)=>{
                                        const var_node = outset_scope_decalarations.get(name);
                                        return var_node === node;
                                    });
                                });
                                if (is_var_in_outset) return component.error(/** @type {any} */ node, compiler_errors.invalid_var_declaration);
                            }
                            if (map.has(node)) scope = map.get(node);
                            if (node.type === "AssignmentExpression") {
                                const left = get_object(node.left);
                                extract_identifiers(left).forEach((node)=>{
                                    assignee_nodes.add(node);
                                    assignees.add(node.name);
                                });
                                if (node.operator !== "=") dependencies.add(left.name);
                            } else if (node.type === "UpdateExpression") {
                                const identifier = get_object(node.argument);
                                assignees.add(identifier.name);
                            } else if (is_reference(/** @type {import('is-reference').NodeWithPropertyDefinition} */ node, /** @type {import('is-reference').NodeWithPropertyDefinition} */ parent)) {
                                const identifier = get_object(node);
                                if (!assignee_nodes.has(identifier)) {
                                    const { name: name } = identifier;
                                    const owner = scope.find_owner(name);
                                    const variable = component.var_lookup.get(name);
                                    let should_add_as_dependency = true;
                                    if (variable) {
                                        variable.is_reactive_dependency = true;
                                        if (variable.module && variable.writable) {
                                            should_add_as_dependency = false;
                                            module_dependencies.add(name);
                                        }
                                    }
                                    const is_writable_or_mutated = variable && (variable.writable || variable.mutated);
                                    if (should_add_as_dependency && (!owner || owner === component.instance_scope) && (name[0] === "$" || is_writable_or_mutated)) dependencies.add(name);
                                }
                                this.skip();
                            }
                        },
                        /** @param {import('estree').Node} node */ leave (node) {
                            if (map.has(node)) scope = scope.parent;
                        }
                    });
                    if (module_dependencies.size > 0 && dependencies.size === 0) component.warn(/** @type {any} */ node.body, compiler_warnings.module_script_variable_reactive_declaration(Array.from(module_dependencies)));
                    const { expression: expression } = /** @type {import('estree').ExpressionStatement} */ node.body;
                    const declaration = expression && /** @type {import('estree').AssignmentExpression} */ expression.left;
                    unsorted_reactive_declarations.push({
                        assignees: assignees,
                        dependencies: dependencies,
                        node: node,
                        declaration: declaration
                    });
                }
                if (ignores.length) this.pop_ignores();
            });
            const lookup = new Map();
            unsorted_reactive_declarations.forEach((declaration)=>{
                declaration.assignees.forEach((name)=>{
                    if (!lookup.has(name)) lookup.set(name, []);
                    // TODO warn or error if a name is assigned to in
                    // multiple reactive declarations?
                    lookup.get(name).push(declaration);
                });
            });
            const cycle = check_graph_for_cycles(unsorted_reactive_declarations.reduce((acc, declaration)=>{
                declaration.assignees.forEach((v)=>{
                    declaration.dependencies.forEach((w)=>{
                        if (!declaration.assignees.has(w)) acc.push([
                            v,
                            w
                        ]);
                    });
                });
                return acc;
            }, []));
            if (cycle && cycle.length) {
                const declaration_list = lookup.get(cycle[0]);
                const declaration = declaration_list[0];
                return this.error(declaration.node, compiler_errors.cyclical_reactive_declaration(cycle));
            }
            /** @param {any} declaration */ const add_declaration = (declaration)=>{
                if (this.reactive_declarations.includes(declaration)) return;
                declaration.dependencies.forEach((name)=>{
                    if (declaration.assignees.has(name)) return;
                    const earlier_declarations = lookup.get(name);
                    if (earlier_declarations) earlier_declarations.forEach(add_declaration);
                });
                this.reactive_declarations.push(declaration);
            };
            unsorted_reactive_declarations.forEach(add_declaration);
        }
        check_if_tags_content_dynamic() {
            this.tags.forEach((tag)=>{
                tag.check_if_content_dynamic();
            });
        }
        /**
	 * @param {string} name
	 * @param {any} node
	 * @param {import('./nodes/shared/TemplateScope.js').default} template_scope
	 * @param {import("./nodes/shared/Node.js").default} [owner]
	 */ warn_if_undefined(name, node, template_scope, owner) {
            if (name[0] === "$") {
                if (name === "$" || name[1] === "$" && !is_reserved_keyword(name)) return this.error(node, compiler_errors.illegal_global(name));
                this.has_reactive_assignments = true; // TODO does this belong here?
                if (is_reserved_keyword(name)) return;
                name = name.slice(1);
            }
            if (this.var_lookup.has(name) && !this.var_lookup.get(name).global) return;
            if (template_scope && template_scope.names.has(name)) return;
            if (globals.has(name) && node.type !== "InlineComponent") return;
            function has_out_of_scope_let() {
                for(let parent = owner.parent; parent; parent = parent.parent)if (parent.type === "InlineComponent") {
                    const { let_attributes: let_attributes } = parent;
                    for (const attr of let_attributes){
                        if (// @ts-expect-error
                        // TODO extract_names only considers patterns but let attributes return expressions
                        attr.expression && extract_names(attr.expression).includes(name) || attr.name === name) return true;
                    }
                }
                return false;
            }
            if (owner && has_out_of_scope_let()) return this.warn(node, {
                code: "missing-declaration",
                message: `let:${name} declared on parent component cannot be used inside named slot`
            });
            this.warn(node, compiler_warnings.missing_declaration(name, !!this.ast.instance));
        }
        /** @param {any} ignores */ push_ignores(ignores) {
            this.ignores = new Set(this.ignores || []);
            add_to_set(this.ignores, ignores);
            this.ignore_stack.push(this.ignores);
        }
        pop_ignores() {
            this.ignore_stack.pop();
            this.ignores = this.ignore_stack[this.ignore_stack.length - 1];
        }
    }
    const regex_valid_tag_name = /^[a-zA-Z][a-zA-Z0-9]*-[a-zA-Z0-9-]+$/;
    /**
 * @param {Component} component
 * @param {any} nodes
 */ function process_component_options(component, nodes) {
        /** @type {ComponentOptions} */ const component_options = {
            immutable: component.compile_options.immutable || false,
            accessors: "accessors" in component.compile_options ? component.compile_options.accessors : !!component.compile_options.customElement,
            preserveWhitespace: !!component.compile_options.preserveWhitespace,
            namespace: component.compile_options.namespace
        };
        const node = nodes.find((node)=>node.name === "svelte:options");
        /**
	 * @param {any} attribute
	 * @param {any} params_0
	 */ function get_value(attribute, { code: code, message: message }) {
            const { value: value } = attribute;
            const chunk = value[0];
            if (!chunk) return true;
            if (value.length > 1) return component.error(attribute, {
                code: code,
                message: message
            });
            if (chunk.type === "Text") return chunk.data;
            if (chunk.expression.type !== "Literal") return component.error(attribute, {
                code: code,
                message: message
            });
            return chunk.expression.value;
        }
        if (node) node.attributes.forEach((attribute)=>{
            if (attribute.type === "Attribute") {
                const { name: name } = attribute;
                /**
				 * @param {import('../interfaces.js').Attribute} attribute
				 * @param {string} tag
				 */ function parse_tag(attribute, tag) {
                    if (typeof tag !== "string" && tag !== null) return component.error(attribute, compiler_errors.invalid_tag_attribute);
                    if (tag && !regex_valid_tag_name.test(tag)) return component.error(attribute, compiler_errors.invalid_tag_property);
                    if (tag && !component.compile_options.customElement) component.warn(attribute, compiler_warnings.missing_custom_element_compile_options);
                    component_options.customElement = component_options.customElement || /** @type {any} */ {};
                    component_options.customElement.tag = tag;
                }
                switch(name){
                    case "tag":
                        component.warn(attribute, compiler_warnings.tag_option_deprecated);
                        parse_tag(attribute, get_value(attribute, compiler_errors.invalid_tag_attribute));
                        break;
                    case "customElement":
                        {
                            component_options.customElement = component_options.customElement || /** @type {any} */ {};
                            const { value: value } = attribute;
                            if (value[0].type === "MustacheTag" && value[0].expression?.value === null) {
                                component_options.customElement.tag = null;
                                break;
                            } else if (value[0].type === "Text") {
                                parse_tag(attribute, get_value(attribute, compiler_errors.invalid_tag_attribute));
                                break;
                            } else if (value[0].expression.type !== "ObjectExpression") return component.error(attribute, compiler_errors.invalid_customElement_attribute);
                            const tag = value[0].expression.properties.find((prop)=>prop.key.name === "tag");
                            if (tag) parse_tag(tag, tag.value?.value);
                            else return component.error(attribute, compiler_errors.invalid_customElement_attribute);
                            const props = value[0].expression.properties.find((prop)=>prop.key.name === "props");
                            if (props) {
                                const error = ()=>component.error(attribute, compiler_errors.invalid_props_attribute);
                                if (props.value?.type !== "ObjectExpression") return error();
                                component_options.customElement.props = {};
                                for (const property of props.value.properties){
                                    if (property.type !== "Property" || property.computed || property.key.type !== "Identifier" || property.value.type !== "ObjectExpression") return error();
                                    component_options.customElement.props[property.key.name] = {};
                                    for (const prop of property.value.properties){
                                        if (prop.type !== "Property" || prop.computed || prop.key.type !== "Identifier" || prop.value.type !== "Literal") return error();
                                        if ([
                                            "reflect",
                                            "attribute",
                                            "type"
                                        ].indexOf(prop.key.name) === -1 || prop.key.name === "type" && [
                                            "String",
                                            "Number",
                                            "Boolean",
                                            "Array",
                                            "Object"
                                        ].indexOf(/** @type {string} */ prop.value.value) === -1 || prop.key.name === "reflect" && typeof prop.value.value !== "boolean" || prop.key.name === "attribute" && typeof prop.value.value !== "string") return error();
                                        component_options.customElement.props[property.key.name][prop.key.name] = prop.value.value;
                                    }
                                }
                            }
                            const shadow = value[0].expression.properties.find((prop)=>prop.key.name === "shadow");
                            if (shadow) {
                                const shadowdom = shadow.value?.value;
                                if (shadowdom !== "open" && shadowdom !== "none") return component.error(shadow, compiler_errors.invalid_shadow_attribute);
                                component_options.customElement.shadow = shadowdom;
                            }
                            const extend = value[0].expression.properties.find((prop)=>prop.key.name === "extend");
                            if (extend?.value) component_options.customElement.extend = extend.value;
                            break;
                        }
                    case "namespace":
                        {
                            const ns = get_value(attribute, compiler_errors.invalid_namespace_attribute);
                            if (typeof ns !== "string") return component.error(attribute, compiler_errors.invalid_namespace_attribute);
                            if (valid_namespaces.indexOf(ns) === -1) {
                                const match = fuzzymatch(ns, valid_namespaces);
                                return component.error(attribute, compiler_errors.invalid_namespace_property(ns, match));
                            }
                            component_options.namespace = ns;
                            break;
                        }
                    case "accessors":
                    case "immutable":
                    case "preserveWhitespace":
                        {
                            const value = get_value(attribute, compiler_errors.invalid_attribute_value(name));
                            if (typeof value !== "boolean") return component.error(attribute, compiler_errors.invalid_attribute_value(name));
                            component_options[name] = value;
                            break;
                        }
                    default:
                        return component.error(attribute, compiler_errors.invalid_options_attribute_unknown(name));
                }
            } else return component.error(attribute, compiler_errors.invalid_options_attribute);
        });
        return component_options;
    }
    /**
 * @param {string} from
 * @param {string} to
 */ function get_relative_path(from, to) {
        const from_parts = from.split(/[/\\]/);
        const to_parts = to.split(/[/\\]/);
        from_parts.pop(); // get dirname
        while(from_parts[0] === to_parts[0]){
            from_parts.shift();
            to_parts.shift();
        }
        if (from_parts.length) {
            let i = from_parts.length;
            while(i--)from_parts[i] = "..";
        }
        return from_parts.concat(to_parts).join("/");
    }
    /** @param {string} filename */ function get_basename(filename) {
        return filename.split(/[/\\]/).pop();
    }
    /** @param {import('../interfaces.js').CompileOptions} compile_options */ function get_sourcemap_source_filename(compile_options) {
        if (!compile_options.filename) return null;
        return compile_options.outputFilename ? get_relative_path(compile_options.outputFilename, compile_options.filename) : get_basename(compile_options.filename);
    }
    /**
 * @typedef {Object} ComponentOptions
 * @property {string} [namespace]
 * @property {boolean} [immutable]
 * @property {boolean} [accessors]
 * @property {boolean} [preserveWhitespace]
 * @property {Object} [customElement]
 * @property {string|null} customElement.tag
 * @property {'open'|'none'} [customElement.shadow]
 * @property {Record<string,{attribute?:string;reflect?:boolean;type?:'String'|'Boolean'|'Number'|'Array'|'Object';}>} [customElement.props]
 * @property {(ceClass: new () => HTMLElement) => new () => HTMLElement} [customElement.extend]
 */ const regex_percentage_characters = /%/g;
    const regex_file_ending = /\.[^.]+$/;
    const regex_repeated_invalid_variable_identifier_characters = /[^a-zA-Z_$0-9]+/g;
    const regex_starts_with_digit = /^(\d)/;
    const regex_may_starts_or_ends_with_underscore = /^_?(.+?)_?$/;
    /**
 * @param {string} filename
 */ function get_name_from_filename(filename) {
        if (!filename) return null;
        const parts = filename.split(/[/\\]/).map(encodeURI);
        if (parts.length > 1) {
            const index_match = parts[parts.length - 1].match(/^index(\.\w+)/);
            if (index_match) {
                parts.pop();
                parts[parts.length - 1] += index_match[1];
            }
        }
        const base = parts.pop().replace(regex_percentage_characters, "u").replace(regex_file_ending, "").replace(regex_repeated_invalid_variable_identifier_characters, "_").replace(regex_may_starts_or_ends_with_underscore, "$1").replace(regex_starts_with_digit, "_$1");
        if (!base) throw new Error(`Could not derive component name from file ${filename}`);
        return base[0].toUpperCase() + base.slice(1);
    }
    const valid_options = [
        "name",
        "filename",
        "sourcemap",
        "enableSourcemap",
        "generate",
        "errorMode",
        "varsReport",
        "outputFilename",
        "cssOutputFilename",
        "sveltePath",
        "dev",
        "accessors",
        "immutable",
        "hydratable",
        "legacy",
        "customElement",
        "namespace",
        "tag",
        "css",
        "loopGuardTimeout",
        "preserveComments",
        "preserveWhitespace",
        "cssHash",
        "discloseVersion"
    ];
    const valid_css_values = [
        true,
        false,
        "injected",
        "external",
        "none"
    ];
    const regex_valid_identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;
    const regex_starts_with_lowercase_character = /^[a-z]/;
    let warned_of_format = false;
    let warned_boolean_css = false;
    /**
 * @param {import('../interfaces.js').CompileOptions} options
 * @param {import('../interfaces.js').Warning[]} warnings
 */ function validate_options(options, warnings) {
        if (/** @type {any} */ options.format) {
            if (!warned_of_format) {
                warned_of_format = true;
                console.warn('The format option has been removed in Svelte 4, the compiler only outputs ESM now. Remove "format" from your compiler options. If you did not set this yourself, bump the version of your bundler plugin (vite-plugin-svelte/rollup-plugin-svelte/svelte-loader)');
            }
            delete /** @type {any} */ options.format;
        }
        const { name: name, filename: filename, loopGuardTimeout: loopGuardTimeout, dev: dev, namespace: namespace, css: css } = options;
        Object.keys(options).forEach((key)=>{
            if (!valid_options.includes(key)) {
                const match = fuzzymatch(key, valid_options);
                let message = `Unrecognized option '${key}'`;
                if (match) message += ` (did you mean '${match}'?)`;
                throw new Error(message);
            }
        });
        if (name && !regex_valid_identifier.test(name)) throw new Error(`options.name must be a valid identifier (got '${name}')`);
        if (name && regex_starts_with_lowercase_character.test(name)) {
            const message = "options.name should be capitalised";
            warnings.push({
                code: "options-lowercase-name",
                message: message,
                filename: filename,
                toString: ()=>message
            });
        }
        if (loopGuardTimeout && !dev) {
            const message = "options.loopGuardTimeout is for options.dev = true only";
            warnings.push({
                code: "options-loop-guard-timeout",
                message: message,
                filename: filename,
                toString: ()=>message
            });
        }
        if (css === true || css === false) {
            options.css = css === true ? "injected" : "external";
            if (!warned_boolean_css) {
                console.warn(`compilerOptions.css as a boolean is deprecated. Use '${options.css}' instead of ${css}.`);
                warned_boolean_css = true;
            }
        }
        if (!valid_css_values.includes(options.css)) throw new Error(`compilerOptions.css must be 'injected', 'external' or 'none' (got '${options.css}').`);
        if (namespace && valid_namespaces.indexOf(namespace) === -1) {
            const match = fuzzymatch(namespace, valid_namespaces);
            if (match) throw new Error(`Invalid namespace '${namespace}' (did you mean '${match}'?)`);
            else throw new Error(`Invalid namespace '${namespace}'`);
        }
        if (options.discloseVersion == undefined) options.discloseVersion = true;
    }
    /**
 * `compile` takes your component source code, and turns it into a JavaScript module that exports a class.
 *
 * https://svelte.dev/docs/svelte-compiler#svelte-compile
 * @param {string} source
 * @param {import('../interfaces.js').CompileOptions} options
 */ function compile(source, options = {}) {
        options = Object.assign({
            generate: "dom",
            dev: false,
            enableSourcemap: true,
            css: "injected"
        }, options);
        const stats = new Stats();
        const warnings = [];
        validate_options(options, warnings);
        stats.start("parse");
        const ast = parse(source, options);
        stats.stop("parse");
        stats.start("create component");
        const component = new Component(ast, source, options.name || get_name_from_filename(options.filename) || "Component", options, stats, warnings);
        stats.stop("create component");
        const result = options.generate === false ? null : options.generate === "ssr" ? ssr(component, options) : dom(component, options);
        return component.generate(result);
    }
    /**
 * Import decoded sourcemap from mozilla/source-map/SourceMapGenerator
 * Forked from source-map/lib/source-map-generator.js
 * from methods _serializeMappings and toJSON.
 * We cannot use source-map.d.ts types, because we access hidden properties.
 * @param {any} generator
 */ function decoded_sourcemap_from_generator(generator) {
        let previous_generated_line = 1;
        const converted_mappings = [
            []
        ];
        let result_line;
        let result_segment;
        let mapping;
        const source_idx = generator._sources.toArray().reduce((acc, val, idx)=>(acc[val] = idx, acc), {});
        const name_idx = generator._names.toArray().reduce((acc, val, idx)=>(acc[val] = idx, acc), {});
        const mappings = generator._mappings.toArray();
        result_line = converted_mappings[0];
        for(let i = 0, len = mappings.length; i < len; i++){
            mapping = mappings[i];
            if (mapping.generatedLine > previous_generated_line) {
                while(mapping.generatedLine > previous_generated_line){
                    converted_mappings.push([]);
                    previous_generated_line++;
                }
                result_line = converted_mappings[mapping.generatedLine - 1]; // line is one-based
            } else if (i > 0) {
                const previous_mapping = mappings[i - 1];
                if (// sorted by selectivity
                mapping.generatedColumn === previous_mapping.generatedColumn && mapping.originalColumn === previous_mapping.originalColumn && mapping.name === previous_mapping.name && mapping.generatedLine === previous_mapping.generatedLine && mapping.originalLine === previous_mapping.originalLine && mapping.source === previous_mapping.source) continue;
            }
            result_line.push([
                mapping.generatedColumn
            ]);
            result_segment = result_line[result_line.length - 1];
            if (mapping.source != null) {
                result_segment.push(...[
                    source_idx[mapping.source],
                    mapping.originalLine - 1,
                    mapping.originalColumn
                ]);
                if (mapping.name != null) result_segment.push(name_idx[mapping.name]);
            }
        }
        const map = {
            version: generator._version,
            sources: generator._sources.toArray(),
            names: generator._names.toArray(),
            mappings: converted_mappings
        };
        if (generator._file != null) map.file = generator._file;
        // not needed: map.sourcesContent and map.sourceRoot
        return map;
    }
    /**
 * @param {import('./public.js').Processed} processed
 */ function decode_map(processed) {
        let decoded_map = typeof processed.map === "string" ? JSON.parse(processed.map) : processed.map;
        if (typeof decoded_map.mappings === "string") decoded_map.mappings = decode(decoded_map.mappings);
        if (decoded_map._mappings && decoded_map.constructor.name === "SourceMapGenerator") // import decoded sourcemap from mozilla/source-map/SourceMapGenerator
        decoded_map = decoded_sourcemap_from_generator(decoded_map);
        return decoded_map;
    }
    /**
 * @param {string} code_slice
 * @param {number} offset
 * @param {import('./private.js').Source} opts
 * @returns {import('./private.js').Source}
 */ function slice_source(code_slice, offset, { file_basename: file_basename, filename: filename, get_location: get_location }) {
        return {
            source: code_slice,
            get_location: (index)=>get_location(index + offset),
            file_basename: file_basename,
            filename: filename
        };
    }
    /**
 * @param {RegExp} re
 * @param {(...match: any[]) => Promise<MappedCode>} get_replacement
 * @param {string} source
 */ function calculate_replacements(re, get_replacement, source) {
        /**
	 * @type {Array<Promise<import('./private.js').Replacement>>}
	 */ const replacements = [];
        source.replace(re, (...match)=>{
            replacements.push(get_replacement(...match).then((replacement)=>{
                const matched_string = match[0];
                const offset = match[match.length - 2];
                return {
                    offset: offset,
                    length: matched_string.length,
                    replacement: replacement
                };
            }));
            return "";
        });
        return Promise.all(replacements);
    }
    /**
 * @param {import('./private.js').Replacement[]} replacements
 * @param {import('./private.js').Source} source
 * @returns {MappedCode}
 */ function perform_replacements(replacements, source) {
        const out = new MappedCode();
        let last_end = 0;
        for (const { offset: offset, length: length, replacement: replacement } of replacements){
            const unchanged_prefix = MappedCode.from_source(slice_source(source.source.slice(last_end, offset), last_end, source));
            out.concat(unchanged_prefix).concat(replacement);
            last_end = offset + length;
        }
        const unchanged_suffix = MappedCode.from_source(slice_source(source.source.slice(last_end), last_end, source));
        return out.concat(unchanged_suffix);
    }
    /**
 * @param {RegExp} regex
 * @param {(...match: any[]) => Promise<MappedCode>} get_replacement
 * @param {import('./private.js').Source} location
 * @returns {Promise<MappedCode>}
 */ async function replace_in_code(regex, get_replacement, location) {
        const replacements = await calculate_replacements(regex, get_replacement, location.source);
        return perform_replacements(replacements, location);
    }
    const regex_filepath_separator = /[/\\]/;
    /**
 * @param {string} filename
 */ function get_file_basename(filename) {
        return filename.split(regex_filepath_separator).pop();
    }
    /**
 * Represents intermediate states of the preprocessing.
 */ class PreprocessResult {
        /** @type {string} */ source;
        /** @type {string | undefined} */ filename;
        // sourcemap_list is sorted in reverse order from last map (index 0) to first map (index -1)
        // so we use sourcemap_list.unshift() to add new maps
        // https://github.com/ampproject/remapping#multiple-transformations-of-a-file
        /**
	 * @default []
	 * @type {Array<import('@ampproject/remapping').DecodedSourceMap | import('@ampproject/remapping').RawSourceMap>}
	 */ sourcemap_list = [];
        /**
	 * @default []
	 * @type {string[]}
	 */ dependencies = [];
        /**
	 * @type {string}
	 */ file_basename = undefined;
        /**
	 * @type {ReturnType<typeof getLocator>}
	 */ get_location = undefined;
        /**
	 *
	 * @param {string} source
	 * @param {string} [filename]
	 */ constructor(source, filename){
            this.source = source;
            this.filename = filename;
            this.update_source({
                string: source
            });
            // preprocess source must be relative to itself or equal null
            this.file_basename = filename == null ? null : get_file_basename(filename);
        }
        /**
	 * @param {import('./private.js').SourceUpdate} opts
	 */ update_source({ string: source, map: map, dependencies: dependencies }) {
            if (source != null) {
                this.source = source;
                this.get_location = getLocator$1(source);
            }
            if (map) this.sourcemap_list.unshift(map);
            if (dependencies) this.dependencies.push(...dependencies);
        }
        /**
	 * @returns {import('./public.js').Processed}
	 */ to_processed() {
            // Combine all the source maps for each preprocessor function into one
            const map = combine_sourcemaps(this.file_basename, this.sourcemap_list);
            return {
                // TODO return separated output, in future version where svelte.compile supports it:
                // style: { code: styleCode, map: styleMap },
                // script { code: scriptCode, map: scriptMap },
                // markup { code: markupCode, map: markupMap },
                code: this.source,
                dependencies: [
                    ...new Set(this.dependencies)
                ],
                map: map,
                toString: ()=>this.source
            };
        }
    }
    /**
 * Convert preprocessor output for the tag content into MappedCode
 * @param {import('./public.js').Processed} processed
 * @param {{ line: number; column: number; }} location
 * @param {string} file_basename
 * @returns {MappedCode}
 */ function processed_content_to_code(processed, location, file_basename) {
        // Convert the preprocessed code and its sourcemap to a MappedCode
        /**
	 * @type {import('@ampproject/remapping').DecodedSourceMap}
	 */ let decoded_map;
        if (processed.map) {
            decoded_map = decode_map(processed);
            // decoded map may not have sources for empty maps like `{ mappings: '' }`
            if (decoded_map.sources) {
                // offset only segments pointing at original component source
                const source_index = decoded_map.sources.indexOf(file_basename);
                if (source_index !== -1) sourcemap_add_offset(decoded_map, location, source_index);
            }
        }
        return MappedCode.from_processed(processed.code, decoded_map);
    }
    /**
 * Given the whole tag including content, return a `MappedCode`
 * representing the tag content replaced with `processed`.
 * @param {import('./public.js').Processed} processed
 * @param {'style' | 'script'} tag_name
 * @param {string} original_attributes
 * @param {string} generated_attributes
 * @param {import('./private.js').Source} source
 * @returns {MappedCode}
 */ function processed_tag_to_code(processed, tag_name, original_attributes, generated_attributes, source) {
        const { file_basename: file_basename, get_location: get_location } = source;
        /**
	 * @param {string} code
	 * @param {number} offset
	 */ const build_mapped_code = (code, offset)=>MappedCode.from_source(slice_source(code, offset, source));
        // To map the open/close tag and content starts positions correctly, we need to
        // differentiate between the original attributes and the generated attributes:
        // `source` contains the original attributes and its get_location maps accordingly.
        const original_tag_open = `<${tag_name}${original_attributes}>`;
        const tag_open = `<${tag_name}${generated_attributes}>`;
        /** @type {MappedCode} */ let tag_open_code;
        if (original_tag_open.length !== tag_open.length) {
            // Generate a source map for the open tag
            /** @type {import('@ampproject/remapping').DecodedSourceMap['mappings']} */ const mappings = [
                [
                    // start of tag
                    [
                        0,
                        0,
                        0,
                        0
                    ],
                    // end of tag start
                    [
                        `<${tag_name}`.length,
                        0,
                        0,
                        `<${tag_name}`.length
                    ]
                ]
            ];
            const line = tag_open.split("\n").length - 1;
            const column = tag_open.length - (line === 0 ? 0 : tag_open.lastIndexOf("\n")) - 1;
            while(mappings.length <= line)// end of tag start again, if this is a multi line mapping
            mappings.push([
                [
                    0,
                    0,
                    0,
                    `<${tag_name}`.length
                ]
            ]);
            // end of tag
            mappings[line].push([
                column,
                0,
                original_tag_open.split("\n").length - 1,
                original_tag_open.length - original_tag_open.lastIndexOf("\n") - 1
            ]);
            /** @type {import('@ampproject/remapping').DecodedSourceMap} */ const map = {
                version: 3,
                names: [],
                sources: [
                    file_basename
                ],
                mappings: mappings
            };
            sourcemap_add_offset(map, get_location(0), 0);
            tag_open_code = MappedCode.from_processed(tag_open, map);
        } else tag_open_code = build_mapped_code(tag_open, 0);
        const tag_close = `</${tag_name}>`;
        const tag_close_code = build_mapped_code(tag_close, original_tag_open.length + source.source.length);
        parse_attached_sourcemap(processed, tag_name);
        const content_code = processed_content_to_code(processed, get_location(original_tag_open.length), file_basename);
        return tag_open_code.concat(content_code).concat(tag_close_code);
    }
    const attribute_pattern = /([\w-$]+\b)(?:=(?:"([^"]*)"|'([^']*)'|(\S+)))?/g;
    /**
 * @param {string} str
 */ function parse_tag_attributes(str) {
        /** @type {Record<string, string | boolean>} */ const attrs = {};
        /** @type {RegExpMatchArray} */ let match;
        while((match = attribute_pattern.exec(str)) !== null){
            const name = match[1];
            const value = match[2] || match[3] || match[4];
            attrs[name] = !value || value;
        }
        return attrs;
    }
    /**
 * @param {Record<string, string | boolean> | undefined} attributes
 */ function stringify_tag_attributes(attributes) {
        if (!attributes) return;
        let value = Object.entries(attributes).map(([key, value])=>value === true ? key : `${key}="${value}"`).join(" ");
        if (value) value = " " + value;
        return value;
    }
    const regex_style_tags = /<!--[^]*?-->|<style((?:\s+[^=>'"\/\s]+=(?:"[^"]*"|'[^']*'|[^>\s]+)|\s+[^=>'"\/\s]+)*\s*)(?:\/>|>([\S\s]*?)<\/style>)/g;
    const regex_script_tags = /<!--[^]*?-->|<script((?:\s+[^=>'"\/\s]+=(?:"[^"]*"|'[^']*'|[^>\s]+)|\s+[^=>'"\/\s]+)*\s*)(?:\/>|>([\S\s]*?)<\/script>)/g;
    /**
 * Calculate the updates required to process all instances of the specified tag.
 * @param {'style' | 'script'} tag_name
 * @param {import('./public.js').Preprocessor} preprocessor
 * @param {import('./private.js').Source} source
 * @returns {Promise<import('./private.js').SourceUpdate>}
 */ async function process_tag(tag_name, preprocessor, source) {
        const { filename: filename, source: markup } = source;
        const tag_regex = tag_name === "style" ? regex_style_tags : regex_script_tags;
        /**
	 * @type {string[]}
	 */ const dependencies = [];
        /**
	 * @param {string} tag_with_content
	 * @param {number} tag_offset
	 * @returns {Promise<MappedCode>}
	 */ async function process_single_tag(tag_with_content, attributes = "", content = "", tag_offset) {
            const no_change = ()=>MappedCode.from_source(slice_source(tag_with_content, tag_offset, source));
            if (!attributes && !content) return no_change();
            const processed = await preprocessor({
                content: content || "",
                attributes: parse_tag_attributes(attributes || ""),
                markup: markup,
                filename: filename
            });
            if (!processed) return no_change();
            if (processed.dependencies) dependencies.push(...processed.dependencies);
            if (!processed.map && processed.code === content) return no_change();
            return processed_tag_to_code(processed, tag_name, attributes, stringify_tag_attributes(processed.attributes) ?? attributes, slice_source(content, tag_offset, source));
        }
        const { string: string, map: map } = await replace_in_code(tag_regex, process_single_tag, source);
        return {
            string: string,
            map: map,
            dependencies: dependencies
        };
    }
    /**
 * @param {import('./public.js').MarkupPreprocessor} process
 * @param {import('./private.js').Source} source
 */ async function process_markup(process1, source) {
        const processed = await process1({
            content: source.source,
            filename: source.filename
        });
        if (processed) return {
            string: processed.code,
            map: processed.map ? typeof processed.map === "string" ? JSON.parse(processed.map) : processed.map : undefined,
            dependencies: processed.dependencies
        };
        else return {};
    }
    /**
 * The preprocess function provides convenient hooks for arbitrarily transforming component source code.
 * For example, it can be used to convert a <style lang="sass"> block into vanilla CSS.
 *
 * https://svelte.dev/docs/svelte-compiler#svelte-preprocess
 * @param {string} source
 * @param {import('./public.js').PreprocessorGroup | import('./public.js').PreprocessorGroup[]} preprocessor
 * @param {{ filename?: string }} [options]
 * @returns {Promise<import('./public.js').Processed>}
 */ async function preprocess(source, preprocessor, options) {
        /**
	 * @type {string | undefined}
	 */ const filename = options && options.filename || /** @type {any} */ preprocessor.filename; // legacy
        const preprocessors = preprocessor ? Array.isArray(preprocessor) ? preprocessor : [
            preprocessor
        ] : [];
        const result = new PreprocessResult(source, filename);
        // TODO keep track: what preprocessor generated what sourcemap?
        // to make debugging easier = detect low-resolution sourcemaps in fn combine_mappings
        for (const preprocessor of preprocessors){
            if (preprocessor.markup) result.update_source(await process_markup(preprocessor.markup, result));
            if (preprocessor.script) result.update_source(await process_tag("script", preprocessor.script, result));
            if (preprocessor.style) result.update_source(await process_tag("style", preprocessor.style, result));
        }
        return result.to_processed();
    }
    exports1.VERSION = VERSION;
    exports1.compile = compile;
    exports1.parse = parse;
    exports1.preprocess = preprocess;
    exports1.walk = walk;
});



const $538971b5b904f078$export$707b977e56f140b4 = (config)=>config;
var $538971b5b904f078$var$bail_1 = $538971b5b904f078$var$bail;
function $538971b5b904f078$var$bail(err) {
    if (err) throw err;
}
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ var $538971b5b904f078$var$isBuffer = function isBuffer(obj) {
    return obj != null && obj.constructor != null && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
};
var $538971b5b904f078$var$hasOwn = Object.prototype.hasOwnProperty;
var $538971b5b904f078$var$toStr = Object.prototype.toString;
var $538971b5b904f078$var$defineProperty = Object.defineProperty;
var $538971b5b904f078$var$gOPD = Object.getOwnPropertyDescriptor;
var $538971b5b904f078$var$isArray = function isArray(arr) {
    if (typeof Array.isArray === "function") return Array.isArray(arr);
    return $538971b5b904f078$var$toStr.call(arr) === "[object Array]";
};
var $538971b5b904f078$var$isPlainObject = function isPlainObject(obj) {
    if (!obj || $538971b5b904f078$var$toStr.call(obj) !== "[object Object]") return false;
    var hasOwnConstructor = $538971b5b904f078$var$hasOwn.call(obj, "constructor");
    var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && $538971b5b904f078$var$hasOwn.call(obj.constructor.prototype, "isPrototypeOf");
    // Not own constructor property must be Object
    if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) return false;
    // Own properties are enumerated firstly, so to speed up,
    // if last one is own, then all properties are own.
    var key;
    for(key in obj);
    return typeof key === "undefined" || $538971b5b904f078$var$hasOwn.call(obj, key);
};
// If name is '__proto__', and Object.defineProperty is available, define __proto__ as an own property on target
var $538971b5b904f078$var$setProperty = function setProperty(target, options) {
    if ($538971b5b904f078$var$defineProperty && options.name === "__proto__") $538971b5b904f078$var$defineProperty(target, options.name, {
        enumerable: true,
        configurable: true,
        value: options.newValue,
        writable: true
    });
    else target[options.name] = options.newValue;
};
// Return undefined instead of __proto__ if '__proto__' is not an own property
var $538971b5b904f078$var$getProperty = function getProperty(obj, name) {
    if (name === "__proto__") {
        if (!$538971b5b904f078$var$hasOwn.call(obj, name)) return void 0;
        else if ($538971b5b904f078$var$gOPD) // In early versions of node, obj['__proto__'] is buggy when obj has
        // __proto__ as an own property. Object.getOwnPropertyDescriptor() works.
        return $538971b5b904f078$var$gOPD(obj, name).value;
    }
    return obj[name];
};
var $538971b5b904f078$var$extend$2 = function extend() {
    var options, name, src, copy, copyIsArray, clone;
    var target = arguments[0];
    var i = 1;
    var length = arguments.length;
    var deep = false;
    // Handle a deep copy situation
    if (typeof target === "boolean") {
        deep = target;
        target = arguments[1] || {};
        // skip the boolean and the target
        i = 2;
    }
    if (target == null || typeof target !== "object" && typeof target !== "function") target = {};
    for(; i < length; ++i){
        options = arguments[i];
        // Only deal with non-null/undefined values
        if (options != null) // Extend the base object
        for(name in options){
            src = $538971b5b904f078$var$getProperty(target, name);
            copy = $538971b5b904f078$var$getProperty(options, name);
            // Prevent never-ending loop
            if (target !== copy) {
                // Recurse if we're merging plain objects or arrays
                if (deep && copy && ($538971b5b904f078$var$isPlainObject(copy) || (copyIsArray = $538971b5b904f078$var$isArray(copy)))) {
                    if (copyIsArray) {
                        copyIsArray = false;
                        clone = src && $538971b5b904f078$var$isArray(src) ? src : [];
                    } else clone = src && $538971b5b904f078$var$isPlainObject(src) ? src : {};
                    // Never move original objects, clone them
                    $538971b5b904f078$var$setProperty(target, {
                        name: name,
                        newValue: extend(deep, clone, copy)
                    });
                // Don't bring in undefined values
                } else if (typeof copy !== "undefined") $538971b5b904f078$var$setProperty(target, {
                    name: name,
                    newValue: copy
                });
            }
        }
    }
    // Return the modified object
    return target;
};
var $538971b5b904f078$var$isPlainObj = (value)=>{
    if (Object.prototype.toString.call(value) !== "[object Object]") return false;
    const prototype = Object.getPrototypeOf(value);
    return prototype === null || prototype === Object.prototype;
};
var $538971b5b904f078$var$slice$3 = [].slice;
var $538971b5b904f078$var$wrap_1$1 = $538971b5b904f078$var$wrap$2;
// Wrap `fn`.
// Can be sync or async; return a promise, receive a completion handler, return
// new values and errors.
function $538971b5b904f078$var$wrap$2(fn, callback) {
    var invoked;
    return wrapped;
    function wrapped() {
        var params = $538971b5b904f078$var$slice$3.call(arguments, 0);
        var callback = fn.length > params.length;
        var result;
        if (callback) params.push(done);
        try {
            result = fn.apply(null, params);
        } catch (error) {
            // Well, this is quite the pickle.
            // `fn` received a callback and invoked it (thus continuing the pipeline),
            // but later also threw an error.
            // We’re not about to restart the pipeline again, so the only thing left
            // to do is to throw the thing instead.
            if (callback && invoked) throw error;
            return done(error);
        }
        if (!callback) {
            if (result && typeof result.then === "function") result.then(then, done);
            else if (result instanceof Error) done(result);
            else then(result);
        }
    }
    // Invoke `next`, only once.
    function done() {
        if (!invoked) {
            invoked = true;
            callback.apply(null, arguments);
        }
    }
    // Invoke `done` with one value.
    // Tracks if an error is passed, too.
    function then(value) {
        done(null, value);
    }
}
var $538971b5b904f078$var$trough_1 = $538971b5b904f078$var$trough;
$538971b5b904f078$var$trough.wrap = $538971b5b904f078$var$wrap_1$1;
var $538971b5b904f078$var$slice$2 = [].slice;
// Create new middleware.
function $538971b5b904f078$var$trough() {
    var fns = [];
    var middleware = {};
    middleware.run = run;
    middleware.use = use;
    return middleware;
    // Run `fns`.  Last argument must be a completion handler.
    function run() {
        var index = -1;
        var input = $538971b5b904f078$var$slice$2.call(arguments, 0, -1);
        var done = arguments[arguments.length - 1];
        if (typeof done !== "function") throw new Error("Expected function as last argument, not " + done);
        next.apply(null, [
            null
        ].concat(input));
        // Run the next `fn`, if any.
        function next(err) {
            var fn = fns[++index];
            var params = $538971b5b904f078$var$slice$2.call(arguments, 0);
            var values = params.slice(1);
            var length = input.length;
            var pos = -1;
            if (err) {
                done(err);
                return;
            }
            // Copy non-nully input into values.
            while(++pos < length)if (values[pos] === null || values[pos] === undefined) values[pos] = input[pos];
            input = values;
            // Next or done.
            if (fn) $538971b5b904f078$var$wrap_1$1(fn, next).apply(null, input);
            else done.apply(null, [
                null
            ].concat(input));
        }
    }
    // Add `fn` to the list.
    function use(fn) {
        if (typeof fn !== "function") throw new Error("Expected `fn` to be a function, not " + fn);
        fns.push(fn);
        return middleware;
    }
}
var $538971b5b904f078$var$own$f = {}.hasOwnProperty;
var $538971b5b904f078$var$unistUtilStringifyPosition = $538971b5b904f078$var$stringify$4;
function $538971b5b904f078$var$stringify$4(value) {
    // Nothing.
    if (!value || typeof value !== "object") return "";
    // Node.
    if ($538971b5b904f078$var$own$f.call(value, "position") || $538971b5b904f078$var$own$f.call(value, "type")) return $538971b5b904f078$var$position$1(value.position);
    // Position.
    if ($538971b5b904f078$var$own$f.call(value, "start") || $538971b5b904f078$var$own$f.call(value, "end")) return $538971b5b904f078$var$position$1(value);
    // Point.
    if ($538971b5b904f078$var$own$f.call(value, "line") || $538971b5b904f078$var$own$f.call(value, "column")) return $538971b5b904f078$var$point(value);
    // ?
    return "";
}
function $538971b5b904f078$var$point(point) {
    if (!point || typeof point !== "object") point = {};
    return $538971b5b904f078$var$index$6(point.line) + ":" + $538971b5b904f078$var$index$6(point.column);
}
function $538971b5b904f078$var$position$1(pos) {
    if (!pos || typeof pos !== "object") pos = {};
    return $538971b5b904f078$var$point(pos.start) + "-" + $538971b5b904f078$var$point(pos.end);
}
function $538971b5b904f078$var$index$6(value) {
    return value && typeof value === "number" ? value : 1;
}
var $538971b5b904f078$var$vfileMessage = $538971b5b904f078$var$VMessage;
// Inherit from `Error#`.
function $538971b5b904f078$var$VMessagePrototype() {}
$538971b5b904f078$var$VMessagePrototype.prototype = Error.prototype;
$538971b5b904f078$var$VMessage.prototype = new $538971b5b904f078$var$VMessagePrototype();
// Message properties.
var $538971b5b904f078$var$proto$6 = $538971b5b904f078$var$VMessage.prototype;
$538971b5b904f078$var$proto$6.file = "";
$538971b5b904f078$var$proto$6.name = "";
$538971b5b904f078$var$proto$6.reason = "";
$538971b5b904f078$var$proto$6.message = "";
$538971b5b904f078$var$proto$6.stack = "";
$538971b5b904f078$var$proto$6.fatal = null;
$538971b5b904f078$var$proto$6.column = null;
$538971b5b904f078$var$proto$6.line = null;
// Construct a new VMessage.
//
// Note: We cannot invoke `Error` on the created context, as that adds readonly
// `line` and `column` attributes on Safari 9, thus throwing and failing the
// data.
function $538971b5b904f078$var$VMessage(reason, position, origin) {
    var parts;
    var range;
    var location;
    if (typeof position === "string") {
        origin = position;
        position = null;
    }
    parts = $538971b5b904f078$var$parseOrigin(origin);
    range = $538971b5b904f078$var$unistUtilStringifyPosition(position) || "1:1";
    location = {
        start: {
            line: null,
            column: null
        },
        end: {
            line: null,
            column: null
        }
    };
    // Node.
    if (position && position.position) position = position.position;
    if (position) {
        // Position.
        if (position.start) {
            location = position;
            position = position.start;
        } else // Point.
        location.start = position;
    }
    if (reason.stack) {
        this.stack = reason.stack;
        reason = reason.message;
    }
    this.message = reason;
    this.name = range;
    this.reason = reason;
    this.line = position ? position.line : null;
    this.column = position ? position.column : null;
    this.location = location;
    this.source = parts[0];
    this.ruleId = parts[1];
}
function $538971b5b904f078$var$parseOrigin(origin) {
    var result = [
        null,
        null
    ];
    var index;
    if (typeof origin === "string") {
        index = origin.indexOf(":");
        if (index === -1) result[1] = origin;
        else {
            result[0] = origin.slice(0, index);
            result[1] = origin.slice(index + 1);
        }
    }
    return result;
}
function $538971b5b904f078$var$replaceExt(npath, ext) {
    if (typeof npath !== "string") return npath;
    if (npath.length === 0) return npath;
    var nFileName = (0, $773sa$path1).basename(npath, (0, $773sa$path1).extname(npath)) + ext;
    return (0, $773sa$path1).join((0, $773sa$path1).dirname(npath), nFileName);
}
var $538971b5b904f078$var$replaceExt_1 = $538971b5b904f078$var$replaceExt;
var $538971b5b904f078$var$core$1 = $538971b5b904f078$var$VFile;
var $538971b5b904f078$var$own$e = {}.hasOwnProperty;
var $538971b5b904f078$var$proto$5 = $538971b5b904f078$var$VFile.prototype;
// Order of setting (least specific to most), we need this because otherwise
// `{stem: 'a', path: '~/b.js'}` would throw, as a path is needed before a
// stem can be set.
var $538971b5b904f078$var$order$1 = [
    "history",
    "path",
    "basename",
    "stem",
    "extname",
    "dirname"
];
$538971b5b904f078$var$proto$5.toString = $538971b5b904f078$var$toString;
// Access full path (`~/index.min.js`).
Object.defineProperty($538971b5b904f078$var$proto$5, "path", {
    get: $538971b5b904f078$var$getPath,
    set: $538971b5b904f078$var$setPath
});
// Access parent path (`~`).
Object.defineProperty($538971b5b904f078$var$proto$5, "dirname", {
    get: $538971b5b904f078$var$getDirname,
    set: $538971b5b904f078$var$setDirname
});
// Access basename (`index.min.js`).
Object.defineProperty($538971b5b904f078$var$proto$5, "basename", {
    get: $538971b5b904f078$var$getBasename,
    set: $538971b5b904f078$var$setBasename
});
// Access extname (`.js`).
Object.defineProperty($538971b5b904f078$var$proto$5, "extname", {
    get: $538971b5b904f078$var$getExtname,
    set: $538971b5b904f078$var$setExtname
});
// Access stem (`index.min`).
Object.defineProperty($538971b5b904f078$var$proto$5, "stem", {
    get: $538971b5b904f078$var$getStem,
    set: $538971b5b904f078$var$setStem
});
// Construct a new file.
function $538971b5b904f078$var$VFile(options) {
    var prop;
    var index;
    var length;
    if (!options) options = {};
    else if (typeof options === "string" || $538971b5b904f078$var$isBuffer(options)) options = {
        contents: options
    };
    else if ("message" in options && "messages" in options) return options;
    if (!(this instanceof $538971b5b904f078$var$VFile)) return new $538971b5b904f078$var$VFile(options);
    this.data = {};
    this.messages = [];
    this.history = [];
    this.cwd = process.cwd();
    // Set path related properties in the correct order.
    index = -1;
    length = $538971b5b904f078$var$order$1.length;
    while(++index < length){
        prop = $538971b5b904f078$var$order$1[index];
        if ($538971b5b904f078$var$own$e.call(options, prop)) this[prop] = options[prop];
    }
    // Set non-path related properties.
    for(prop in options)if ($538971b5b904f078$var$order$1.indexOf(prop) === -1) this[prop] = options[prop];
}
function $538971b5b904f078$var$getPath() {
    return this.history[this.history.length - 1];
}
function $538971b5b904f078$var$setPath(path) {
    $538971b5b904f078$var$assertNonEmpty(path, "path");
    if (path !== this.path) this.history.push(path);
}
function $538971b5b904f078$var$getDirname() {
    return typeof this.path === "string" ? (0, $773sa$path1).dirname(this.path) : undefined;
}
function $538971b5b904f078$var$setDirname(dirname) {
    $538971b5b904f078$var$assertPath(this.path, "dirname");
    this.path = (0, $773sa$path1).join(dirname || "", this.basename);
}
function $538971b5b904f078$var$getBasename() {
    return typeof this.path === "string" ? (0, $773sa$path1).basename(this.path) : undefined;
}
function $538971b5b904f078$var$setBasename(basename) {
    $538971b5b904f078$var$assertNonEmpty(basename, "basename");
    $538971b5b904f078$var$assertPart(basename, "basename");
    this.path = (0, $773sa$path1).join(this.dirname || "", basename);
}
function $538971b5b904f078$var$getExtname() {
    return typeof this.path === "string" ? (0, $773sa$path1).extname(this.path) : undefined;
}
function $538971b5b904f078$var$setExtname(extname) {
    var ext = extname || "";
    $538971b5b904f078$var$assertPart(ext, "extname");
    $538971b5b904f078$var$assertPath(this.path, "extname");
    if (ext) {
        if (ext.charAt(0) !== ".") throw new Error("`extname` must start with `.`");
        if (ext.indexOf(".", 1) !== -1) throw new Error("`extname` cannot contain multiple dots");
    }
    this.path = $538971b5b904f078$var$replaceExt_1(this.path, ext);
}
function $538971b5b904f078$var$getStem() {
    return typeof this.path === "string" ? (0, $773sa$path1).basename(this.path, this.extname) : undefined;
}
function $538971b5b904f078$var$setStem(stem) {
    $538971b5b904f078$var$assertNonEmpty(stem, "stem");
    $538971b5b904f078$var$assertPart(stem, "stem");
    this.path = (0, $773sa$path1).join(this.dirname || "", stem + (this.extname || ""));
}
// Get the value of the file.
function $538971b5b904f078$var$toString(encoding) {
    var value = this.contents || "";
    return $538971b5b904f078$var$isBuffer(value) ? value.toString(encoding) : String(value);
}
// Assert that `part` is not a path (i.e., does not contain `path.sep`).
function $538971b5b904f078$var$assertPart(part, name) {
    if (part.indexOf((0, $773sa$path1).sep) !== -1) throw new Error("`" + name + "` cannot be a path: did not expect `" + (0, $773sa$path1).sep + "`");
}
// Assert that `part` is not empty.
function $538971b5b904f078$var$assertNonEmpty(part, name) {
    if (!part) throw new Error("`" + name + "` cannot be empty");
}
// Assert `path` exists.
function $538971b5b904f078$var$assertPath(path, name) {
    if (!path) throw new Error("Setting `" + name + "` requires `path` to be set too");
}
var $538971b5b904f078$var$vfile = $538971b5b904f078$var$core$1;
var $538971b5b904f078$var$proto$4 = $538971b5b904f078$var$core$1.prototype;
$538971b5b904f078$var$proto$4.message = $538971b5b904f078$var$message;
$538971b5b904f078$var$proto$4.info = $538971b5b904f078$var$info$1;
$538971b5b904f078$var$proto$4.fail = $538971b5b904f078$var$fail;
// Create a message with `reason` at `position`.
// When an error is passed in as `reason`, copies the stack.
function $538971b5b904f078$var$message(reason, position, origin) {
    var filePath = this.path;
    var message = new $538971b5b904f078$var$vfileMessage(reason, position, origin);
    if (filePath) {
        message.name = filePath + ":" + message.name;
        message.file = filePath;
    }
    message.fatal = false;
    this.messages.push(message);
    return message;
}
// Fail: creates a vmessage, associates it with the file, and throws it.
function $538971b5b904f078$var$fail() {
    var message = this.message.apply(this, arguments);
    message.fatal = true;
    throw message;
}
// Info: creates a vmessage, associates it with the file, and marks the fatality
// as null.
function $538971b5b904f078$var$info$1() {
    var message = this.message.apply(this, arguments);
    message.fatal = null;
    return message;
}
// Expose a frozen processor.
var $538971b5b904f078$var$unified_1$1 = $538971b5b904f078$var$unified$1().freeze();
var $538971b5b904f078$var$slice$1 = [].slice;
var $538971b5b904f078$var$own$d = {}.hasOwnProperty;
// Process pipeline.
var $538971b5b904f078$var$pipeline$1 = $538971b5b904f078$var$trough_1().use($538971b5b904f078$var$pipelineParse$1).use($538971b5b904f078$var$pipelineRun$1).use($538971b5b904f078$var$pipelineStringify$1);
function $538971b5b904f078$var$pipelineParse$1(p, ctx) {
    ctx.tree = p.parse(ctx.file);
}
function $538971b5b904f078$var$pipelineRun$1(p, ctx, next) {
    p.run(ctx.tree, ctx.file, done);
    function done(err, tree, file) {
        if (err) next(err);
        else {
            ctx.tree = tree;
            ctx.file = file;
            next();
        }
    }
}
function $538971b5b904f078$var$pipelineStringify$1(p, ctx) {
    var result = p.stringify(ctx.tree, ctx.file);
    var file = ctx.file;
    if (result === undefined || result === null) ;
    else if (typeof result === "string" || $538971b5b904f078$var$isBuffer(result)) file.contents = result;
    else file.result = result;
}
// Function to create the first processor.
function $538971b5b904f078$var$unified$1() {
    var attachers = [];
    var transformers = $538971b5b904f078$var$trough_1();
    var namespace = {};
    var frozen = false;
    var freezeIndex = -1;
    // Data management.
    processor.data = data;
    // Lock.
    processor.freeze = freeze;
    // Plugins.
    processor.attachers = attachers;
    processor.use = use;
    // API.
    processor.parse = parse;
    processor.stringify = stringify;
    processor.run = run;
    processor.runSync = runSync;
    processor.process = process1;
    processor.processSync = processSync;
    // Expose.
    return processor;
    // Create a new processor based on the processor in the current scope.
    function processor() {
        var destination = $538971b5b904f078$var$unified$1();
        var length = attachers.length;
        var index = -1;
        while(++index < length)destination.use.apply(null, attachers[index]);
        destination.data($538971b5b904f078$var$extend$2(true, {}, namespace));
        return destination;
    }
    // Freeze: used to signal a processor that has finished configuration.
    //
    // For example, take unified itself: it’s frozen.
    // Plugins should not be added to it.
    // Rather, it should be extended, by invoking it, before modifying it.
    //
    // In essence, always invoke this when exporting a processor.
    function freeze() {
        var values;
        var plugin;
        var options;
        var transformer;
        if (frozen) return processor;
        while(++freezeIndex < attachers.length){
            values = attachers[freezeIndex];
            plugin = values[0];
            options = values[1];
            transformer = null;
            if (options === false) continue;
            if (options === true) values[1] = undefined;
            transformer = plugin.apply(processor, values.slice(1));
            if (typeof transformer === "function") transformers.use(transformer);
        }
        frozen = true;
        freezeIndex = Infinity;
        return processor;
    }
    // Data management.
    // Getter / setter for processor-specific informtion.
    function data(key, value) {
        if (typeof key === "string") {
            // Set `key`.
            if (arguments.length === 2) {
                $538971b5b904f078$var$assertUnfrozen$1("data", frozen);
                namespace[key] = value;
                return processor;
            }
            // Get `key`.
            return $538971b5b904f078$var$own$d.call(namespace, key) && namespace[key] || null;
        }
        // Set space.
        if (key) {
            $538971b5b904f078$var$assertUnfrozen$1("data", frozen);
            namespace = key;
            return processor;
        }
        // Get space.
        return namespace;
    }
    // Plugin management.
    //
    // Pass it:
    // *   an attacher and options,
    // *   a preset,
    // *   a list of presets, attachers, and arguments (list of attachers and
    //     options).
    function use(value) {
        var settings;
        $538971b5b904f078$var$assertUnfrozen$1("use", frozen);
        if (value === null || value === undefined) ;
        else if (typeof value === "function") addPlugin.apply(null, arguments);
        else if (typeof value === "object") {
            if ("length" in value) addList(value);
            else addPreset(value);
        } else throw new Error("Expected usable value, not `" + value + "`");
        if (settings) namespace.settings = $538971b5b904f078$var$extend$2(namespace.settings || {}, settings);
        return processor;
        function addPreset(result) {
            addList(result.plugins);
            if (result.settings) settings = $538971b5b904f078$var$extend$2(settings || {}, result.settings);
        }
        function add(value) {
            if (typeof value === "function") addPlugin(value);
            else if (typeof value === "object") {
                if ("length" in value) addPlugin.apply(null, value);
                else addPreset(value);
            } else throw new Error("Expected usable value, not `" + value + "`");
        }
        function addList(plugins) {
            var length;
            var index;
            if (plugins === null || plugins === undefined) ;
            else if (typeof plugins === "object" && "length" in plugins) {
                length = plugins.length;
                index = -1;
                while(++index < length)add(plugins[index]);
            } else throw new Error("Expected a list of plugins, not `" + plugins + "`");
        }
        function addPlugin(plugin, value) {
            var entry = find(plugin);
            if (entry) {
                if ($538971b5b904f078$var$isPlainObj(entry[1]) && $538971b5b904f078$var$isPlainObj(value)) value = $538971b5b904f078$var$extend$2(entry[1], value);
                entry[1] = value;
            } else attachers.push($538971b5b904f078$var$slice$1.call(arguments));
        }
    }
    function find(plugin) {
        var length = attachers.length;
        var index = -1;
        var entry;
        while(++index < length){
            entry = attachers[index];
            if (entry[0] === plugin) return entry;
        }
    }
    // Parse a file (in string or vfile representation) into a unist node using
    // the `Parser` on the processor.
    function parse(doc) {
        var file = $538971b5b904f078$var$vfile(doc);
        var Parser;
        freeze();
        Parser = processor.Parser;
        $538971b5b904f078$var$assertParser$1("parse", Parser);
        if ($538971b5b904f078$var$newable$1(Parser, "parse")) return new Parser(String(file), file).parse();
        return Parser(String(file), file) // eslint-disable-line new-cap
        ;
    }
    // Run transforms on a unist node representation of a file (in string or
    // vfile representation), async.
    function run(node, file, cb) {
        $538971b5b904f078$var$assertNode$1(node);
        freeze();
        if (!cb && typeof file === "function") {
            cb = file;
            file = null;
        }
        if (!cb) return new Promise(executor);
        executor(null, cb);
        function executor(resolve, reject) {
            transformers.run(node, $538971b5b904f078$var$vfile(file), done);
            function done(err, tree, file) {
                tree = tree || node;
                if (err) reject(err);
                else if (resolve) resolve(tree);
                else cb(null, tree, file);
            }
        }
    }
    // Run transforms on a unist node representation of a file (in string or
    // vfile representation), sync.
    function runSync(node, file) {
        var complete = false;
        var result;
        run(node, file, done);
        $538971b5b904f078$var$assertDone$1("runSync", "run", complete);
        return result;
        function done(err, tree) {
            complete = true;
            $538971b5b904f078$var$bail_1(err);
            result = tree;
        }
    }
    // Stringify a unist node representation of a file (in string or vfile
    // representation) into a string using the `Compiler` on the processor.
    function stringify(node, doc) {
        var file = $538971b5b904f078$var$vfile(doc);
        var Compiler;
        freeze();
        Compiler = processor.Compiler;
        $538971b5b904f078$var$assertCompiler$1("stringify", Compiler);
        $538971b5b904f078$var$assertNode$1(node);
        if ($538971b5b904f078$var$newable$1(Compiler, "compile")) return new Compiler(node, file).compile();
        return Compiler(node, file) // eslint-disable-line new-cap
        ;
    }
    // Parse a file (in string or vfile representation) into a unist node using
    // the `Parser` on the processor, then run transforms on that node, and
    // compile the resulting node using the `Compiler` on the processor, and
    // store that result on the vfile.
    function process1(doc, cb) {
        freeze();
        $538971b5b904f078$var$assertParser$1("process", processor.Parser);
        $538971b5b904f078$var$assertCompiler$1("process", processor.Compiler);
        if (!cb) return new Promise(executor);
        executor(null, cb);
        function executor(resolve, reject) {
            var file = $538971b5b904f078$var$vfile(doc);
            $538971b5b904f078$var$pipeline$1.run(processor, {
                file: file
            }, done);
            function done(err) {
                if (err) reject(err);
                else if (resolve) resolve(file);
                else cb(null, file);
            }
        }
    }
    // Process the given document (in string or vfile representation), sync.
    function processSync(doc) {
        var complete = false;
        var file;
        freeze();
        $538971b5b904f078$var$assertParser$1("processSync", processor.Parser);
        $538971b5b904f078$var$assertCompiler$1("processSync", processor.Compiler);
        file = $538971b5b904f078$var$vfile(doc);
        process1(file, done);
        $538971b5b904f078$var$assertDone$1("processSync", "process", complete);
        return file;
        function done(err) {
            complete = true;
            $538971b5b904f078$var$bail_1(err);
        }
    }
}
// Check if `value` is a constructor.
function $538971b5b904f078$var$newable$1(value, name) {
    return typeof value === "function" && value.prototype && // A function with keys in its prototype is probably a constructor.
    // Classes’ prototype methods are not enumerable, so we check if some value
    // exists in the prototype.
    ($538971b5b904f078$var$keys$2(value.prototype) || name in value.prototype);
}
// Check if `value` is an object with keys.
function $538971b5b904f078$var$keys$2(value) {
    var key;
    for(key in value)return true;
    return false;
}
// Assert a parser is available.
function $538971b5b904f078$var$assertParser$1(name, Parser) {
    if (typeof Parser !== "function") throw new Error("Cannot `" + name + "` without `Parser`");
}
// Assert a compiler is available.
function $538971b5b904f078$var$assertCompiler$1(name, Compiler) {
    if (typeof Compiler !== "function") throw new Error("Cannot `" + name + "` without `Compiler`");
}
// Assert the processor is not frozen.
function $538971b5b904f078$var$assertUnfrozen$1(name, frozen) {
    if (frozen) throw new Error("Cannot invoke `" + name + "` on a frozen processor.\nCreate a new processor first, by invoking it: use `processor()` instead of `processor`.");
}
// Assert `node` is a unist node.
function $538971b5b904f078$var$assertNode$1(node) {
    if (!node || typeof node.type !== "string") throw new Error("Expected node, got `" + node + "`");
}
// Assert that `complete` is `true`.
function $538971b5b904f078$var$assertDone$1(name, asyncName, complete) {
    if (!complete) throw new Error("`" + name + "` finished async. Use `" + asyncName + "` instead");
}
var $538971b5b904f078$var$immutable = $538971b5b904f078$var$extend$1;
var $538971b5b904f078$var$hasOwnProperty = Object.prototype.hasOwnProperty;
function $538971b5b904f078$var$extend$1() {
    var target = {};
    for(var i = 0; i < arguments.length; i++){
        var source = arguments[i];
        for(var key in source)if ($538971b5b904f078$var$hasOwnProperty.call(source, key)) target[key] = source[key];
    }
    return target;
}
function $538971b5b904f078$var$commonjsRequire() {
    throw new Error("Dynamic requires are not currently supported by rollup-plugin-commonjs");
}
function $538971b5b904f078$var$createCommonjsModule(fn, module) {
    return module = {
        exports: {}
    }, fn(module, module.exports), module.exports;
}
function $538971b5b904f078$var$getCjsExportFromNamespace(n) {
    return n && n["default"] || n;
}
var $538971b5b904f078$var$inherits_browser = $538971b5b904f078$var$createCommonjsModule(function(module) {
    if (typeof Object.create === "function") // implementation from standard node.js 'util' module
    module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
            ctor.super_ = superCtor;
            ctor.prototype = Object.create(superCtor.prototype, {
                constructor: {
                    value: ctor,
                    enumerable: false,
                    writable: true,
                    configurable: true
                }
            });
        }
    };
    else // old school shim for old browsers
    module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = function() {};
            TempCtor.prototype = superCtor.prototype;
            ctor.prototype = new TempCtor();
            ctor.prototype.constructor = ctor;
        }
    };
});
var $538971b5b904f078$var$inherits = $538971b5b904f078$var$createCommonjsModule(function(module) {
    try {
        var util$1 = (0, $773sa$util);
        /* istanbul ignore next */ if (typeof util$1.inherits !== "function") throw "";
        module.exports = util$1.inherits;
    } catch (e) {
        /* istanbul ignore next */ module.exports = $538971b5b904f078$var$inherits_browser;
    }
});
var $538971b5b904f078$var$unherit_1 = $538971b5b904f078$var$unherit;
// Create a custom constructor which can be modified without affecting the
// original class.
function $538971b5b904f078$var$unherit(Super) {
    var result;
    var key;
    var value;
    $538971b5b904f078$var$inherits(Of, Super);
    $538971b5b904f078$var$inherits(From, Of);
    // Clone values.
    result = Of.prototype;
    for(key in result){
        value = result[key];
        if (value && typeof value === "object") result[key] = "concat" in value ? value.concat() : $538971b5b904f078$var$immutable(value);
    }
    return Of;
    // Constructor accepting a single argument, which itself is an `arguments`
    // object.
    function From(parameters) {
        return Super.apply(this, parameters);
    }
    // Constructor accepting variadic arguments.
    function Of() {
        if (!(this instanceof Of)) return new From(arguments);
        return Super.apply(this, arguments);
    }
}
var $538971b5b904f078$var$stateToggle = $538971b5b904f078$var$factory$6;
// Construct a state `toggler`: a function which inverses `property` in context
// based on its current value.
// The by `toggler` returned function restores that value.
function $538971b5b904f078$var$factory$6(key, state, ctx) {
    return enter;
    function enter() {
        var context = ctx || this;
        var current = context[key];
        context[key] = !state;
        return exit;
        function exit() {
            context[key] = current;
        }
    }
}
var $538971b5b904f078$var$vfileLocation = $538971b5b904f078$var$factory$5;
function $538971b5b904f078$var$factory$5(file) {
    var contents = $538971b5b904f078$var$indices(String(file));
    return {
        toPosition: $538971b5b904f078$var$offsetToPositionFactory(contents),
        toOffset: $538971b5b904f078$var$positionToOffsetFactory(contents)
    };
}
// Factory to get the line and column-based `position` for `offset` in the bound
// indices.
function $538971b5b904f078$var$offsetToPositionFactory(indices) {
    return offsetToPosition;
    // Get the line and column-based `position` for `offset` in the bound indices.
    function offsetToPosition(offset) {
        var index = -1;
        var length = indices.length;
        if (offset < 0) return {};
        while(++index < length){
            if (indices[index] > offset) return {
                line: index + 1,
                column: offset - (indices[index - 1] || 0) + 1,
                offset: offset
            };
        }
        return {};
    }
}
// Factory to get the `offset` for a line and column-based `position` in the
// bound indices.
function $538971b5b904f078$var$positionToOffsetFactory(indices) {
    return positionToOffset;
    // Get the `offset` for a line and column-based `position` in the bound
    // indices.
    function positionToOffset(position) {
        var line = position && position.line;
        var column = position && position.column;
        if (!isNaN(line) && !isNaN(column) && line - 1 in indices) return (indices[line - 2] || 0) + column - 1 || 0;
        return -1;
    }
}
// Get indices of line-breaks in `value`.
function $538971b5b904f078$var$indices(value) {
    var result = [];
    var index = value.indexOf("\n");
    while(index !== -1){
        result.push(index + 1);
        index = value.indexOf("\n", index + 1);
    }
    result.push(value.length + 1);
    return result;
}
var $538971b5b904f078$var$_unescape = $538971b5b904f078$var$factory$4;
var $538971b5b904f078$var$backslash$7 = "\\";
// Factory to de-escape a value, based on a list at `key` in `ctx`.
function $538971b5b904f078$var$factory$4(ctx, key) {
    return unescape;
    // De-escape a string using the expression at `key` in `ctx`.
    function unescape(value) {
        var previous = 0;
        var index = value.indexOf($538971b5b904f078$var$backslash$7);
        var escape = ctx[key];
        var queue = [];
        var character;
        while(index !== -1){
            queue.push(value.slice(previous, index));
            previous = index + 1;
            character = value.charAt(previous);
            // If the following character is not a valid escape, add the slash.
            if (!character || escape.indexOf(character) === -1) queue.push($538971b5b904f078$var$backslash$7);
            index = value.indexOf($538971b5b904f078$var$backslash$7, previous + 1);
        }
        queue.push(value.slice(previous));
        return queue.join("");
    }
}
var $538971b5b904f078$var$AElig$2 = "\xc6";
var $538971b5b904f078$var$AMP$2 = "&";
var $538971b5b904f078$var$Aacute$2 = "\xc1";
var $538971b5b904f078$var$Acirc$2 = "\xc2";
var $538971b5b904f078$var$Agrave$2 = "\xc0";
var $538971b5b904f078$var$Aring$2 = "\xc5";
var $538971b5b904f078$var$Atilde$2 = "\xc3";
var $538971b5b904f078$var$Auml$2 = "\xc4";
var $538971b5b904f078$var$COPY$1 = "\xa9";
var $538971b5b904f078$var$Ccedil$2 = "\xc7";
var $538971b5b904f078$var$ETH$2 = "\xd0";
var $538971b5b904f078$var$Eacute$2 = "\xc9";
var $538971b5b904f078$var$Ecirc$2 = "\xca";
var $538971b5b904f078$var$Egrave$2 = "\xc8";
var $538971b5b904f078$var$Euml$2 = "\xcb";
var $538971b5b904f078$var$GT$2 = ">";
var $538971b5b904f078$var$Iacute$2 = "\xcd";
var $538971b5b904f078$var$Icirc$2 = "\xce";
var $538971b5b904f078$var$Igrave$2 = "\xcc";
var $538971b5b904f078$var$Iuml$2 = "\xcf";
var $538971b5b904f078$var$LT$2 = "<";
var $538971b5b904f078$var$Ntilde$2 = "\xd1";
var $538971b5b904f078$var$Oacute$2 = "\xd3";
var $538971b5b904f078$var$Ocirc$2 = "\xd4";
var $538971b5b904f078$var$Ograve$2 = "\xd2";
var $538971b5b904f078$var$Oslash$2 = "\xd8";
var $538971b5b904f078$var$Otilde$2 = "\xd5";
var $538971b5b904f078$var$Ouml$2 = "\xd6";
var $538971b5b904f078$var$QUOT$1 = '"';
var $538971b5b904f078$var$REG$1 = "\xae";
var $538971b5b904f078$var$THORN$2 = "\xde";
var $538971b5b904f078$var$Uacute$2 = "\xda";
var $538971b5b904f078$var$Ucirc$2 = "\xdb";
var $538971b5b904f078$var$Ugrave$2 = "\xd9";
var $538971b5b904f078$var$Uuml$2 = "\xdc";
var $538971b5b904f078$var$Yacute$2 = "\xdd";
var $538971b5b904f078$var$aacute$2 = "\xe1";
var $538971b5b904f078$var$acirc$2 = "\xe2";
var $538971b5b904f078$var$acute$2 = "\xb4";
var $538971b5b904f078$var$aelig$2 = "\xe6";
var $538971b5b904f078$var$agrave$2 = "\xe0";
var $538971b5b904f078$var$amp$2 = "&";
var $538971b5b904f078$var$aring$2 = "\xe5";
var $538971b5b904f078$var$atilde$2 = "\xe3";
var $538971b5b904f078$var$auml$2 = "\xe4";
var $538971b5b904f078$var$brvbar$2 = "\xa6";
var $538971b5b904f078$var$ccedil$2 = "\xe7";
var $538971b5b904f078$var$cedil$2 = "\xb8";
var $538971b5b904f078$var$cent$2 = "\xa2";
var $538971b5b904f078$var$copy$2 = "\xa9";
var $538971b5b904f078$var$curren$2 = "\xa4";
var $538971b5b904f078$var$deg$2 = "\xb0";
var $538971b5b904f078$var$divide$2 = "\xf7";
var $538971b5b904f078$var$eacute$2 = "\xe9";
var $538971b5b904f078$var$ecirc$2 = "\xea";
var $538971b5b904f078$var$egrave$2 = "\xe8";
var $538971b5b904f078$var$eth$2 = "\xf0";
var $538971b5b904f078$var$euml$2 = "\xeb";
var $538971b5b904f078$var$frac12$2 = "\xbd";
var $538971b5b904f078$var$frac14$2 = "\xbc";
var $538971b5b904f078$var$frac34$2 = "\xbe";
var $538971b5b904f078$var$gt$2 = ">";
var $538971b5b904f078$var$iacute$2 = "\xed";
var $538971b5b904f078$var$icirc$2 = "\xee";
var $538971b5b904f078$var$iexcl$2 = "\xa1";
var $538971b5b904f078$var$igrave$2 = "\xec";
var $538971b5b904f078$var$iquest$2 = "\xbf";
var $538971b5b904f078$var$iuml$2 = "\xef";
var $538971b5b904f078$var$laquo$2 = "\xab";
var $538971b5b904f078$var$lt$2 = "<";
var $538971b5b904f078$var$macr$2 = "\xaf";
var $538971b5b904f078$var$micro$2 = "\xb5";
var $538971b5b904f078$var$middot$2 = "\xb7";
var $538971b5b904f078$var$nbsp$2 = "\xa0";
var $538971b5b904f078$var$not$2 = "\xac";
var $538971b5b904f078$var$ntilde$2 = "\xf1";
var $538971b5b904f078$var$oacute$2 = "\xf3";
var $538971b5b904f078$var$ocirc$2 = "\xf4";
var $538971b5b904f078$var$ograve$2 = "\xf2";
var $538971b5b904f078$var$ordf$2 = "\xaa";
var $538971b5b904f078$var$ordm$2 = "\xba";
var $538971b5b904f078$var$oslash$2 = "\xf8";
var $538971b5b904f078$var$otilde$2 = "\xf5";
var $538971b5b904f078$var$ouml$2 = "\xf6";
var $538971b5b904f078$var$para$2 = "\xb6";
var $538971b5b904f078$var$plusmn$2 = "\xb1";
var $538971b5b904f078$var$pound$2 = "\xa3";
var $538971b5b904f078$var$quot$2 = '"';
var $538971b5b904f078$var$raquo$2 = "\xbb";
var $538971b5b904f078$var$reg$2 = "\xae";
var $538971b5b904f078$var$sect$2 = "\xa7";
var $538971b5b904f078$var$shy$2 = "\xad";
var $538971b5b904f078$var$sup1$2 = "\xb9";
var $538971b5b904f078$var$sup2$2 = "\xb2";
var $538971b5b904f078$var$sup3$2 = "\xb3";
var $538971b5b904f078$var$szlig$2 = "\xdf";
var $538971b5b904f078$var$thorn$2 = "\xfe";
var $538971b5b904f078$var$times$2 = "\xd7";
var $538971b5b904f078$var$uacute$2 = "\xfa";
var $538971b5b904f078$var$ucirc$2 = "\xfb";
var $538971b5b904f078$var$ugrave$2 = "\xf9";
var $538971b5b904f078$var$uml$2 = "\xa8";
var $538971b5b904f078$var$uuml$2 = "\xfc";
var $538971b5b904f078$var$yacute$2 = "\xfd";
var $538971b5b904f078$var$yen$2 = "\xa5";
var $538971b5b904f078$var$yuml$2 = "\xff";
var $538971b5b904f078$var$index$5 = {
    AElig: $538971b5b904f078$var$AElig$2,
    AMP: $538971b5b904f078$var$AMP$2,
    Aacute: $538971b5b904f078$var$Aacute$2,
    Acirc: $538971b5b904f078$var$Acirc$2,
    Agrave: $538971b5b904f078$var$Agrave$2,
    Aring: $538971b5b904f078$var$Aring$2,
    Atilde: $538971b5b904f078$var$Atilde$2,
    Auml: $538971b5b904f078$var$Auml$2,
    COPY: $538971b5b904f078$var$COPY$1,
    Ccedil: $538971b5b904f078$var$Ccedil$2,
    ETH: $538971b5b904f078$var$ETH$2,
    Eacute: $538971b5b904f078$var$Eacute$2,
    Ecirc: $538971b5b904f078$var$Ecirc$2,
    Egrave: $538971b5b904f078$var$Egrave$2,
    Euml: $538971b5b904f078$var$Euml$2,
    GT: $538971b5b904f078$var$GT$2,
    Iacute: $538971b5b904f078$var$Iacute$2,
    Icirc: $538971b5b904f078$var$Icirc$2,
    Igrave: $538971b5b904f078$var$Igrave$2,
    Iuml: $538971b5b904f078$var$Iuml$2,
    LT: $538971b5b904f078$var$LT$2,
    Ntilde: $538971b5b904f078$var$Ntilde$2,
    Oacute: $538971b5b904f078$var$Oacute$2,
    Ocirc: $538971b5b904f078$var$Ocirc$2,
    Ograve: $538971b5b904f078$var$Ograve$2,
    Oslash: $538971b5b904f078$var$Oslash$2,
    Otilde: $538971b5b904f078$var$Otilde$2,
    Ouml: $538971b5b904f078$var$Ouml$2,
    QUOT: $538971b5b904f078$var$QUOT$1,
    REG: $538971b5b904f078$var$REG$1,
    THORN: $538971b5b904f078$var$THORN$2,
    Uacute: $538971b5b904f078$var$Uacute$2,
    Ucirc: $538971b5b904f078$var$Ucirc$2,
    Ugrave: $538971b5b904f078$var$Ugrave$2,
    Uuml: $538971b5b904f078$var$Uuml$2,
    Yacute: $538971b5b904f078$var$Yacute$2,
    aacute: $538971b5b904f078$var$aacute$2,
    acirc: $538971b5b904f078$var$acirc$2,
    acute: $538971b5b904f078$var$acute$2,
    aelig: $538971b5b904f078$var$aelig$2,
    agrave: $538971b5b904f078$var$agrave$2,
    amp: $538971b5b904f078$var$amp$2,
    aring: $538971b5b904f078$var$aring$2,
    atilde: $538971b5b904f078$var$atilde$2,
    auml: $538971b5b904f078$var$auml$2,
    brvbar: $538971b5b904f078$var$brvbar$2,
    ccedil: $538971b5b904f078$var$ccedil$2,
    cedil: $538971b5b904f078$var$cedil$2,
    cent: $538971b5b904f078$var$cent$2,
    copy: $538971b5b904f078$var$copy$2,
    curren: $538971b5b904f078$var$curren$2,
    deg: $538971b5b904f078$var$deg$2,
    divide: $538971b5b904f078$var$divide$2,
    eacute: $538971b5b904f078$var$eacute$2,
    ecirc: $538971b5b904f078$var$ecirc$2,
    egrave: $538971b5b904f078$var$egrave$2,
    eth: $538971b5b904f078$var$eth$2,
    euml: $538971b5b904f078$var$euml$2,
    frac12: $538971b5b904f078$var$frac12$2,
    frac14: $538971b5b904f078$var$frac14$2,
    frac34: $538971b5b904f078$var$frac34$2,
    gt: $538971b5b904f078$var$gt$2,
    iacute: $538971b5b904f078$var$iacute$2,
    icirc: $538971b5b904f078$var$icirc$2,
    iexcl: $538971b5b904f078$var$iexcl$2,
    igrave: $538971b5b904f078$var$igrave$2,
    iquest: $538971b5b904f078$var$iquest$2,
    iuml: $538971b5b904f078$var$iuml$2,
    laquo: $538971b5b904f078$var$laquo$2,
    lt: $538971b5b904f078$var$lt$2,
    macr: $538971b5b904f078$var$macr$2,
    micro: $538971b5b904f078$var$micro$2,
    middot: $538971b5b904f078$var$middot$2,
    nbsp: $538971b5b904f078$var$nbsp$2,
    not: $538971b5b904f078$var$not$2,
    ntilde: $538971b5b904f078$var$ntilde$2,
    oacute: $538971b5b904f078$var$oacute$2,
    ocirc: $538971b5b904f078$var$ocirc$2,
    ograve: $538971b5b904f078$var$ograve$2,
    ordf: $538971b5b904f078$var$ordf$2,
    ordm: $538971b5b904f078$var$ordm$2,
    oslash: $538971b5b904f078$var$oslash$2,
    otilde: $538971b5b904f078$var$otilde$2,
    ouml: $538971b5b904f078$var$ouml$2,
    para: $538971b5b904f078$var$para$2,
    plusmn: $538971b5b904f078$var$plusmn$2,
    pound: $538971b5b904f078$var$pound$2,
    quot: $538971b5b904f078$var$quot$2,
    raquo: $538971b5b904f078$var$raquo$2,
    reg: $538971b5b904f078$var$reg$2,
    sect: $538971b5b904f078$var$sect$2,
    shy: $538971b5b904f078$var$shy$2,
    sup1: $538971b5b904f078$var$sup1$2,
    sup2: $538971b5b904f078$var$sup2$2,
    sup3: $538971b5b904f078$var$sup3$2,
    szlig: $538971b5b904f078$var$szlig$2,
    thorn: $538971b5b904f078$var$thorn$2,
    times: $538971b5b904f078$var$times$2,
    uacute: $538971b5b904f078$var$uacute$2,
    ucirc: $538971b5b904f078$var$ucirc$2,
    ugrave: $538971b5b904f078$var$ugrave$2,
    uml: $538971b5b904f078$var$uml$2,
    uuml: $538971b5b904f078$var$uuml$2,
    yacute: $538971b5b904f078$var$yacute$2,
    yen: $538971b5b904f078$var$yen$2,
    yuml: $538971b5b904f078$var$yuml$2
};
var $538971b5b904f078$var$characterEntitiesLegacy = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    AElig: $538971b5b904f078$var$AElig$2,
    AMP: $538971b5b904f078$var$AMP$2,
    Aacute: $538971b5b904f078$var$Aacute$2,
    Acirc: $538971b5b904f078$var$Acirc$2,
    Agrave: $538971b5b904f078$var$Agrave$2,
    Aring: $538971b5b904f078$var$Aring$2,
    Atilde: $538971b5b904f078$var$Atilde$2,
    Auml: $538971b5b904f078$var$Auml$2,
    COPY: $538971b5b904f078$var$COPY$1,
    Ccedil: $538971b5b904f078$var$Ccedil$2,
    ETH: $538971b5b904f078$var$ETH$2,
    Eacute: $538971b5b904f078$var$Eacute$2,
    Ecirc: $538971b5b904f078$var$Ecirc$2,
    Egrave: $538971b5b904f078$var$Egrave$2,
    Euml: $538971b5b904f078$var$Euml$2,
    GT: $538971b5b904f078$var$GT$2,
    Iacute: $538971b5b904f078$var$Iacute$2,
    Icirc: $538971b5b904f078$var$Icirc$2,
    Igrave: $538971b5b904f078$var$Igrave$2,
    Iuml: $538971b5b904f078$var$Iuml$2,
    LT: $538971b5b904f078$var$LT$2,
    Ntilde: $538971b5b904f078$var$Ntilde$2,
    Oacute: $538971b5b904f078$var$Oacute$2,
    Ocirc: $538971b5b904f078$var$Ocirc$2,
    Ograve: $538971b5b904f078$var$Ograve$2,
    Oslash: $538971b5b904f078$var$Oslash$2,
    Otilde: $538971b5b904f078$var$Otilde$2,
    Ouml: $538971b5b904f078$var$Ouml$2,
    QUOT: $538971b5b904f078$var$QUOT$1,
    REG: $538971b5b904f078$var$REG$1,
    THORN: $538971b5b904f078$var$THORN$2,
    Uacute: $538971b5b904f078$var$Uacute$2,
    Ucirc: $538971b5b904f078$var$Ucirc$2,
    Ugrave: $538971b5b904f078$var$Ugrave$2,
    Uuml: $538971b5b904f078$var$Uuml$2,
    Yacute: $538971b5b904f078$var$Yacute$2,
    aacute: $538971b5b904f078$var$aacute$2,
    acirc: $538971b5b904f078$var$acirc$2,
    acute: $538971b5b904f078$var$acute$2,
    aelig: $538971b5b904f078$var$aelig$2,
    agrave: $538971b5b904f078$var$agrave$2,
    amp: $538971b5b904f078$var$amp$2,
    aring: $538971b5b904f078$var$aring$2,
    atilde: $538971b5b904f078$var$atilde$2,
    auml: $538971b5b904f078$var$auml$2,
    brvbar: $538971b5b904f078$var$brvbar$2,
    ccedil: $538971b5b904f078$var$ccedil$2,
    cedil: $538971b5b904f078$var$cedil$2,
    cent: $538971b5b904f078$var$cent$2,
    copy: $538971b5b904f078$var$copy$2,
    curren: $538971b5b904f078$var$curren$2,
    deg: $538971b5b904f078$var$deg$2,
    divide: $538971b5b904f078$var$divide$2,
    eacute: $538971b5b904f078$var$eacute$2,
    ecirc: $538971b5b904f078$var$ecirc$2,
    egrave: $538971b5b904f078$var$egrave$2,
    eth: $538971b5b904f078$var$eth$2,
    euml: $538971b5b904f078$var$euml$2,
    frac12: $538971b5b904f078$var$frac12$2,
    frac14: $538971b5b904f078$var$frac14$2,
    frac34: $538971b5b904f078$var$frac34$2,
    gt: $538971b5b904f078$var$gt$2,
    iacute: $538971b5b904f078$var$iacute$2,
    icirc: $538971b5b904f078$var$icirc$2,
    iexcl: $538971b5b904f078$var$iexcl$2,
    igrave: $538971b5b904f078$var$igrave$2,
    iquest: $538971b5b904f078$var$iquest$2,
    iuml: $538971b5b904f078$var$iuml$2,
    laquo: $538971b5b904f078$var$laquo$2,
    lt: $538971b5b904f078$var$lt$2,
    macr: $538971b5b904f078$var$macr$2,
    micro: $538971b5b904f078$var$micro$2,
    middot: $538971b5b904f078$var$middot$2,
    nbsp: $538971b5b904f078$var$nbsp$2,
    not: $538971b5b904f078$var$not$2,
    ntilde: $538971b5b904f078$var$ntilde$2,
    oacute: $538971b5b904f078$var$oacute$2,
    ocirc: $538971b5b904f078$var$ocirc$2,
    ograve: $538971b5b904f078$var$ograve$2,
    ordf: $538971b5b904f078$var$ordf$2,
    ordm: $538971b5b904f078$var$ordm$2,
    oslash: $538971b5b904f078$var$oslash$2,
    otilde: $538971b5b904f078$var$otilde$2,
    ouml: $538971b5b904f078$var$ouml$2,
    para: $538971b5b904f078$var$para$2,
    plusmn: $538971b5b904f078$var$plusmn$2,
    pound: $538971b5b904f078$var$pound$2,
    quot: $538971b5b904f078$var$quot$2,
    raquo: $538971b5b904f078$var$raquo$2,
    reg: $538971b5b904f078$var$reg$2,
    sect: $538971b5b904f078$var$sect$2,
    shy: $538971b5b904f078$var$shy$2,
    sup1: $538971b5b904f078$var$sup1$2,
    sup2: $538971b5b904f078$var$sup2$2,
    sup3: $538971b5b904f078$var$sup3$2,
    szlig: $538971b5b904f078$var$szlig$2,
    thorn: $538971b5b904f078$var$thorn$2,
    times: $538971b5b904f078$var$times$2,
    uacute: $538971b5b904f078$var$uacute$2,
    ucirc: $538971b5b904f078$var$ucirc$2,
    ugrave: $538971b5b904f078$var$ugrave$2,
    uml: $538971b5b904f078$var$uml$2,
    uuml: $538971b5b904f078$var$uuml$2,
    yacute: $538971b5b904f078$var$yacute$2,
    yen: $538971b5b904f078$var$yen$2,
    yuml: $538971b5b904f078$var$yuml$2,
    "default": $538971b5b904f078$var$index$5
});
var $538971b5b904f078$var$index$4 = {
    "0": "\uFFFD",
    "128": "\u20AC",
    "130": "\u201A",
    "131": "\u0192",
    "132": "\u201E",
    "133": "\u2026",
    "134": "\u2020",
    "135": "\u2021",
    "136": "\u02C6",
    "137": "\u2030",
    "138": "\u0160",
    "139": "\u2039",
    "140": "\u0152",
    "142": "\u017D",
    "145": "\u2018",
    "146": "\u2019",
    "147": "\u201C",
    "148": "\u201D",
    "149": "\u2022",
    "150": "\u2013",
    "151": "\u2014",
    "152": "\u02DC",
    "153": "\u2122",
    "154": "\u0161",
    "155": "\u203A",
    "156": "\u0153",
    "158": "\u017E",
    "159": "\u0178"
};
var $538971b5b904f078$var$characterReferenceInvalid = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    "default": $538971b5b904f078$var$index$4
});
var $538971b5b904f078$var$isDecimal = $538971b5b904f078$var$decimal$1;
// Check if the given character code, or the character code at the first
// character, is decimal.
function $538971b5b904f078$var$decimal$1(character) {
    var code = typeof character === "string" ? character.charCodeAt(0) : character;
    return code >= 48 && code <= 57 /* 0-9 */ ;
}
var $538971b5b904f078$var$isHexadecimal = $538971b5b904f078$var$hexadecimal;
// Check if the given character code, or the character code at the first
// character, is hexadecimal.
function $538971b5b904f078$var$hexadecimal(character) {
    var code = typeof character === "string" ? character.charCodeAt(0) : character;
    return code >= 97 /* a */  && code <= 102 || code >= 65 /* A */  && code <= 70 || code >= 48 /* A */  && code <= 57;
}
var $538971b5b904f078$var$isAlphabetical = $538971b5b904f078$var$alphabetical;
// Check if the given character code, or the character code at the first
// character, is alphabetical.
function $538971b5b904f078$var$alphabetical(character) {
    var code = typeof character === "string" ? character.charCodeAt(0) : character;
    return code >= 97 && code <= 122 || code >= 65 && code <= 90;
}
var $538971b5b904f078$var$isAlphanumerical = $538971b5b904f078$var$alphanumerical;
// Check if the given character code, or the character code at the first
// character, is alphanumerical.
function $538971b5b904f078$var$alphanumerical(character) {
    return $538971b5b904f078$var$isAlphabetical(character) || $538971b5b904f078$var$isDecimal(character);
}
var $538971b5b904f078$var$AEli = "\xc6";
var $538971b5b904f078$var$AElig$1 = "\xc6";
var $538971b5b904f078$var$AM = "&";
var $538971b5b904f078$var$AMP$1 = "&";
var $538971b5b904f078$var$Aacut = "\xc1";
var $538971b5b904f078$var$Aacute$1 = "\xc1";
var $538971b5b904f078$var$Abreve = "\u0102";
var $538971b5b904f078$var$Acir = "\xc2";
var $538971b5b904f078$var$Acirc$1 = "\xc2";
var $538971b5b904f078$var$Acy = "\u0410";
var $538971b5b904f078$var$Afr = "\uD835\uDD04";
var $538971b5b904f078$var$Agrav = "\xc0";
var $538971b5b904f078$var$Agrave$1 = "\xc0";
var $538971b5b904f078$var$Alpha$1 = "\u0391";
var $538971b5b904f078$var$Amacr = "\u0100";
var $538971b5b904f078$var$And = "\u2A53";
var $538971b5b904f078$var$Aogon = "\u0104";
var $538971b5b904f078$var$Aopf = "\uD835\uDD38";
var $538971b5b904f078$var$ApplyFunction = "\u2061";
var $538971b5b904f078$var$Arin = "\xc5";
var $538971b5b904f078$var$Aring$1 = "\xc5";
var $538971b5b904f078$var$Ascr = "\uD835\uDC9C";
var $538971b5b904f078$var$Assign = "\u2254";
var $538971b5b904f078$var$Atild = "\xc3";
var $538971b5b904f078$var$Atilde$1 = "\xc3";
var $538971b5b904f078$var$Aum = "\xc4";
var $538971b5b904f078$var$Auml$1 = "\xc4";
var $538971b5b904f078$var$Backslash = "\u2216";
var $538971b5b904f078$var$Barv = "\u2AE7";
var $538971b5b904f078$var$Barwed = "\u2306";
var $538971b5b904f078$var$Bcy = "\u0411";
var $538971b5b904f078$var$Because = "\u2235";
var $538971b5b904f078$var$Bernoullis = "\u212C";
var $538971b5b904f078$var$Beta$1 = "\u0392";
var $538971b5b904f078$var$Bfr = "\uD835\uDD05";
var $538971b5b904f078$var$Bopf = "\uD835\uDD39";
var $538971b5b904f078$var$Breve = "\u02D8";
var $538971b5b904f078$var$Bscr = "\u212C";
var $538971b5b904f078$var$Bumpeq = "\u224E";
var $538971b5b904f078$var$CHcy = "\u0427";
var $538971b5b904f078$var$COP = "\xa9";
var $538971b5b904f078$var$COPY = "\xa9";
var $538971b5b904f078$var$Cacute = "\u0106";
var $538971b5b904f078$var$Cap = "\u22D2";
var $538971b5b904f078$var$CapitalDifferentialD = "\u2145";
var $538971b5b904f078$var$Cayleys = "\u212D";
var $538971b5b904f078$var$Ccaron = "\u010C";
var $538971b5b904f078$var$Ccedi = "\xc7";
var $538971b5b904f078$var$Ccedil$1 = "\xc7";
var $538971b5b904f078$var$Ccirc = "\u0108";
var $538971b5b904f078$var$Cconint = "\u2230";
var $538971b5b904f078$var$Cdot = "\u010A";
var $538971b5b904f078$var$Cedilla = "\xb8";
var $538971b5b904f078$var$CenterDot = "\xb7";
var $538971b5b904f078$var$Cfr = "\u212D";
var $538971b5b904f078$var$Chi$1 = "\u03A7";
var $538971b5b904f078$var$CircleDot = "\u2299";
var $538971b5b904f078$var$CircleMinus = "\u2296";
var $538971b5b904f078$var$CirclePlus = "\u2295";
var $538971b5b904f078$var$CircleTimes = "\u2297";
var $538971b5b904f078$var$ClockwiseContourIntegral = "\u2232";
var $538971b5b904f078$var$CloseCurlyDoubleQuote = "\u201D";
var $538971b5b904f078$var$CloseCurlyQuote = "\u2019";
var $538971b5b904f078$var$Colon = "\u2237";
var $538971b5b904f078$var$Colone = "\u2A74";
var $538971b5b904f078$var$Congruent = "\u2261";
var $538971b5b904f078$var$Conint = "\u222F";
var $538971b5b904f078$var$ContourIntegral = "\u222E";
var $538971b5b904f078$var$Copf = "\u2102";
var $538971b5b904f078$var$Coproduct = "\u2210";
var $538971b5b904f078$var$CounterClockwiseContourIntegral = "\u2233";
var $538971b5b904f078$var$Cross = "\u2A2F";
var $538971b5b904f078$var$Cscr = "\uD835\uDC9E";
var $538971b5b904f078$var$Cup = "\u22D3";
var $538971b5b904f078$var$CupCap = "\u224D";
var $538971b5b904f078$var$DD = "\u2145";
var $538971b5b904f078$var$DDotrahd = "\u2911";
var $538971b5b904f078$var$DJcy = "\u0402";
var $538971b5b904f078$var$DScy = "\u0405";
var $538971b5b904f078$var$DZcy = "\u040F";
var $538971b5b904f078$var$Dagger$1 = "\u2021";
var $538971b5b904f078$var$Darr = "\u21A1";
var $538971b5b904f078$var$Dashv = "\u2AE4";
var $538971b5b904f078$var$Dcaron = "\u010E";
var $538971b5b904f078$var$Dcy = "\u0414";
var $538971b5b904f078$var$Del = "\u2207";
var $538971b5b904f078$var$Delta$1 = "\u0394";
var $538971b5b904f078$var$Dfr = "\uD835\uDD07";
var $538971b5b904f078$var$DiacriticalAcute = "\xb4";
var $538971b5b904f078$var$DiacriticalDot = "\u02D9";
var $538971b5b904f078$var$DiacriticalDoubleAcute = "\u02DD";
var $538971b5b904f078$var$DiacriticalGrave = "`";
var $538971b5b904f078$var$DiacriticalTilde = "\u02DC";
var $538971b5b904f078$var$Diamond = "\u22C4";
var $538971b5b904f078$var$DifferentialD = "\u2146";
var $538971b5b904f078$var$Dopf = "\uD835\uDD3B";
var $538971b5b904f078$var$Dot = "\xa8";
var $538971b5b904f078$var$DotDot = "\u20DC";
var $538971b5b904f078$var$DotEqual = "\u2250";
var $538971b5b904f078$var$DoubleContourIntegral = "\u222F";
var $538971b5b904f078$var$DoubleDot = "\xa8";
var $538971b5b904f078$var$DoubleDownArrow = "\u21D3";
var $538971b5b904f078$var$DoubleLeftArrow = "\u21D0";
var $538971b5b904f078$var$DoubleLeftRightArrow = "\u21D4";
var $538971b5b904f078$var$DoubleLeftTee = "\u2AE4";
var $538971b5b904f078$var$DoubleLongLeftArrow = "\u27F8";
var $538971b5b904f078$var$DoubleLongLeftRightArrow = "\u27FA";
var $538971b5b904f078$var$DoubleLongRightArrow = "\u27F9";
var $538971b5b904f078$var$DoubleRightArrow = "\u21D2";
var $538971b5b904f078$var$DoubleRightTee = "\u22A8";
var $538971b5b904f078$var$DoubleUpArrow = "\u21D1";
var $538971b5b904f078$var$DoubleUpDownArrow = "\u21D5";
var $538971b5b904f078$var$DoubleVerticalBar = "\u2225";
var $538971b5b904f078$var$DownArrow = "\u2193";
var $538971b5b904f078$var$DownArrowBar = "\u2913";
var $538971b5b904f078$var$DownArrowUpArrow = "\u21F5";
var $538971b5b904f078$var$DownBreve = "\u0311";
var $538971b5b904f078$var$DownLeftRightVector = "\u2950";
var $538971b5b904f078$var$DownLeftTeeVector = "\u295E";
var $538971b5b904f078$var$DownLeftVector = "\u21BD";
var $538971b5b904f078$var$DownLeftVectorBar = "\u2956";
var $538971b5b904f078$var$DownRightTeeVector = "\u295F";
var $538971b5b904f078$var$DownRightVector = "\u21C1";
var $538971b5b904f078$var$DownRightVectorBar = "\u2957";
var $538971b5b904f078$var$DownTee = "\u22A4";
var $538971b5b904f078$var$DownTeeArrow = "\u21A7";
var $538971b5b904f078$var$Downarrow = "\u21D3";
var $538971b5b904f078$var$Dscr = "\uD835\uDC9F";
var $538971b5b904f078$var$Dstrok = "\u0110";
var $538971b5b904f078$var$ENG = "\u014A";
var $538971b5b904f078$var$ET = "\xd0";
var $538971b5b904f078$var$ETH$1 = "\xd0";
var $538971b5b904f078$var$Eacut = "\xc9";
var $538971b5b904f078$var$Eacute$1 = "\xc9";
var $538971b5b904f078$var$Ecaron = "\u011A";
var $538971b5b904f078$var$Ecir = "\xca";
var $538971b5b904f078$var$Ecirc$1 = "\xca";
var $538971b5b904f078$var$Ecy = "\u042D";
var $538971b5b904f078$var$Edot = "\u0116";
var $538971b5b904f078$var$Efr = "\uD835\uDD08";
var $538971b5b904f078$var$Egrav = "\xc8";
var $538971b5b904f078$var$Egrave$1 = "\xc8";
var $538971b5b904f078$var$Element = "\u2208";
var $538971b5b904f078$var$Emacr = "\u0112";
var $538971b5b904f078$var$EmptySmallSquare = "\u25FB";
var $538971b5b904f078$var$EmptyVerySmallSquare = "\u25AB";
var $538971b5b904f078$var$Eogon = "\u0118";
var $538971b5b904f078$var$Eopf = "\uD835\uDD3C";
var $538971b5b904f078$var$Epsilon$1 = "\u0395";
var $538971b5b904f078$var$Equal = "\u2A75";
var $538971b5b904f078$var$EqualTilde = "\u2242";
var $538971b5b904f078$var$Equilibrium = "\u21CC";
var $538971b5b904f078$var$Escr = "\u2130";
var $538971b5b904f078$var$Esim = "\u2A73";
var $538971b5b904f078$var$Eta$1 = "\u0397";
var $538971b5b904f078$var$Eum = "\xcb";
var $538971b5b904f078$var$Euml$1 = "\xcb";
var $538971b5b904f078$var$Exists = "\u2203";
var $538971b5b904f078$var$ExponentialE = "\u2147";
var $538971b5b904f078$var$Fcy = "\u0424";
var $538971b5b904f078$var$Ffr = "\uD835\uDD09";
var $538971b5b904f078$var$FilledSmallSquare = "\u25FC";
var $538971b5b904f078$var$FilledVerySmallSquare = "\u25AA";
var $538971b5b904f078$var$Fopf = "\uD835\uDD3D";
var $538971b5b904f078$var$ForAll = "\u2200";
var $538971b5b904f078$var$Fouriertrf = "\u2131";
var $538971b5b904f078$var$Fscr = "\u2131";
var $538971b5b904f078$var$GJcy = "\u0403";
var $538971b5b904f078$var$G = ">";
var $538971b5b904f078$var$GT$1 = ">";
var $538971b5b904f078$var$Gamma$1 = "\u0393";
var $538971b5b904f078$var$Gammad = "\u03DC";
var $538971b5b904f078$var$Gbreve = "\u011E";
var $538971b5b904f078$var$Gcedil = "\u0122";
var $538971b5b904f078$var$Gcirc = "\u011C";
var $538971b5b904f078$var$Gcy = "\u0413";
var $538971b5b904f078$var$Gdot = "\u0120";
var $538971b5b904f078$var$Gfr = "\uD835\uDD0A";
var $538971b5b904f078$var$Gg = "\u22D9";
var $538971b5b904f078$var$Gopf = "\uD835\uDD3E";
var $538971b5b904f078$var$GreaterEqual = "\u2265";
var $538971b5b904f078$var$GreaterEqualLess = "\u22DB";
var $538971b5b904f078$var$GreaterFullEqual = "\u2267";
var $538971b5b904f078$var$GreaterGreater = "\u2AA2";
var $538971b5b904f078$var$GreaterLess = "\u2277";
var $538971b5b904f078$var$GreaterSlantEqual = "\u2A7E";
var $538971b5b904f078$var$GreaterTilde = "\u2273";
var $538971b5b904f078$var$Gscr = "\uD835\uDCA2";
var $538971b5b904f078$var$Gt = "\u226B";
var $538971b5b904f078$var$HARDcy = "\u042A";
var $538971b5b904f078$var$Hacek = "\u02C7";
var $538971b5b904f078$var$Hat = "^";
var $538971b5b904f078$var$Hcirc = "\u0124";
var $538971b5b904f078$var$Hfr = "\u210C";
var $538971b5b904f078$var$HilbertSpace = "\u210B";
var $538971b5b904f078$var$Hopf = "\u210D";
var $538971b5b904f078$var$HorizontalLine = "\u2500";
var $538971b5b904f078$var$Hscr = "\u210B";
var $538971b5b904f078$var$Hstrok = "\u0126";
var $538971b5b904f078$var$HumpDownHump = "\u224E";
var $538971b5b904f078$var$HumpEqual = "\u224F";
var $538971b5b904f078$var$IEcy = "\u0415";
var $538971b5b904f078$var$IJlig = "\u0132";
var $538971b5b904f078$var$IOcy = "\u0401";
var $538971b5b904f078$var$Iacut = "\xcd";
var $538971b5b904f078$var$Iacute$1 = "\xcd";
var $538971b5b904f078$var$Icir = "\xce";
var $538971b5b904f078$var$Icirc$1 = "\xce";
var $538971b5b904f078$var$Icy = "\u0418";
var $538971b5b904f078$var$Idot = "\u0130";
var $538971b5b904f078$var$Ifr = "\u2111";
var $538971b5b904f078$var$Igrav = "\xcc";
var $538971b5b904f078$var$Igrave$1 = "\xcc";
var $538971b5b904f078$var$Im = "\u2111";
var $538971b5b904f078$var$Imacr = "\u012A";
var $538971b5b904f078$var$ImaginaryI = "\u2148";
var $538971b5b904f078$var$Implies = "\u21D2";
var $538971b5b904f078$var$Int = "\u222C";
var $538971b5b904f078$var$Integral = "\u222B";
var $538971b5b904f078$var$Intersection = "\u22C2";
var $538971b5b904f078$var$InvisibleComma = "\u2063";
var $538971b5b904f078$var$InvisibleTimes = "\u2062";
var $538971b5b904f078$var$Iogon = "\u012E";
var $538971b5b904f078$var$Iopf = "\uD835\uDD40";
var $538971b5b904f078$var$Iota$1 = "\u0399";
var $538971b5b904f078$var$Iscr = "\u2110";
var $538971b5b904f078$var$Itilde = "\u0128";
var $538971b5b904f078$var$Iukcy = "\u0406";
var $538971b5b904f078$var$Ium = "\xcf";
var $538971b5b904f078$var$Iuml$1 = "\xcf";
var $538971b5b904f078$var$Jcirc = "\u0134";
var $538971b5b904f078$var$Jcy = "\u0419";
var $538971b5b904f078$var$Jfr = "\uD835\uDD0D";
var $538971b5b904f078$var$Jopf = "\uD835\uDD41";
var $538971b5b904f078$var$Jscr = "\uD835\uDCA5";
var $538971b5b904f078$var$Jsercy = "\u0408";
var $538971b5b904f078$var$Jukcy = "\u0404";
var $538971b5b904f078$var$KHcy = "\u0425";
var $538971b5b904f078$var$KJcy = "\u040C";
var $538971b5b904f078$var$Kappa$1 = "\u039A";
var $538971b5b904f078$var$Kcedil = "\u0136";
var $538971b5b904f078$var$Kcy = "\u041A";
var $538971b5b904f078$var$Kfr = "\uD835\uDD0E";
var $538971b5b904f078$var$Kopf = "\uD835\uDD42";
var $538971b5b904f078$var$Kscr = "\uD835\uDCA6";
var $538971b5b904f078$var$LJcy = "\u0409";
var $538971b5b904f078$var$L = "<";
var $538971b5b904f078$var$LT$1 = "<";
var $538971b5b904f078$var$Lacute = "\u0139";
var $538971b5b904f078$var$Lambda$1 = "\u039B";
var $538971b5b904f078$var$Lang = "\u27EA";
var $538971b5b904f078$var$Laplacetrf = "\u2112";
var $538971b5b904f078$var$Larr = "\u219E";
var $538971b5b904f078$var$Lcaron = "\u013D";
var $538971b5b904f078$var$Lcedil = "\u013B";
var $538971b5b904f078$var$Lcy = "\u041B";
var $538971b5b904f078$var$LeftAngleBracket = "\u27E8";
var $538971b5b904f078$var$LeftArrow = "\u2190";
var $538971b5b904f078$var$LeftArrowBar = "\u21E4";
var $538971b5b904f078$var$LeftArrowRightArrow = "\u21C6";
var $538971b5b904f078$var$LeftCeiling = "\u2308";
var $538971b5b904f078$var$LeftDoubleBracket = "\u27E6";
var $538971b5b904f078$var$LeftDownTeeVector = "\u2961";
var $538971b5b904f078$var$LeftDownVector = "\u21C3";
var $538971b5b904f078$var$LeftDownVectorBar = "\u2959";
var $538971b5b904f078$var$LeftFloor = "\u230A";
var $538971b5b904f078$var$LeftRightArrow = "\u2194";
var $538971b5b904f078$var$LeftRightVector = "\u294E";
var $538971b5b904f078$var$LeftTee = "\u22A3";
var $538971b5b904f078$var$LeftTeeArrow = "\u21A4";
var $538971b5b904f078$var$LeftTeeVector = "\u295A";
var $538971b5b904f078$var$LeftTriangle = "\u22B2";
var $538971b5b904f078$var$LeftTriangleBar = "\u29CF";
var $538971b5b904f078$var$LeftTriangleEqual = "\u22B4";
var $538971b5b904f078$var$LeftUpDownVector = "\u2951";
var $538971b5b904f078$var$LeftUpTeeVector = "\u2960";
var $538971b5b904f078$var$LeftUpVector = "\u21BF";
var $538971b5b904f078$var$LeftUpVectorBar = "\u2958";
var $538971b5b904f078$var$LeftVector = "\u21BC";
var $538971b5b904f078$var$LeftVectorBar = "\u2952";
var $538971b5b904f078$var$Leftarrow = "\u21D0";
var $538971b5b904f078$var$Leftrightarrow = "\u21D4";
var $538971b5b904f078$var$LessEqualGreater = "\u22DA";
var $538971b5b904f078$var$LessFullEqual = "\u2266";
var $538971b5b904f078$var$LessGreater = "\u2276";
var $538971b5b904f078$var$LessLess = "\u2AA1";
var $538971b5b904f078$var$LessSlantEqual = "\u2A7D";
var $538971b5b904f078$var$LessTilde = "\u2272";
var $538971b5b904f078$var$Lfr = "\uD835\uDD0F";
var $538971b5b904f078$var$Ll = "\u22D8";
var $538971b5b904f078$var$Lleftarrow = "\u21DA";
var $538971b5b904f078$var$Lmidot = "\u013F";
var $538971b5b904f078$var$LongLeftArrow = "\u27F5";
var $538971b5b904f078$var$LongLeftRightArrow = "\u27F7";
var $538971b5b904f078$var$LongRightArrow = "\u27F6";
var $538971b5b904f078$var$Longleftarrow = "\u27F8";
var $538971b5b904f078$var$Longleftrightarrow = "\u27FA";
var $538971b5b904f078$var$Longrightarrow = "\u27F9";
var $538971b5b904f078$var$Lopf = "\uD835\uDD43";
var $538971b5b904f078$var$LowerLeftArrow = "\u2199";
var $538971b5b904f078$var$LowerRightArrow = "\u2198";
var $538971b5b904f078$var$Lscr = "\u2112";
var $538971b5b904f078$var$Lsh = "\u21B0";
var $538971b5b904f078$var$Lstrok = "\u0141";
var $538971b5b904f078$var$Lt = "\u226A";
var $538971b5b904f078$var$Mcy = "\u041C";
var $538971b5b904f078$var$MediumSpace = "\u205F";
var $538971b5b904f078$var$Mellintrf = "\u2133";
var $538971b5b904f078$var$Mfr = "\uD835\uDD10";
var $538971b5b904f078$var$MinusPlus = "\u2213";
var $538971b5b904f078$var$Mopf = "\uD835\uDD44";
var $538971b5b904f078$var$Mscr = "\u2133";
var $538971b5b904f078$var$Mu$1 = "\u039C";
var $538971b5b904f078$var$NJcy = "\u040A";
var $538971b5b904f078$var$Nacute = "\u0143";
var $538971b5b904f078$var$Ncaron = "\u0147";
var $538971b5b904f078$var$Ncedil = "\u0145";
var $538971b5b904f078$var$Ncy = "\u041D";
var $538971b5b904f078$var$NegativeMediumSpace = "\u200B";
var $538971b5b904f078$var$NegativeThickSpace = "\u200B";
var $538971b5b904f078$var$NegativeThinSpace = "\u200B";
var $538971b5b904f078$var$NegativeVeryThinSpace = "\u200B";
var $538971b5b904f078$var$NestedGreaterGreater = "\u226B";
var $538971b5b904f078$var$NestedLessLess = "\u226A";
var $538971b5b904f078$var$NewLine = "\n";
var $538971b5b904f078$var$Nfr = "\uD835\uDD11";
var $538971b5b904f078$var$NoBreak = "\u2060";
var $538971b5b904f078$var$NonBreakingSpace = "\xa0";
var $538971b5b904f078$var$Nopf = "\u2115";
var $538971b5b904f078$var$Not = "\u2AEC";
var $538971b5b904f078$var$NotCongruent = "\u2262";
var $538971b5b904f078$var$NotCupCap = "\u226D";
var $538971b5b904f078$var$NotDoubleVerticalBar = "\u2226";
var $538971b5b904f078$var$NotElement = "\u2209";
var $538971b5b904f078$var$NotEqual = "\u2260";
var $538971b5b904f078$var$NotEqualTilde = "\u2242\u0338";
var $538971b5b904f078$var$NotExists = "\u2204";
var $538971b5b904f078$var$NotGreater = "\u226F";
var $538971b5b904f078$var$NotGreaterEqual = "\u2271";
var $538971b5b904f078$var$NotGreaterFullEqual = "\u2267\u0338";
var $538971b5b904f078$var$NotGreaterGreater = "\u226B\u0338";
var $538971b5b904f078$var$NotGreaterLess = "\u2279";
var $538971b5b904f078$var$NotGreaterSlantEqual = "\u2A7E\u0338";
var $538971b5b904f078$var$NotGreaterTilde = "\u2275";
var $538971b5b904f078$var$NotHumpDownHump = "\u224E\u0338";
var $538971b5b904f078$var$NotHumpEqual = "\u224F\u0338";
var $538971b5b904f078$var$NotLeftTriangle = "\u22EA";
var $538971b5b904f078$var$NotLeftTriangleBar = "\u29CF\u0338";
var $538971b5b904f078$var$NotLeftTriangleEqual = "\u22EC";
var $538971b5b904f078$var$NotLess = "\u226E";
var $538971b5b904f078$var$NotLessEqual = "\u2270";
var $538971b5b904f078$var$NotLessGreater = "\u2278";
var $538971b5b904f078$var$NotLessLess = "\u226A\u0338";
var $538971b5b904f078$var$NotLessSlantEqual = "\u2A7D\u0338";
var $538971b5b904f078$var$NotLessTilde = "\u2274";
var $538971b5b904f078$var$NotNestedGreaterGreater = "\u2AA2\u0338";
var $538971b5b904f078$var$NotNestedLessLess = "\u2AA1\u0338";
var $538971b5b904f078$var$NotPrecedes = "\u2280";
var $538971b5b904f078$var$NotPrecedesEqual = "\u2AAF\u0338";
var $538971b5b904f078$var$NotPrecedesSlantEqual = "\u22E0";
var $538971b5b904f078$var$NotReverseElement = "\u220C";
var $538971b5b904f078$var$NotRightTriangle = "\u22EB";
var $538971b5b904f078$var$NotRightTriangleBar = "\u29D0\u0338";
var $538971b5b904f078$var$NotRightTriangleEqual = "\u22ED";
var $538971b5b904f078$var$NotSquareSubset = "\u228F\u0338";
var $538971b5b904f078$var$NotSquareSubsetEqual = "\u22E2";
var $538971b5b904f078$var$NotSquareSuperset = "\u2290\u0338";
var $538971b5b904f078$var$NotSquareSupersetEqual = "\u22E3";
var $538971b5b904f078$var$NotSubset = "\u2282\u20D2";
var $538971b5b904f078$var$NotSubsetEqual = "\u2288";
var $538971b5b904f078$var$NotSucceeds = "\u2281";
var $538971b5b904f078$var$NotSucceedsEqual = "\u2AB0\u0338";
var $538971b5b904f078$var$NotSucceedsSlantEqual = "\u22E1";
var $538971b5b904f078$var$NotSucceedsTilde = "\u227F\u0338";
var $538971b5b904f078$var$NotSuperset = "\u2283\u20D2";
var $538971b5b904f078$var$NotSupersetEqual = "\u2289";
var $538971b5b904f078$var$NotTilde = "\u2241";
var $538971b5b904f078$var$NotTildeEqual = "\u2244";
var $538971b5b904f078$var$NotTildeFullEqual = "\u2247";
var $538971b5b904f078$var$NotTildeTilde = "\u2249";
var $538971b5b904f078$var$NotVerticalBar = "\u2224";
var $538971b5b904f078$var$Nscr = "\uD835\uDCA9";
var $538971b5b904f078$var$Ntild = "\xd1";
var $538971b5b904f078$var$Ntilde$1 = "\xd1";
var $538971b5b904f078$var$Nu$1 = "\u039D";
var $538971b5b904f078$var$OElig$1 = "\u0152";
var $538971b5b904f078$var$Oacut = "\xd3";
var $538971b5b904f078$var$Oacute$1 = "\xd3";
var $538971b5b904f078$var$Ocir = "\xd4";
var $538971b5b904f078$var$Ocirc$1 = "\xd4";
var $538971b5b904f078$var$Ocy = "\u041E";
var $538971b5b904f078$var$Odblac = "\u0150";
var $538971b5b904f078$var$Ofr = "\uD835\uDD12";
var $538971b5b904f078$var$Ograv = "\xd2";
var $538971b5b904f078$var$Ograve$1 = "\xd2";
var $538971b5b904f078$var$Omacr = "\u014C";
var $538971b5b904f078$var$Omega$1 = "\u03A9";
var $538971b5b904f078$var$Omicron$1 = "\u039F";
var $538971b5b904f078$var$Oopf = "\uD835\uDD46";
var $538971b5b904f078$var$OpenCurlyDoubleQuote = "\u201C";
var $538971b5b904f078$var$OpenCurlyQuote = "\u2018";
var $538971b5b904f078$var$Or = "\u2A54";
var $538971b5b904f078$var$Oscr = "\uD835\uDCAA";
var $538971b5b904f078$var$Oslas = "\xd8";
var $538971b5b904f078$var$Oslash$1 = "\xd8";
var $538971b5b904f078$var$Otild = "\xd5";
var $538971b5b904f078$var$Otilde$1 = "\xd5";
var $538971b5b904f078$var$Otimes = "\u2A37";
var $538971b5b904f078$var$Oum = "\xd6";
var $538971b5b904f078$var$Ouml$1 = "\xd6";
var $538971b5b904f078$var$OverBar = "\u203E";
var $538971b5b904f078$var$OverBrace = "\u23DE";
var $538971b5b904f078$var$OverBracket = "\u23B4";
var $538971b5b904f078$var$OverParenthesis = "\u23DC";
var $538971b5b904f078$var$PartialD = "\u2202";
var $538971b5b904f078$var$Pcy = "\u041F";
var $538971b5b904f078$var$Pfr = "\uD835\uDD13";
var $538971b5b904f078$var$Phi$1 = "\u03A6";
var $538971b5b904f078$var$Pi$1 = "\u03A0";
var $538971b5b904f078$var$PlusMinus = "\xb1";
var $538971b5b904f078$var$Poincareplane = "\u210C";
var $538971b5b904f078$var$Popf = "\u2119";
var $538971b5b904f078$var$Pr = "\u2ABB";
var $538971b5b904f078$var$Precedes = "\u227A";
var $538971b5b904f078$var$PrecedesEqual = "\u2AAF";
var $538971b5b904f078$var$PrecedesSlantEqual = "\u227C";
var $538971b5b904f078$var$PrecedesTilde = "\u227E";
var $538971b5b904f078$var$Prime$1 = "\u2033";
var $538971b5b904f078$var$Product = "\u220F";
var $538971b5b904f078$var$Proportion = "\u2237";
var $538971b5b904f078$var$Proportional = "\u221D";
var $538971b5b904f078$var$Pscr = "\uD835\uDCAB";
var $538971b5b904f078$var$Psi$1 = "\u03A8";
var $538971b5b904f078$var$QUO = '"';
var $538971b5b904f078$var$QUOT = '"';
var $538971b5b904f078$var$Qfr = "\uD835\uDD14";
var $538971b5b904f078$var$Qopf = "\u211A";
var $538971b5b904f078$var$Qscr = "\uD835\uDCAC";
var $538971b5b904f078$var$RBarr = "\u2910";
var $538971b5b904f078$var$RE = "\xae";
var $538971b5b904f078$var$REG = "\xae";
var $538971b5b904f078$var$Racute = "\u0154";
var $538971b5b904f078$var$Rang = "\u27EB";
var $538971b5b904f078$var$Rarr = "\u21A0";
var $538971b5b904f078$var$Rarrtl = "\u2916";
var $538971b5b904f078$var$Rcaron = "\u0158";
var $538971b5b904f078$var$Rcedil = "\u0156";
var $538971b5b904f078$var$Rcy = "\u0420";
var $538971b5b904f078$var$Re = "\u211C";
var $538971b5b904f078$var$ReverseElement = "\u220B";
var $538971b5b904f078$var$ReverseEquilibrium = "\u21CB";
var $538971b5b904f078$var$ReverseUpEquilibrium = "\u296F";
var $538971b5b904f078$var$Rfr = "\u211C";
var $538971b5b904f078$var$Rho$1 = "\u03A1";
var $538971b5b904f078$var$RightAngleBracket = "\u27E9";
var $538971b5b904f078$var$RightArrow = "\u2192";
var $538971b5b904f078$var$RightArrowBar = "\u21E5";
var $538971b5b904f078$var$RightArrowLeftArrow = "\u21C4";
var $538971b5b904f078$var$RightCeiling = "\u2309";
var $538971b5b904f078$var$RightDoubleBracket = "\u27E7";
var $538971b5b904f078$var$RightDownTeeVector = "\u295D";
var $538971b5b904f078$var$RightDownVector = "\u21C2";
var $538971b5b904f078$var$RightDownVectorBar = "\u2955";
var $538971b5b904f078$var$RightFloor = "\u230B";
var $538971b5b904f078$var$RightTee = "\u22A2";
var $538971b5b904f078$var$RightTeeArrow = "\u21A6";
var $538971b5b904f078$var$RightTeeVector = "\u295B";
var $538971b5b904f078$var$RightTriangle = "\u22B3";
var $538971b5b904f078$var$RightTriangleBar = "\u29D0";
var $538971b5b904f078$var$RightTriangleEqual = "\u22B5";
var $538971b5b904f078$var$RightUpDownVector = "\u294F";
var $538971b5b904f078$var$RightUpTeeVector = "\u295C";
var $538971b5b904f078$var$RightUpVector = "\u21BE";
var $538971b5b904f078$var$RightUpVectorBar = "\u2954";
var $538971b5b904f078$var$RightVector = "\u21C0";
var $538971b5b904f078$var$RightVectorBar = "\u2953";
var $538971b5b904f078$var$Rightarrow = "\u21D2";
var $538971b5b904f078$var$Ropf = "\u211D";
var $538971b5b904f078$var$RoundImplies = "\u2970";
var $538971b5b904f078$var$Rrightarrow = "\u21DB";
var $538971b5b904f078$var$Rscr = "\u211B";
var $538971b5b904f078$var$Rsh = "\u21B1";
var $538971b5b904f078$var$RuleDelayed = "\u29F4";
var $538971b5b904f078$var$SHCHcy = "\u0429";
var $538971b5b904f078$var$SHcy = "\u0428";
var $538971b5b904f078$var$SOFTcy = "\u042C";
var $538971b5b904f078$var$Sacute = "\u015A";
var $538971b5b904f078$var$Sc = "\u2ABC";
var $538971b5b904f078$var$Scaron$1 = "\u0160";
var $538971b5b904f078$var$Scedil = "\u015E";
var $538971b5b904f078$var$Scirc = "\u015C";
var $538971b5b904f078$var$Scy = "\u0421";
var $538971b5b904f078$var$Sfr = "\uD835\uDD16";
var $538971b5b904f078$var$ShortDownArrow = "\u2193";
var $538971b5b904f078$var$ShortLeftArrow = "\u2190";
var $538971b5b904f078$var$ShortRightArrow = "\u2192";
var $538971b5b904f078$var$ShortUpArrow = "\u2191";
var $538971b5b904f078$var$Sigma$1 = "\u03A3";
var $538971b5b904f078$var$SmallCircle = "\u2218";
var $538971b5b904f078$var$Sopf = "\uD835\uDD4A";
var $538971b5b904f078$var$Sqrt = "\u221A";
var $538971b5b904f078$var$Square = "\u25A1";
var $538971b5b904f078$var$SquareIntersection = "\u2293";
var $538971b5b904f078$var$SquareSubset = "\u228F";
var $538971b5b904f078$var$SquareSubsetEqual = "\u2291";
var $538971b5b904f078$var$SquareSuperset = "\u2290";
var $538971b5b904f078$var$SquareSupersetEqual = "\u2292";
var $538971b5b904f078$var$SquareUnion = "\u2294";
var $538971b5b904f078$var$Sscr = "\uD835\uDCAE";
var $538971b5b904f078$var$Star = "\u22C6";
var $538971b5b904f078$var$Sub = "\u22D0";
var $538971b5b904f078$var$Subset = "\u22D0";
var $538971b5b904f078$var$SubsetEqual = "\u2286";
var $538971b5b904f078$var$Succeeds = "\u227B";
var $538971b5b904f078$var$SucceedsEqual = "\u2AB0";
var $538971b5b904f078$var$SucceedsSlantEqual = "\u227D";
var $538971b5b904f078$var$SucceedsTilde = "\u227F";
var $538971b5b904f078$var$SuchThat = "\u220B";
var $538971b5b904f078$var$Sum = "\u2211";
var $538971b5b904f078$var$Sup = "\u22D1";
var $538971b5b904f078$var$Superset = "\u2283";
var $538971b5b904f078$var$SupersetEqual = "\u2287";
var $538971b5b904f078$var$Supset = "\u22D1";
var $538971b5b904f078$var$THOR = "\xde";
var $538971b5b904f078$var$THORN$1 = "\xde";
var $538971b5b904f078$var$TRADE = "\u2122";
var $538971b5b904f078$var$TSHcy = "\u040B";
var $538971b5b904f078$var$TScy = "\u0426";
var $538971b5b904f078$var$Tab = "	";
var $538971b5b904f078$var$Tau$1 = "\u03A4";
var $538971b5b904f078$var$Tcaron = "\u0164";
var $538971b5b904f078$var$Tcedil = "\u0162";
var $538971b5b904f078$var$Tcy = "\u0422";
var $538971b5b904f078$var$Tfr = "\uD835\uDD17";
var $538971b5b904f078$var$Therefore = "\u2234";
var $538971b5b904f078$var$Theta$1 = "\u0398";
var $538971b5b904f078$var$ThickSpace = "\u205F\u200A";
var $538971b5b904f078$var$ThinSpace = "\u2009";
var $538971b5b904f078$var$Tilde = "\u223C";
var $538971b5b904f078$var$TildeEqual = "\u2243";
var $538971b5b904f078$var$TildeFullEqual = "\u2245";
var $538971b5b904f078$var$TildeTilde = "\u2248";
var $538971b5b904f078$var$Topf = "\uD835\uDD4B";
var $538971b5b904f078$var$TripleDot = "\u20DB";
var $538971b5b904f078$var$Tscr = "\uD835\uDCAF";
var $538971b5b904f078$var$Tstrok = "\u0166";
var $538971b5b904f078$var$Uacut = "\xda";
var $538971b5b904f078$var$Uacute$1 = "\xda";
var $538971b5b904f078$var$Uarr = "\u219F";
var $538971b5b904f078$var$Uarrocir = "\u2949";
var $538971b5b904f078$var$Ubrcy = "\u040E";
var $538971b5b904f078$var$Ubreve = "\u016C";
var $538971b5b904f078$var$Ucir = "\xdb";
var $538971b5b904f078$var$Ucirc$1 = "\xdb";
var $538971b5b904f078$var$Ucy = "\u0423";
var $538971b5b904f078$var$Udblac = "\u0170";
var $538971b5b904f078$var$Ufr = "\uD835\uDD18";
var $538971b5b904f078$var$Ugrav = "\xd9";
var $538971b5b904f078$var$Ugrave$1 = "\xd9";
var $538971b5b904f078$var$Umacr = "\u016A";
var $538971b5b904f078$var$UnderBar = "_";
var $538971b5b904f078$var$UnderBrace = "\u23DF";
var $538971b5b904f078$var$UnderBracket = "\u23B5";
var $538971b5b904f078$var$UnderParenthesis = "\u23DD";
var $538971b5b904f078$var$Union = "\u22C3";
var $538971b5b904f078$var$UnionPlus = "\u228E";
var $538971b5b904f078$var$Uogon = "\u0172";
var $538971b5b904f078$var$Uopf = "\uD835\uDD4C";
var $538971b5b904f078$var$UpArrow = "\u2191";
var $538971b5b904f078$var$UpArrowBar = "\u2912";
var $538971b5b904f078$var$UpArrowDownArrow = "\u21C5";
var $538971b5b904f078$var$UpDownArrow = "\u2195";
var $538971b5b904f078$var$UpEquilibrium = "\u296E";
var $538971b5b904f078$var$UpTee = "\u22A5";
var $538971b5b904f078$var$UpTeeArrow = "\u21A5";
var $538971b5b904f078$var$Uparrow = "\u21D1";
var $538971b5b904f078$var$Updownarrow = "\u21D5";
var $538971b5b904f078$var$UpperLeftArrow = "\u2196";
var $538971b5b904f078$var$UpperRightArrow = "\u2197";
var $538971b5b904f078$var$Upsi = "\u03D2";
var $538971b5b904f078$var$Upsilon$1 = "\u03A5";
var $538971b5b904f078$var$Uring = "\u016E";
var $538971b5b904f078$var$Uscr = "\uD835\uDCB0";
var $538971b5b904f078$var$Utilde = "\u0168";
var $538971b5b904f078$var$Uum = "\xdc";
var $538971b5b904f078$var$Uuml$1 = "\xdc";
var $538971b5b904f078$var$VDash = "\u22AB";
var $538971b5b904f078$var$Vbar = "\u2AEB";
var $538971b5b904f078$var$Vcy = "\u0412";
var $538971b5b904f078$var$Vdash = "\u22A9";
var $538971b5b904f078$var$Vdashl = "\u2AE6";
var $538971b5b904f078$var$Vee = "\u22C1";
var $538971b5b904f078$var$Verbar = "\u2016";
var $538971b5b904f078$var$Vert = "\u2016";
var $538971b5b904f078$var$VerticalBar = "\u2223";
var $538971b5b904f078$var$VerticalLine = "|";
var $538971b5b904f078$var$VerticalSeparator = "\u2758";
var $538971b5b904f078$var$VerticalTilde = "\u2240";
var $538971b5b904f078$var$VeryThinSpace = "\u200A";
var $538971b5b904f078$var$Vfr = "\uD835\uDD19";
var $538971b5b904f078$var$Vopf = "\uD835\uDD4D";
var $538971b5b904f078$var$Vscr = "\uD835\uDCB1";
var $538971b5b904f078$var$Vvdash = "\u22AA";
var $538971b5b904f078$var$Wcirc = "\u0174";
var $538971b5b904f078$var$Wedge = "\u22C0";
var $538971b5b904f078$var$Wfr = "\uD835\uDD1A";
var $538971b5b904f078$var$Wopf = "\uD835\uDD4E";
var $538971b5b904f078$var$Wscr = "\uD835\uDCB2";
var $538971b5b904f078$var$Xfr = "\uD835\uDD1B";
var $538971b5b904f078$var$Xi$1 = "\u039E";
var $538971b5b904f078$var$Xopf = "\uD835\uDD4F";
var $538971b5b904f078$var$Xscr = "\uD835\uDCB3";
var $538971b5b904f078$var$YAcy = "\u042F";
var $538971b5b904f078$var$YIcy = "\u0407";
var $538971b5b904f078$var$YUcy = "\u042E";
var $538971b5b904f078$var$Yacut = "\xdd";
var $538971b5b904f078$var$Yacute$1 = "\xdd";
var $538971b5b904f078$var$Ycirc = "\u0176";
var $538971b5b904f078$var$Ycy = "\u042B";
var $538971b5b904f078$var$Yfr = "\uD835\uDD1C";
var $538971b5b904f078$var$Yopf = "\uD835\uDD50";
var $538971b5b904f078$var$Yscr = "\uD835\uDCB4";
var $538971b5b904f078$var$Yuml$1 = "\u0178";
var $538971b5b904f078$var$ZHcy = "\u0416";
var $538971b5b904f078$var$Zacute = "\u0179";
var $538971b5b904f078$var$Zcaron = "\u017D";
var $538971b5b904f078$var$Zcy = "\u0417";
var $538971b5b904f078$var$Zdot = "\u017B";
var $538971b5b904f078$var$ZeroWidthSpace = "\u200B";
var $538971b5b904f078$var$Zeta$1 = "\u0396";
var $538971b5b904f078$var$Zfr = "\u2128";
var $538971b5b904f078$var$Zopf = "\u2124";
var $538971b5b904f078$var$Zscr = "\uD835\uDCB5";
var $538971b5b904f078$var$aacut = "\xe1";
var $538971b5b904f078$var$aacute$1 = "\xe1";
var $538971b5b904f078$var$abreve = "\u0103";
var $538971b5b904f078$var$ac = "\u223E";
var $538971b5b904f078$var$acE = "\u223E\u0333";
var $538971b5b904f078$var$acd = "\u223F";
var $538971b5b904f078$var$acir = "\xe2";
var $538971b5b904f078$var$acirc$1 = "\xe2";
var $538971b5b904f078$var$acut = "\xb4";
var $538971b5b904f078$var$acute$1 = "\xb4";
var $538971b5b904f078$var$acy = "\u0430";
var $538971b5b904f078$var$aeli = "\xe6";
var $538971b5b904f078$var$aelig$1 = "\xe6";
var $538971b5b904f078$var$af = "\u2061";
var $538971b5b904f078$var$afr = "\uD835\uDD1E";
var $538971b5b904f078$var$agrav = "\xe0";
var $538971b5b904f078$var$agrave$1 = "\xe0";
var $538971b5b904f078$var$alefsym$1 = "\u2135";
var $538971b5b904f078$var$aleph = "\u2135";
var $538971b5b904f078$var$alpha$1 = "\u03B1";
var $538971b5b904f078$var$amacr = "\u0101";
var $538971b5b904f078$var$amalg = "\u2A3F";
var $538971b5b904f078$var$am = "&";
var $538971b5b904f078$var$amp$1 = "&";
var $538971b5b904f078$var$and$1 = "\u2227";
var $538971b5b904f078$var$andand = "\u2A55";
var $538971b5b904f078$var$andd = "\u2A5C";
var $538971b5b904f078$var$andslope = "\u2A58";
var $538971b5b904f078$var$andv = "\u2A5A";
var $538971b5b904f078$var$ang$1 = "\u2220";
var $538971b5b904f078$var$ange = "\u29A4";
var $538971b5b904f078$var$angle = "\u2220";
var $538971b5b904f078$var$angmsd = "\u2221";
var $538971b5b904f078$var$angmsdaa = "\u29A8";
var $538971b5b904f078$var$angmsdab = "\u29A9";
var $538971b5b904f078$var$angmsdac = "\u29AA";
var $538971b5b904f078$var$angmsdad = "\u29AB";
var $538971b5b904f078$var$angmsdae = "\u29AC";
var $538971b5b904f078$var$angmsdaf = "\u29AD";
var $538971b5b904f078$var$angmsdag = "\u29AE";
var $538971b5b904f078$var$angmsdah = "\u29AF";
var $538971b5b904f078$var$angrt = "\u221F";
var $538971b5b904f078$var$angrtvb = "\u22BE";
var $538971b5b904f078$var$angrtvbd = "\u299D";
var $538971b5b904f078$var$angsph = "\u2222";
var $538971b5b904f078$var$angst = "\xc5";
var $538971b5b904f078$var$angzarr = "\u237C";
var $538971b5b904f078$var$aogon = "\u0105";
var $538971b5b904f078$var$aopf = "\uD835\uDD52";
var $538971b5b904f078$var$ap = "\u2248";
var $538971b5b904f078$var$apE = "\u2A70";
var $538971b5b904f078$var$apacir = "\u2A6F";
var $538971b5b904f078$var$ape = "\u224A";
var $538971b5b904f078$var$apid = "\u224B";
var $538971b5b904f078$var$apos = "'";
var $538971b5b904f078$var$approx = "\u2248";
var $538971b5b904f078$var$approxeq = "\u224A";
var $538971b5b904f078$var$arin = "\xe5";
var $538971b5b904f078$var$aring$1 = "\xe5";
var $538971b5b904f078$var$ascr = "\uD835\uDCB6";
var $538971b5b904f078$var$ast = "*";
var $538971b5b904f078$var$asymp$1 = "\u2248";
var $538971b5b904f078$var$asympeq = "\u224D";
var $538971b5b904f078$var$atild = "\xe3";
var $538971b5b904f078$var$atilde$1 = "\xe3";
var $538971b5b904f078$var$aum = "\xe4";
var $538971b5b904f078$var$auml$1 = "\xe4";
var $538971b5b904f078$var$awconint = "\u2233";
var $538971b5b904f078$var$awint = "\u2A11";
var $538971b5b904f078$var$bNot = "\u2AED";
var $538971b5b904f078$var$backcong = "\u224C";
var $538971b5b904f078$var$backepsilon = "\u03F6";
var $538971b5b904f078$var$backprime = "\u2035";
var $538971b5b904f078$var$backsim = "\u223D";
var $538971b5b904f078$var$backsimeq = "\u22CD";
var $538971b5b904f078$var$barvee = "\u22BD";
var $538971b5b904f078$var$barwed = "\u2305";
var $538971b5b904f078$var$barwedge = "\u2305";
var $538971b5b904f078$var$bbrk = "\u23B5";
var $538971b5b904f078$var$bbrktbrk = "\u23B6";
var $538971b5b904f078$var$bcong = "\u224C";
var $538971b5b904f078$var$bcy = "\u0431";
var $538971b5b904f078$var$bdquo$1 = "\u201E";
var $538971b5b904f078$var$becaus = "\u2235";
var $538971b5b904f078$var$because = "\u2235";
var $538971b5b904f078$var$bemptyv = "\u29B0";
var $538971b5b904f078$var$bepsi = "\u03F6";
var $538971b5b904f078$var$bernou = "\u212C";
var $538971b5b904f078$var$beta$1 = "\u03B2";
var $538971b5b904f078$var$beth = "\u2136";
var $538971b5b904f078$var$between = "\u226C";
var $538971b5b904f078$var$bfr = "\uD835\uDD1F";
var $538971b5b904f078$var$bigcap = "\u22C2";
var $538971b5b904f078$var$bigcirc = "\u25EF";
var $538971b5b904f078$var$bigcup = "\u22C3";
var $538971b5b904f078$var$bigodot = "\u2A00";
var $538971b5b904f078$var$bigoplus = "\u2A01";
var $538971b5b904f078$var$bigotimes = "\u2A02";
var $538971b5b904f078$var$bigsqcup = "\u2A06";
var $538971b5b904f078$var$bigstar = "\u2605";
var $538971b5b904f078$var$bigtriangledown = "\u25BD";
var $538971b5b904f078$var$bigtriangleup = "\u25B3";
var $538971b5b904f078$var$biguplus = "\u2A04";
var $538971b5b904f078$var$bigvee = "\u22C1";
var $538971b5b904f078$var$bigwedge = "\u22C0";
var $538971b5b904f078$var$bkarow = "\u290D";
var $538971b5b904f078$var$blacklozenge = "\u29EB";
var $538971b5b904f078$var$blacksquare = "\u25AA";
var $538971b5b904f078$var$blacktriangle = "\u25B4";
var $538971b5b904f078$var$blacktriangledown = "\u25BE";
var $538971b5b904f078$var$blacktriangleleft = "\u25C2";
var $538971b5b904f078$var$blacktriangleright = "\u25B8";
var $538971b5b904f078$var$blank = "\u2423";
var $538971b5b904f078$var$blk12 = "\u2592";
var $538971b5b904f078$var$blk14 = "\u2591";
var $538971b5b904f078$var$blk34 = "\u2593";
var $538971b5b904f078$var$block = "\u2588";
var $538971b5b904f078$var$bne = "=\u20E5";
var $538971b5b904f078$var$bnequiv = "\u2261\u20E5";
var $538971b5b904f078$var$bnot = "\u2310";
var $538971b5b904f078$var$bopf = "\uD835\uDD53";
var $538971b5b904f078$var$bot = "\u22A5";
var $538971b5b904f078$var$bottom = "\u22A5";
var $538971b5b904f078$var$bowtie = "\u22C8";
var $538971b5b904f078$var$boxDL = "\u2557";
var $538971b5b904f078$var$boxDR = "\u2554";
var $538971b5b904f078$var$boxDl = "\u2556";
var $538971b5b904f078$var$boxDr = "\u2553";
var $538971b5b904f078$var$boxH = "\u2550";
var $538971b5b904f078$var$boxHD = "\u2566";
var $538971b5b904f078$var$boxHU = "\u2569";
var $538971b5b904f078$var$boxHd = "\u2564";
var $538971b5b904f078$var$boxHu = "\u2567";
var $538971b5b904f078$var$boxUL = "\u255D";
var $538971b5b904f078$var$boxUR = "\u255A";
var $538971b5b904f078$var$boxUl = "\u255C";
var $538971b5b904f078$var$boxUr = "\u2559";
var $538971b5b904f078$var$boxV = "\u2551";
var $538971b5b904f078$var$boxVH = "\u256C";
var $538971b5b904f078$var$boxVL = "\u2563";
var $538971b5b904f078$var$boxVR = "\u2560";
var $538971b5b904f078$var$boxVh = "\u256B";
var $538971b5b904f078$var$boxVl = "\u2562";
var $538971b5b904f078$var$boxVr = "\u255F";
var $538971b5b904f078$var$boxbox = "\u29C9";
var $538971b5b904f078$var$boxdL = "\u2555";
var $538971b5b904f078$var$boxdR = "\u2552";
var $538971b5b904f078$var$boxdl = "\u2510";
var $538971b5b904f078$var$boxdr = "\u250C";
var $538971b5b904f078$var$boxh = "\u2500";
var $538971b5b904f078$var$boxhD = "\u2565";
var $538971b5b904f078$var$boxhU = "\u2568";
var $538971b5b904f078$var$boxhd = "\u252C";
var $538971b5b904f078$var$boxhu = "\u2534";
var $538971b5b904f078$var$boxminus = "\u229F";
var $538971b5b904f078$var$boxplus = "\u229E";
var $538971b5b904f078$var$boxtimes = "\u22A0";
var $538971b5b904f078$var$boxuL = "\u255B";
var $538971b5b904f078$var$boxuR = "\u2558";
var $538971b5b904f078$var$boxul = "\u2518";
var $538971b5b904f078$var$boxur = "\u2514";
var $538971b5b904f078$var$boxv = "\u2502";
var $538971b5b904f078$var$boxvH = "\u256A";
var $538971b5b904f078$var$boxvL = "\u2561";
var $538971b5b904f078$var$boxvR = "\u255E";
var $538971b5b904f078$var$boxvh = "\u253C";
var $538971b5b904f078$var$boxvl = "\u2524";
var $538971b5b904f078$var$boxvr = "\u251C";
var $538971b5b904f078$var$bprime = "\u2035";
var $538971b5b904f078$var$breve = "\u02D8";
var $538971b5b904f078$var$brvba = "\xa6";
var $538971b5b904f078$var$brvbar$1 = "\xa6";
var $538971b5b904f078$var$bscr = "\uD835\uDCB7";
var $538971b5b904f078$var$bsemi = "\u204F";
var $538971b5b904f078$var$bsim = "\u223D";
var $538971b5b904f078$var$bsime = "\u22CD";
var $538971b5b904f078$var$bsol = "\\";
var $538971b5b904f078$var$bsolb = "\u29C5";
var $538971b5b904f078$var$bsolhsub = "\u27C8";
var $538971b5b904f078$var$bull$1 = "\u2022";
var $538971b5b904f078$var$bullet = "\u2022";
var $538971b5b904f078$var$bump = "\u224E";
var $538971b5b904f078$var$bumpE = "\u2AAE";
var $538971b5b904f078$var$bumpe = "\u224F";
var $538971b5b904f078$var$bumpeq = "\u224F";
var $538971b5b904f078$var$cacute = "\u0107";
var $538971b5b904f078$var$cap$2 = "\u2229";
var $538971b5b904f078$var$capand = "\u2A44";
var $538971b5b904f078$var$capbrcup = "\u2A49";
var $538971b5b904f078$var$capcap = "\u2A4B";
var $538971b5b904f078$var$capcup = "\u2A47";
var $538971b5b904f078$var$capdot = "\u2A40";
var $538971b5b904f078$var$caps = "\u2229\uFE00";
var $538971b5b904f078$var$caret = "\u2041";
var $538971b5b904f078$var$caron = "\u02C7";
var $538971b5b904f078$var$ccaps = "\u2A4D";
var $538971b5b904f078$var$ccaron = "\u010D";
var $538971b5b904f078$var$ccedi = "\xe7";
var $538971b5b904f078$var$ccedil$1 = "\xe7";
var $538971b5b904f078$var$ccirc = "\u0109";
var $538971b5b904f078$var$ccups = "\u2A4C";
var $538971b5b904f078$var$ccupssm = "\u2A50";
var $538971b5b904f078$var$cdot = "\u010B";
var $538971b5b904f078$var$cedi = "\xb8";
var $538971b5b904f078$var$cedil$1 = "\xb8";
var $538971b5b904f078$var$cemptyv = "\u29B2";
var $538971b5b904f078$var$cen = "\xa2";
var $538971b5b904f078$var$cent$1 = "\xa2";
var $538971b5b904f078$var$centerdot = "\xb7";
var $538971b5b904f078$var$cfr = "\uD835\uDD20";
var $538971b5b904f078$var$chcy = "\u0447";
var $538971b5b904f078$var$check = "\u2713";
var $538971b5b904f078$var$checkmark = "\u2713";
var $538971b5b904f078$var$chi$1 = "\u03C7";
var $538971b5b904f078$var$cir = "\u25CB";
var $538971b5b904f078$var$cirE = "\u29C3";
var $538971b5b904f078$var$circ$1 = "\u02C6";
var $538971b5b904f078$var$circeq = "\u2257";
var $538971b5b904f078$var$circlearrowleft = "\u21BA";
var $538971b5b904f078$var$circlearrowright = "\u21BB";
var $538971b5b904f078$var$circledR = "\xae";
var $538971b5b904f078$var$circledS = "\u24C8";
var $538971b5b904f078$var$circledast = "\u229B";
var $538971b5b904f078$var$circledcirc = "\u229A";
var $538971b5b904f078$var$circleddash = "\u229D";
var $538971b5b904f078$var$cire = "\u2257";
var $538971b5b904f078$var$cirfnint = "\u2A10";
var $538971b5b904f078$var$cirmid = "\u2AEF";
var $538971b5b904f078$var$cirscir = "\u29C2";
var $538971b5b904f078$var$clubs$1 = "\u2663";
var $538971b5b904f078$var$clubsuit = "\u2663";
var $538971b5b904f078$var$colon$3 = ":";
var $538971b5b904f078$var$colone = "\u2254";
var $538971b5b904f078$var$coloneq = "\u2254";
var $538971b5b904f078$var$comma$2 = ",";
var $538971b5b904f078$var$commat = "@";
var $538971b5b904f078$var$comp = "\u2201";
var $538971b5b904f078$var$compfn = "\u2218";
var $538971b5b904f078$var$complement = "\u2201";
var $538971b5b904f078$var$complexes = "\u2102";
var $538971b5b904f078$var$cong$1 = "\u2245";
var $538971b5b904f078$var$congdot = "\u2A6D";
var $538971b5b904f078$var$conint = "\u222E";
var $538971b5b904f078$var$copf = "\uD835\uDD54";
var $538971b5b904f078$var$coprod = "\u2210";
var $538971b5b904f078$var$cop = "\xa9";
var $538971b5b904f078$var$copy$1 = "\xa9";
var $538971b5b904f078$var$copysr = "\u2117";
var $538971b5b904f078$var$crarr$1 = "\u21B5";
var $538971b5b904f078$var$cross = "\u2717";
var $538971b5b904f078$var$cscr = "\uD835\uDCB8";
var $538971b5b904f078$var$csub = "\u2ACF";
var $538971b5b904f078$var$csube = "\u2AD1";
var $538971b5b904f078$var$csup = "\u2AD0";
var $538971b5b904f078$var$csupe = "\u2AD2";
var $538971b5b904f078$var$ctdot = "\u22EF";
var $538971b5b904f078$var$cudarrl = "\u2938";
var $538971b5b904f078$var$cudarrr = "\u2935";
var $538971b5b904f078$var$cuepr = "\u22DE";
var $538971b5b904f078$var$cuesc = "\u22DF";
var $538971b5b904f078$var$cularr = "\u21B6";
var $538971b5b904f078$var$cularrp = "\u293D";
var $538971b5b904f078$var$cup$1 = "\u222A";
var $538971b5b904f078$var$cupbrcap = "\u2A48";
var $538971b5b904f078$var$cupcap = "\u2A46";
var $538971b5b904f078$var$cupcup = "\u2A4A";
var $538971b5b904f078$var$cupdot = "\u228D";
var $538971b5b904f078$var$cupor = "\u2A45";
var $538971b5b904f078$var$cups = "\u222A\uFE00";
var $538971b5b904f078$var$curarr = "\u21B7";
var $538971b5b904f078$var$curarrm = "\u293C";
var $538971b5b904f078$var$curlyeqprec = "\u22DE";
var $538971b5b904f078$var$curlyeqsucc = "\u22DF";
var $538971b5b904f078$var$curlyvee = "\u22CE";
var $538971b5b904f078$var$curlywedge = "\u22CF";
var $538971b5b904f078$var$curre = "\xa4";
var $538971b5b904f078$var$curren$1 = "\xa4";
var $538971b5b904f078$var$curvearrowleft = "\u21B6";
var $538971b5b904f078$var$curvearrowright = "\u21B7";
var $538971b5b904f078$var$cuvee = "\u22CE";
var $538971b5b904f078$var$cuwed = "\u22CF";
var $538971b5b904f078$var$cwconint = "\u2232";
var $538971b5b904f078$var$cwint = "\u2231";
var $538971b5b904f078$var$cylcty = "\u232D";
var $538971b5b904f078$var$dArr$1 = "\u21D3";
var $538971b5b904f078$var$dHar = "\u2965";
var $538971b5b904f078$var$dagger$1 = "\u2020";
var $538971b5b904f078$var$daleth = "\u2138";
var $538971b5b904f078$var$darr$1 = "\u2193";
var $538971b5b904f078$var$dash$8 = "\u2010";
var $538971b5b904f078$var$dashv = "\u22A3";
var $538971b5b904f078$var$dbkarow = "\u290F";
var $538971b5b904f078$var$dblac = "\u02DD";
var $538971b5b904f078$var$dcaron = "\u010F";
var $538971b5b904f078$var$dcy = "\u0434";
var $538971b5b904f078$var$dd$1 = "\u2146";
var $538971b5b904f078$var$ddagger = "\u2021";
var $538971b5b904f078$var$ddarr = "\u21CA";
var $538971b5b904f078$var$ddotseq = "\u2A77";
var $538971b5b904f078$var$de = "\xb0";
var $538971b5b904f078$var$deg$1 = "\xb0";
var $538971b5b904f078$var$delta$1 = "\u03B4";
var $538971b5b904f078$var$demptyv = "\u29B1";
var $538971b5b904f078$var$dfisht = "\u297F";
var $538971b5b904f078$var$dfr = "\uD835\uDD21";
var $538971b5b904f078$var$dharl = "\u21C3";
var $538971b5b904f078$var$dharr = "\u21C2";
var $538971b5b904f078$var$diam = "\u22C4";
var $538971b5b904f078$var$diamond = "\u22C4";
var $538971b5b904f078$var$diamondsuit = "\u2666";
var $538971b5b904f078$var$diams$1 = "\u2666";
var $538971b5b904f078$var$die = "\xa8";
var $538971b5b904f078$var$digamma = "\u03DD";
var $538971b5b904f078$var$disin = "\u22F2";
var $538971b5b904f078$var$div = "\xf7";
var $538971b5b904f078$var$divid = "\xf7";
var $538971b5b904f078$var$divide$1 = "\xf7";
var $538971b5b904f078$var$divideontimes = "\u22C7";
var $538971b5b904f078$var$divonx = "\u22C7";
var $538971b5b904f078$var$djcy = "\u0452";
var $538971b5b904f078$var$dlcorn = "\u231E";
var $538971b5b904f078$var$dlcrop = "\u230D";
var $538971b5b904f078$var$dollar = "$";
var $538971b5b904f078$var$dopf = "\uD835\uDD55";
var $538971b5b904f078$var$dot$4 = "\u02D9";
var $538971b5b904f078$var$doteq = "\u2250";
var $538971b5b904f078$var$doteqdot = "\u2251";
var $538971b5b904f078$var$dotminus = "\u2238";
var $538971b5b904f078$var$dotplus = "\u2214";
var $538971b5b904f078$var$dotsquare = "\u22A1";
var $538971b5b904f078$var$doublebarwedge = "\u2306";
var $538971b5b904f078$var$downarrow = "\u2193";
var $538971b5b904f078$var$downdownarrows = "\u21CA";
var $538971b5b904f078$var$downharpoonleft = "\u21C3";
var $538971b5b904f078$var$downharpoonright = "\u21C2";
var $538971b5b904f078$var$drbkarow = "\u2910";
var $538971b5b904f078$var$drcorn = "\u231F";
var $538971b5b904f078$var$drcrop = "\u230C";
var $538971b5b904f078$var$dscr = "\uD835\uDCB9";
var $538971b5b904f078$var$dscy = "\u0455";
var $538971b5b904f078$var$dsol = "\u29F6";
var $538971b5b904f078$var$dstrok = "\u0111";
var $538971b5b904f078$var$dtdot = "\u22F1";
var $538971b5b904f078$var$dtri = "\u25BF";
var $538971b5b904f078$var$dtrif = "\u25BE";
var $538971b5b904f078$var$duarr = "\u21F5";
var $538971b5b904f078$var$duhar = "\u296F";
var $538971b5b904f078$var$dwangle = "\u29A6";
var $538971b5b904f078$var$dzcy = "\u045F";
var $538971b5b904f078$var$dzigrarr = "\u27FF";
var $538971b5b904f078$var$eDDot = "\u2A77";
var $538971b5b904f078$var$eDot = "\u2251";
var $538971b5b904f078$var$eacut = "\xe9";
var $538971b5b904f078$var$eacute$1 = "\xe9";
var $538971b5b904f078$var$easter = "\u2A6E";
var $538971b5b904f078$var$ecaron = "\u011B";
var $538971b5b904f078$var$ecir = "\xea";
var $538971b5b904f078$var$ecirc$1 = "\xea";
var $538971b5b904f078$var$ecolon = "\u2255";
var $538971b5b904f078$var$ecy = "\u044D";
var $538971b5b904f078$var$edot = "\u0117";
var $538971b5b904f078$var$ee = "\u2147";
var $538971b5b904f078$var$efDot = "\u2252";
var $538971b5b904f078$var$efr = "\uD835\uDD22";
var $538971b5b904f078$var$eg = "\u2A9A";
var $538971b5b904f078$var$egrav = "\xe8";
var $538971b5b904f078$var$egrave$1 = "\xe8";
var $538971b5b904f078$var$egs = "\u2A96";
var $538971b5b904f078$var$egsdot = "\u2A98";
var $538971b5b904f078$var$el = "\u2A99";
var $538971b5b904f078$var$elinters = "\u23E7";
var $538971b5b904f078$var$ell = "\u2113";
var $538971b5b904f078$var$els = "\u2A95";
var $538971b5b904f078$var$elsdot = "\u2A97";
var $538971b5b904f078$var$emacr = "\u0113";
var $538971b5b904f078$var$empty$3 = "\u2205";
var $538971b5b904f078$var$emptyset = "\u2205";
var $538971b5b904f078$var$emptyv = "\u2205";
var $538971b5b904f078$var$emsp13 = "\u2004";
var $538971b5b904f078$var$emsp14 = "\u2005";
var $538971b5b904f078$var$emsp$1 = "\u2003";
var $538971b5b904f078$var$eng = "\u014B";
var $538971b5b904f078$var$ensp$1 = "\u2002";
var $538971b5b904f078$var$eogon = "\u0119";
var $538971b5b904f078$var$eopf = "\uD835\uDD56";
var $538971b5b904f078$var$epar = "\u22D5";
var $538971b5b904f078$var$eparsl = "\u29E3";
var $538971b5b904f078$var$eplus = "\u2A71";
var $538971b5b904f078$var$epsi = "\u03B5";
var $538971b5b904f078$var$epsilon$1 = "\u03B5";
var $538971b5b904f078$var$epsiv = "\u03F5";
var $538971b5b904f078$var$eqcirc = "\u2256";
var $538971b5b904f078$var$eqcolon = "\u2255";
var $538971b5b904f078$var$eqsim = "\u2242";
var $538971b5b904f078$var$eqslantgtr = "\u2A96";
var $538971b5b904f078$var$eqslantless = "\u2A95";
var $538971b5b904f078$var$equals = "=";
var $538971b5b904f078$var$equest = "\u225F";
var $538971b5b904f078$var$equiv$1 = "\u2261";
var $538971b5b904f078$var$equivDD = "\u2A78";
var $538971b5b904f078$var$eqvparsl = "\u29E5";
var $538971b5b904f078$var$erDot = "\u2253";
var $538971b5b904f078$var$erarr = "\u2971";
var $538971b5b904f078$var$escr = "\u212F";
var $538971b5b904f078$var$esdot = "\u2250";
var $538971b5b904f078$var$esim = "\u2242";
var $538971b5b904f078$var$eta$1 = "\u03B7";
var $538971b5b904f078$var$et = "\xf0";
var $538971b5b904f078$var$eth$1 = "\xf0";
var $538971b5b904f078$var$eum = "\xeb";
var $538971b5b904f078$var$euml$1 = "\xeb";
var $538971b5b904f078$var$euro$1 = "\u20AC";
var $538971b5b904f078$var$excl = "!";
var $538971b5b904f078$var$exist$1 = "\u2203";
var $538971b5b904f078$var$expectation = "\u2130";
var $538971b5b904f078$var$exponentiale = "\u2147";
var $538971b5b904f078$var$fallingdotseq = "\u2252";
var $538971b5b904f078$var$fcy = "\u0444";
var $538971b5b904f078$var$female = "\u2640";
var $538971b5b904f078$var$ffilig = "\uFB03";
var $538971b5b904f078$var$fflig = "\uFB00";
var $538971b5b904f078$var$ffllig = "\uFB04";
var $538971b5b904f078$var$ffr = "\uD835\uDD23";
var $538971b5b904f078$var$filig = "\uFB01";
var $538971b5b904f078$var$fjlig = "fj";
var $538971b5b904f078$var$flat = "\u266D";
var $538971b5b904f078$var$fllig = "\uFB02";
var $538971b5b904f078$var$fltns = "\u25B1";
var $538971b5b904f078$var$fnof$1 = "\u0192";
var $538971b5b904f078$var$fopf = "\uD835\uDD57";
var $538971b5b904f078$var$forall$1 = "\u2200";
var $538971b5b904f078$var$fork = "\u22D4";
var $538971b5b904f078$var$forkv = "\u2AD9";
var $538971b5b904f078$var$fpartint = "\u2A0D";
var $538971b5b904f078$var$frac1 = "\xbc";
var $538971b5b904f078$var$frac12$1 = "\xbd";
var $538971b5b904f078$var$frac13 = "\u2153";
var $538971b5b904f078$var$frac14$1 = "\xbc";
var $538971b5b904f078$var$frac15 = "\u2155";
var $538971b5b904f078$var$frac16 = "\u2159";
var $538971b5b904f078$var$frac18 = "\u215B";
var $538971b5b904f078$var$frac23 = "\u2154";
var $538971b5b904f078$var$frac25 = "\u2156";
var $538971b5b904f078$var$frac3 = "\xbe";
var $538971b5b904f078$var$frac34$1 = "\xbe";
var $538971b5b904f078$var$frac35 = "\u2157";
var $538971b5b904f078$var$frac38 = "\u215C";
var $538971b5b904f078$var$frac45 = "\u2158";
var $538971b5b904f078$var$frac56 = "\u215A";
var $538971b5b904f078$var$frac58 = "\u215D";
var $538971b5b904f078$var$frac78 = "\u215E";
var $538971b5b904f078$var$frasl$1 = "\u2044";
var $538971b5b904f078$var$frown = "\u2322";
var $538971b5b904f078$var$fscr = "\uD835\uDCBB";
var $538971b5b904f078$var$gE = "\u2267";
var $538971b5b904f078$var$gEl = "\u2A8C";
var $538971b5b904f078$var$gacute = "\u01F5";
var $538971b5b904f078$var$gamma$1 = "\u03B3";
var $538971b5b904f078$var$gammad = "\u03DD";
var $538971b5b904f078$var$gap = "\u2A86";
var $538971b5b904f078$var$gbreve = "\u011F";
var $538971b5b904f078$var$gcirc = "\u011D";
var $538971b5b904f078$var$gcy = "\u0433";
var $538971b5b904f078$var$gdot = "\u0121";
var $538971b5b904f078$var$ge$1 = "\u2265";
var $538971b5b904f078$var$gel = "\u22DB";
var $538971b5b904f078$var$geq = "\u2265";
var $538971b5b904f078$var$geqq = "\u2267";
var $538971b5b904f078$var$geqslant = "\u2A7E";
var $538971b5b904f078$var$ges = "\u2A7E";
var $538971b5b904f078$var$gescc = "\u2AA9";
var $538971b5b904f078$var$gesdot = "\u2A80";
var $538971b5b904f078$var$gesdoto = "\u2A82";
var $538971b5b904f078$var$gesdotol = "\u2A84";
var $538971b5b904f078$var$gesl = "\u22DB\uFE00";
var $538971b5b904f078$var$gesles = "\u2A94";
var $538971b5b904f078$var$gfr = "\uD835\uDD24";
var $538971b5b904f078$var$gg = "\u226B";
var $538971b5b904f078$var$ggg = "\u22D9";
var $538971b5b904f078$var$gimel = "\u2137";
var $538971b5b904f078$var$gjcy = "\u0453";
var $538971b5b904f078$var$gl = "\u2277";
var $538971b5b904f078$var$glE = "\u2A92";
var $538971b5b904f078$var$gla = "\u2AA5";
var $538971b5b904f078$var$glj = "\u2AA4";
var $538971b5b904f078$var$gnE = "\u2269";
var $538971b5b904f078$var$gnap = "\u2A8A";
var $538971b5b904f078$var$gnapprox = "\u2A8A";
var $538971b5b904f078$var$gne = "\u2A88";
var $538971b5b904f078$var$gneq = "\u2A88";
var $538971b5b904f078$var$gneqq = "\u2269";
var $538971b5b904f078$var$gnsim = "\u22E7";
var $538971b5b904f078$var$gopf = "\uD835\uDD58";
var $538971b5b904f078$var$grave = "`";
var $538971b5b904f078$var$gscr = "\u210A";
var $538971b5b904f078$var$gsim = "\u2273";
var $538971b5b904f078$var$gsime = "\u2A8E";
var $538971b5b904f078$var$gsiml = "\u2A90";
var $538971b5b904f078$var$g = ">";
var $538971b5b904f078$var$gt$1 = ">";
var $538971b5b904f078$var$gtcc = "\u2AA7";
var $538971b5b904f078$var$gtcir = "\u2A7A";
var $538971b5b904f078$var$gtdot = "\u22D7";
var $538971b5b904f078$var$gtlPar = "\u2995";
var $538971b5b904f078$var$gtquest = "\u2A7C";
var $538971b5b904f078$var$gtrapprox = "\u2A86";
var $538971b5b904f078$var$gtrarr = "\u2978";
var $538971b5b904f078$var$gtrdot = "\u22D7";
var $538971b5b904f078$var$gtreqless = "\u22DB";
var $538971b5b904f078$var$gtreqqless = "\u2A8C";
var $538971b5b904f078$var$gtrless = "\u2277";
var $538971b5b904f078$var$gtrsim = "\u2273";
var $538971b5b904f078$var$gvertneqq = "\u2269\uFE00";
var $538971b5b904f078$var$gvnE = "\u2269\uFE00";
var $538971b5b904f078$var$hArr$1 = "\u21D4";
var $538971b5b904f078$var$hairsp = "\u200A";
var $538971b5b904f078$var$half = "\xbd";
var $538971b5b904f078$var$hamilt = "\u210B";
var $538971b5b904f078$var$hardcy = "\u044A";
var $538971b5b904f078$var$harr$1 = "\u2194";
var $538971b5b904f078$var$harrcir = "\u2948";
var $538971b5b904f078$var$harrw = "\u21AD";
var $538971b5b904f078$var$hbar = "\u210F";
var $538971b5b904f078$var$hcirc = "\u0125";
var $538971b5b904f078$var$hearts$1 = "\u2665";
var $538971b5b904f078$var$heartsuit = "\u2665";
var $538971b5b904f078$var$hellip$1 = "\u2026";
var $538971b5b904f078$var$hercon = "\u22B9";
var $538971b5b904f078$var$hfr = "\uD835\uDD25";
var $538971b5b904f078$var$hksearow = "\u2925";
var $538971b5b904f078$var$hkswarow = "\u2926";
var $538971b5b904f078$var$hoarr = "\u21FF";
var $538971b5b904f078$var$homtht = "\u223B";
var $538971b5b904f078$var$hookleftarrow = "\u21A9";
var $538971b5b904f078$var$hookrightarrow = "\u21AA";
var $538971b5b904f078$var$hopf = "\uD835\uDD59";
var $538971b5b904f078$var$horbar = "\u2015";
var $538971b5b904f078$var$hscr = "\uD835\uDCBD";
var $538971b5b904f078$var$hslash = "\u210F";
var $538971b5b904f078$var$hstrok = "\u0127";
var $538971b5b904f078$var$hybull = "\u2043";
var $538971b5b904f078$var$hyphen = "\u2010";
var $538971b5b904f078$var$iacut = "\xed";
var $538971b5b904f078$var$iacute$1 = "\xed";
var $538971b5b904f078$var$ic = "\u2063";
var $538971b5b904f078$var$icir = "\xee";
var $538971b5b904f078$var$icirc$1 = "\xee";
var $538971b5b904f078$var$icy = "\u0438";
var $538971b5b904f078$var$iecy = "\u0435";
var $538971b5b904f078$var$iexc = "\xa1";
var $538971b5b904f078$var$iexcl$1 = "\xa1";
var $538971b5b904f078$var$iff = "\u21D4";
var $538971b5b904f078$var$ifr = "\uD835\uDD26";
var $538971b5b904f078$var$igrav = "\xec";
var $538971b5b904f078$var$igrave$1 = "\xec";
var $538971b5b904f078$var$ii = "\u2148";
var $538971b5b904f078$var$iiiint = "\u2A0C";
var $538971b5b904f078$var$iiint = "\u222D";
var $538971b5b904f078$var$iinfin = "\u29DC";
var $538971b5b904f078$var$iiota = "\u2129";
var $538971b5b904f078$var$ijlig = "\u0133";
var $538971b5b904f078$var$imacr = "\u012B";
var $538971b5b904f078$var$image$3 = "\u2111";
var $538971b5b904f078$var$imagline = "\u2110";
var $538971b5b904f078$var$imagpart = "\u2111";
var $538971b5b904f078$var$imath = "\u0131";
var $538971b5b904f078$var$imof = "\u22B7";
var $538971b5b904f078$var$imped = "\u01B5";
var $538971b5b904f078$var$incare = "\u2105";
var $538971b5b904f078$var$infin$1 = "\u221E";
var $538971b5b904f078$var$infintie = "\u29DD";
var $538971b5b904f078$var$inodot = "\u0131";
var $538971b5b904f078$var$int$1 = "\u222B";
var $538971b5b904f078$var$intcal = "\u22BA";
var $538971b5b904f078$var$integers = "\u2124";
var $538971b5b904f078$var$intercal = "\u22BA";
var $538971b5b904f078$var$intlarhk = "\u2A17";
var $538971b5b904f078$var$intprod = "\u2A3C";
var $538971b5b904f078$var$iocy = "\u0451";
var $538971b5b904f078$var$iogon = "\u012F";
var $538971b5b904f078$var$iopf = "\uD835\uDD5A";
var $538971b5b904f078$var$iota$1 = "\u03B9";
var $538971b5b904f078$var$iprod = "\u2A3C";
var $538971b5b904f078$var$iques = "\xbf";
var $538971b5b904f078$var$iquest$1 = "\xbf";
var $538971b5b904f078$var$iscr = "\uD835\uDCBE";
var $538971b5b904f078$var$isin$1 = "\u2208";
var $538971b5b904f078$var$isinE = "\u22F9";
var $538971b5b904f078$var$isindot = "\u22F5";
var $538971b5b904f078$var$isins = "\u22F4";
var $538971b5b904f078$var$isinsv = "\u22F3";
var $538971b5b904f078$var$isinv = "\u2208";
var $538971b5b904f078$var$it = "\u2062";
var $538971b5b904f078$var$itilde = "\u0129";
var $538971b5b904f078$var$iukcy = "\u0456";
var $538971b5b904f078$var$ium = "\xef";
var $538971b5b904f078$var$iuml$1 = "\xef";
var $538971b5b904f078$var$jcirc = "\u0135";
var $538971b5b904f078$var$jcy = "\u0439";
var $538971b5b904f078$var$jfr = "\uD835\uDD27";
var $538971b5b904f078$var$jmath = "\u0237";
var $538971b5b904f078$var$jopf = "\uD835\uDD5B";
var $538971b5b904f078$var$jscr = "\uD835\uDCBF";
var $538971b5b904f078$var$jsercy = "\u0458";
var $538971b5b904f078$var$jukcy = "\u0454";
var $538971b5b904f078$var$kappa$1 = "\u03BA";
var $538971b5b904f078$var$kappav = "\u03F0";
var $538971b5b904f078$var$kcedil = "\u0137";
var $538971b5b904f078$var$kcy = "\u043A";
var $538971b5b904f078$var$kfr = "\uD835\uDD28";
var $538971b5b904f078$var$kgreen = "\u0138";
var $538971b5b904f078$var$khcy = "\u0445";
var $538971b5b904f078$var$kjcy = "\u045C";
var $538971b5b904f078$var$kopf = "\uD835\uDD5C";
var $538971b5b904f078$var$kscr = "\uD835\uDCC0";
var $538971b5b904f078$var$lAarr = "\u21DA";
var $538971b5b904f078$var$lArr$1 = "\u21D0";
var $538971b5b904f078$var$lAtail = "\u291B";
var $538971b5b904f078$var$lBarr = "\u290E";
var $538971b5b904f078$var$lE = "\u2266";
var $538971b5b904f078$var$lEg = "\u2A8B";
var $538971b5b904f078$var$lHar = "\u2962";
var $538971b5b904f078$var$lacute = "\u013A";
var $538971b5b904f078$var$laemptyv = "\u29B4";
var $538971b5b904f078$var$lagran = "\u2112";
var $538971b5b904f078$var$lambda$1 = "\u03BB";
var $538971b5b904f078$var$lang$1 = "\u27E8";
var $538971b5b904f078$var$langd = "\u2991";
var $538971b5b904f078$var$langle = "\u27E8";
var $538971b5b904f078$var$lap = "\u2A85";
var $538971b5b904f078$var$laqu = "\xab";
var $538971b5b904f078$var$laquo$1 = "\xab";
var $538971b5b904f078$var$larr$1 = "\u2190";
var $538971b5b904f078$var$larrb = "\u21E4";
var $538971b5b904f078$var$larrbfs = "\u291F";
var $538971b5b904f078$var$larrfs = "\u291D";
var $538971b5b904f078$var$larrhk = "\u21A9";
var $538971b5b904f078$var$larrlp = "\u21AB";
var $538971b5b904f078$var$larrpl = "\u2939";
var $538971b5b904f078$var$larrsim = "\u2973";
var $538971b5b904f078$var$larrtl = "\u21A2";
var $538971b5b904f078$var$lat = "\u2AAB";
var $538971b5b904f078$var$latail = "\u2919";
var $538971b5b904f078$var$late = "\u2AAD";
var $538971b5b904f078$var$lates = "\u2AAD\uFE00";
var $538971b5b904f078$var$lbarr = "\u290C";
var $538971b5b904f078$var$lbbrk = "\u2772";
var $538971b5b904f078$var$lbrace = "{";
var $538971b5b904f078$var$lbrack = "[";
var $538971b5b904f078$var$lbrke = "\u298B";
var $538971b5b904f078$var$lbrksld = "\u298F";
var $538971b5b904f078$var$lbrkslu = "\u298D";
var $538971b5b904f078$var$lcaron = "\u013E";
var $538971b5b904f078$var$lcedil = "\u013C";
var $538971b5b904f078$var$lceil$1 = "\u2308";
var $538971b5b904f078$var$lcub = "{";
var $538971b5b904f078$var$lcy = "\u043B";
var $538971b5b904f078$var$ldca = "\u2936";
var $538971b5b904f078$var$ldquo$1 = "\u201C";
var $538971b5b904f078$var$ldquor = "\u201E";
var $538971b5b904f078$var$ldrdhar = "\u2967";
var $538971b5b904f078$var$ldrushar = "\u294B";
var $538971b5b904f078$var$ldsh = "\u21B2";
var $538971b5b904f078$var$le$1 = "\u2264";
var $538971b5b904f078$var$leftarrow = "\u2190";
var $538971b5b904f078$var$leftarrowtail = "\u21A2";
var $538971b5b904f078$var$leftharpoondown = "\u21BD";
var $538971b5b904f078$var$leftharpoonup = "\u21BC";
var $538971b5b904f078$var$leftleftarrows = "\u21C7";
var $538971b5b904f078$var$leftrightarrow = "\u2194";
var $538971b5b904f078$var$leftrightarrows = "\u21C6";
var $538971b5b904f078$var$leftrightharpoons = "\u21CB";
var $538971b5b904f078$var$leftrightsquigarrow = "\u21AD";
var $538971b5b904f078$var$leftthreetimes = "\u22CB";
var $538971b5b904f078$var$leg = "\u22DA";
var $538971b5b904f078$var$leq = "\u2264";
var $538971b5b904f078$var$leqq = "\u2266";
var $538971b5b904f078$var$leqslant = "\u2A7D";
var $538971b5b904f078$var$les = "\u2A7D";
var $538971b5b904f078$var$lescc = "\u2AA8";
var $538971b5b904f078$var$lesdot = "\u2A7F";
var $538971b5b904f078$var$lesdoto = "\u2A81";
var $538971b5b904f078$var$lesdotor = "\u2A83";
var $538971b5b904f078$var$lesg = "\u22DA\uFE00";
var $538971b5b904f078$var$lesges = "\u2A93";
var $538971b5b904f078$var$lessapprox = "\u2A85";
var $538971b5b904f078$var$lessdot = "\u22D6";
var $538971b5b904f078$var$lesseqgtr = "\u22DA";
var $538971b5b904f078$var$lesseqqgtr = "\u2A8B";
var $538971b5b904f078$var$lessgtr = "\u2276";
var $538971b5b904f078$var$lesssim = "\u2272";
var $538971b5b904f078$var$lfisht = "\u297C";
var $538971b5b904f078$var$lfloor$1 = "\u230A";
var $538971b5b904f078$var$lfr = "\uD835\uDD29";
var $538971b5b904f078$var$lg = "\u2276";
var $538971b5b904f078$var$lgE = "\u2A91";
var $538971b5b904f078$var$lhard = "\u21BD";
var $538971b5b904f078$var$lharu = "\u21BC";
var $538971b5b904f078$var$lharul = "\u296A";
var $538971b5b904f078$var$lhblk = "\u2584";
var $538971b5b904f078$var$ljcy = "\u0459";
var $538971b5b904f078$var$ll = "\u226A";
var $538971b5b904f078$var$llarr = "\u21C7";
var $538971b5b904f078$var$llcorner = "\u231E";
var $538971b5b904f078$var$llhard = "\u296B";
var $538971b5b904f078$var$lltri = "\u25FA";
var $538971b5b904f078$var$lmidot = "\u0140";
var $538971b5b904f078$var$lmoust = "\u23B0";
var $538971b5b904f078$var$lmoustache = "\u23B0";
var $538971b5b904f078$var$lnE = "\u2268";
var $538971b5b904f078$var$lnap = "\u2A89";
var $538971b5b904f078$var$lnapprox = "\u2A89";
var $538971b5b904f078$var$lne = "\u2A87";
var $538971b5b904f078$var$lneq = "\u2A87";
var $538971b5b904f078$var$lneqq = "\u2268";
var $538971b5b904f078$var$lnsim = "\u22E6";
var $538971b5b904f078$var$loang = "\u27EC";
var $538971b5b904f078$var$loarr = "\u21FD";
var $538971b5b904f078$var$lobrk = "\u27E6";
var $538971b5b904f078$var$longleftarrow = "\u27F5";
var $538971b5b904f078$var$longleftrightarrow = "\u27F7";
var $538971b5b904f078$var$longmapsto = "\u27FC";
var $538971b5b904f078$var$longrightarrow = "\u27F6";
var $538971b5b904f078$var$looparrowleft = "\u21AB";
var $538971b5b904f078$var$looparrowright = "\u21AC";
var $538971b5b904f078$var$lopar = "\u2985";
var $538971b5b904f078$var$lopf = "\uD835\uDD5D";
var $538971b5b904f078$var$loplus = "\u2A2D";
var $538971b5b904f078$var$lotimes = "\u2A34";
var $538971b5b904f078$var$lowast$1 = "\u2217";
var $538971b5b904f078$var$lowbar = "_";
var $538971b5b904f078$var$loz$1 = "\u25CA";
var $538971b5b904f078$var$lozenge = "\u25CA";
var $538971b5b904f078$var$lozf = "\u29EB";
var $538971b5b904f078$var$lpar = "(";
var $538971b5b904f078$var$lparlt = "\u2993";
var $538971b5b904f078$var$lrarr = "\u21C6";
var $538971b5b904f078$var$lrcorner = "\u231F";
var $538971b5b904f078$var$lrhar = "\u21CB";
var $538971b5b904f078$var$lrhard = "\u296D";
var $538971b5b904f078$var$lrm$1 = "\u200E";
var $538971b5b904f078$var$lrtri = "\u22BF";
var $538971b5b904f078$var$lsaquo$1 = "\u2039";
var $538971b5b904f078$var$lscr = "\uD835\uDCC1";
var $538971b5b904f078$var$lsh = "\u21B0";
var $538971b5b904f078$var$lsim = "\u2272";
var $538971b5b904f078$var$lsime = "\u2A8D";
var $538971b5b904f078$var$lsimg = "\u2A8F";
var $538971b5b904f078$var$lsqb = "[";
var $538971b5b904f078$var$lsquo$1 = "\u2018";
var $538971b5b904f078$var$lsquor = "\u201A";
var $538971b5b904f078$var$lstrok = "\u0142";
var $538971b5b904f078$var$l = "<";
var $538971b5b904f078$var$lt$1 = "<";
var $538971b5b904f078$var$ltcc = "\u2AA6";
var $538971b5b904f078$var$ltcir = "\u2A79";
var $538971b5b904f078$var$ltdot = "\u22D6";
var $538971b5b904f078$var$lthree = "\u22CB";
var $538971b5b904f078$var$ltimes = "\u22C9";
var $538971b5b904f078$var$ltlarr = "\u2976";
var $538971b5b904f078$var$ltquest = "\u2A7B";
var $538971b5b904f078$var$ltrPar = "\u2996";
var $538971b5b904f078$var$ltri = "\u25C3";
var $538971b5b904f078$var$ltrie = "\u22B4";
var $538971b5b904f078$var$ltrif = "\u25C2";
var $538971b5b904f078$var$lurdshar = "\u294A";
var $538971b5b904f078$var$luruhar = "\u2966";
var $538971b5b904f078$var$lvertneqq = "\u2268\uFE00";
var $538971b5b904f078$var$lvnE = "\u2268\uFE00";
var $538971b5b904f078$var$mDDot = "\u223A";
var $538971b5b904f078$var$mac = "\xaf";
var $538971b5b904f078$var$macr$1 = "\xaf";
var $538971b5b904f078$var$male = "\u2642";
var $538971b5b904f078$var$malt = "\u2720";
var $538971b5b904f078$var$maltese = "\u2720";
var $538971b5b904f078$var$map$1 = "\u21A6";
var $538971b5b904f078$var$mapsto = "\u21A6";
var $538971b5b904f078$var$mapstodown = "\u21A7";
var $538971b5b904f078$var$mapstoleft = "\u21A4";
var $538971b5b904f078$var$mapstoup = "\u21A5";
var $538971b5b904f078$var$marker = "\u25AE";
var $538971b5b904f078$var$mcomma = "\u2A29";
var $538971b5b904f078$var$mcy = "\u043C";
var $538971b5b904f078$var$mdash$1 = "\u2014";
var $538971b5b904f078$var$measuredangle = "\u2221";
var $538971b5b904f078$var$mfr = "\uD835\uDD2A";
var $538971b5b904f078$var$mho = "\u2127";
var $538971b5b904f078$var$micr = "\xb5";
var $538971b5b904f078$var$micro$1 = "\xb5";
var $538971b5b904f078$var$mid = "\u2223";
var $538971b5b904f078$var$midast = "*";
var $538971b5b904f078$var$midcir = "\u2AF0";
var $538971b5b904f078$var$middo = "\xb7";
var $538971b5b904f078$var$middot$1 = "\xb7";
var $538971b5b904f078$var$minus$1 = "\u2212";
var $538971b5b904f078$var$minusb = "\u229F";
var $538971b5b904f078$var$minusd = "\u2238";
var $538971b5b904f078$var$minusdu = "\u2A2A";
var $538971b5b904f078$var$mlcp = "\u2ADB";
var $538971b5b904f078$var$mldr = "\u2026";
var $538971b5b904f078$var$mnplus = "\u2213";
var $538971b5b904f078$var$models = "\u22A7";
var $538971b5b904f078$var$mopf = "\uD835\uDD5E";
var $538971b5b904f078$var$mp = "\u2213";
var $538971b5b904f078$var$mscr = "\uD835\uDCC2";
var $538971b5b904f078$var$mstpos = "\u223E";
var $538971b5b904f078$var$mu$1 = "\u03BC";
var $538971b5b904f078$var$multimap = "\u22B8";
var $538971b5b904f078$var$mumap = "\u22B8";
var $538971b5b904f078$var$nGg = "\u22D9\u0338";
var $538971b5b904f078$var$nGt = "\u226B\u20D2";
var $538971b5b904f078$var$nGtv = "\u226B\u0338";
var $538971b5b904f078$var$nLeftarrow = "\u21CD";
var $538971b5b904f078$var$nLeftrightarrow = "\u21CE";
var $538971b5b904f078$var$nLl = "\u22D8\u0338";
var $538971b5b904f078$var$nLt = "\u226A\u20D2";
var $538971b5b904f078$var$nLtv = "\u226A\u0338";
var $538971b5b904f078$var$nRightarrow = "\u21CF";
var $538971b5b904f078$var$nVDash = "\u22AF";
var $538971b5b904f078$var$nVdash = "\u22AE";
var $538971b5b904f078$var$nabla$1 = "\u2207";
var $538971b5b904f078$var$nacute = "\u0144";
var $538971b5b904f078$var$nang = "\u2220\u20D2";
var $538971b5b904f078$var$nap = "\u2249";
var $538971b5b904f078$var$napE = "\u2A70\u0338";
var $538971b5b904f078$var$napid = "\u224B\u0338";
var $538971b5b904f078$var$napos = "\u0149";
var $538971b5b904f078$var$napprox = "\u2249";
var $538971b5b904f078$var$natur = "\u266E";
var $538971b5b904f078$var$natural = "\u266E";
var $538971b5b904f078$var$naturals = "\u2115";
var $538971b5b904f078$var$nbs = "\xa0";
var $538971b5b904f078$var$nbsp$1 = "\xa0";
var $538971b5b904f078$var$nbump = "\u224E\u0338";
var $538971b5b904f078$var$nbumpe = "\u224F\u0338";
var $538971b5b904f078$var$ncap = "\u2A43";
var $538971b5b904f078$var$ncaron = "\u0148";
var $538971b5b904f078$var$ncedil = "\u0146";
var $538971b5b904f078$var$ncong = "\u2247";
var $538971b5b904f078$var$ncongdot = "\u2A6D\u0338";
var $538971b5b904f078$var$ncup = "\u2A42";
var $538971b5b904f078$var$ncy = "\u043D";
var $538971b5b904f078$var$ndash$1 = "\u2013";
var $538971b5b904f078$var$ne$1 = "\u2260";
var $538971b5b904f078$var$neArr = "\u21D7";
var $538971b5b904f078$var$nearhk = "\u2924";
var $538971b5b904f078$var$nearr = "\u2197";
var $538971b5b904f078$var$nearrow = "\u2197";
var $538971b5b904f078$var$nedot = "\u2250\u0338";
var $538971b5b904f078$var$nequiv = "\u2262";
var $538971b5b904f078$var$nesear = "\u2928";
var $538971b5b904f078$var$nesim = "\u2242\u0338";
var $538971b5b904f078$var$nexist = "\u2204";
var $538971b5b904f078$var$nexists = "\u2204";
var $538971b5b904f078$var$nfr = "\uD835\uDD2B";
var $538971b5b904f078$var$ngE = "\u2267\u0338";
var $538971b5b904f078$var$nge = "\u2271";
var $538971b5b904f078$var$ngeq = "\u2271";
var $538971b5b904f078$var$ngeqq = "\u2267\u0338";
var $538971b5b904f078$var$ngeqslant = "\u2A7E\u0338";
var $538971b5b904f078$var$nges = "\u2A7E\u0338";
var $538971b5b904f078$var$ngsim = "\u2275";
var $538971b5b904f078$var$ngt = "\u226F";
var $538971b5b904f078$var$ngtr = "\u226F";
var $538971b5b904f078$var$nhArr = "\u21CE";
var $538971b5b904f078$var$nharr = "\u21AE";
var $538971b5b904f078$var$nhpar = "\u2AF2";
var $538971b5b904f078$var$ni$1 = "\u220B";
var $538971b5b904f078$var$nis = "\u22FC";
var $538971b5b904f078$var$nisd = "\u22FA";
var $538971b5b904f078$var$niv = "\u220B";
var $538971b5b904f078$var$njcy = "\u045A";
var $538971b5b904f078$var$nlArr = "\u21CD";
var $538971b5b904f078$var$nlE = "\u2266\u0338";
var $538971b5b904f078$var$nlarr = "\u219A";
var $538971b5b904f078$var$nldr = "\u2025";
var $538971b5b904f078$var$nle = "\u2270";
var $538971b5b904f078$var$nleftarrow = "\u219A";
var $538971b5b904f078$var$nleftrightarrow = "\u21AE";
var $538971b5b904f078$var$nleq = "\u2270";
var $538971b5b904f078$var$nleqq = "\u2266\u0338";
var $538971b5b904f078$var$nleqslant = "\u2A7D\u0338";
var $538971b5b904f078$var$nles = "\u2A7D\u0338";
var $538971b5b904f078$var$nless = "\u226E";
var $538971b5b904f078$var$nlsim = "\u2274";
var $538971b5b904f078$var$nlt = "\u226E";
var $538971b5b904f078$var$nltri = "\u22EA";
var $538971b5b904f078$var$nltrie = "\u22EC";
var $538971b5b904f078$var$nmid = "\u2224";
var $538971b5b904f078$var$nopf = "\uD835\uDD5F";
var $538971b5b904f078$var$no = "\xac";
var $538971b5b904f078$var$not$1 = "\xac";
var $538971b5b904f078$var$notin$1 = "\u2209";
var $538971b5b904f078$var$notinE = "\u22F9\u0338";
var $538971b5b904f078$var$notindot = "\u22F5\u0338";
var $538971b5b904f078$var$notinva = "\u2209";
var $538971b5b904f078$var$notinvb = "\u22F7";
var $538971b5b904f078$var$notinvc = "\u22F6";
var $538971b5b904f078$var$notni = "\u220C";
var $538971b5b904f078$var$notniva = "\u220C";
var $538971b5b904f078$var$notnivb = "\u22FE";
var $538971b5b904f078$var$notnivc = "\u22FD";
var $538971b5b904f078$var$npar = "\u2226";
var $538971b5b904f078$var$nparallel = "\u2226";
var $538971b5b904f078$var$nparsl = "\u2AFD\u20E5";
var $538971b5b904f078$var$npart = "\u2202\u0338";
var $538971b5b904f078$var$npolint = "\u2A14";
var $538971b5b904f078$var$npr = "\u2280";
var $538971b5b904f078$var$nprcue = "\u22E0";
var $538971b5b904f078$var$npre = "\u2AAF\u0338";
var $538971b5b904f078$var$nprec = "\u2280";
var $538971b5b904f078$var$npreceq = "\u2AAF\u0338";
var $538971b5b904f078$var$nrArr = "\u21CF";
var $538971b5b904f078$var$nrarr = "\u219B";
var $538971b5b904f078$var$nrarrc = "\u2933\u0338";
var $538971b5b904f078$var$nrarrw = "\u219D\u0338";
var $538971b5b904f078$var$nrightarrow = "\u219B";
var $538971b5b904f078$var$nrtri = "\u22EB";
var $538971b5b904f078$var$nrtrie = "\u22ED";
var $538971b5b904f078$var$nsc = "\u2281";
var $538971b5b904f078$var$nsccue = "\u22E1";
var $538971b5b904f078$var$nsce = "\u2AB0\u0338";
var $538971b5b904f078$var$nscr = "\uD835\uDCC3";
var $538971b5b904f078$var$nshortmid = "\u2224";
var $538971b5b904f078$var$nshortparallel = "\u2226";
var $538971b5b904f078$var$nsim = "\u2241";
var $538971b5b904f078$var$nsime = "\u2244";
var $538971b5b904f078$var$nsimeq = "\u2244";
var $538971b5b904f078$var$nsmid = "\u2224";
var $538971b5b904f078$var$nspar = "\u2226";
var $538971b5b904f078$var$nsqsube = "\u22E2";
var $538971b5b904f078$var$nsqsupe = "\u22E3";
var $538971b5b904f078$var$nsub$1 = "\u2284";
var $538971b5b904f078$var$nsubE = "\u2AC5\u0338";
var $538971b5b904f078$var$nsube = "\u2288";
var $538971b5b904f078$var$nsubset = "\u2282\u20D2";
var $538971b5b904f078$var$nsubseteq = "\u2288";
var $538971b5b904f078$var$nsubseteqq = "\u2AC5\u0338";
var $538971b5b904f078$var$nsucc = "\u2281";
var $538971b5b904f078$var$nsucceq = "\u2AB0\u0338";
var $538971b5b904f078$var$nsup = "\u2285";
var $538971b5b904f078$var$nsupE = "\u2AC6\u0338";
var $538971b5b904f078$var$nsupe = "\u2289";
var $538971b5b904f078$var$nsupset = "\u2283\u20D2";
var $538971b5b904f078$var$nsupseteq = "\u2289";
var $538971b5b904f078$var$nsupseteqq = "\u2AC6\u0338";
var $538971b5b904f078$var$ntgl = "\u2279";
var $538971b5b904f078$var$ntild = "\xf1";
var $538971b5b904f078$var$ntilde$1 = "\xf1";
var $538971b5b904f078$var$ntlg = "\u2278";
var $538971b5b904f078$var$ntriangleleft = "\u22EA";
var $538971b5b904f078$var$ntrianglelefteq = "\u22EC";
var $538971b5b904f078$var$ntriangleright = "\u22EB";
var $538971b5b904f078$var$ntrianglerighteq = "\u22ED";
var $538971b5b904f078$var$nu$1 = "\u03BD";
var $538971b5b904f078$var$num = "#";
var $538971b5b904f078$var$numero = "\u2116";
var $538971b5b904f078$var$numsp = "\u2007";
var $538971b5b904f078$var$nvDash = "\u22AD";
var $538971b5b904f078$var$nvHarr = "\u2904";
var $538971b5b904f078$var$nvap = "\u224D\u20D2";
var $538971b5b904f078$var$nvdash = "\u22AC";
var $538971b5b904f078$var$nvge = "\u2265\u20D2";
var $538971b5b904f078$var$nvgt = ">\u20D2";
var $538971b5b904f078$var$nvinfin = "\u29DE";
var $538971b5b904f078$var$nvlArr = "\u2902";
var $538971b5b904f078$var$nvle = "\u2264\u20D2";
var $538971b5b904f078$var$nvlt = "<\u20D2";
var $538971b5b904f078$var$nvltrie = "\u22B4\u20D2";
var $538971b5b904f078$var$nvrArr = "\u2903";
var $538971b5b904f078$var$nvrtrie = "\u22B5\u20D2";
var $538971b5b904f078$var$nvsim = "\u223C\u20D2";
var $538971b5b904f078$var$nwArr = "\u21D6";
var $538971b5b904f078$var$nwarhk = "\u2923";
var $538971b5b904f078$var$nwarr = "\u2196";
var $538971b5b904f078$var$nwarrow = "\u2196";
var $538971b5b904f078$var$nwnear = "\u2927";
var $538971b5b904f078$var$oS = "\u24C8";
var $538971b5b904f078$var$oacut = "\xf3";
var $538971b5b904f078$var$oacute$1 = "\xf3";
var $538971b5b904f078$var$oast = "\u229B";
var $538971b5b904f078$var$ocir = "\xf4";
var $538971b5b904f078$var$ocirc$1 = "\xf4";
var $538971b5b904f078$var$ocy = "\u043E";
var $538971b5b904f078$var$odash = "\u229D";
var $538971b5b904f078$var$odblac = "\u0151";
var $538971b5b904f078$var$odiv = "\u2A38";
var $538971b5b904f078$var$odot = "\u2299";
var $538971b5b904f078$var$odsold = "\u29BC";
var $538971b5b904f078$var$oelig$1 = "\u0153";
var $538971b5b904f078$var$ofcir = "\u29BF";
var $538971b5b904f078$var$ofr = "\uD835\uDD2C";
var $538971b5b904f078$var$ogon = "\u02DB";
var $538971b5b904f078$var$ograv = "\xf2";
var $538971b5b904f078$var$ograve$1 = "\xf2";
var $538971b5b904f078$var$ogt = "\u29C1";
var $538971b5b904f078$var$ohbar = "\u29B5";
var $538971b5b904f078$var$ohm = "\u03A9";
var $538971b5b904f078$var$oint = "\u222E";
var $538971b5b904f078$var$olarr = "\u21BA";
var $538971b5b904f078$var$olcir = "\u29BE";
var $538971b5b904f078$var$olcross = "\u29BB";
var $538971b5b904f078$var$oline$1 = "\u203E";
var $538971b5b904f078$var$olt = "\u29C0";
var $538971b5b904f078$var$omacr = "\u014D";
var $538971b5b904f078$var$omega$1 = "\u03C9";
var $538971b5b904f078$var$omicron$1 = "\u03BF";
var $538971b5b904f078$var$omid = "\u29B6";
var $538971b5b904f078$var$ominus = "\u2296";
var $538971b5b904f078$var$oopf = "\uD835\uDD60";
var $538971b5b904f078$var$opar = "\u29B7";
var $538971b5b904f078$var$operp = "\u29B9";
var $538971b5b904f078$var$oplus$1 = "\u2295";
var $538971b5b904f078$var$or$1 = "\u2228";
var $538971b5b904f078$var$orarr = "\u21BB";
var $538971b5b904f078$var$ord = "\xba";
var $538971b5b904f078$var$order = "\u2134";
var $538971b5b904f078$var$orderof = "\u2134";
var $538971b5b904f078$var$ordf$1 = "\xaa";
var $538971b5b904f078$var$ordm$1 = "\xba";
var $538971b5b904f078$var$origof = "\u22B6";
var $538971b5b904f078$var$oror = "\u2A56";
var $538971b5b904f078$var$orslope = "\u2A57";
var $538971b5b904f078$var$orv = "\u2A5B";
var $538971b5b904f078$var$oscr = "\u2134";
var $538971b5b904f078$var$oslas = "\xf8";
var $538971b5b904f078$var$oslash$1 = "\xf8";
var $538971b5b904f078$var$osol = "\u2298";
var $538971b5b904f078$var$otild = "\xf5";
var $538971b5b904f078$var$otilde$1 = "\xf5";
var $538971b5b904f078$var$otimes$1 = "\u2297";
var $538971b5b904f078$var$otimesas = "\u2A36";
var $538971b5b904f078$var$oum = "\xf6";
var $538971b5b904f078$var$ouml$1 = "\xf6";
var $538971b5b904f078$var$ovbar = "\u233D";
var $538971b5b904f078$var$par = "\xb6";
var $538971b5b904f078$var$para$1 = "\xb6";
var $538971b5b904f078$var$parallel = "\u2225";
var $538971b5b904f078$var$parsim = "\u2AF3";
var $538971b5b904f078$var$parsl = "\u2AFD";
var $538971b5b904f078$var$part$1 = "\u2202";
var $538971b5b904f078$var$pcy = "\u043F";
var $538971b5b904f078$var$percnt = "%";
var $538971b5b904f078$var$period = ".";
var $538971b5b904f078$var$permil$1 = "\u2030";
var $538971b5b904f078$var$perp$1 = "\u22A5";
var $538971b5b904f078$var$pertenk = "\u2031";
var $538971b5b904f078$var$pfr = "\uD835\uDD2D";
var $538971b5b904f078$var$phi$1 = "\u03C6";
var $538971b5b904f078$var$phiv = "\u03D5";
var $538971b5b904f078$var$phmmat = "\u2133";
var $538971b5b904f078$var$phone = "\u260E";
var $538971b5b904f078$var$pi$1 = "\u03C0";
var $538971b5b904f078$var$pitchfork = "\u22D4";
var $538971b5b904f078$var$piv$1 = "\u03D6";
var $538971b5b904f078$var$planck = "\u210F";
var $538971b5b904f078$var$planckh = "\u210E";
var $538971b5b904f078$var$plankv = "\u210F";
var $538971b5b904f078$var$plus = "+";
var $538971b5b904f078$var$plusacir = "\u2A23";
var $538971b5b904f078$var$plusb = "\u229E";
var $538971b5b904f078$var$pluscir = "\u2A22";
var $538971b5b904f078$var$plusdo = "\u2214";
var $538971b5b904f078$var$plusdu = "\u2A25";
var $538971b5b904f078$var$pluse = "\u2A72";
var $538971b5b904f078$var$plusm = "\xb1";
var $538971b5b904f078$var$plusmn$1 = "\xb1";
var $538971b5b904f078$var$plussim = "\u2A26";
var $538971b5b904f078$var$plustwo = "\u2A27";
var $538971b5b904f078$var$pm = "\xb1";
var $538971b5b904f078$var$pointint = "\u2A15";
var $538971b5b904f078$var$popf = "\uD835\uDD61";
var $538971b5b904f078$var$poun = "\xa3";
var $538971b5b904f078$var$pound$1 = "\xa3";
var $538971b5b904f078$var$pr = "\u227A";
var $538971b5b904f078$var$prE = "\u2AB3";
var $538971b5b904f078$var$prap = "\u2AB7";
var $538971b5b904f078$var$prcue = "\u227C";
var $538971b5b904f078$var$pre = "\u2AAF";
var $538971b5b904f078$var$prec = "\u227A";
var $538971b5b904f078$var$precapprox = "\u2AB7";
var $538971b5b904f078$var$preccurlyeq = "\u227C";
var $538971b5b904f078$var$preceq = "\u2AAF";
var $538971b5b904f078$var$precnapprox = "\u2AB9";
var $538971b5b904f078$var$precneqq = "\u2AB5";
var $538971b5b904f078$var$precnsim = "\u22E8";
var $538971b5b904f078$var$precsim = "\u227E";
var $538971b5b904f078$var$prime$1 = "\u2032";
var $538971b5b904f078$var$primes = "\u2119";
var $538971b5b904f078$var$prnE = "\u2AB5";
var $538971b5b904f078$var$prnap = "\u2AB9";
var $538971b5b904f078$var$prnsim = "\u22E8";
var $538971b5b904f078$var$prod$1 = "\u220F";
var $538971b5b904f078$var$profalar = "\u232E";
var $538971b5b904f078$var$profline = "\u2312";
var $538971b5b904f078$var$profsurf = "\u2313";
var $538971b5b904f078$var$prop$1 = "\u221D";
var $538971b5b904f078$var$propto = "\u221D";
var $538971b5b904f078$var$prsim = "\u227E";
var $538971b5b904f078$var$prurel = "\u22B0";
var $538971b5b904f078$var$pscr = "\uD835\uDCC5";
var $538971b5b904f078$var$psi$1 = "\u03C8";
var $538971b5b904f078$var$puncsp = "\u2008";
var $538971b5b904f078$var$qfr = "\uD835\uDD2E";
var $538971b5b904f078$var$qint = "\u2A0C";
var $538971b5b904f078$var$qopf = "\uD835\uDD62";
var $538971b5b904f078$var$qprime = "\u2057";
var $538971b5b904f078$var$qscr = "\uD835\uDCC6";
var $538971b5b904f078$var$quaternions = "\u210D";
var $538971b5b904f078$var$quatint = "\u2A16";
var $538971b5b904f078$var$quest = "?";
var $538971b5b904f078$var$questeq = "\u225F";
var $538971b5b904f078$var$quo = '"';
var $538971b5b904f078$var$quot$1 = '"';
var $538971b5b904f078$var$rAarr = "\u21DB";
var $538971b5b904f078$var$rArr$1 = "\u21D2";
var $538971b5b904f078$var$rAtail = "\u291C";
var $538971b5b904f078$var$rBarr = "\u290F";
var $538971b5b904f078$var$rHar = "\u2964";
var $538971b5b904f078$var$race = "\u223D\u0331";
var $538971b5b904f078$var$racute = "\u0155";
var $538971b5b904f078$var$radic$1 = "\u221A";
var $538971b5b904f078$var$raemptyv = "\u29B3";
var $538971b5b904f078$var$rang$1 = "\u27E9";
var $538971b5b904f078$var$rangd = "\u2992";
var $538971b5b904f078$var$range = "\u29A5";
var $538971b5b904f078$var$rangle = "\u27E9";
var $538971b5b904f078$var$raqu = "\xbb";
var $538971b5b904f078$var$raquo$1 = "\xbb";
var $538971b5b904f078$var$rarr$1 = "\u2192";
var $538971b5b904f078$var$rarrap = "\u2975";
var $538971b5b904f078$var$rarrb = "\u21E5";
var $538971b5b904f078$var$rarrbfs = "\u2920";
var $538971b5b904f078$var$rarrc = "\u2933";
var $538971b5b904f078$var$rarrfs = "\u291E";
var $538971b5b904f078$var$rarrhk = "\u21AA";
var $538971b5b904f078$var$rarrlp = "\u21AC";
var $538971b5b904f078$var$rarrpl = "\u2945";
var $538971b5b904f078$var$rarrsim = "\u2974";
var $538971b5b904f078$var$rarrtl = "\u21A3";
var $538971b5b904f078$var$rarrw = "\u219D";
var $538971b5b904f078$var$ratail = "\u291A";
var $538971b5b904f078$var$ratio = "\u2236";
var $538971b5b904f078$var$rationals = "\u211A";
var $538971b5b904f078$var$rbarr = "\u290D";
var $538971b5b904f078$var$rbbrk = "\u2773";
var $538971b5b904f078$var$rbrace = "}";
var $538971b5b904f078$var$rbrack = "]";
var $538971b5b904f078$var$rbrke = "\u298C";
var $538971b5b904f078$var$rbrksld = "\u298E";
var $538971b5b904f078$var$rbrkslu = "\u2990";
var $538971b5b904f078$var$rcaron = "\u0159";
var $538971b5b904f078$var$rcedil = "\u0157";
var $538971b5b904f078$var$rceil$1 = "\u2309";
var $538971b5b904f078$var$rcub = "}";
var $538971b5b904f078$var$rcy = "\u0440";
var $538971b5b904f078$var$rdca = "\u2937";
var $538971b5b904f078$var$rdldhar = "\u2969";
var $538971b5b904f078$var$rdquo$1 = "\u201D";
var $538971b5b904f078$var$rdquor = "\u201D";
var $538971b5b904f078$var$rdsh = "\u21B3";
var $538971b5b904f078$var$real$1 = "\u211C";
var $538971b5b904f078$var$realine = "\u211B";
var $538971b5b904f078$var$realpart = "\u211C";
var $538971b5b904f078$var$reals = "\u211D";
var $538971b5b904f078$var$rect = "\u25AD";
var $538971b5b904f078$var$re$3 = "\xae";
var $538971b5b904f078$var$reg$1 = "\xae";
var $538971b5b904f078$var$rfisht = "\u297D";
var $538971b5b904f078$var$rfloor$1 = "\u230B";
var $538971b5b904f078$var$rfr = "\uD835\uDD2F";
var $538971b5b904f078$var$rhard = "\u21C1";
var $538971b5b904f078$var$rharu = "\u21C0";
var $538971b5b904f078$var$rharul = "\u296C";
var $538971b5b904f078$var$rho$1 = "\u03C1";
var $538971b5b904f078$var$rhov = "\u03F1";
var $538971b5b904f078$var$rightarrow = "\u2192";
var $538971b5b904f078$var$rightarrowtail = "\u21A3";
var $538971b5b904f078$var$rightharpoondown = "\u21C1";
var $538971b5b904f078$var$rightharpoonup = "\u21C0";
var $538971b5b904f078$var$rightleftarrows = "\u21C4";
var $538971b5b904f078$var$rightleftharpoons = "\u21CC";
var $538971b5b904f078$var$rightrightarrows = "\u21C9";
var $538971b5b904f078$var$rightsquigarrow = "\u219D";
var $538971b5b904f078$var$rightthreetimes = "\u22CC";
var $538971b5b904f078$var$ring = "\u02DA";
var $538971b5b904f078$var$risingdotseq = "\u2253";
var $538971b5b904f078$var$rlarr = "\u21C4";
var $538971b5b904f078$var$rlhar = "\u21CC";
var $538971b5b904f078$var$rlm$1 = "\u200F";
var $538971b5b904f078$var$rmoust = "\u23B1";
var $538971b5b904f078$var$rmoustache = "\u23B1";
var $538971b5b904f078$var$rnmid = "\u2AEE";
var $538971b5b904f078$var$roang = "\u27ED";
var $538971b5b904f078$var$roarr = "\u21FE";
var $538971b5b904f078$var$robrk = "\u27E7";
var $538971b5b904f078$var$ropar = "\u2986";
var $538971b5b904f078$var$ropf = "\uD835\uDD63";
var $538971b5b904f078$var$roplus = "\u2A2E";
var $538971b5b904f078$var$rotimes = "\u2A35";
var $538971b5b904f078$var$rpar = ")";
var $538971b5b904f078$var$rpargt = "\u2994";
var $538971b5b904f078$var$rppolint = "\u2A12";
var $538971b5b904f078$var$rrarr = "\u21C9";
var $538971b5b904f078$var$rsaquo$1 = "\u203A";
var $538971b5b904f078$var$rscr = "\uD835\uDCC7";
var $538971b5b904f078$var$rsh = "\u21B1";
var $538971b5b904f078$var$rsqb = "]";
var $538971b5b904f078$var$rsquo$1 = "\u2019";
var $538971b5b904f078$var$rsquor = "\u2019";
var $538971b5b904f078$var$rthree = "\u22CC";
var $538971b5b904f078$var$rtimes = "\u22CA";
var $538971b5b904f078$var$rtri = "\u25B9";
var $538971b5b904f078$var$rtrie = "\u22B5";
var $538971b5b904f078$var$rtrif = "\u25B8";
var $538971b5b904f078$var$rtriltri = "\u29CE";
var $538971b5b904f078$var$ruluhar = "\u2968";
var $538971b5b904f078$var$rx = "\u211E";
var $538971b5b904f078$var$sacute = "\u015B";
var $538971b5b904f078$var$sbquo$1 = "\u201A";
var $538971b5b904f078$var$sc = "\u227B";
var $538971b5b904f078$var$scE = "\u2AB4";
var $538971b5b904f078$var$scap = "\u2AB8";
var $538971b5b904f078$var$scaron$1 = "\u0161";
var $538971b5b904f078$var$sccue = "\u227D";
var $538971b5b904f078$var$sce = "\u2AB0";
var $538971b5b904f078$var$scedil = "\u015F";
var $538971b5b904f078$var$scirc = "\u015D";
var $538971b5b904f078$var$scnE = "\u2AB6";
var $538971b5b904f078$var$scnap = "\u2ABA";
var $538971b5b904f078$var$scnsim = "\u22E9";
var $538971b5b904f078$var$scpolint = "\u2A13";
var $538971b5b904f078$var$scsim = "\u227F";
var $538971b5b904f078$var$scy = "\u0441";
var $538971b5b904f078$var$sdot$1 = "\u22C5";
var $538971b5b904f078$var$sdotb = "\u22A1";
var $538971b5b904f078$var$sdote = "\u2A66";
var $538971b5b904f078$var$seArr = "\u21D8";
var $538971b5b904f078$var$searhk = "\u2925";
var $538971b5b904f078$var$searr = "\u2198";
var $538971b5b904f078$var$searrow = "\u2198";
var $538971b5b904f078$var$sec = "\xa7";
var $538971b5b904f078$var$sect$1 = "\xa7";
var $538971b5b904f078$var$semi = ";";
var $538971b5b904f078$var$seswar = "\u2929";
var $538971b5b904f078$var$setminus = "\u2216";
var $538971b5b904f078$var$setmn = "\u2216";
var $538971b5b904f078$var$sext = "\u2736";
var $538971b5b904f078$var$sfr = "\uD835\uDD30";
var $538971b5b904f078$var$sfrown = "\u2322";
var $538971b5b904f078$var$sharp = "\u266F";
var $538971b5b904f078$var$shchcy = "\u0449";
var $538971b5b904f078$var$shcy = "\u0448";
var $538971b5b904f078$var$shortmid = "\u2223";
var $538971b5b904f078$var$shortparallel = "\u2225";
var $538971b5b904f078$var$sh = "\xad";
var $538971b5b904f078$var$shy$1 = "\xad";
var $538971b5b904f078$var$sigma$1 = "\u03C3";
var $538971b5b904f078$var$sigmaf$1 = "\u03C2";
var $538971b5b904f078$var$sigmav = "\u03C2";
var $538971b5b904f078$var$sim$1 = "\u223C";
var $538971b5b904f078$var$simdot = "\u2A6A";
var $538971b5b904f078$var$sime = "\u2243";
var $538971b5b904f078$var$simeq = "\u2243";
var $538971b5b904f078$var$simg = "\u2A9E";
var $538971b5b904f078$var$simgE = "\u2AA0";
var $538971b5b904f078$var$siml = "\u2A9D";
var $538971b5b904f078$var$simlE = "\u2A9F";
var $538971b5b904f078$var$simne = "\u2246";
var $538971b5b904f078$var$simplus = "\u2A24";
var $538971b5b904f078$var$simrarr = "\u2972";
var $538971b5b904f078$var$slarr = "\u2190";
var $538971b5b904f078$var$smallsetminus = "\u2216";
var $538971b5b904f078$var$smashp = "\u2A33";
var $538971b5b904f078$var$smeparsl = "\u29E4";
var $538971b5b904f078$var$smid = "\u2223";
var $538971b5b904f078$var$smile = "\u2323";
var $538971b5b904f078$var$smt = "\u2AAA";
var $538971b5b904f078$var$smte = "\u2AAC";
var $538971b5b904f078$var$smtes = "\u2AAC\uFE00";
var $538971b5b904f078$var$softcy = "\u044C";
var $538971b5b904f078$var$sol = "/";
var $538971b5b904f078$var$solb = "\u29C4";
var $538971b5b904f078$var$solbar = "\u233F";
var $538971b5b904f078$var$sopf = "\uD835\uDD64";
var $538971b5b904f078$var$spades$1 = "\u2660";
var $538971b5b904f078$var$spadesuit = "\u2660";
var $538971b5b904f078$var$spar = "\u2225";
var $538971b5b904f078$var$sqcap = "\u2293";
var $538971b5b904f078$var$sqcaps = "\u2293\uFE00";
var $538971b5b904f078$var$sqcup = "\u2294";
var $538971b5b904f078$var$sqcups = "\u2294\uFE00";
var $538971b5b904f078$var$sqsub = "\u228F";
var $538971b5b904f078$var$sqsube = "\u2291";
var $538971b5b904f078$var$sqsubset = "\u228F";
var $538971b5b904f078$var$sqsubseteq = "\u2291";
var $538971b5b904f078$var$sqsup = "\u2290";
var $538971b5b904f078$var$sqsupe = "\u2292";
var $538971b5b904f078$var$sqsupset = "\u2290";
var $538971b5b904f078$var$sqsupseteq = "\u2292";
var $538971b5b904f078$var$squ = "\u25A1";
var $538971b5b904f078$var$square = "\u25A1";
var $538971b5b904f078$var$squarf = "\u25AA";
var $538971b5b904f078$var$squf = "\u25AA";
var $538971b5b904f078$var$srarr = "\u2192";
var $538971b5b904f078$var$sscr = "\uD835\uDCC8";
var $538971b5b904f078$var$ssetmn = "\u2216";
var $538971b5b904f078$var$ssmile = "\u2323";
var $538971b5b904f078$var$sstarf = "\u22C6";
var $538971b5b904f078$var$star = "\u2606";
var $538971b5b904f078$var$starf = "\u2605";
var $538971b5b904f078$var$straightepsilon = "\u03F5";
var $538971b5b904f078$var$straightphi = "\u03D5";
var $538971b5b904f078$var$strns = "\xaf";
var $538971b5b904f078$var$sub$1 = "\u2282";
var $538971b5b904f078$var$subE = "\u2AC5";
var $538971b5b904f078$var$subdot = "\u2ABD";
var $538971b5b904f078$var$sube$1 = "\u2286";
var $538971b5b904f078$var$subedot = "\u2AC3";
var $538971b5b904f078$var$submult = "\u2AC1";
var $538971b5b904f078$var$subnE = "\u2ACB";
var $538971b5b904f078$var$subne = "\u228A";
var $538971b5b904f078$var$subplus = "\u2ABF";
var $538971b5b904f078$var$subrarr = "\u2979";
var $538971b5b904f078$var$subset = "\u2282";
var $538971b5b904f078$var$subseteq = "\u2286";
var $538971b5b904f078$var$subseteqq = "\u2AC5";
var $538971b5b904f078$var$subsetneq = "\u228A";
var $538971b5b904f078$var$subsetneqq = "\u2ACB";
var $538971b5b904f078$var$subsim = "\u2AC7";
var $538971b5b904f078$var$subsub = "\u2AD5";
var $538971b5b904f078$var$subsup = "\u2AD3";
var $538971b5b904f078$var$succ = "\u227B";
var $538971b5b904f078$var$succapprox = "\u2AB8";
var $538971b5b904f078$var$succcurlyeq = "\u227D";
var $538971b5b904f078$var$succeq = "\u2AB0";
var $538971b5b904f078$var$succnapprox = "\u2ABA";
var $538971b5b904f078$var$succneqq = "\u2AB6";
var $538971b5b904f078$var$succnsim = "\u22E9";
var $538971b5b904f078$var$succsim = "\u227F";
var $538971b5b904f078$var$sum$1 = "\u2211";
var $538971b5b904f078$var$sung = "\u266A";
var $538971b5b904f078$var$sup$1 = "\u2283";
var $538971b5b904f078$var$sup1$1 = "\xb9";
var $538971b5b904f078$var$sup2$1 = "\xb2";
var $538971b5b904f078$var$sup3$1 = "\xb3";
var $538971b5b904f078$var$supE = "\u2AC6";
var $538971b5b904f078$var$supdot = "\u2ABE";
var $538971b5b904f078$var$supdsub = "\u2AD8";
var $538971b5b904f078$var$supe$1 = "\u2287";
var $538971b5b904f078$var$supedot = "\u2AC4";
var $538971b5b904f078$var$suphsol = "\u27C9";
var $538971b5b904f078$var$suphsub = "\u2AD7";
var $538971b5b904f078$var$suplarr = "\u297B";
var $538971b5b904f078$var$supmult = "\u2AC2";
var $538971b5b904f078$var$supnE = "\u2ACC";
var $538971b5b904f078$var$supne = "\u228B";
var $538971b5b904f078$var$supplus = "\u2AC0";
var $538971b5b904f078$var$supset = "\u2283";
var $538971b5b904f078$var$supseteq = "\u2287";
var $538971b5b904f078$var$supseteqq = "\u2AC6";
var $538971b5b904f078$var$supsetneq = "\u228B";
var $538971b5b904f078$var$supsetneqq = "\u2ACC";
var $538971b5b904f078$var$supsim = "\u2AC8";
var $538971b5b904f078$var$supsub = "\u2AD4";
var $538971b5b904f078$var$supsup = "\u2AD6";
var $538971b5b904f078$var$swArr = "\u21D9";
var $538971b5b904f078$var$swarhk = "\u2926";
var $538971b5b904f078$var$swarr = "\u2199";
var $538971b5b904f078$var$swarrow = "\u2199";
var $538971b5b904f078$var$swnwar = "\u292A";
var $538971b5b904f078$var$szli = "\xdf";
var $538971b5b904f078$var$szlig$1 = "\xdf";
var $538971b5b904f078$var$target = "\u2316";
var $538971b5b904f078$var$tau$1 = "\u03C4";
var $538971b5b904f078$var$tbrk = "\u23B4";
var $538971b5b904f078$var$tcaron = "\u0165";
var $538971b5b904f078$var$tcedil = "\u0163";
var $538971b5b904f078$var$tcy = "\u0442";
var $538971b5b904f078$var$tdot = "\u20DB";
var $538971b5b904f078$var$telrec = "\u2315";
var $538971b5b904f078$var$tfr = "\uD835\uDD31";
var $538971b5b904f078$var$there4$1 = "\u2234";
var $538971b5b904f078$var$therefore = "\u2234";
var $538971b5b904f078$var$theta$1 = "\u03B8";
var $538971b5b904f078$var$thetasym$1 = "\u03D1";
var $538971b5b904f078$var$thetav = "\u03D1";
var $538971b5b904f078$var$thickapprox = "\u2248";
var $538971b5b904f078$var$thicksim = "\u223C";
var $538971b5b904f078$var$thinsp$1 = "\u2009";
var $538971b5b904f078$var$thkap = "\u2248";
var $538971b5b904f078$var$thksim = "\u223C";
var $538971b5b904f078$var$thor = "\xfe";
var $538971b5b904f078$var$thorn$1 = "\xfe";
var $538971b5b904f078$var$tilde$4 = "\u02DC";
var $538971b5b904f078$var$time = "\xd7";
var $538971b5b904f078$var$times$1 = "\xd7";
var $538971b5b904f078$var$timesb = "\u22A0";
var $538971b5b904f078$var$timesbar = "\u2A31";
var $538971b5b904f078$var$timesd = "\u2A30";
var $538971b5b904f078$var$tint = "\u222D";
var $538971b5b904f078$var$toea = "\u2928";
var $538971b5b904f078$var$top = "\u22A4";
var $538971b5b904f078$var$topbot = "\u2336";
var $538971b5b904f078$var$topcir = "\u2AF1";
var $538971b5b904f078$var$topf = "\uD835\uDD65";
var $538971b5b904f078$var$topfork = "\u2ADA";
var $538971b5b904f078$var$tosa = "\u2929";
var $538971b5b904f078$var$tprime = "\u2034";
var $538971b5b904f078$var$trade$1 = "\u2122";
var $538971b5b904f078$var$triangle = "\u25B5";
var $538971b5b904f078$var$triangledown = "\u25BF";
var $538971b5b904f078$var$triangleleft = "\u25C3";
var $538971b5b904f078$var$trianglelefteq = "\u22B4";
var $538971b5b904f078$var$triangleq = "\u225C";
var $538971b5b904f078$var$triangleright = "\u25B9";
var $538971b5b904f078$var$trianglerighteq = "\u22B5";
var $538971b5b904f078$var$tridot = "\u25EC";
var $538971b5b904f078$var$trie = "\u225C";
var $538971b5b904f078$var$triminus = "\u2A3A";
var $538971b5b904f078$var$triplus = "\u2A39";
var $538971b5b904f078$var$trisb = "\u29CD";
var $538971b5b904f078$var$tritime = "\u2A3B";
var $538971b5b904f078$var$trpezium = "\u23E2";
var $538971b5b904f078$var$tscr = "\uD835\uDCC9";
var $538971b5b904f078$var$tscy = "\u0446";
var $538971b5b904f078$var$tshcy = "\u045B";
var $538971b5b904f078$var$tstrok = "\u0167";
var $538971b5b904f078$var$twixt = "\u226C";
var $538971b5b904f078$var$twoheadleftarrow = "\u219E";
var $538971b5b904f078$var$twoheadrightarrow = "\u21A0";
var $538971b5b904f078$var$uArr$1 = "\u21D1";
var $538971b5b904f078$var$uHar = "\u2963";
var $538971b5b904f078$var$uacut = "\xfa";
var $538971b5b904f078$var$uacute$1 = "\xfa";
var $538971b5b904f078$var$uarr$1 = "\u2191";
var $538971b5b904f078$var$ubrcy = "\u045E";
var $538971b5b904f078$var$ubreve = "\u016D";
var $538971b5b904f078$var$ucir = "\xfb";
var $538971b5b904f078$var$ucirc$1 = "\xfb";
var $538971b5b904f078$var$ucy = "\u0443";
var $538971b5b904f078$var$udarr = "\u21C5";
var $538971b5b904f078$var$udblac = "\u0171";
var $538971b5b904f078$var$udhar = "\u296E";
var $538971b5b904f078$var$ufisht = "\u297E";
var $538971b5b904f078$var$ufr = "\uD835\uDD32";
var $538971b5b904f078$var$ugrav = "\xf9";
var $538971b5b904f078$var$ugrave$1 = "\xf9";
var $538971b5b904f078$var$uharl = "\u21BF";
var $538971b5b904f078$var$uharr = "\u21BE";
var $538971b5b904f078$var$uhblk = "\u2580";
var $538971b5b904f078$var$ulcorn = "\u231C";
var $538971b5b904f078$var$ulcorner = "\u231C";
var $538971b5b904f078$var$ulcrop = "\u230F";
var $538971b5b904f078$var$ultri = "\u25F8";
var $538971b5b904f078$var$umacr = "\u016B";
var $538971b5b904f078$var$um = "\xa8";
var $538971b5b904f078$var$uml$1 = "\xa8";
var $538971b5b904f078$var$uogon = "\u0173";
var $538971b5b904f078$var$uopf = "\uD835\uDD66";
var $538971b5b904f078$var$uparrow = "\u2191";
var $538971b5b904f078$var$updownarrow = "\u2195";
var $538971b5b904f078$var$upharpoonleft = "\u21BF";
var $538971b5b904f078$var$upharpoonright = "\u21BE";
var $538971b5b904f078$var$uplus = "\u228E";
var $538971b5b904f078$var$upsi = "\u03C5";
var $538971b5b904f078$var$upsih$1 = "\u03D2";
var $538971b5b904f078$var$upsilon$1 = "\u03C5";
var $538971b5b904f078$var$upuparrows = "\u21C8";
var $538971b5b904f078$var$urcorn = "\u231D";
var $538971b5b904f078$var$urcorner = "\u231D";
var $538971b5b904f078$var$urcrop = "\u230E";
var $538971b5b904f078$var$uring = "\u016F";
var $538971b5b904f078$var$urtri = "\u25F9";
var $538971b5b904f078$var$uscr = "\uD835\uDCCA";
var $538971b5b904f078$var$utdot = "\u22F0";
var $538971b5b904f078$var$utilde = "\u0169";
var $538971b5b904f078$var$utri = "\u25B5";
var $538971b5b904f078$var$utrif = "\u25B4";
var $538971b5b904f078$var$uuarr = "\u21C8";
var $538971b5b904f078$var$uum = "\xfc";
var $538971b5b904f078$var$uuml$1 = "\xfc";
var $538971b5b904f078$var$uwangle = "\u29A7";
var $538971b5b904f078$var$vArr = "\u21D5";
var $538971b5b904f078$var$vBar = "\u2AE8";
var $538971b5b904f078$var$vBarv = "\u2AE9";
var $538971b5b904f078$var$vDash = "\u22A8";
var $538971b5b904f078$var$vangrt = "\u299C";
var $538971b5b904f078$var$varepsilon = "\u03F5";
var $538971b5b904f078$var$varkappa = "\u03F0";
var $538971b5b904f078$var$varnothing = "\u2205";
var $538971b5b904f078$var$varphi = "\u03D5";
var $538971b5b904f078$var$varpi = "\u03D6";
var $538971b5b904f078$var$varpropto = "\u221D";
var $538971b5b904f078$var$varr = "\u2195";
var $538971b5b904f078$var$varrho = "\u03F1";
var $538971b5b904f078$var$varsigma = "\u03C2";
var $538971b5b904f078$var$varsubsetneq = "\u228A\uFE00";
var $538971b5b904f078$var$varsubsetneqq = "\u2ACB\uFE00";
var $538971b5b904f078$var$varsupsetneq = "\u228B\uFE00";
var $538971b5b904f078$var$varsupsetneqq = "\u2ACC\uFE00";
var $538971b5b904f078$var$vartheta = "\u03D1";
var $538971b5b904f078$var$vartriangleleft = "\u22B2";
var $538971b5b904f078$var$vartriangleright = "\u22B3";
var $538971b5b904f078$var$vcy = "\u0432";
var $538971b5b904f078$var$vdash = "\u22A2";
var $538971b5b904f078$var$vee = "\u2228";
var $538971b5b904f078$var$veebar = "\u22BB";
var $538971b5b904f078$var$veeeq = "\u225A";
var $538971b5b904f078$var$vellip = "\u22EE";
var $538971b5b904f078$var$verbar = "|";
var $538971b5b904f078$var$vert = "|";
var $538971b5b904f078$var$vfr = "\uD835\uDD33";
var $538971b5b904f078$var$vltri = "\u22B2";
var $538971b5b904f078$var$vnsub = "\u2282\u20D2";
var $538971b5b904f078$var$vnsup = "\u2283\u20D2";
var $538971b5b904f078$var$vopf = "\uD835\uDD67";
var $538971b5b904f078$var$vprop = "\u221D";
var $538971b5b904f078$var$vrtri = "\u22B3";
var $538971b5b904f078$var$vscr = "\uD835\uDCCB";
var $538971b5b904f078$var$vsubnE = "\u2ACB\uFE00";
var $538971b5b904f078$var$vsubne = "\u228A\uFE00";
var $538971b5b904f078$var$vsupnE = "\u2ACC\uFE00";
var $538971b5b904f078$var$vsupne = "\u228B\uFE00";
var $538971b5b904f078$var$vzigzag = "\u299A";
var $538971b5b904f078$var$wcirc = "\u0175";
var $538971b5b904f078$var$wedbar = "\u2A5F";
var $538971b5b904f078$var$wedge = "\u2227";
var $538971b5b904f078$var$wedgeq = "\u2259";
var $538971b5b904f078$var$weierp$1 = "\u2118";
var $538971b5b904f078$var$wfr = "\uD835\uDD34";
var $538971b5b904f078$var$wopf = "\uD835\uDD68";
var $538971b5b904f078$var$wp = "\u2118";
var $538971b5b904f078$var$wr = "\u2240";
var $538971b5b904f078$var$wreath = "\u2240";
var $538971b5b904f078$var$wscr = "\uD835\uDCCC";
var $538971b5b904f078$var$xcap = "\u22C2";
var $538971b5b904f078$var$xcirc = "\u25EF";
var $538971b5b904f078$var$xcup = "\u22C3";
var $538971b5b904f078$var$xdtri = "\u25BD";
var $538971b5b904f078$var$xfr = "\uD835\uDD35";
var $538971b5b904f078$var$xhArr = "\u27FA";
var $538971b5b904f078$var$xharr = "\u27F7";
var $538971b5b904f078$var$xi$1 = "\u03BE";
var $538971b5b904f078$var$xlArr = "\u27F8";
var $538971b5b904f078$var$xlarr = "\u27F5";
var $538971b5b904f078$var$xmap = "\u27FC";
var $538971b5b904f078$var$xnis = "\u22FB";
var $538971b5b904f078$var$xodot = "\u2A00";
var $538971b5b904f078$var$xopf = "\uD835\uDD69";
var $538971b5b904f078$var$xoplus = "\u2A01";
var $538971b5b904f078$var$xotime = "\u2A02";
var $538971b5b904f078$var$xrArr = "\u27F9";
var $538971b5b904f078$var$xrarr = "\u27F6";
var $538971b5b904f078$var$xscr = "\uD835\uDCCD";
var $538971b5b904f078$var$xsqcup = "\u2A06";
var $538971b5b904f078$var$xuplus = "\u2A04";
var $538971b5b904f078$var$xutri = "\u25B3";
var $538971b5b904f078$var$xvee = "\u22C1";
var $538971b5b904f078$var$xwedge = "\u22C0";
var $538971b5b904f078$var$yacut = "\xfd";
var $538971b5b904f078$var$yacute$1 = "\xfd";
var $538971b5b904f078$var$yacy = "\u044F";
var $538971b5b904f078$var$ycirc = "\u0177";
var $538971b5b904f078$var$ycy = "\u044B";
var $538971b5b904f078$var$ye = "\xa5";
var $538971b5b904f078$var$yen$1 = "\xa5";
var $538971b5b904f078$var$yfr = "\uD835\uDD36";
var $538971b5b904f078$var$yicy = "\u0457";
var $538971b5b904f078$var$yopf = "\uD835\uDD6A";
var $538971b5b904f078$var$yscr = "\uD835\uDCCE";
var $538971b5b904f078$var$yucy = "\u044E";
var $538971b5b904f078$var$yum = "\xff";
var $538971b5b904f078$var$yuml$1 = "\xff";
var $538971b5b904f078$var$zacute = "\u017A";
var $538971b5b904f078$var$zcaron = "\u017E";
var $538971b5b904f078$var$zcy = "\u0437";
var $538971b5b904f078$var$zdot = "\u017C";
var $538971b5b904f078$var$zeetrf = "\u2128";
var $538971b5b904f078$var$zeta$1 = "\u03B6";
var $538971b5b904f078$var$zfr = "\uD835\uDD37";
var $538971b5b904f078$var$zhcy = "\u0436";
var $538971b5b904f078$var$zigrarr = "\u21DD";
var $538971b5b904f078$var$zopf = "\uD835\uDD6B";
var $538971b5b904f078$var$zscr = "\uD835\uDCCF";
var $538971b5b904f078$var$zwj$1 = "\u200D";
var $538971b5b904f078$var$zwnj$1 = "\u200C";
var $538971b5b904f078$var$index$3 = {
    AEli: $538971b5b904f078$var$AEli,
    AElig: $538971b5b904f078$var$AElig$1,
    AM: $538971b5b904f078$var$AM,
    AMP: $538971b5b904f078$var$AMP$1,
    Aacut: $538971b5b904f078$var$Aacut,
    Aacute: $538971b5b904f078$var$Aacute$1,
    Abreve: $538971b5b904f078$var$Abreve,
    Acir: $538971b5b904f078$var$Acir,
    Acirc: $538971b5b904f078$var$Acirc$1,
    Acy: $538971b5b904f078$var$Acy,
    Afr: $538971b5b904f078$var$Afr,
    Agrav: $538971b5b904f078$var$Agrav,
    Agrave: $538971b5b904f078$var$Agrave$1,
    Alpha: $538971b5b904f078$var$Alpha$1,
    Amacr: $538971b5b904f078$var$Amacr,
    And: $538971b5b904f078$var$And,
    Aogon: $538971b5b904f078$var$Aogon,
    Aopf: $538971b5b904f078$var$Aopf,
    ApplyFunction: $538971b5b904f078$var$ApplyFunction,
    Arin: $538971b5b904f078$var$Arin,
    Aring: $538971b5b904f078$var$Aring$1,
    Ascr: $538971b5b904f078$var$Ascr,
    Assign: $538971b5b904f078$var$Assign,
    Atild: $538971b5b904f078$var$Atild,
    Atilde: $538971b5b904f078$var$Atilde$1,
    Aum: $538971b5b904f078$var$Aum,
    Auml: $538971b5b904f078$var$Auml$1,
    Backslash: $538971b5b904f078$var$Backslash,
    Barv: $538971b5b904f078$var$Barv,
    Barwed: $538971b5b904f078$var$Barwed,
    Bcy: $538971b5b904f078$var$Bcy,
    Because: $538971b5b904f078$var$Because,
    Bernoullis: $538971b5b904f078$var$Bernoullis,
    Beta: $538971b5b904f078$var$Beta$1,
    Bfr: $538971b5b904f078$var$Bfr,
    Bopf: $538971b5b904f078$var$Bopf,
    Breve: $538971b5b904f078$var$Breve,
    Bscr: $538971b5b904f078$var$Bscr,
    Bumpeq: $538971b5b904f078$var$Bumpeq,
    CHcy: $538971b5b904f078$var$CHcy,
    COP: $538971b5b904f078$var$COP,
    COPY: $538971b5b904f078$var$COPY,
    Cacute: $538971b5b904f078$var$Cacute,
    Cap: $538971b5b904f078$var$Cap,
    CapitalDifferentialD: $538971b5b904f078$var$CapitalDifferentialD,
    Cayleys: $538971b5b904f078$var$Cayleys,
    Ccaron: $538971b5b904f078$var$Ccaron,
    Ccedi: $538971b5b904f078$var$Ccedi,
    Ccedil: $538971b5b904f078$var$Ccedil$1,
    Ccirc: $538971b5b904f078$var$Ccirc,
    Cconint: $538971b5b904f078$var$Cconint,
    Cdot: $538971b5b904f078$var$Cdot,
    Cedilla: $538971b5b904f078$var$Cedilla,
    CenterDot: $538971b5b904f078$var$CenterDot,
    Cfr: $538971b5b904f078$var$Cfr,
    Chi: $538971b5b904f078$var$Chi$1,
    CircleDot: $538971b5b904f078$var$CircleDot,
    CircleMinus: $538971b5b904f078$var$CircleMinus,
    CirclePlus: $538971b5b904f078$var$CirclePlus,
    CircleTimes: $538971b5b904f078$var$CircleTimes,
    ClockwiseContourIntegral: $538971b5b904f078$var$ClockwiseContourIntegral,
    CloseCurlyDoubleQuote: $538971b5b904f078$var$CloseCurlyDoubleQuote,
    CloseCurlyQuote: $538971b5b904f078$var$CloseCurlyQuote,
    Colon: $538971b5b904f078$var$Colon,
    Colone: $538971b5b904f078$var$Colone,
    Congruent: $538971b5b904f078$var$Congruent,
    Conint: $538971b5b904f078$var$Conint,
    ContourIntegral: $538971b5b904f078$var$ContourIntegral,
    Copf: $538971b5b904f078$var$Copf,
    Coproduct: $538971b5b904f078$var$Coproduct,
    CounterClockwiseContourIntegral: $538971b5b904f078$var$CounterClockwiseContourIntegral,
    Cross: $538971b5b904f078$var$Cross,
    Cscr: $538971b5b904f078$var$Cscr,
    Cup: $538971b5b904f078$var$Cup,
    CupCap: $538971b5b904f078$var$CupCap,
    DD: $538971b5b904f078$var$DD,
    DDotrahd: $538971b5b904f078$var$DDotrahd,
    DJcy: $538971b5b904f078$var$DJcy,
    DScy: $538971b5b904f078$var$DScy,
    DZcy: $538971b5b904f078$var$DZcy,
    Dagger: $538971b5b904f078$var$Dagger$1,
    Darr: $538971b5b904f078$var$Darr,
    Dashv: $538971b5b904f078$var$Dashv,
    Dcaron: $538971b5b904f078$var$Dcaron,
    Dcy: $538971b5b904f078$var$Dcy,
    Del: $538971b5b904f078$var$Del,
    Delta: $538971b5b904f078$var$Delta$1,
    Dfr: $538971b5b904f078$var$Dfr,
    DiacriticalAcute: $538971b5b904f078$var$DiacriticalAcute,
    DiacriticalDot: $538971b5b904f078$var$DiacriticalDot,
    DiacriticalDoubleAcute: $538971b5b904f078$var$DiacriticalDoubleAcute,
    DiacriticalGrave: $538971b5b904f078$var$DiacriticalGrave,
    DiacriticalTilde: $538971b5b904f078$var$DiacriticalTilde,
    Diamond: $538971b5b904f078$var$Diamond,
    DifferentialD: $538971b5b904f078$var$DifferentialD,
    Dopf: $538971b5b904f078$var$Dopf,
    Dot: $538971b5b904f078$var$Dot,
    DotDot: $538971b5b904f078$var$DotDot,
    DotEqual: $538971b5b904f078$var$DotEqual,
    DoubleContourIntegral: $538971b5b904f078$var$DoubleContourIntegral,
    DoubleDot: $538971b5b904f078$var$DoubleDot,
    DoubleDownArrow: $538971b5b904f078$var$DoubleDownArrow,
    DoubleLeftArrow: $538971b5b904f078$var$DoubleLeftArrow,
    DoubleLeftRightArrow: $538971b5b904f078$var$DoubleLeftRightArrow,
    DoubleLeftTee: $538971b5b904f078$var$DoubleLeftTee,
    DoubleLongLeftArrow: $538971b5b904f078$var$DoubleLongLeftArrow,
    DoubleLongLeftRightArrow: $538971b5b904f078$var$DoubleLongLeftRightArrow,
    DoubleLongRightArrow: $538971b5b904f078$var$DoubleLongRightArrow,
    DoubleRightArrow: $538971b5b904f078$var$DoubleRightArrow,
    DoubleRightTee: $538971b5b904f078$var$DoubleRightTee,
    DoubleUpArrow: $538971b5b904f078$var$DoubleUpArrow,
    DoubleUpDownArrow: $538971b5b904f078$var$DoubleUpDownArrow,
    DoubleVerticalBar: $538971b5b904f078$var$DoubleVerticalBar,
    DownArrow: $538971b5b904f078$var$DownArrow,
    DownArrowBar: $538971b5b904f078$var$DownArrowBar,
    DownArrowUpArrow: $538971b5b904f078$var$DownArrowUpArrow,
    DownBreve: $538971b5b904f078$var$DownBreve,
    DownLeftRightVector: $538971b5b904f078$var$DownLeftRightVector,
    DownLeftTeeVector: $538971b5b904f078$var$DownLeftTeeVector,
    DownLeftVector: $538971b5b904f078$var$DownLeftVector,
    DownLeftVectorBar: $538971b5b904f078$var$DownLeftVectorBar,
    DownRightTeeVector: $538971b5b904f078$var$DownRightTeeVector,
    DownRightVector: $538971b5b904f078$var$DownRightVector,
    DownRightVectorBar: $538971b5b904f078$var$DownRightVectorBar,
    DownTee: $538971b5b904f078$var$DownTee,
    DownTeeArrow: $538971b5b904f078$var$DownTeeArrow,
    Downarrow: $538971b5b904f078$var$Downarrow,
    Dscr: $538971b5b904f078$var$Dscr,
    Dstrok: $538971b5b904f078$var$Dstrok,
    ENG: $538971b5b904f078$var$ENG,
    ET: $538971b5b904f078$var$ET,
    ETH: $538971b5b904f078$var$ETH$1,
    Eacut: $538971b5b904f078$var$Eacut,
    Eacute: $538971b5b904f078$var$Eacute$1,
    Ecaron: $538971b5b904f078$var$Ecaron,
    Ecir: $538971b5b904f078$var$Ecir,
    Ecirc: $538971b5b904f078$var$Ecirc$1,
    Ecy: $538971b5b904f078$var$Ecy,
    Edot: $538971b5b904f078$var$Edot,
    Efr: $538971b5b904f078$var$Efr,
    Egrav: $538971b5b904f078$var$Egrav,
    Egrave: $538971b5b904f078$var$Egrave$1,
    Element: $538971b5b904f078$var$Element,
    Emacr: $538971b5b904f078$var$Emacr,
    EmptySmallSquare: $538971b5b904f078$var$EmptySmallSquare,
    EmptyVerySmallSquare: $538971b5b904f078$var$EmptyVerySmallSquare,
    Eogon: $538971b5b904f078$var$Eogon,
    Eopf: $538971b5b904f078$var$Eopf,
    Epsilon: $538971b5b904f078$var$Epsilon$1,
    Equal: $538971b5b904f078$var$Equal,
    EqualTilde: $538971b5b904f078$var$EqualTilde,
    Equilibrium: $538971b5b904f078$var$Equilibrium,
    Escr: $538971b5b904f078$var$Escr,
    Esim: $538971b5b904f078$var$Esim,
    Eta: $538971b5b904f078$var$Eta$1,
    Eum: $538971b5b904f078$var$Eum,
    Euml: $538971b5b904f078$var$Euml$1,
    Exists: $538971b5b904f078$var$Exists,
    ExponentialE: $538971b5b904f078$var$ExponentialE,
    Fcy: $538971b5b904f078$var$Fcy,
    Ffr: $538971b5b904f078$var$Ffr,
    FilledSmallSquare: $538971b5b904f078$var$FilledSmallSquare,
    FilledVerySmallSquare: $538971b5b904f078$var$FilledVerySmallSquare,
    Fopf: $538971b5b904f078$var$Fopf,
    ForAll: $538971b5b904f078$var$ForAll,
    Fouriertrf: $538971b5b904f078$var$Fouriertrf,
    Fscr: $538971b5b904f078$var$Fscr,
    GJcy: $538971b5b904f078$var$GJcy,
    G: $538971b5b904f078$var$G,
    GT: $538971b5b904f078$var$GT$1,
    Gamma: $538971b5b904f078$var$Gamma$1,
    Gammad: $538971b5b904f078$var$Gammad,
    Gbreve: $538971b5b904f078$var$Gbreve,
    Gcedil: $538971b5b904f078$var$Gcedil,
    Gcirc: $538971b5b904f078$var$Gcirc,
    Gcy: $538971b5b904f078$var$Gcy,
    Gdot: $538971b5b904f078$var$Gdot,
    Gfr: $538971b5b904f078$var$Gfr,
    Gg: $538971b5b904f078$var$Gg,
    Gopf: $538971b5b904f078$var$Gopf,
    GreaterEqual: $538971b5b904f078$var$GreaterEqual,
    GreaterEqualLess: $538971b5b904f078$var$GreaterEqualLess,
    GreaterFullEqual: $538971b5b904f078$var$GreaterFullEqual,
    GreaterGreater: $538971b5b904f078$var$GreaterGreater,
    GreaterLess: $538971b5b904f078$var$GreaterLess,
    GreaterSlantEqual: $538971b5b904f078$var$GreaterSlantEqual,
    GreaterTilde: $538971b5b904f078$var$GreaterTilde,
    Gscr: $538971b5b904f078$var$Gscr,
    Gt: $538971b5b904f078$var$Gt,
    HARDcy: $538971b5b904f078$var$HARDcy,
    Hacek: $538971b5b904f078$var$Hacek,
    Hat: $538971b5b904f078$var$Hat,
    Hcirc: $538971b5b904f078$var$Hcirc,
    Hfr: $538971b5b904f078$var$Hfr,
    HilbertSpace: $538971b5b904f078$var$HilbertSpace,
    Hopf: $538971b5b904f078$var$Hopf,
    HorizontalLine: $538971b5b904f078$var$HorizontalLine,
    Hscr: $538971b5b904f078$var$Hscr,
    Hstrok: $538971b5b904f078$var$Hstrok,
    HumpDownHump: $538971b5b904f078$var$HumpDownHump,
    HumpEqual: $538971b5b904f078$var$HumpEqual,
    IEcy: $538971b5b904f078$var$IEcy,
    IJlig: $538971b5b904f078$var$IJlig,
    IOcy: $538971b5b904f078$var$IOcy,
    Iacut: $538971b5b904f078$var$Iacut,
    Iacute: $538971b5b904f078$var$Iacute$1,
    Icir: $538971b5b904f078$var$Icir,
    Icirc: $538971b5b904f078$var$Icirc$1,
    Icy: $538971b5b904f078$var$Icy,
    Idot: $538971b5b904f078$var$Idot,
    Ifr: $538971b5b904f078$var$Ifr,
    Igrav: $538971b5b904f078$var$Igrav,
    Igrave: $538971b5b904f078$var$Igrave$1,
    Im: $538971b5b904f078$var$Im,
    Imacr: $538971b5b904f078$var$Imacr,
    ImaginaryI: $538971b5b904f078$var$ImaginaryI,
    Implies: $538971b5b904f078$var$Implies,
    Int: $538971b5b904f078$var$Int,
    Integral: $538971b5b904f078$var$Integral,
    Intersection: $538971b5b904f078$var$Intersection,
    InvisibleComma: $538971b5b904f078$var$InvisibleComma,
    InvisibleTimes: $538971b5b904f078$var$InvisibleTimes,
    Iogon: $538971b5b904f078$var$Iogon,
    Iopf: $538971b5b904f078$var$Iopf,
    Iota: $538971b5b904f078$var$Iota$1,
    Iscr: $538971b5b904f078$var$Iscr,
    Itilde: $538971b5b904f078$var$Itilde,
    Iukcy: $538971b5b904f078$var$Iukcy,
    Ium: $538971b5b904f078$var$Ium,
    Iuml: $538971b5b904f078$var$Iuml$1,
    Jcirc: $538971b5b904f078$var$Jcirc,
    Jcy: $538971b5b904f078$var$Jcy,
    Jfr: $538971b5b904f078$var$Jfr,
    Jopf: $538971b5b904f078$var$Jopf,
    Jscr: $538971b5b904f078$var$Jscr,
    Jsercy: $538971b5b904f078$var$Jsercy,
    Jukcy: $538971b5b904f078$var$Jukcy,
    KHcy: $538971b5b904f078$var$KHcy,
    KJcy: $538971b5b904f078$var$KJcy,
    Kappa: $538971b5b904f078$var$Kappa$1,
    Kcedil: $538971b5b904f078$var$Kcedil,
    Kcy: $538971b5b904f078$var$Kcy,
    Kfr: $538971b5b904f078$var$Kfr,
    Kopf: $538971b5b904f078$var$Kopf,
    Kscr: $538971b5b904f078$var$Kscr,
    LJcy: $538971b5b904f078$var$LJcy,
    L: $538971b5b904f078$var$L,
    LT: $538971b5b904f078$var$LT$1,
    Lacute: $538971b5b904f078$var$Lacute,
    Lambda: $538971b5b904f078$var$Lambda$1,
    Lang: $538971b5b904f078$var$Lang,
    Laplacetrf: $538971b5b904f078$var$Laplacetrf,
    Larr: $538971b5b904f078$var$Larr,
    Lcaron: $538971b5b904f078$var$Lcaron,
    Lcedil: $538971b5b904f078$var$Lcedil,
    Lcy: $538971b5b904f078$var$Lcy,
    LeftAngleBracket: $538971b5b904f078$var$LeftAngleBracket,
    LeftArrow: $538971b5b904f078$var$LeftArrow,
    LeftArrowBar: $538971b5b904f078$var$LeftArrowBar,
    LeftArrowRightArrow: $538971b5b904f078$var$LeftArrowRightArrow,
    LeftCeiling: $538971b5b904f078$var$LeftCeiling,
    LeftDoubleBracket: $538971b5b904f078$var$LeftDoubleBracket,
    LeftDownTeeVector: $538971b5b904f078$var$LeftDownTeeVector,
    LeftDownVector: $538971b5b904f078$var$LeftDownVector,
    LeftDownVectorBar: $538971b5b904f078$var$LeftDownVectorBar,
    LeftFloor: $538971b5b904f078$var$LeftFloor,
    LeftRightArrow: $538971b5b904f078$var$LeftRightArrow,
    LeftRightVector: $538971b5b904f078$var$LeftRightVector,
    LeftTee: $538971b5b904f078$var$LeftTee,
    LeftTeeArrow: $538971b5b904f078$var$LeftTeeArrow,
    LeftTeeVector: $538971b5b904f078$var$LeftTeeVector,
    LeftTriangle: $538971b5b904f078$var$LeftTriangle,
    LeftTriangleBar: $538971b5b904f078$var$LeftTriangleBar,
    LeftTriangleEqual: $538971b5b904f078$var$LeftTriangleEqual,
    LeftUpDownVector: $538971b5b904f078$var$LeftUpDownVector,
    LeftUpTeeVector: $538971b5b904f078$var$LeftUpTeeVector,
    LeftUpVector: $538971b5b904f078$var$LeftUpVector,
    LeftUpVectorBar: $538971b5b904f078$var$LeftUpVectorBar,
    LeftVector: $538971b5b904f078$var$LeftVector,
    LeftVectorBar: $538971b5b904f078$var$LeftVectorBar,
    Leftarrow: $538971b5b904f078$var$Leftarrow,
    Leftrightarrow: $538971b5b904f078$var$Leftrightarrow,
    LessEqualGreater: $538971b5b904f078$var$LessEqualGreater,
    LessFullEqual: $538971b5b904f078$var$LessFullEqual,
    LessGreater: $538971b5b904f078$var$LessGreater,
    LessLess: $538971b5b904f078$var$LessLess,
    LessSlantEqual: $538971b5b904f078$var$LessSlantEqual,
    LessTilde: $538971b5b904f078$var$LessTilde,
    Lfr: $538971b5b904f078$var$Lfr,
    Ll: $538971b5b904f078$var$Ll,
    Lleftarrow: $538971b5b904f078$var$Lleftarrow,
    Lmidot: $538971b5b904f078$var$Lmidot,
    LongLeftArrow: $538971b5b904f078$var$LongLeftArrow,
    LongLeftRightArrow: $538971b5b904f078$var$LongLeftRightArrow,
    LongRightArrow: $538971b5b904f078$var$LongRightArrow,
    Longleftarrow: $538971b5b904f078$var$Longleftarrow,
    Longleftrightarrow: $538971b5b904f078$var$Longleftrightarrow,
    Longrightarrow: $538971b5b904f078$var$Longrightarrow,
    Lopf: $538971b5b904f078$var$Lopf,
    LowerLeftArrow: $538971b5b904f078$var$LowerLeftArrow,
    LowerRightArrow: $538971b5b904f078$var$LowerRightArrow,
    Lscr: $538971b5b904f078$var$Lscr,
    Lsh: $538971b5b904f078$var$Lsh,
    Lstrok: $538971b5b904f078$var$Lstrok,
    Lt: $538971b5b904f078$var$Lt,
    "Map": "\u2905",
    Mcy: $538971b5b904f078$var$Mcy,
    MediumSpace: $538971b5b904f078$var$MediumSpace,
    Mellintrf: $538971b5b904f078$var$Mellintrf,
    Mfr: $538971b5b904f078$var$Mfr,
    MinusPlus: $538971b5b904f078$var$MinusPlus,
    Mopf: $538971b5b904f078$var$Mopf,
    Mscr: $538971b5b904f078$var$Mscr,
    Mu: $538971b5b904f078$var$Mu$1,
    NJcy: $538971b5b904f078$var$NJcy,
    Nacute: $538971b5b904f078$var$Nacute,
    Ncaron: $538971b5b904f078$var$Ncaron,
    Ncedil: $538971b5b904f078$var$Ncedil,
    Ncy: $538971b5b904f078$var$Ncy,
    NegativeMediumSpace: $538971b5b904f078$var$NegativeMediumSpace,
    NegativeThickSpace: $538971b5b904f078$var$NegativeThickSpace,
    NegativeThinSpace: $538971b5b904f078$var$NegativeThinSpace,
    NegativeVeryThinSpace: $538971b5b904f078$var$NegativeVeryThinSpace,
    NestedGreaterGreater: $538971b5b904f078$var$NestedGreaterGreater,
    NestedLessLess: $538971b5b904f078$var$NestedLessLess,
    NewLine: $538971b5b904f078$var$NewLine,
    Nfr: $538971b5b904f078$var$Nfr,
    NoBreak: $538971b5b904f078$var$NoBreak,
    NonBreakingSpace: $538971b5b904f078$var$NonBreakingSpace,
    Nopf: $538971b5b904f078$var$Nopf,
    Not: $538971b5b904f078$var$Not,
    NotCongruent: $538971b5b904f078$var$NotCongruent,
    NotCupCap: $538971b5b904f078$var$NotCupCap,
    NotDoubleVerticalBar: $538971b5b904f078$var$NotDoubleVerticalBar,
    NotElement: $538971b5b904f078$var$NotElement,
    NotEqual: $538971b5b904f078$var$NotEqual,
    NotEqualTilde: $538971b5b904f078$var$NotEqualTilde,
    NotExists: $538971b5b904f078$var$NotExists,
    NotGreater: $538971b5b904f078$var$NotGreater,
    NotGreaterEqual: $538971b5b904f078$var$NotGreaterEqual,
    NotGreaterFullEqual: $538971b5b904f078$var$NotGreaterFullEqual,
    NotGreaterGreater: $538971b5b904f078$var$NotGreaterGreater,
    NotGreaterLess: $538971b5b904f078$var$NotGreaterLess,
    NotGreaterSlantEqual: $538971b5b904f078$var$NotGreaterSlantEqual,
    NotGreaterTilde: $538971b5b904f078$var$NotGreaterTilde,
    NotHumpDownHump: $538971b5b904f078$var$NotHumpDownHump,
    NotHumpEqual: $538971b5b904f078$var$NotHumpEqual,
    NotLeftTriangle: $538971b5b904f078$var$NotLeftTriangle,
    NotLeftTriangleBar: $538971b5b904f078$var$NotLeftTriangleBar,
    NotLeftTriangleEqual: $538971b5b904f078$var$NotLeftTriangleEqual,
    NotLess: $538971b5b904f078$var$NotLess,
    NotLessEqual: $538971b5b904f078$var$NotLessEqual,
    NotLessGreater: $538971b5b904f078$var$NotLessGreater,
    NotLessLess: $538971b5b904f078$var$NotLessLess,
    NotLessSlantEqual: $538971b5b904f078$var$NotLessSlantEqual,
    NotLessTilde: $538971b5b904f078$var$NotLessTilde,
    NotNestedGreaterGreater: $538971b5b904f078$var$NotNestedGreaterGreater,
    NotNestedLessLess: $538971b5b904f078$var$NotNestedLessLess,
    NotPrecedes: $538971b5b904f078$var$NotPrecedes,
    NotPrecedesEqual: $538971b5b904f078$var$NotPrecedesEqual,
    NotPrecedesSlantEqual: $538971b5b904f078$var$NotPrecedesSlantEqual,
    NotReverseElement: $538971b5b904f078$var$NotReverseElement,
    NotRightTriangle: $538971b5b904f078$var$NotRightTriangle,
    NotRightTriangleBar: $538971b5b904f078$var$NotRightTriangleBar,
    NotRightTriangleEqual: $538971b5b904f078$var$NotRightTriangleEqual,
    NotSquareSubset: $538971b5b904f078$var$NotSquareSubset,
    NotSquareSubsetEqual: $538971b5b904f078$var$NotSquareSubsetEqual,
    NotSquareSuperset: $538971b5b904f078$var$NotSquareSuperset,
    NotSquareSupersetEqual: $538971b5b904f078$var$NotSquareSupersetEqual,
    NotSubset: $538971b5b904f078$var$NotSubset,
    NotSubsetEqual: $538971b5b904f078$var$NotSubsetEqual,
    NotSucceeds: $538971b5b904f078$var$NotSucceeds,
    NotSucceedsEqual: $538971b5b904f078$var$NotSucceedsEqual,
    NotSucceedsSlantEqual: $538971b5b904f078$var$NotSucceedsSlantEqual,
    NotSucceedsTilde: $538971b5b904f078$var$NotSucceedsTilde,
    NotSuperset: $538971b5b904f078$var$NotSuperset,
    NotSupersetEqual: $538971b5b904f078$var$NotSupersetEqual,
    NotTilde: $538971b5b904f078$var$NotTilde,
    NotTildeEqual: $538971b5b904f078$var$NotTildeEqual,
    NotTildeFullEqual: $538971b5b904f078$var$NotTildeFullEqual,
    NotTildeTilde: $538971b5b904f078$var$NotTildeTilde,
    NotVerticalBar: $538971b5b904f078$var$NotVerticalBar,
    Nscr: $538971b5b904f078$var$Nscr,
    Ntild: $538971b5b904f078$var$Ntild,
    Ntilde: $538971b5b904f078$var$Ntilde$1,
    Nu: $538971b5b904f078$var$Nu$1,
    OElig: $538971b5b904f078$var$OElig$1,
    Oacut: $538971b5b904f078$var$Oacut,
    Oacute: $538971b5b904f078$var$Oacute$1,
    Ocir: $538971b5b904f078$var$Ocir,
    Ocirc: $538971b5b904f078$var$Ocirc$1,
    Ocy: $538971b5b904f078$var$Ocy,
    Odblac: $538971b5b904f078$var$Odblac,
    Ofr: $538971b5b904f078$var$Ofr,
    Ograv: $538971b5b904f078$var$Ograv,
    Ograve: $538971b5b904f078$var$Ograve$1,
    Omacr: $538971b5b904f078$var$Omacr,
    Omega: $538971b5b904f078$var$Omega$1,
    Omicron: $538971b5b904f078$var$Omicron$1,
    Oopf: $538971b5b904f078$var$Oopf,
    OpenCurlyDoubleQuote: $538971b5b904f078$var$OpenCurlyDoubleQuote,
    OpenCurlyQuote: $538971b5b904f078$var$OpenCurlyQuote,
    Or: $538971b5b904f078$var$Or,
    Oscr: $538971b5b904f078$var$Oscr,
    Oslas: $538971b5b904f078$var$Oslas,
    Oslash: $538971b5b904f078$var$Oslash$1,
    Otild: $538971b5b904f078$var$Otild,
    Otilde: $538971b5b904f078$var$Otilde$1,
    Otimes: $538971b5b904f078$var$Otimes,
    Oum: $538971b5b904f078$var$Oum,
    Ouml: $538971b5b904f078$var$Ouml$1,
    OverBar: $538971b5b904f078$var$OverBar,
    OverBrace: $538971b5b904f078$var$OverBrace,
    OverBracket: $538971b5b904f078$var$OverBracket,
    OverParenthesis: $538971b5b904f078$var$OverParenthesis,
    PartialD: $538971b5b904f078$var$PartialD,
    Pcy: $538971b5b904f078$var$Pcy,
    Pfr: $538971b5b904f078$var$Pfr,
    Phi: $538971b5b904f078$var$Phi$1,
    Pi: $538971b5b904f078$var$Pi$1,
    PlusMinus: $538971b5b904f078$var$PlusMinus,
    Poincareplane: $538971b5b904f078$var$Poincareplane,
    Popf: $538971b5b904f078$var$Popf,
    Pr: $538971b5b904f078$var$Pr,
    Precedes: $538971b5b904f078$var$Precedes,
    PrecedesEqual: $538971b5b904f078$var$PrecedesEqual,
    PrecedesSlantEqual: $538971b5b904f078$var$PrecedesSlantEqual,
    PrecedesTilde: $538971b5b904f078$var$PrecedesTilde,
    Prime: $538971b5b904f078$var$Prime$1,
    Product: $538971b5b904f078$var$Product,
    Proportion: $538971b5b904f078$var$Proportion,
    Proportional: $538971b5b904f078$var$Proportional,
    Pscr: $538971b5b904f078$var$Pscr,
    Psi: $538971b5b904f078$var$Psi$1,
    QUO: $538971b5b904f078$var$QUO,
    QUOT: $538971b5b904f078$var$QUOT,
    Qfr: $538971b5b904f078$var$Qfr,
    Qopf: $538971b5b904f078$var$Qopf,
    Qscr: $538971b5b904f078$var$Qscr,
    RBarr: $538971b5b904f078$var$RBarr,
    RE: $538971b5b904f078$var$RE,
    REG: $538971b5b904f078$var$REG,
    Racute: $538971b5b904f078$var$Racute,
    Rang: $538971b5b904f078$var$Rang,
    Rarr: $538971b5b904f078$var$Rarr,
    Rarrtl: $538971b5b904f078$var$Rarrtl,
    Rcaron: $538971b5b904f078$var$Rcaron,
    Rcedil: $538971b5b904f078$var$Rcedil,
    Rcy: $538971b5b904f078$var$Rcy,
    Re: $538971b5b904f078$var$Re,
    ReverseElement: $538971b5b904f078$var$ReverseElement,
    ReverseEquilibrium: $538971b5b904f078$var$ReverseEquilibrium,
    ReverseUpEquilibrium: $538971b5b904f078$var$ReverseUpEquilibrium,
    Rfr: $538971b5b904f078$var$Rfr,
    Rho: $538971b5b904f078$var$Rho$1,
    RightAngleBracket: $538971b5b904f078$var$RightAngleBracket,
    RightArrow: $538971b5b904f078$var$RightArrow,
    RightArrowBar: $538971b5b904f078$var$RightArrowBar,
    RightArrowLeftArrow: $538971b5b904f078$var$RightArrowLeftArrow,
    RightCeiling: $538971b5b904f078$var$RightCeiling,
    RightDoubleBracket: $538971b5b904f078$var$RightDoubleBracket,
    RightDownTeeVector: $538971b5b904f078$var$RightDownTeeVector,
    RightDownVector: $538971b5b904f078$var$RightDownVector,
    RightDownVectorBar: $538971b5b904f078$var$RightDownVectorBar,
    RightFloor: $538971b5b904f078$var$RightFloor,
    RightTee: $538971b5b904f078$var$RightTee,
    RightTeeArrow: $538971b5b904f078$var$RightTeeArrow,
    RightTeeVector: $538971b5b904f078$var$RightTeeVector,
    RightTriangle: $538971b5b904f078$var$RightTriangle,
    RightTriangleBar: $538971b5b904f078$var$RightTriangleBar,
    RightTriangleEqual: $538971b5b904f078$var$RightTriangleEqual,
    RightUpDownVector: $538971b5b904f078$var$RightUpDownVector,
    RightUpTeeVector: $538971b5b904f078$var$RightUpTeeVector,
    RightUpVector: $538971b5b904f078$var$RightUpVector,
    RightUpVectorBar: $538971b5b904f078$var$RightUpVectorBar,
    RightVector: $538971b5b904f078$var$RightVector,
    RightVectorBar: $538971b5b904f078$var$RightVectorBar,
    Rightarrow: $538971b5b904f078$var$Rightarrow,
    Ropf: $538971b5b904f078$var$Ropf,
    RoundImplies: $538971b5b904f078$var$RoundImplies,
    Rrightarrow: $538971b5b904f078$var$Rrightarrow,
    Rscr: $538971b5b904f078$var$Rscr,
    Rsh: $538971b5b904f078$var$Rsh,
    RuleDelayed: $538971b5b904f078$var$RuleDelayed,
    SHCHcy: $538971b5b904f078$var$SHCHcy,
    SHcy: $538971b5b904f078$var$SHcy,
    SOFTcy: $538971b5b904f078$var$SOFTcy,
    Sacute: $538971b5b904f078$var$Sacute,
    Sc: $538971b5b904f078$var$Sc,
    Scaron: $538971b5b904f078$var$Scaron$1,
    Scedil: $538971b5b904f078$var$Scedil,
    Scirc: $538971b5b904f078$var$Scirc,
    Scy: $538971b5b904f078$var$Scy,
    Sfr: $538971b5b904f078$var$Sfr,
    ShortDownArrow: $538971b5b904f078$var$ShortDownArrow,
    ShortLeftArrow: $538971b5b904f078$var$ShortLeftArrow,
    ShortRightArrow: $538971b5b904f078$var$ShortRightArrow,
    ShortUpArrow: $538971b5b904f078$var$ShortUpArrow,
    Sigma: $538971b5b904f078$var$Sigma$1,
    SmallCircle: $538971b5b904f078$var$SmallCircle,
    Sopf: $538971b5b904f078$var$Sopf,
    Sqrt: $538971b5b904f078$var$Sqrt,
    Square: $538971b5b904f078$var$Square,
    SquareIntersection: $538971b5b904f078$var$SquareIntersection,
    SquareSubset: $538971b5b904f078$var$SquareSubset,
    SquareSubsetEqual: $538971b5b904f078$var$SquareSubsetEqual,
    SquareSuperset: $538971b5b904f078$var$SquareSuperset,
    SquareSupersetEqual: $538971b5b904f078$var$SquareSupersetEqual,
    SquareUnion: $538971b5b904f078$var$SquareUnion,
    Sscr: $538971b5b904f078$var$Sscr,
    Star: $538971b5b904f078$var$Star,
    Sub: $538971b5b904f078$var$Sub,
    Subset: $538971b5b904f078$var$Subset,
    SubsetEqual: $538971b5b904f078$var$SubsetEqual,
    Succeeds: $538971b5b904f078$var$Succeeds,
    SucceedsEqual: $538971b5b904f078$var$SucceedsEqual,
    SucceedsSlantEqual: $538971b5b904f078$var$SucceedsSlantEqual,
    SucceedsTilde: $538971b5b904f078$var$SucceedsTilde,
    SuchThat: $538971b5b904f078$var$SuchThat,
    Sum: $538971b5b904f078$var$Sum,
    Sup: $538971b5b904f078$var$Sup,
    Superset: $538971b5b904f078$var$Superset,
    SupersetEqual: $538971b5b904f078$var$SupersetEqual,
    Supset: $538971b5b904f078$var$Supset,
    THOR: $538971b5b904f078$var$THOR,
    THORN: $538971b5b904f078$var$THORN$1,
    TRADE: $538971b5b904f078$var$TRADE,
    TSHcy: $538971b5b904f078$var$TSHcy,
    TScy: $538971b5b904f078$var$TScy,
    Tab: $538971b5b904f078$var$Tab,
    Tau: $538971b5b904f078$var$Tau$1,
    Tcaron: $538971b5b904f078$var$Tcaron,
    Tcedil: $538971b5b904f078$var$Tcedil,
    Tcy: $538971b5b904f078$var$Tcy,
    Tfr: $538971b5b904f078$var$Tfr,
    Therefore: $538971b5b904f078$var$Therefore,
    Theta: $538971b5b904f078$var$Theta$1,
    ThickSpace: $538971b5b904f078$var$ThickSpace,
    ThinSpace: $538971b5b904f078$var$ThinSpace,
    Tilde: $538971b5b904f078$var$Tilde,
    TildeEqual: $538971b5b904f078$var$TildeEqual,
    TildeFullEqual: $538971b5b904f078$var$TildeFullEqual,
    TildeTilde: $538971b5b904f078$var$TildeTilde,
    Topf: $538971b5b904f078$var$Topf,
    TripleDot: $538971b5b904f078$var$TripleDot,
    Tscr: $538971b5b904f078$var$Tscr,
    Tstrok: $538971b5b904f078$var$Tstrok,
    Uacut: $538971b5b904f078$var$Uacut,
    Uacute: $538971b5b904f078$var$Uacute$1,
    Uarr: $538971b5b904f078$var$Uarr,
    Uarrocir: $538971b5b904f078$var$Uarrocir,
    Ubrcy: $538971b5b904f078$var$Ubrcy,
    Ubreve: $538971b5b904f078$var$Ubreve,
    Ucir: $538971b5b904f078$var$Ucir,
    Ucirc: $538971b5b904f078$var$Ucirc$1,
    Ucy: $538971b5b904f078$var$Ucy,
    Udblac: $538971b5b904f078$var$Udblac,
    Ufr: $538971b5b904f078$var$Ufr,
    Ugrav: $538971b5b904f078$var$Ugrav,
    Ugrave: $538971b5b904f078$var$Ugrave$1,
    Umacr: $538971b5b904f078$var$Umacr,
    UnderBar: $538971b5b904f078$var$UnderBar,
    UnderBrace: $538971b5b904f078$var$UnderBrace,
    UnderBracket: $538971b5b904f078$var$UnderBracket,
    UnderParenthesis: $538971b5b904f078$var$UnderParenthesis,
    Union: $538971b5b904f078$var$Union,
    UnionPlus: $538971b5b904f078$var$UnionPlus,
    Uogon: $538971b5b904f078$var$Uogon,
    Uopf: $538971b5b904f078$var$Uopf,
    UpArrow: $538971b5b904f078$var$UpArrow,
    UpArrowBar: $538971b5b904f078$var$UpArrowBar,
    UpArrowDownArrow: $538971b5b904f078$var$UpArrowDownArrow,
    UpDownArrow: $538971b5b904f078$var$UpDownArrow,
    UpEquilibrium: $538971b5b904f078$var$UpEquilibrium,
    UpTee: $538971b5b904f078$var$UpTee,
    UpTeeArrow: $538971b5b904f078$var$UpTeeArrow,
    Uparrow: $538971b5b904f078$var$Uparrow,
    Updownarrow: $538971b5b904f078$var$Updownarrow,
    UpperLeftArrow: $538971b5b904f078$var$UpperLeftArrow,
    UpperRightArrow: $538971b5b904f078$var$UpperRightArrow,
    Upsi: $538971b5b904f078$var$Upsi,
    Upsilon: $538971b5b904f078$var$Upsilon$1,
    Uring: $538971b5b904f078$var$Uring,
    Uscr: $538971b5b904f078$var$Uscr,
    Utilde: $538971b5b904f078$var$Utilde,
    Uum: $538971b5b904f078$var$Uum,
    Uuml: $538971b5b904f078$var$Uuml$1,
    VDash: $538971b5b904f078$var$VDash,
    Vbar: $538971b5b904f078$var$Vbar,
    Vcy: $538971b5b904f078$var$Vcy,
    Vdash: $538971b5b904f078$var$Vdash,
    Vdashl: $538971b5b904f078$var$Vdashl,
    Vee: $538971b5b904f078$var$Vee,
    Verbar: $538971b5b904f078$var$Verbar,
    Vert: $538971b5b904f078$var$Vert,
    VerticalBar: $538971b5b904f078$var$VerticalBar,
    VerticalLine: $538971b5b904f078$var$VerticalLine,
    VerticalSeparator: $538971b5b904f078$var$VerticalSeparator,
    VerticalTilde: $538971b5b904f078$var$VerticalTilde,
    VeryThinSpace: $538971b5b904f078$var$VeryThinSpace,
    Vfr: $538971b5b904f078$var$Vfr,
    Vopf: $538971b5b904f078$var$Vopf,
    Vscr: $538971b5b904f078$var$Vscr,
    Vvdash: $538971b5b904f078$var$Vvdash,
    Wcirc: $538971b5b904f078$var$Wcirc,
    Wedge: $538971b5b904f078$var$Wedge,
    Wfr: $538971b5b904f078$var$Wfr,
    Wopf: $538971b5b904f078$var$Wopf,
    Wscr: $538971b5b904f078$var$Wscr,
    Xfr: $538971b5b904f078$var$Xfr,
    Xi: $538971b5b904f078$var$Xi$1,
    Xopf: $538971b5b904f078$var$Xopf,
    Xscr: $538971b5b904f078$var$Xscr,
    YAcy: $538971b5b904f078$var$YAcy,
    YIcy: $538971b5b904f078$var$YIcy,
    YUcy: $538971b5b904f078$var$YUcy,
    Yacut: $538971b5b904f078$var$Yacut,
    Yacute: $538971b5b904f078$var$Yacute$1,
    Ycirc: $538971b5b904f078$var$Ycirc,
    Ycy: $538971b5b904f078$var$Ycy,
    Yfr: $538971b5b904f078$var$Yfr,
    Yopf: $538971b5b904f078$var$Yopf,
    Yscr: $538971b5b904f078$var$Yscr,
    Yuml: $538971b5b904f078$var$Yuml$1,
    ZHcy: $538971b5b904f078$var$ZHcy,
    Zacute: $538971b5b904f078$var$Zacute,
    Zcaron: $538971b5b904f078$var$Zcaron,
    Zcy: $538971b5b904f078$var$Zcy,
    Zdot: $538971b5b904f078$var$Zdot,
    ZeroWidthSpace: $538971b5b904f078$var$ZeroWidthSpace,
    Zeta: $538971b5b904f078$var$Zeta$1,
    Zfr: $538971b5b904f078$var$Zfr,
    Zopf: $538971b5b904f078$var$Zopf,
    Zscr: $538971b5b904f078$var$Zscr,
    aacut: $538971b5b904f078$var$aacut,
    aacute: $538971b5b904f078$var$aacute$1,
    abreve: $538971b5b904f078$var$abreve,
    ac: $538971b5b904f078$var$ac,
    acE: $538971b5b904f078$var$acE,
    acd: $538971b5b904f078$var$acd,
    acir: $538971b5b904f078$var$acir,
    acirc: $538971b5b904f078$var$acirc$1,
    acut: $538971b5b904f078$var$acut,
    acute: $538971b5b904f078$var$acute$1,
    acy: $538971b5b904f078$var$acy,
    aeli: $538971b5b904f078$var$aeli,
    aelig: $538971b5b904f078$var$aelig$1,
    af: $538971b5b904f078$var$af,
    afr: $538971b5b904f078$var$afr,
    agrav: $538971b5b904f078$var$agrav,
    agrave: $538971b5b904f078$var$agrave$1,
    alefsym: $538971b5b904f078$var$alefsym$1,
    aleph: $538971b5b904f078$var$aleph,
    alpha: $538971b5b904f078$var$alpha$1,
    amacr: $538971b5b904f078$var$amacr,
    amalg: $538971b5b904f078$var$amalg,
    am: $538971b5b904f078$var$am,
    amp: $538971b5b904f078$var$amp$1,
    and: $538971b5b904f078$var$and$1,
    andand: $538971b5b904f078$var$andand,
    andd: $538971b5b904f078$var$andd,
    andslope: $538971b5b904f078$var$andslope,
    andv: $538971b5b904f078$var$andv,
    ang: $538971b5b904f078$var$ang$1,
    ange: $538971b5b904f078$var$ange,
    angle: $538971b5b904f078$var$angle,
    angmsd: $538971b5b904f078$var$angmsd,
    angmsdaa: $538971b5b904f078$var$angmsdaa,
    angmsdab: $538971b5b904f078$var$angmsdab,
    angmsdac: $538971b5b904f078$var$angmsdac,
    angmsdad: $538971b5b904f078$var$angmsdad,
    angmsdae: $538971b5b904f078$var$angmsdae,
    angmsdaf: $538971b5b904f078$var$angmsdaf,
    angmsdag: $538971b5b904f078$var$angmsdag,
    angmsdah: $538971b5b904f078$var$angmsdah,
    angrt: $538971b5b904f078$var$angrt,
    angrtvb: $538971b5b904f078$var$angrtvb,
    angrtvbd: $538971b5b904f078$var$angrtvbd,
    angsph: $538971b5b904f078$var$angsph,
    angst: $538971b5b904f078$var$angst,
    angzarr: $538971b5b904f078$var$angzarr,
    aogon: $538971b5b904f078$var$aogon,
    aopf: $538971b5b904f078$var$aopf,
    ap: $538971b5b904f078$var$ap,
    apE: $538971b5b904f078$var$apE,
    apacir: $538971b5b904f078$var$apacir,
    ape: $538971b5b904f078$var$ape,
    apid: $538971b5b904f078$var$apid,
    apos: $538971b5b904f078$var$apos,
    approx: $538971b5b904f078$var$approx,
    approxeq: $538971b5b904f078$var$approxeq,
    arin: $538971b5b904f078$var$arin,
    aring: $538971b5b904f078$var$aring$1,
    ascr: $538971b5b904f078$var$ascr,
    ast: $538971b5b904f078$var$ast,
    asymp: $538971b5b904f078$var$asymp$1,
    asympeq: $538971b5b904f078$var$asympeq,
    atild: $538971b5b904f078$var$atild,
    atilde: $538971b5b904f078$var$atilde$1,
    aum: $538971b5b904f078$var$aum,
    auml: $538971b5b904f078$var$auml$1,
    awconint: $538971b5b904f078$var$awconint,
    awint: $538971b5b904f078$var$awint,
    bNot: $538971b5b904f078$var$bNot,
    backcong: $538971b5b904f078$var$backcong,
    backepsilon: $538971b5b904f078$var$backepsilon,
    backprime: $538971b5b904f078$var$backprime,
    backsim: $538971b5b904f078$var$backsim,
    backsimeq: $538971b5b904f078$var$backsimeq,
    barvee: $538971b5b904f078$var$barvee,
    barwed: $538971b5b904f078$var$barwed,
    barwedge: $538971b5b904f078$var$barwedge,
    bbrk: $538971b5b904f078$var$bbrk,
    bbrktbrk: $538971b5b904f078$var$bbrktbrk,
    bcong: $538971b5b904f078$var$bcong,
    bcy: $538971b5b904f078$var$bcy,
    bdquo: $538971b5b904f078$var$bdquo$1,
    becaus: $538971b5b904f078$var$becaus,
    because: $538971b5b904f078$var$because,
    bemptyv: $538971b5b904f078$var$bemptyv,
    bepsi: $538971b5b904f078$var$bepsi,
    bernou: $538971b5b904f078$var$bernou,
    beta: $538971b5b904f078$var$beta$1,
    beth: $538971b5b904f078$var$beth,
    between: $538971b5b904f078$var$between,
    bfr: $538971b5b904f078$var$bfr,
    bigcap: $538971b5b904f078$var$bigcap,
    bigcirc: $538971b5b904f078$var$bigcirc,
    bigcup: $538971b5b904f078$var$bigcup,
    bigodot: $538971b5b904f078$var$bigodot,
    bigoplus: $538971b5b904f078$var$bigoplus,
    bigotimes: $538971b5b904f078$var$bigotimes,
    bigsqcup: $538971b5b904f078$var$bigsqcup,
    bigstar: $538971b5b904f078$var$bigstar,
    bigtriangledown: $538971b5b904f078$var$bigtriangledown,
    bigtriangleup: $538971b5b904f078$var$bigtriangleup,
    biguplus: $538971b5b904f078$var$biguplus,
    bigvee: $538971b5b904f078$var$bigvee,
    bigwedge: $538971b5b904f078$var$bigwedge,
    bkarow: $538971b5b904f078$var$bkarow,
    blacklozenge: $538971b5b904f078$var$blacklozenge,
    blacksquare: $538971b5b904f078$var$blacksquare,
    blacktriangle: $538971b5b904f078$var$blacktriangle,
    blacktriangledown: $538971b5b904f078$var$blacktriangledown,
    blacktriangleleft: $538971b5b904f078$var$blacktriangleleft,
    blacktriangleright: $538971b5b904f078$var$blacktriangleright,
    blank: $538971b5b904f078$var$blank,
    blk12: $538971b5b904f078$var$blk12,
    blk14: $538971b5b904f078$var$blk14,
    blk34: $538971b5b904f078$var$blk34,
    block: $538971b5b904f078$var$block,
    bne: $538971b5b904f078$var$bne,
    bnequiv: $538971b5b904f078$var$bnequiv,
    bnot: $538971b5b904f078$var$bnot,
    bopf: $538971b5b904f078$var$bopf,
    bot: $538971b5b904f078$var$bot,
    bottom: $538971b5b904f078$var$bottom,
    bowtie: $538971b5b904f078$var$bowtie,
    boxDL: $538971b5b904f078$var$boxDL,
    boxDR: $538971b5b904f078$var$boxDR,
    boxDl: $538971b5b904f078$var$boxDl,
    boxDr: $538971b5b904f078$var$boxDr,
    boxH: $538971b5b904f078$var$boxH,
    boxHD: $538971b5b904f078$var$boxHD,
    boxHU: $538971b5b904f078$var$boxHU,
    boxHd: $538971b5b904f078$var$boxHd,
    boxHu: $538971b5b904f078$var$boxHu,
    boxUL: $538971b5b904f078$var$boxUL,
    boxUR: $538971b5b904f078$var$boxUR,
    boxUl: $538971b5b904f078$var$boxUl,
    boxUr: $538971b5b904f078$var$boxUr,
    boxV: $538971b5b904f078$var$boxV,
    boxVH: $538971b5b904f078$var$boxVH,
    boxVL: $538971b5b904f078$var$boxVL,
    boxVR: $538971b5b904f078$var$boxVR,
    boxVh: $538971b5b904f078$var$boxVh,
    boxVl: $538971b5b904f078$var$boxVl,
    boxVr: $538971b5b904f078$var$boxVr,
    boxbox: $538971b5b904f078$var$boxbox,
    boxdL: $538971b5b904f078$var$boxdL,
    boxdR: $538971b5b904f078$var$boxdR,
    boxdl: $538971b5b904f078$var$boxdl,
    boxdr: $538971b5b904f078$var$boxdr,
    boxh: $538971b5b904f078$var$boxh,
    boxhD: $538971b5b904f078$var$boxhD,
    boxhU: $538971b5b904f078$var$boxhU,
    boxhd: $538971b5b904f078$var$boxhd,
    boxhu: $538971b5b904f078$var$boxhu,
    boxminus: $538971b5b904f078$var$boxminus,
    boxplus: $538971b5b904f078$var$boxplus,
    boxtimes: $538971b5b904f078$var$boxtimes,
    boxuL: $538971b5b904f078$var$boxuL,
    boxuR: $538971b5b904f078$var$boxuR,
    boxul: $538971b5b904f078$var$boxul,
    boxur: $538971b5b904f078$var$boxur,
    boxv: $538971b5b904f078$var$boxv,
    boxvH: $538971b5b904f078$var$boxvH,
    boxvL: $538971b5b904f078$var$boxvL,
    boxvR: $538971b5b904f078$var$boxvR,
    boxvh: $538971b5b904f078$var$boxvh,
    boxvl: $538971b5b904f078$var$boxvl,
    boxvr: $538971b5b904f078$var$boxvr,
    bprime: $538971b5b904f078$var$bprime,
    breve: $538971b5b904f078$var$breve,
    brvba: $538971b5b904f078$var$brvba,
    brvbar: $538971b5b904f078$var$brvbar$1,
    bscr: $538971b5b904f078$var$bscr,
    bsemi: $538971b5b904f078$var$bsemi,
    bsim: $538971b5b904f078$var$bsim,
    bsime: $538971b5b904f078$var$bsime,
    bsol: $538971b5b904f078$var$bsol,
    bsolb: $538971b5b904f078$var$bsolb,
    bsolhsub: $538971b5b904f078$var$bsolhsub,
    bull: $538971b5b904f078$var$bull$1,
    bullet: $538971b5b904f078$var$bullet,
    bump: $538971b5b904f078$var$bump,
    bumpE: $538971b5b904f078$var$bumpE,
    bumpe: $538971b5b904f078$var$bumpe,
    bumpeq: $538971b5b904f078$var$bumpeq,
    cacute: $538971b5b904f078$var$cacute,
    cap: $538971b5b904f078$var$cap$2,
    capand: $538971b5b904f078$var$capand,
    capbrcup: $538971b5b904f078$var$capbrcup,
    capcap: $538971b5b904f078$var$capcap,
    capcup: $538971b5b904f078$var$capcup,
    capdot: $538971b5b904f078$var$capdot,
    caps: $538971b5b904f078$var$caps,
    caret: $538971b5b904f078$var$caret,
    caron: $538971b5b904f078$var$caron,
    ccaps: $538971b5b904f078$var$ccaps,
    ccaron: $538971b5b904f078$var$ccaron,
    ccedi: $538971b5b904f078$var$ccedi,
    ccedil: $538971b5b904f078$var$ccedil$1,
    ccirc: $538971b5b904f078$var$ccirc,
    ccups: $538971b5b904f078$var$ccups,
    ccupssm: $538971b5b904f078$var$ccupssm,
    cdot: $538971b5b904f078$var$cdot,
    cedi: $538971b5b904f078$var$cedi,
    cedil: $538971b5b904f078$var$cedil$1,
    cemptyv: $538971b5b904f078$var$cemptyv,
    cen: $538971b5b904f078$var$cen,
    cent: $538971b5b904f078$var$cent$1,
    centerdot: $538971b5b904f078$var$centerdot,
    cfr: $538971b5b904f078$var$cfr,
    chcy: $538971b5b904f078$var$chcy,
    check: $538971b5b904f078$var$check,
    checkmark: $538971b5b904f078$var$checkmark,
    chi: $538971b5b904f078$var$chi$1,
    cir: $538971b5b904f078$var$cir,
    cirE: $538971b5b904f078$var$cirE,
    circ: $538971b5b904f078$var$circ$1,
    circeq: $538971b5b904f078$var$circeq,
    circlearrowleft: $538971b5b904f078$var$circlearrowleft,
    circlearrowright: $538971b5b904f078$var$circlearrowright,
    circledR: $538971b5b904f078$var$circledR,
    circledS: $538971b5b904f078$var$circledS,
    circledast: $538971b5b904f078$var$circledast,
    circledcirc: $538971b5b904f078$var$circledcirc,
    circleddash: $538971b5b904f078$var$circleddash,
    cire: $538971b5b904f078$var$cire,
    cirfnint: $538971b5b904f078$var$cirfnint,
    cirmid: $538971b5b904f078$var$cirmid,
    cirscir: $538971b5b904f078$var$cirscir,
    clubs: $538971b5b904f078$var$clubs$1,
    clubsuit: $538971b5b904f078$var$clubsuit,
    colon: $538971b5b904f078$var$colon$3,
    colone: $538971b5b904f078$var$colone,
    coloneq: $538971b5b904f078$var$coloneq,
    comma: $538971b5b904f078$var$comma$2,
    commat: $538971b5b904f078$var$commat,
    comp: $538971b5b904f078$var$comp,
    compfn: $538971b5b904f078$var$compfn,
    complement: $538971b5b904f078$var$complement,
    complexes: $538971b5b904f078$var$complexes,
    cong: $538971b5b904f078$var$cong$1,
    congdot: $538971b5b904f078$var$congdot,
    conint: $538971b5b904f078$var$conint,
    copf: $538971b5b904f078$var$copf,
    coprod: $538971b5b904f078$var$coprod,
    cop: $538971b5b904f078$var$cop,
    copy: $538971b5b904f078$var$copy$1,
    copysr: $538971b5b904f078$var$copysr,
    crarr: $538971b5b904f078$var$crarr$1,
    cross: $538971b5b904f078$var$cross,
    cscr: $538971b5b904f078$var$cscr,
    csub: $538971b5b904f078$var$csub,
    csube: $538971b5b904f078$var$csube,
    csup: $538971b5b904f078$var$csup,
    csupe: $538971b5b904f078$var$csupe,
    ctdot: $538971b5b904f078$var$ctdot,
    cudarrl: $538971b5b904f078$var$cudarrl,
    cudarrr: $538971b5b904f078$var$cudarrr,
    cuepr: $538971b5b904f078$var$cuepr,
    cuesc: $538971b5b904f078$var$cuesc,
    cularr: $538971b5b904f078$var$cularr,
    cularrp: $538971b5b904f078$var$cularrp,
    cup: $538971b5b904f078$var$cup$1,
    cupbrcap: $538971b5b904f078$var$cupbrcap,
    cupcap: $538971b5b904f078$var$cupcap,
    cupcup: $538971b5b904f078$var$cupcup,
    cupdot: $538971b5b904f078$var$cupdot,
    cupor: $538971b5b904f078$var$cupor,
    cups: $538971b5b904f078$var$cups,
    curarr: $538971b5b904f078$var$curarr,
    curarrm: $538971b5b904f078$var$curarrm,
    curlyeqprec: $538971b5b904f078$var$curlyeqprec,
    curlyeqsucc: $538971b5b904f078$var$curlyeqsucc,
    curlyvee: $538971b5b904f078$var$curlyvee,
    curlywedge: $538971b5b904f078$var$curlywedge,
    curre: $538971b5b904f078$var$curre,
    curren: $538971b5b904f078$var$curren$1,
    curvearrowleft: $538971b5b904f078$var$curvearrowleft,
    curvearrowright: $538971b5b904f078$var$curvearrowright,
    cuvee: $538971b5b904f078$var$cuvee,
    cuwed: $538971b5b904f078$var$cuwed,
    cwconint: $538971b5b904f078$var$cwconint,
    cwint: $538971b5b904f078$var$cwint,
    cylcty: $538971b5b904f078$var$cylcty,
    dArr: $538971b5b904f078$var$dArr$1,
    dHar: $538971b5b904f078$var$dHar,
    dagger: $538971b5b904f078$var$dagger$1,
    daleth: $538971b5b904f078$var$daleth,
    darr: $538971b5b904f078$var$darr$1,
    dash: $538971b5b904f078$var$dash$8,
    dashv: $538971b5b904f078$var$dashv,
    dbkarow: $538971b5b904f078$var$dbkarow,
    dblac: $538971b5b904f078$var$dblac,
    dcaron: $538971b5b904f078$var$dcaron,
    dcy: $538971b5b904f078$var$dcy,
    dd: $538971b5b904f078$var$dd$1,
    ddagger: $538971b5b904f078$var$ddagger,
    ddarr: $538971b5b904f078$var$ddarr,
    ddotseq: $538971b5b904f078$var$ddotseq,
    de: $538971b5b904f078$var$de,
    deg: $538971b5b904f078$var$deg$1,
    delta: $538971b5b904f078$var$delta$1,
    demptyv: $538971b5b904f078$var$demptyv,
    dfisht: $538971b5b904f078$var$dfisht,
    dfr: $538971b5b904f078$var$dfr,
    dharl: $538971b5b904f078$var$dharl,
    dharr: $538971b5b904f078$var$dharr,
    diam: $538971b5b904f078$var$diam,
    diamond: $538971b5b904f078$var$diamond,
    diamondsuit: $538971b5b904f078$var$diamondsuit,
    diams: $538971b5b904f078$var$diams$1,
    die: $538971b5b904f078$var$die,
    digamma: $538971b5b904f078$var$digamma,
    disin: $538971b5b904f078$var$disin,
    div: $538971b5b904f078$var$div,
    divid: $538971b5b904f078$var$divid,
    divide: $538971b5b904f078$var$divide$1,
    divideontimes: $538971b5b904f078$var$divideontimes,
    divonx: $538971b5b904f078$var$divonx,
    djcy: $538971b5b904f078$var$djcy,
    dlcorn: $538971b5b904f078$var$dlcorn,
    dlcrop: $538971b5b904f078$var$dlcrop,
    dollar: $538971b5b904f078$var$dollar,
    dopf: $538971b5b904f078$var$dopf,
    dot: $538971b5b904f078$var$dot$4,
    doteq: $538971b5b904f078$var$doteq,
    doteqdot: $538971b5b904f078$var$doteqdot,
    dotminus: $538971b5b904f078$var$dotminus,
    dotplus: $538971b5b904f078$var$dotplus,
    dotsquare: $538971b5b904f078$var$dotsquare,
    doublebarwedge: $538971b5b904f078$var$doublebarwedge,
    downarrow: $538971b5b904f078$var$downarrow,
    downdownarrows: $538971b5b904f078$var$downdownarrows,
    downharpoonleft: $538971b5b904f078$var$downharpoonleft,
    downharpoonright: $538971b5b904f078$var$downharpoonright,
    drbkarow: $538971b5b904f078$var$drbkarow,
    drcorn: $538971b5b904f078$var$drcorn,
    drcrop: $538971b5b904f078$var$drcrop,
    dscr: $538971b5b904f078$var$dscr,
    dscy: $538971b5b904f078$var$dscy,
    dsol: $538971b5b904f078$var$dsol,
    dstrok: $538971b5b904f078$var$dstrok,
    dtdot: $538971b5b904f078$var$dtdot,
    dtri: $538971b5b904f078$var$dtri,
    dtrif: $538971b5b904f078$var$dtrif,
    duarr: $538971b5b904f078$var$duarr,
    duhar: $538971b5b904f078$var$duhar,
    dwangle: $538971b5b904f078$var$dwangle,
    dzcy: $538971b5b904f078$var$dzcy,
    dzigrarr: $538971b5b904f078$var$dzigrarr,
    eDDot: $538971b5b904f078$var$eDDot,
    eDot: $538971b5b904f078$var$eDot,
    eacut: $538971b5b904f078$var$eacut,
    eacute: $538971b5b904f078$var$eacute$1,
    easter: $538971b5b904f078$var$easter,
    ecaron: $538971b5b904f078$var$ecaron,
    ecir: $538971b5b904f078$var$ecir,
    ecirc: $538971b5b904f078$var$ecirc$1,
    ecolon: $538971b5b904f078$var$ecolon,
    ecy: $538971b5b904f078$var$ecy,
    edot: $538971b5b904f078$var$edot,
    ee: $538971b5b904f078$var$ee,
    efDot: $538971b5b904f078$var$efDot,
    efr: $538971b5b904f078$var$efr,
    eg: $538971b5b904f078$var$eg,
    egrav: $538971b5b904f078$var$egrav,
    egrave: $538971b5b904f078$var$egrave$1,
    egs: $538971b5b904f078$var$egs,
    egsdot: $538971b5b904f078$var$egsdot,
    el: $538971b5b904f078$var$el,
    elinters: $538971b5b904f078$var$elinters,
    ell: $538971b5b904f078$var$ell,
    els: $538971b5b904f078$var$els,
    elsdot: $538971b5b904f078$var$elsdot,
    emacr: $538971b5b904f078$var$emacr,
    empty: $538971b5b904f078$var$empty$3,
    emptyset: $538971b5b904f078$var$emptyset,
    emptyv: $538971b5b904f078$var$emptyv,
    emsp13: $538971b5b904f078$var$emsp13,
    emsp14: $538971b5b904f078$var$emsp14,
    emsp: $538971b5b904f078$var$emsp$1,
    eng: $538971b5b904f078$var$eng,
    ensp: $538971b5b904f078$var$ensp$1,
    eogon: $538971b5b904f078$var$eogon,
    eopf: $538971b5b904f078$var$eopf,
    epar: $538971b5b904f078$var$epar,
    eparsl: $538971b5b904f078$var$eparsl,
    eplus: $538971b5b904f078$var$eplus,
    epsi: $538971b5b904f078$var$epsi,
    epsilon: $538971b5b904f078$var$epsilon$1,
    epsiv: $538971b5b904f078$var$epsiv,
    eqcirc: $538971b5b904f078$var$eqcirc,
    eqcolon: $538971b5b904f078$var$eqcolon,
    eqsim: $538971b5b904f078$var$eqsim,
    eqslantgtr: $538971b5b904f078$var$eqslantgtr,
    eqslantless: $538971b5b904f078$var$eqslantless,
    equals: $538971b5b904f078$var$equals,
    equest: $538971b5b904f078$var$equest,
    equiv: $538971b5b904f078$var$equiv$1,
    equivDD: $538971b5b904f078$var$equivDD,
    eqvparsl: $538971b5b904f078$var$eqvparsl,
    erDot: $538971b5b904f078$var$erDot,
    erarr: $538971b5b904f078$var$erarr,
    escr: $538971b5b904f078$var$escr,
    esdot: $538971b5b904f078$var$esdot,
    esim: $538971b5b904f078$var$esim,
    eta: $538971b5b904f078$var$eta$1,
    et: $538971b5b904f078$var$et,
    eth: $538971b5b904f078$var$eth$1,
    eum: $538971b5b904f078$var$eum,
    euml: $538971b5b904f078$var$euml$1,
    euro: $538971b5b904f078$var$euro$1,
    excl: $538971b5b904f078$var$excl,
    exist: $538971b5b904f078$var$exist$1,
    expectation: $538971b5b904f078$var$expectation,
    exponentiale: $538971b5b904f078$var$exponentiale,
    fallingdotseq: $538971b5b904f078$var$fallingdotseq,
    fcy: $538971b5b904f078$var$fcy,
    female: $538971b5b904f078$var$female,
    ffilig: $538971b5b904f078$var$ffilig,
    fflig: $538971b5b904f078$var$fflig,
    ffllig: $538971b5b904f078$var$ffllig,
    ffr: $538971b5b904f078$var$ffr,
    filig: $538971b5b904f078$var$filig,
    fjlig: $538971b5b904f078$var$fjlig,
    flat: $538971b5b904f078$var$flat,
    fllig: $538971b5b904f078$var$fllig,
    fltns: $538971b5b904f078$var$fltns,
    fnof: $538971b5b904f078$var$fnof$1,
    fopf: $538971b5b904f078$var$fopf,
    forall: $538971b5b904f078$var$forall$1,
    fork: $538971b5b904f078$var$fork,
    forkv: $538971b5b904f078$var$forkv,
    fpartint: $538971b5b904f078$var$fpartint,
    frac1: $538971b5b904f078$var$frac1,
    frac12: $538971b5b904f078$var$frac12$1,
    frac13: $538971b5b904f078$var$frac13,
    frac14: $538971b5b904f078$var$frac14$1,
    frac15: $538971b5b904f078$var$frac15,
    frac16: $538971b5b904f078$var$frac16,
    frac18: $538971b5b904f078$var$frac18,
    frac23: $538971b5b904f078$var$frac23,
    frac25: $538971b5b904f078$var$frac25,
    frac3: $538971b5b904f078$var$frac3,
    frac34: $538971b5b904f078$var$frac34$1,
    frac35: $538971b5b904f078$var$frac35,
    frac38: $538971b5b904f078$var$frac38,
    frac45: $538971b5b904f078$var$frac45,
    frac56: $538971b5b904f078$var$frac56,
    frac58: $538971b5b904f078$var$frac58,
    frac78: $538971b5b904f078$var$frac78,
    frasl: $538971b5b904f078$var$frasl$1,
    frown: $538971b5b904f078$var$frown,
    fscr: $538971b5b904f078$var$fscr,
    gE: $538971b5b904f078$var$gE,
    gEl: $538971b5b904f078$var$gEl,
    gacute: $538971b5b904f078$var$gacute,
    gamma: $538971b5b904f078$var$gamma$1,
    gammad: $538971b5b904f078$var$gammad,
    gap: $538971b5b904f078$var$gap,
    gbreve: $538971b5b904f078$var$gbreve,
    gcirc: $538971b5b904f078$var$gcirc,
    gcy: $538971b5b904f078$var$gcy,
    gdot: $538971b5b904f078$var$gdot,
    ge: $538971b5b904f078$var$ge$1,
    gel: $538971b5b904f078$var$gel,
    geq: $538971b5b904f078$var$geq,
    geqq: $538971b5b904f078$var$geqq,
    geqslant: $538971b5b904f078$var$geqslant,
    ges: $538971b5b904f078$var$ges,
    gescc: $538971b5b904f078$var$gescc,
    gesdot: $538971b5b904f078$var$gesdot,
    gesdoto: $538971b5b904f078$var$gesdoto,
    gesdotol: $538971b5b904f078$var$gesdotol,
    gesl: $538971b5b904f078$var$gesl,
    gesles: $538971b5b904f078$var$gesles,
    gfr: $538971b5b904f078$var$gfr,
    gg: $538971b5b904f078$var$gg,
    ggg: $538971b5b904f078$var$ggg,
    gimel: $538971b5b904f078$var$gimel,
    gjcy: $538971b5b904f078$var$gjcy,
    gl: $538971b5b904f078$var$gl,
    glE: $538971b5b904f078$var$glE,
    gla: $538971b5b904f078$var$gla,
    glj: $538971b5b904f078$var$glj,
    gnE: $538971b5b904f078$var$gnE,
    gnap: $538971b5b904f078$var$gnap,
    gnapprox: $538971b5b904f078$var$gnapprox,
    gne: $538971b5b904f078$var$gne,
    gneq: $538971b5b904f078$var$gneq,
    gneqq: $538971b5b904f078$var$gneqq,
    gnsim: $538971b5b904f078$var$gnsim,
    gopf: $538971b5b904f078$var$gopf,
    grave: $538971b5b904f078$var$grave,
    gscr: $538971b5b904f078$var$gscr,
    gsim: $538971b5b904f078$var$gsim,
    gsime: $538971b5b904f078$var$gsime,
    gsiml: $538971b5b904f078$var$gsiml,
    g: $538971b5b904f078$var$g,
    gt: $538971b5b904f078$var$gt$1,
    gtcc: $538971b5b904f078$var$gtcc,
    gtcir: $538971b5b904f078$var$gtcir,
    gtdot: $538971b5b904f078$var$gtdot,
    gtlPar: $538971b5b904f078$var$gtlPar,
    gtquest: $538971b5b904f078$var$gtquest,
    gtrapprox: $538971b5b904f078$var$gtrapprox,
    gtrarr: $538971b5b904f078$var$gtrarr,
    gtrdot: $538971b5b904f078$var$gtrdot,
    gtreqless: $538971b5b904f078$var$gtreqless,
    gtreqqless: $538971b5b904f078$var$gtreqqless,
    gtrless: $538971b5b904f078$var$gtrless,
    gtrsim: $538971b5b904f078$var$gtrsim,
    gvertneqq: $538971b5b904f078$var$gvertneqq,
    gvnE: $538971b5b904f078$var$gvnE,
    hArr: $538971b5b904f078$var$hArr$1,
    hairsp: $538971b5b904f078$var$hairsp,
    half: $538971b5b904f078$var$half,
    hamilt: $538971b5b904f078$var$hamilt,
    hardcy: $538971b5b904f078$var$hardcy,
    harr: $538971b5b904f078$var$harr$1,
    harrcir: $538971b5b904f078$var$harrcir,
    harrw: $538971b5b904f078$var$harrw,
    hbar: $538971b5b904f078$var$hbar,
    hcirc: $538971b5b904f078$var$hcirc,
    hearts: $538971b5b904f078$var$hearts$1,
    heartsuit: $538971b5b904f078$var$heartsuit,
    hellip: $538971b5b904f078$var$hellip$1,
    hercon: $538971b5b904f078$var$hercon,
    hfr: $538971b5b904f078$var$hfr,
    hksearow: $538971b5b904f078$var$hksearow,
    hkswarow: $538971b5b904f078$var$hkswarow,
    hoarr: $538971b5b904f078$var$hoarr,
    homtht: $538971b5b904f078$var$homtht,
    hookleftarrow: $538971b5b904f078$var$hookleftarrow,
    hookrightarrow: $538971b5b904f078$var$hookrightarrow,
    hopf: $538971b5b904f078$var$hopf,
    horbar: $538971b5b904f078$var$horbar,
    hscr: $538971b5b904f078$var$hscr,
    hslash: $538971b5b904f078$var$hslash,
    hstrok: $538971b5b904f078$var$hstrok,
    hybull: $538971b5b904f078$var$hybull,
    hyphen: $538971b5b904f078$var$hyphen,
    iacut: $538971b5b904f078$var$iacut,
    iacute: $538971b5b904f078$var$iacute$1,
    ic: $538971b5b904f078$var$ic,
    icir: $538971b5b904f078$var$icir,
    icirc: $538971b5b904f078$var$icirc$1,
    icy: $538971b5b904f078$var$icy,
    iecy: $538971b5b904f078$var$iecy,
    iexc: $538971b5b904f078$var$iexc,
    iexcl: $538971b5b904f078$var$iexcl$1,
    iff: $538971b5b904f078$var$iff,
    ifr: $538971b5b904f078$var$ifr,
    igrav: $538971b5b904f078$var$igrav,
    igrave: $538971b5b904f078$var$igrave$1,
    ii: $538971b5b904f078$var$ii,
    iiiint: $538971b5b904f078$var$iiiint,
    iiint: $538971b5b904f078$var$iiint,
    iinfin: $538971b5b904f078$var$iinfin,
    iiota: $538971b5b904f078$var$iiota,
    ijlig: $538971b5b904f078$var$ijlig,
    imacr: $538971b5b904f078$var$imacr,
    image: $538971b5b904f078$var$image$3,
    imagline: $538971b5b904f078$var$imagline,
    imagpart: $538971b5b904f078$var$imagpart,
    imath: $538971b5b904f078$var$imath,
    imof: $538971b5b904f078$var$imof,
    imped: $538971b5b904f078$var$imped,
    "in": "\u2208",
    incare: $538971b5b904f078$var$incare,
    infin: $538971b5b904f078$var$infin$1,
    infintie: $538971b5b904f078$var$infintie,
    inodot: $538971b5b904f078$var$inodot,
    int: $538971b5b904f078$var$int$1,
    intcal: $538971b5b904f078$var$intcal,
    integers: $538971b5b904f078$var$integers,
    intercal: $538971b5b904f078$var$intercal,
    intlarhk: $538971b5b904f078$var$intlarhk,
    intprod: $538971b5b904f078$var$intprod,
    iocy: $538971b5b904f078$var$iocy,
    iogon: $538971b5b904f078$var$iogon,
    iopf: $538971b5b904f078$var$iopf,
    iota: $538971b5b904f078$var$iota$1,
    iprod: $538971b5b904f078$var$iprod,
    iques: $538971b5b904f078$var$iques,
    iquest: $538971b5b904f078$var$iquest$1,
    iscr: $538971b5b904f078$var$iscr,
    isin: $538971b5b904f078$var$isin$1,
    isinE: $538971b5b904f078$var$isinE,
    isindot: $538971b5b904f078$var$isindot,
    isins: $538971b5b904f078$var$isins,
    isinsv: $538971b5b904f078$var$isinsv,
    isinv: $538971b5b904f078$var$isinv,
    it: $538971b5b904f078$var$it,
    itilde: $538971b5b904f078$var$itilde,
    iukcy: $538971b5b904f078$var$iukcy,
    ium: $538971b5b904f078$var$ium,
    iuml: $538971b5b904f078$var$iuml$1,
    jcirc: $538971b5b904f078$var$jcirc,
    jcy: $538971b5b904f078$var$jcy,
    jfr: $538971b5b904f078$var$jfr,
    jmath: $538971b5b904f078$var$jmath,
    jopf: $538971b5b904f078$var$jopf,
    jscr: $538971b5b904f078$var$jscr,
    jsercy: $538971b5b904f078$var$jsercy,
    jukcy: $538971b5b904f078$var$jukcy,
    kappa: $538971b5b904f078$var$kappa$1,
    kappav: $538971b5b904f078$var$kappav,
    kcedil: $538971b5b904f078$var$kcedil,
    kcy: $538971b5b904f078$var$kcy,
    kfr: $538971b5b904f078$var$kfr,
    kgreen: $538971b5b904f078$var$kgreen,
    khcy: $538971b5b904f078$var$khcy,
    kjcy: $538971b5b904f078$var$kjcy,
    kopf: $538971b5b904f078$var$kopf,
    kscr: $538971b5b904f078$var$kscr,
    lAarr: $538971b5b904f078$var$lAarr,
    lArr: $538971b5b904f078$var$lArr$1,
    lAtail: $538971b5b904f078$var$lAtail,
    lBarr: $538971b5b904f078$var$lBarr,
    lE: $538971b5b904f078$var$lE,
    lEg: $538971b5b904f078$var$lEg,
    lHar: $538971b5b904f078$var$lHar,
    lacute: $538971b5b904f078$var$lacute,
    laemptyv: $538971b5b904f078$var$laemptyv,
    lagran: $538971b5b904f078$var$lagran,
    lambda: $538971b5b904f078$var$lambda$1,
    lang: $538971b5b904f078$var$lang$1,
    langd: $538971b5b904f078$var$langd,
    langle: $538971b5b904f078$var$langle,
    lap: $538971b5b904f078$var$lap,
    laqu: $538971b5b904f078$var$laqu,
    laquo: $538971b5b904f078$var$laquo$1,
    larr: $538971b5b904f078$var$larr$1,
    larrb: $538971b5b904f078$var$larrb,
    larrbfs: $538971b5b904f078$var$larrbfs,
    larrfs: $538971b5b904f078$var$larrfs,
    larrhk: $538971b5b904f078$var$larrhk,
    larrlp: $538971b5b904f078$var$larrlp,
    larrpl: $538971b5b904f078$var$larrpl,
    larrsim: $538971b5b904f078$var$larrsim,
    larrtl: $538971b5b904f078$var$larrtl,
    lat: $538971b5b904f078$var$lat,
    latail: $538971b5b904f078$var$latail,
    late: $538971b5b904f078$var$late,
    lates: $538971b5b904f078$var$lates,
    lbarr: $538971b5b904f078$var$lbarr,
    lbbrk: $538971b5b904f078$var$lbbrk,
    lbrace: $538971b5b904f078$var$lbrace,
    lbrack: $538971b5b904f078$var$lbrack,
    lbrke: $538971b5b904f078$var$lbrke,
    lbrksld: $538971b5b904f078$var$lbrksld,
    lbrkslu: $538971b5b904f078$var$lbrkslu,
    lcaron: $538971b5b904f078$var$lcaron,
    lcedil: $538971b5b904f078$var$lcedil,
    lceil: $538971b5b904f078$var$lceil$1,
    lcub: $538971b5b904f078$var$lcub,
    lcy: $538971b5b904f078$var$lcy,
    ldca: $538971b5b904f078$var$ldca,
    ldquo: $538971b5b904f078$var$ldquo$1,
    ldquor: $538971b5b904f078$var$ldquor,
    ldrdhar: $538971b5b904f078$var$ldrdhar,
    ldrushar: $538971b5b904f078$var$ldrushar,
    ldsh: $538971b5b904f078$var$ldsh,
    le: $538971b5b904f078$var$le$1,
    leftarrow: $538971b5b904f078$var$leftarrow,
    leftarrowtail: $538971b5b904f078$var$leftarrowtail,
    leftharpoondown: $538971b5b904f078$var$leftharpoondown,
    leftharpoonup: $538971b5b904f078$var$leftharpoonup,
    leftleftarrows: $538971b5b904f078$var$leftleftarrows,
    leftrightarrow: $538971b5b904f078$var$leftrightarrow,
    leftrightarrows: $538971b5b904f078$var$leftrightarrows,
    leftrightharpoons: $538971b5b904f078$var$leftrightharpoons,
    leftrightsquigarrow: $538971b5b904f078$var$leftrightsquigarrow,
    leftthreetimes: $538971b5b904f078$var$leftthreetimes,
    leg: $538971b5b904f078$var$leg,
    leq: $538971b5b904f078$var$leq,
    leqq: $538971b5b904f078$var$leqq,
    leqslant: $538971b5b904f078$var$leqslant,
    les: $538971b5b904f078$var$les,
    lescc: $538971b5b904f078$var$lescc,
    lesdot: $538971b5b904f078$var$lesdot,
    lesdoto: $538971b5b904f078$var$lesdoto,
    lesdotor: $538971b5b904f078$var$lesdotor,
    lesg: $538971b5b904f078$var$lesg,
    lesges: $538971b5b904f078$var$lesges,
    lessapprox: $538971b5b904f078$var$lessapprox,
    lessdot: $538971b5b904f078$var$lessdot,
    lesseqgtr: $538971b5b904f078$var$lesseqgtr,
    lesseqqgtr: $538971b5b904f078$var$lesseqqgtr,
    lessgtr: $538971b5b904f078$var$lessgtr,
    lesssim: $538971b5b904f078$var$lesssim,
    lfisht: $538971b5b904f078$var$lfisht,
    lfloor: $538971b5b904f078$var$lfloor$1,
    lfr: $538971b5b904f078$var$lfr,
    lg: $538971b5b904f078$var$lg,
    lgE: $538971b5b904f078$var$lgE,
    lhard: $538971b5b904f078$var$lhard,
    lharu: $538971b5b904f078$var$lharu,
    lharul: $538971b5b904f078$var$lharul,
    lhblk: $538971b5b904f078$var$lhblk,
    ljcy: $538971b5b904f078$var$ljcy,
    ll: $538971b5b904f078$var$ll,
    llarr: $538971b5b904f078$var$llarr,
    llcorner: $538971b5b904f078$var$llcorner,
    llhard: $538971b5b904f078$var$llhard,
    lltri: $538971b5b904f078$var$lltri,
    lmidot: $538971b5b904f078$var$lmidot,
    lmoust: $538971b5b904f078$var$lmoust,
    lmoustache: $538971b5b904f078$var$lmoustache,
    lnE: $538971b5b904f078$var$lnE,
    lnap: $538971b5b904f078$var$lnap,
    lnapprox: $538971b5b904f078$var$lnapprox,
    lne: $538971b5b904f078$var$lne,
    lneq: $538971b5b904f078$var$lneq,
    lneqq: $538971b5b904f078$var$lneqq,
    lnsim: $538971b5b904f078$var$lnsim,
    loang: $538971b5b904f078$var$loang,
    loarr: $538971b5b904f078$var$loarr,
    lobrk: $538971b5b904f078$var$lobrk,
    longleftarrow: $538971b5b904f078$var$longleftarrow,
    longleftrightarrow: $538971b5b904f078$var$longleftrightarrow,
    longmapsto: $538971b5b904f078$var$longmapsto,
    longrightarrow: $538971b5b904f078$var$longrightarrow,
    looparrowleft: $538971b5b904f078$var$looparrowleft,
    looparrowright: $538971b5b904f078$var$looparrowright,
    lopar: $538971b5b904f078$var$lopar,
    lopf: $538971b5b904f078$var$lopf,
    loplus: $538971b5b904f078$var$loplus,
    lotimes: $538971b5b904f078$var$lotimes,
    lowast: $538971b5b904f078$var$lowast$1,
    lowbar: $538971b5b904f078$var$lowbar,
    loz: $538971b5b904f078$var$loz$1,
    lozenge: $538971b5b904f078$var$lozenge,
    lozf: $538971b5b904f078$var$lozf,
    lpar: $538971b5b904f078$var$lpar,
    lparlt: $538971b5b904f078$var$lparlt,
    lrarr: $538971b5b904f078$var$lrarr,
    lrcorner: $538971b5b904f078$var$lrcorner,
    lrhar: $538971b5b904f078$var$lrhar,
    lrhard: $538971b5b904f078$var$lrhard,
    lrm: $538971b5b904f078$var$lrm$1,
    lrtri: $538971b5b904f078$var$lrtri,
    lsaquo: $538971b5b904f078$var$lsaquo$1,
    lscr: $538971b5b904f078$var$lscr,
    lsh: $538971b5b904f078$var$lsh,
    lsim: $538971b5b904f078$var$lsim,
    lsime: $538971b5b904f078$var$lsime,
    lsimg: $538971b5b904f078$var$lsimg,
    lsqb: $538971b5b904f078$var$lsqb,
    lsquo: $538971b5b904f078$var$lsquo$1,
    lsquor: $538971b5b904f078$var$lsquor,
    lstrok: $538971b5b904f078$var$lstrok,
    l: $538971b5b904f078$var$l,
    lt: $538971b5b904f078$var$lt$1,
    ltcc: $538971b5b904f078$var$ltcc,
    ltcir: $538971b5b904f078$var$ltcir,
    ltdot: $538971b5b904f078$var$ltdot,
    lthree: $538971b5b904f078$var$lthree,
    ltimes: $538971b5b904f078$var$ltimes,
    ltlarr: $538971b5b904f078$var$ltlarr,
    ltquest: $538971b5b904f078$var$ltquest,
    ltrPar: $538971b5b904f078$var$ltrPar,
    ltri: $538971b5b904f078$var$ltri,
    ltrie: $538971b5b904f078$var$ltrie,
    ltrif: $538971b5b904f078$var$ltrif,
    lurdshar: $538971b5b904f078$var$lurdshar,
    luruhar: $538971b5b904f078$var$luruhar,
    lvertneqq: $538971b5b904f078$var$lvertneqq,
    lvnE: $538971b5b904f078$var$lvnE,
    mDDot: $538971b5b904f078$var$mDDot,
    mac: $538971b5b904f078$var$mac,
    macr: $538971b5b904f078$var$macr$1,
    male: $538971b5b904f078$var$male,
    malt: $538971b5b904f078$var$malt,
    maltese: $538971b5b904f078$var$maltese,
    map: $538971b5b904f078$var$map$1,
    mapsto: $538971b5b904f078$var$mapsto,
    mapstodown: $538971b5b904f078$var$mapstodown,
    mapstoleft: $538971b5b904f078$var$mapstoleft,
    mapstoup: $538971b5b904f078$var$mapstoup,
    marker: $538971b5b904f078$var$marker,
    mcomma: $538971b5b904f078$var$mcomma,
    mcy: $538971b5b904f078$var$mcy,
    mdash: $538971b5b904f078$var$mdash$1,
    measuredangle: $538971b5b904f078$var$measuredangle,
    mfr: $538971b5b904f078$var$mfr,
    mho: $538971b5b904f078$var$mho,
    micr: $538971b5b904f078$var$micr,
    micro: $538971b5b904f078$var$micro$1,
    mid: $538971b5b904f078$var$mid,
    midast: $538971b5b904f078$var$midast,
    midcir: $538971b5b904f078$var$midcir,
    middo: $538971b5b904f078$var$middo,
    middot: $538971b5b904f078$var$middot$1,
    minus: $538971b5b904f078$var$minus$1,
    minusb: $538971b5b904f078$var$minusb,
    minusd: $538971b5b904f078$var$minusd,
    minusdu: $538971b5b904f078$var$minusdu,
    mlcp: $538971b5b904f078$var$mlcp,
    mldr: $538971b5b904f078$var$mldr,
    mnplus: $538971b5b904f078$var$mnplus,
    models: $538971b5b904f078$var$models,
    mopf: $538971b5b904f078$var$mopf,
    mp: $538971b5b904f078$var$mp,
    mscr: $538971b5b904f078$var$mscr,
    mstpos: $538971b5b904f078$var$mstpos,
    mu: $538971b5b904f078$var$mu$1,
    multimap: $538971b5b904f078$var$multimap,
    mumap: $538971b5b904f078$var$mumap,
    nGg: $538971b5b904f078$var$nGg,
    nGt: $538971b5b904f078$var$nGt,
    nGtv: $538971b5b904f078$var$nGtv,
    nLeftarrow: $538971b5b904f078$var$nLeftarrow,
    nLeftrightarrow: $538971b5b904f078$var$nLeftrightarrow,
    nLl: $538971b5b904f078$var$nLl,
    nLt: $538971b5b904f078$var$nLt,
    nLtv: $538971b5b904f078$var$nLtv,
    nRightarrow: $538971b5b904f078$var$nRightarrow,
    nVDash: $538971b5b904f078$var$nVDash,
    nVdash: $538971b5b904f078$var$nVdash,
    nabla: $538971b5b904f078$var$nabla$1,
    nacute: $538971b5b904f078$var$nacute,
    nang: $538971b5b904f078$var$nang,
    nap: $538971b5b904f078$var$nap,
    napE: $538971b5b904f078$var$napE,
    napid: $538971b5b904f078$var$napid,
    napos: $538971b5b904f078$var$napos,
    napprox: $538971b5b904f078$var$napprox,
    natur: $538971b5b904f078$var$natur,
    natural: $538971b5b904f078$var$natural,
    naturals: $538971b5b904f078$var$naturals,
    nbs: $538971b5b904f078$var$nbs,
    nbsp: $538971b5b904f078$var$nbsp$1,
    nbump: $538971b5b904f078$var$nbump,
    nbumpe: $538971b5b904f078$var$nbumpe,
    ncap: $538971b5b904f078$var$ncap,
    ncaron: $538971b5b904f078$var$ncaron,
    ncedil: $538971b5b904f078$var$ncedil,
    ncong: $538971b5b904f078$var$ncong,
    ncongdot: $538971b5b904f078$var$ncongdot,
    ncup: $538971b5b904f078$var$ncup,
    ncy: $538971b5b904f078$var$ncy,
    ndash: $538971b5b904f078$var$ndash$1,
    ne: $538971b5b904f078$var$ne$1,
    neArr: $538971b5b904f078$var$neArr,
    nearhk: $538971b5b904f078$var$nearhk,
    nearr: $538971b5b904f078$var$nearr,
    nearrow: $538971b5b904f078$var$nearrow,
    nedot: $538971b5b904f078$var$nedot,
    nequiv: $538971b5b904f078$var$nequiv,
    nesear: $538971b5b904f078$var$nesear,
    nesim: $538971b5b904f078$var$nesim,
    nexist: $538971b5b904f078$var$nexist,
    nexists: $538971b5b904f078$var$nexists,
    nfr: $538971b5b904f078$var$nfr,
    ngE: $538971b5b904f078$var$ngE,
    nge: $538971b5b904f078$var$nge,
    ngeq: $538971b5b904f078$var$ngeq,
    ngeqq: $538971b5b904f078$var$ngeqq,
    ngeqslant: $538971b5b904f078$var$ngeqslant,
    nges: $538971b5b904f078$var$nges,
    ngsim: $538971b5b904f078$var$ngsim,
    ngt: $538971b5b904f078$var$ngt,
    ngtr: $538971b5b904f078$var$ngtr,
    nhArr: $538971b5b904f078$var$nhArr,
    nharr: $538971b5b904f078$var$nharr,
    nhpar: $538971b5b904f078$var$nhpar,
    ni: $538971b5b904f078$var$ni$1,
    nis: $538971b5b904f078$var$nis,
    nisd: $538971b5b904f078$var$nisd,
    niv: $538971b5b904f078$var$niv,
    njcy: $538971b5b904f078$var$njcy,
    nlArr: $538971b5b904f078$var$nlArr,
    nlE: $538971b5b904f078$var$nlE,
    nlarr: $538971b5b904f078$var$nlarr,
    nldr: $538971b5b904f078$var$nldr,
    nle: $538971b5b904f078$var$nle,
    nleftarrow: $538971b5b904f078$var$nleftarrow,
    nleftrightarrow: $538971b5b904f078$var$nleftrightarrow,
    nleq: $538971b5b904f078$var$nleq,
    nleqq: $538971b5b904f078$var$nleqq,
    nleqslant: $538971b5b904f078$var$nleqslant,
    nles: $538971b5b904f078$var$nles,
    nless: $538971b5b904f078$var$nless,
    nlsim: $538971b5b904f078$var$nlsim,
    nlt: $538971b5b904f078$var$nlt,
    nltri: $538971b5b904f078$var$nltri,
    nltrie: $538971b5b904f078$var$nltrie,
    nmid: $538971b5b904f078$var$nmid,
    nopf: $538971b5b904f078$var$nopf,
    no: $538971b5b904f078$var$no,
    not: $538971b5b904f078$var$not$1,
    notin: $538971b5b904f078$var$notin$1,
    notinE: $538971b5b904f078$var$notinE,
    notindot: $538971b5b904f078$var$notindot,
    notinva: $538971b5b904f078$var$notinva,
    notinvb: $538971b5b904f078$var$notinvb,
    notinvc: $538971b5b904f078$var$notinvc,
    notni: $538971b5b904f078$var$notni,
    notniva: $538971b5b904f078$var$notniva,
    notnivb: $538971b5b904f078$var$notnivb,
    notnivc: $538971b5b904f078$var$notnivc,
    npar: $538971b5b904f078$var$npar,
    nparallel: $538971b5b904f078$var$nparallel,
    nparsl: $538971b5b904f078$var$nparsl,
    npart: $538971b5b904f078$var$npart,
    npolint: $538971b5b904f078$var$npolint,
    npr: $538971b5b904f078$var$npr,
    nprcue: $538971b5b904f078$var$nprcue,
    npre: $538971b5b904f078$var$npre,
    nprec: $538971b5b904f078$var$nprec,
    npreceq: $538971b5b904f078$var$npreceq,
    nrArr: $538971b5b904f078$var$nrArr,
    nrarr: $538971b5b904f078$var$nrarr,
    nrarrc: $538971b5b904f078$var$nrarrc,
    nrarrw: $538971b5b904f078$var$nrarrw,
    nrightarrow: $538971b5b904f078$var$nrightarrow,
    nrtri: $538971b5b904f078$var$nrtri,
    nrtrie: $538971b5b904f078$var$nrtrie,
    nsc: $538971b5b904f078$var$nsc,
    nsccue: $538971b5b904f078$var$nsccue,
    nsce: $538971b5b904f078$var$nsce,
    nscr: $538971b5b904f078$var$nscr,
    nshortmid: $538971b5b904f078$var$nshortmid,
    nshortparallel: $538971b5b904f078$var$nshortparallel,
    nsim: $538971b5b904f078$var$nsim,
    nsime: $538971b5b904f078$var$nsime,
    nsimeq: $538971b5b904f078$var$nsimeq,
    nsmid: $538971b5b904f078$var$nsmid,
    nspar: $538971b5b904f078$var$nspar,
    nsqsube: $538971b5b904f078$var$nsqsube,
    nsqsupe: $538971b5b904f078$var$nsqsupe,
    nsub: $538971b5b904f078$var$nsub$1,
    nsubE: $538971b5b904f078$var$nsubE,
    nsube: $538971b5b904f078$var$nsube,
    nsubset: $538971b5b904f078$var$nsubset,
    nsubseteq: $538971b5b904f078$var$nsubseteq,
    nsubseteqq: $538971b5b904f078$var$nsubseteqq,
    nsucc: $538971b5b904f078$var$nsucc,
    nsucceq: $538971b5b904f078$var$nsucceq,
    nsup: $538971b5b904f078$var$nsup,
    nsupE: $538971b5b904f078$var$nsupE,
    nsupe: $538971b5b904f078$var$nsupe,
    nsupset: $538971b5b904f078$var$nsupset,
    nsupseteq: $538971b5b904f078$var$nsupseteq,
    nsupseteqq: $538971b5b904f078$var$nsupseteqq,
    ntgl: $538971b5b904f078$var$ntgl,
    ntild: $538971b5b904f078$var$ntild,
    ntilde: $538971b5b904f078$var$ntilde$1,
    ntlg: $538971b5b904f078$var$ntlg,
    ntriangleleft: $538971b5b904f078$var$ntriangleleft,
    ntrianglelefteq: $538971b5b904f078$var$ntrianglelefteq,
    ntriangleright: $538971b5b904f078$var$ntriangleright,
    ntrianglerighteq: $538971b5b904f078$var$ntrianglerighteq,
    nu: $538971b5b904f078$var$nu$1,
    num: $538971b5b904f078$var$num,
    numero: $538971b5b904f078$var$numero,
    numsp: $538971b5b904f078$var$numsp,
    nvDash: $538971b5b904f078$var$nvDash,
    nvHarr: $538971b5b904f078$var$nvHarr,
    nvap: $538971b5b904f078$var$nvap,
    nvdash: $538971b5b904f078$var$nvdash,
    nvge: $538971b5b904f078$var$nvge,
    nvgt: $538971b5b904f078$var$nvgt,
    nvinfin: $538971b5b904f078$var$nvinfin,
    nvlArr: $538971b5b904f078$var$nvlArr,
    nvle: $538971b5b904f078$var$nvle,
    nvlt: $538971b5b904f078$var$nvlt,
    nvltrie: $538971b5b904f078$var$nvltrie,
    nvrArr: $538971b5b904f078$var$nvrArr,
    nvrtrie: $538971b5b904f078$var$nvrtrie,
    nvsim: $538971b5b904f078$var$nvsim,
    nwArr: $538971b5b904f078$var$nwArr,
    nwarhk: $538971b5b904f078$var$nwarhk,
    nwarr: $538971b5b904f078$var$nwarr,
    nwarrow: $538971b5b904f078$var$nwarrow,
    nwnear: $538971b5b904f078$var$nwnear,
    oS: $538971b5b904f078$var$oS,
    oacut: $538971b5b904f078$var$oacut,
    oacute: $538971b5b904f078$var$oacute$1,
    oast: $538971b5b904f078$var$oast,
    ocir: $538971b5b904f078$var$ocir,
    ocirc: $538971b5b904f078$var$ocirc$1,
    ocy: $538971b5b904f078$var$ocy,
    odash: $538971b5b904f078$var$odash,
    odblac: $538971b5b904f078$var$odblac,
    odiv: $538971b5b904f078$var$odiv,
    odot: $538971b5b904f078$var$odot,
    odsold: $538971b5b904f078$var$odsold,
    oelig: $538971b5b904f078$var$oelig$1,
    ofcir: $538971b5b904f078$var$ofcir,
    ofr: $538971b5b904f078$var$ofr,
    ogon: $538971b5b904f078$var$ogon,
    ograv: $538971b5b904f078$var$ograv,
    ograve: $538971b5b904f078$var$ograve$1,
    ogt: $538971b5b904f078$var$ogt,
    ohbar: $538971b5b904f078$var$ohbar,
    ohm: $538971b5b904f078$var$ohm,
    oint: $538971b5b904f078$var$oint,
    olarr: $538971b5b904f078$var$olarr,
    olcir: $538971b5b904f078$var$olcir,
    olcross: $538971b5b904f078$var$olcross,
    oline: $538971b5b904f078$var$oline$1,
    olt: $538971b5b904f078$var$olt,
    omacr: $538971b5b904f078$var$omacr,
    omega: $538971b5b904f078$var$omega$1,
    omicron: $538971b5b904f078$var$omicron$1,
    omid: $538971b5b904f078$var$omid,
    ominus: $538971b5b904f078$var$ominus,
    oopf: $538971b5b904f078$var$oopf,
    opar: $538971b5b904f078$var$opar,
    operp: $538971b5b904f078$var$operp,
    oplus: $538971b5b904f078$var$oplus$1,
    or: $538971b5b904f078$var$or$1,
    orarr: $538971b5b904f078$var$orarr,
    ord: $538971b5b904f078$var$ord,
    order: $538971b5b904f078$var$order,
    orderof: $538971b5b904f078$var$orderof,
    ordf: $538971b5b904f078$var$ordf$1,
    ordm: $538971b5b904f078$var$ordm$1,
    origof: $538971b5b904f078$var$origof,
    oror: $538971b5b904f078$var$oror,
    orslope: $538971b5b904f078$var$orslope,
    orv: $538971b5b904f078$var$orv,
    oscr: $538971b5b904f078$var$oscr,
    oslas: $538971b5b904f078$var$oslas,
    oslash: $538971b5b904f078$var$oslash$1,
    osol: $538971b5b904f078$var$osol,
    otild: $538971b5b904f078$var$otild,
    otilde: $538971b5b904f078$var$otilde$1,
    otimes: $538971b5b904f078$var$otimes$1,
    otimesas: $538971b5b904f078$var$otimesas,
    oum: $538971b5b904f078$var$oum,
    ouml: $538971b5b904f078$var$ouml$1,
    ovbar: $538971b5b904f078$var$ovbar,
    par: $538971b5b904f078$var$par,
    para: $538971b5b904f078$var$para$1,
    parallel: $538971b5b904f078$var$parallel,
    parsim: $538971b5b904f078$var$parsim,
    parsl: $538971b5b904f078$var$parsl,
    part: $538971b5b904f078$var$part$1,
    pcy: $538971b5b904f078$var$pcy,
    percnt: $538971b5b904f078$var$percnt,
    period: $538971b5b904f078$var$period,
    permil: $538971b5b904f078$var$permil$1,
    perp: $538971b5b904f078$var$perp$1,
    pertenk: $538971b5b904f078$var$pertenk,
    pfr: $538971b5b904f078$var$pfr,
    phi: $538971b5b904f078$var$phi$1,
    phiv: $538971b5b904f078$var$phiv,
    phmmat: $538971b5b904f078$var$phmmat,
    phone: $538971b5b904f078$var$phone,
    pi: $538971b5b904f078$var$pi$1,
    pitchfork: $538971b5b904f078$var$pitchfork,
    piv: $538971b5b904f078$var$piv$1,
    planck: $538971b5b904f078$var$planck,
    planckh: $538971b5b904f078$var$planckh,
    plankv: $538971b5b904f078$var$plankv,
    plus: $538971b5b904f078$var$plus,
    plusacir: $538971b5b904f078$var$plusacir,
    plusb: $538971b5b904f078$var$plusb,
    pluscir: $538971b5b904f078$var$pluscir,
    plusdo: $538971b5b904f078$var$plusdo,
    plusdu: $538971b5b904f078$var$plusdu,
    pluse: $538971b5b904f078$var$pluse,
    plusm: $538971b5b904f078$var$plusm,
    plusmn: $538971b5b904f078$var$plusmn$1,
    plussim: $538971b5b904f078$var$plussim,
    plustwo: $538971b5b904f078$var$plustwo,
    pm: $538971b5b904f078$var$pm,
    pointint: $538971b5b904f078$var$pointint,
    popf: $538971b5b904f078$var$popf,
    poun: $538971b5b904f078$var$poun,
    pound: $538971b5b904f078$var$pound$1,
    pr: $538971b5b904f078$var$pr,
    prE: $538971b5b904f078$var$prE,
    prap: $538971b5b904f078$var$prap,
    prcue: $538971b5b904f078$var$prcue,
    pre: $538971b5b904f078$var$pre,
    prec: $538971b5b904f078$var$prec,
    precapprox: $538971b5b904f078$var$precapprox,
    preccurlyeq: $538971b5b904f078$var$preccurlyeq,
    preceq: $538971b5b904f078$var$preceq,
    precnapprox: $538971b5b904f078$var$precnapprox,
    precneqq: $538971b5b904f078$var$precneqq,
    precnsim: $538971b5b904f078$var$precnsim,
    precsim: $538971b5b904f078$var$precsim,
    prime: $538971b5b904f078$var$prime$1,
    primes: $538971b5b904f078$var$primes,
    prnE: $538971b5b904f078$var$prnE,
    prnap: $538971b5b904f078$var$prnap,
    prnsim: $538971b5b904f078$var$prnsim,
    prod: $538971b5b904f078$var$prod$1,
    profalar: $538971b5b904f078$var$profalar,
    profline: $538971b5b904f078$var$profline,
    profsurf: $538971b5b904f078$var$profsurf,
    prop: $538971b5b904f078$var$prop$1,
    propto: $538971b5b904f078$var$propto,
    prsim: $538971b5b904f078$var$prsim,
    prurel: $538971b5b904f078$var$prurel,
    pscr: $538971b5b904f078$var$pscr,
    psi: $538971b5b904f078$var$psi$1,
    puncsp: $538971b5b904f078$var$puncsp,
    qfr: $538971b5b904f078$var$qfr,
    qint: $538971b5b904f078$var$qint,
    qopf: $538971b5b904f078$var$qopf,
    qprime: $538971b5b904f078$var$qprime,
    qscr: $538971b5b904f078$var$qscr,
    quaternions: $538971b5b904f078$var$quaternions,
    quatint: $538971b5b904f078$var$quatint,
    quest: $538971b5b904f078$var$quest,
    questeq: $538971b5b904f078$var$questeq,
    quo: $538971b5b904f078$var$quo,
    quot: $538971b5b904f078$var$quot$1,
    rAarr: $538971b5b904f078$var$rAarr,
    rArr: $538971b5b904f078$var$rArr$1,
    rAtail: $538971b5b904f078$var$rAtail,
    rBarr: $538971b5b904f078$var$rBarr,
    rHar: $538971b5b904f078$var$rHar,
    race: $538971b5b904f078$var$race,
    racute: $538971b5b904f078$var$racute,
    radic: $538971b5b904f078$var$radic$1,
    raemptyv: $538971b5b904f078$var$raemptyv,
    rang: $538971b5b904f078$var$rang$1,
    rangd: $538971b5b904f078$var$rangd,
    range: $538971b5b904f078$var$range,
    rangle: $538971b5b904f078$var$rangle,
    raqu: $538971b5b904f078$var$raqu,
    raquo: $538971b5b904f078$var$raquo$1,
    rarr: $538971b5b904f078$var$rarr$1,
    rarrap: $538971b5b904f078$var$rarrap,
    rarrb: $538971b5b904f078$var$rarrb,
    rarrbfs: $538971b5b904f078$var$rarrbfs,
    rarrc: $538971b5b904f078$var$rarrc,
    rarrfs: $538971b5b904f078$var$rarrfs,
    rarrhk: $538971b5b904f078$var$rarrhk,
    rarrlp: $538971b5b904f078$var$rarrlp,
    rarrpl: $538971b5b904f078$var$rarrpl,
    rarrsim: $538971b5b904f078$var$rarrsim,
    rarrtl: $538971b5b904f078$var$rarrtl,
    rarrw: $538971b5b904f078$var$rarrw,
    ratail: $538971b5b904f078$var$ratail,
    ratio: $538971b5b904f078$var$ratio,
    rationals: $538971b5b904f078$var$rationals,
    rbarr: $538971b5b904f078$var$rbarr,
    rbbrk: $538971b5b904f078$var$rbbrk,
    rbrace: $538971b5b904f078$var$rbrace,
    rbrack: $538971b5b904f078$var$rbrack,
    rbrke: $538971b5b904f078$var$rbrke,
    rbrksld: $538971b5b904f078$var$rbrksld,
    rbrkslu: $538971b5b904f078$var$rbrkslu,
    rcaron: $538971b5b904f078$var$rcaron,
    rcedil: $538971b5b904f078$var$rcedil,
    rceil: $538971b5b904f078$var$rceil$1,
    rcub: $538971b5b904f078$var$rcub,
    rcy: $538971b5b904f078$var$rcy,
    rdca: $538971b5b904f078$var$rdca,
    rdldhar: $538971b5b904f078$var$rdldhar,
    rdquo: $538971b5b904f078$var$rdquo$1,
    rdquor: $538971b5b904f078$var$rdquor,
    rdsh: $538971b5b904f078$var$rdsh,
    real: $538971b5b904f078$var$real$1,
    realine: $538971b5b904f078$var$realine,
    realpart: $538971b5b904f078$var$realpart,
    reals: $538971b5b904f078$var$reals,
    rect: $538971b5b904f078$var$rect,
    re: $538971b5b904f078$var$re$3,
    reg: $538971b5b904f078$var$reg$1,
    rfisht: $538971b5b904f078$var$rfisht,
    rfloor: $538971b5b904f078$var$rfloor$1,
    rfr: $538971b5b904f078$var$rfr,
    rhard: $538971b5b904f078$var$rhard,
    rharu: $538971b5b904f078$var$rharu,
    rharul: $538971b5b904f078$var$rharul,
    rho: $538971b5b904f078$var$rho$1,
    rhov: $538971b5b904f078$var$rhov,
    rightarrow: $538971b5b904f078$var$rightarrow,
    rightarrowtail: $538971b5b904f078$var$rightarrowtail,
    rightharpoondown: $538971b5b904f078$var$rightharpoondown,
    rightharpoonup: $538971b5b904f078$var$rightharpoonup,
    rightleftarrows: $538971b5b904f078$var$rightleftarrows,
    rightleftharpoons: $538971b5b904f078$var$rightleftharpoons,
    rightrightarrows: $538971b5b904f078$var$rightrightarrows,
    rightsquigarrow: $538971b5b904f078$var$rightsquigarrow,
    rightthreetimes: $538971b5b904f078$var$rightthreetimes,
    ring: $538971b5b904f078$var$ring,
    risingdotseq: $538971b5b904f078$var$risingdotseq,
    rlarr: $538971b5b904f078$var$rlarr,
    rlhar: $538971b5b904f078$var$rlhar,
    rlm: $538971b5b904f078$var$rlm$1,
    rmoust: $538971b5b904f078$var$rmoust,
    rmoustache: $538971b5b904f078$var$rmoustache,
    rnmid: $538971b5b904f078$var$rnmid,
    roang: $538971b5b904f078$var$roang,
    roarr: $538971b5b904f078$var$roarr,
    robrk: $538971b5b904f078$var$robrk,
    ropar: $538971b5b904f078$var$ropar,
    ropf: $538971b5b904f078$var$ropf,
    roplus: $538971b5b904f078$var$roplus,
    rotimes: $538971b5b904f078$var$rotimes,
    rpar: $538971b5b904f078$var$rpar,
    rpargt: $538971b5b904f078$var$rpargt,
    rppolint: $538971b5b904f078$var$rppolint,
    rrarr: $538971b5b904f078$var$rrarr,
    rsaquo: $538971b5b904f078$var$rsaquo$1,
    rscr: $538971b5b904f078$var$rscr,
    rsh: $538971b5b904f078$var$rsh,
    rsqb: $538971b5b904f078$var$rsqb,
    rsquo: $538971b5b904f078$var$rsquo$1,
    rsquor: $538971b5b904f078$var$rsquor,
    rthree: $538971b5b904f078$var$rthree,
    rtimes: $538971b5b904f078$var$rtimes,
    rtri: $538971b5b904f078$var$rtri,
    rtrie: $538971b5b904f078$var$rtrie,
    rtrif: $538971b5b904f078$var$rtrif,
    rtriltri: $538971b5b904f078$var$rtriltri,
    ruluhar: $538971b5b904f078$var$ruluhar,
    rx: $538971b5b904f078$var$rx,
    sacute: $538971b5b904f078$var$sacute,
    sbquo: $538971b5b904f078$var$sbquo$1,
    sc: $538971b5b904f078$var$sc,
    scE: $538971b5b904f078$var$scE,
    scap: $538971b5b904f078$var$scap,
    scaron: $538971b5b904f078$var$scaron$1,
    sccue: $538971b5b904f078$var$sccue,
    sce: $538971b5b904f078$var$sce,
    scedil: $538971b5b904f078$var$scedil,
    scirc: $538971b5b904f078$var$scirc,
    scnE: $538971b5b904f078$var$scnE,
    scnap: $538971b5b904f078$var$scnap,
    scnsim: $538971b5b904f078$var$scnsim,
    scpolint: $538971b5b904f078$var$scpolint,
    scsim: $538971b5b904f078$var$scsim,
    scy: $538971b5b904f078$var$scy,
    sdot: $538971b5b904f078$var$sdot$1,
    sdotb: $538971b5b904f078$var$sdotb,
    sdote: $538971b5b904f078$var$sdote,
    seArr: $538971b5b904f078$var$seArr,
    searhk: $538971b5b904f078$var$searhk,
    searr: $538971b5b904f078$var$searr,
    searrow: $538971b5b904f078$var$searrow,
    sec: $538971b5b904f078$var$sec,
    sect: $538971b5b904f078$var$sect$1,
    semi: $538971b5b904f078$var$semi,
    seswar: $538971b5b904f078$var$seswar,
    setminus: $538971b5b904f078$var$setminus,
    setmn: $538971b5b904f078$var$setmn,
    sext: $538971b5b904f078$var$sext,
    sfr: $538971b5b904f078$var$sfr,
    sfrown: $538971b5b904f078$var$sfrown,
    sharp: $538971b5b904f078$var$sharp,
    shchcy: $538971b5b904f078$var$shchcy,
    shcy: $538971b5b904f078$var$shcy,
    shortmid: $538971b5b904f078$var$shortmid,
    shortparallel: $538971b5b904f078$var$shortparallel,
    sh: $538971b5b904f078$var$sh,
    shy: $538971b5b904f078$var$shy$1,
    sigma: $538971b5b904f078$var$sigma$1,
    sigmaf: $538971b5b904f078$var$sigmaf$1,
    sigmav: $538971b5b904f078$var$sigmav,
    sim: $538971b5b904f078$var$sim$1,
    simdot: $538971b5b904f078$var$simdot,
    sime: $538971b5b904f078$var$sime,
    simeq: $538971b5b904f078$var$simeq,
    simg: $538971b5b904f078$var$simg,
    simgE: $538971b5b904f078$var$simgE,
    siml: $538971b5b904f078$var$siml,
    simlE: $538971b5b904f078$var$simlE,
    simne: $538971b5b904f078$var$simne,
    simplus: $538971b5b904f078$var$simplus,
    simrarr: $538971b5b904f078$var$simrarr,
    slarr: $538971b5b904f078$var$slarr,
    smallsetminus: $538971b5b904f078$var$smallsetminus,
    smashp: $538971b5b904f078$var$smashp,
    smeparsl: $538971b5b904f078$var$smeparsl,
    smid: $538971b5b904f078$var$smid,
    smile: $538971b5b904f078$var$smile,
    smt: $538971b5b904f078$var$smt,
    smte: $538971b5b904f078$var$smte,
    smtes: $538971b5b904f078$var$smtes,
    softcy: $538971b5b904f078$var$softcy,
    sol: $538971b5b904f078$var$sol,
    solb: $538971b5b904f078$var$solb,
    solbar: $538971b5b904f078$var$solbar,
    sopf: $538971b5b904f078$var$sopf,
    spades: $538971b5b904f078$var$spades$1,
    spadesuit: $538971b5b904f078$var$spadesuit,
    spar: $538971b5b904f078$var$spar,
    sqcap: $538971b5b904f078$var$sqcap,
    sqcaps: $538971b5b904f078$var$sqcaps,
    sqcup: $538971b5b904f078$var$sqcup,
    sqcups: $538971b5b904f078$var$sqcups,
    sqsub: $538971b5b904f078$var$sqsub,
    sqsube: $538971b5b904f078$var$sqsube,
    sqsubset: $538971b5b904f078$var$sqsubset,
    sqsubseteq: $538971b5b904f078$var$sqsubseteq,
    sqsup: $538971b5b904f078$var$sqsup,
    sqsupe: $538971b5b904f078$var$sqsupe,
    sqsupset: $538971b5b904f078$var$sqsupset,
    sqsupseteq: $538971b5b904f078$var$sqsupseteq,
    squ: $538971b5b904f078$var$squ,
    square: $538971b5b904f078$var$square,
    squarf: $538971b5b904f078$var$squarf,
    squf: $538971b5b904f078$var$squf,
    srarr: $538971b5b904f078$var$srarr,
    sscr: $538971b5b904f078$var$sscr,
    ssetmn: $538971b5b904f078$var$ssetmn,
    ssmile: $538971b5b904f078$var$ssmile,
    sstarf: $538971b5b904f078$var$sstarf,
    star: $538971b5b904f078$var$star,
    starf: $538971b5b904f078$var$starf,
    straightepsilon: $538971b5b904f078$var$straightepsilon,
    straightphi: $538971b5b904f078$var$straightphi,
    strns: $538971b5b904f078$var$strns,
    sub: $538971b5b904f078$var$sub$1,
    subE: $538971b5b904f078$var$subE,
    subdot: $538971b5b904f078$var$subdot,
    sube: $538971b5b904f078$var$sube$1,
    subedot: $538971b5b904f078$var$subedot,
    submult: $538971b5b904f078$var$submult,
    subnE: $538971b5b904f078$var$subnE,
    subne: $538971b5b904f078$var$subne,
    subplus: $538971b5b904f078$var$subplus,
    subrarr: $538971b5b904f078$var$subrarr,
    subset: $538971b5b904f078$var$subset,
    subseteq: $538971b5b904f078$var$subseteq,
    subseteqq: $538971b5b904f078$var$subseteqq,
    subsetneq: $538971b5b904f078$var$subsetneq,
    subsetneqq: $538971b5b904f078$var$subsetneqq,
    subsim: $538971b5b904f078$var$subsim,
    subsub: $538971b5b904f078$var$subsub,
    subsup: $538971b5b904f078$var$subsup,
    succ: $538971b5b904f078$var$succ,
    succapprox: $538971b5b904f078$var$succapprox,
    succcurlyeq: $538971b5b904f078$var$succcurlyeq,
    succeq: $538971b5b904f078$var$succeq,
    succnapprox: $538971b5b904f078$var$succnapprox,
    succneqq: $538971b5b904f078$var$succneqq,
    succnsim: $538971b5b904f078$var$succnsim,
    succsim: $538971b5b904f078$var$succsim,
    sum: $538971b5b904f078$var$sum$1,
    sung: $538971b5b904f078$var$sung,
    sup: $538971b5b904f078$var$sup$1,
    sup1: $538971b5b904f078$var$sup1$1,
    sup2: $538971b5b904f078$var$sup2$1,
    sup3: $538971b5b904f078$var$sup3$1,
    supE: $538971b5b904f078$var$supE,
    supdot: $538971b5b904f078$var$supdot,
    supdsub: $538971b5b904f078$var$supdsub,
    supe: $538971b5b904f078$var$supe$1,
    supedot: $538971b5b904f078$var$supedot,
    suphsol: $538971b5b904f078$var$suphsol,
    suphsub: $538971b5b904f078$var$suphsub,
    suplarr: $538971b5b904f078$var$suplarr,
    supmult: $538971b5b904f078$var$supmult,
    supnE: $538971b5b904f078$var$supnE,
    supne: $538971b5b904f078$var$supne,
    supplus: $538971b5b904f078$var$supplus,
    supset: $538971b5b904f078$var$supset,
    supseteq: $538971b5b904f078$var$supseteq,
    supseteqq: $538971b5b904f078$var$supseteqq,
    supsetneq: $538971b5b904f078$var$supsetneq,
    supsetneqq: $538971b5b904f078$var$supsetneqq,
    supsim: $538971b5b904f078$var$supsim,
    supsub: $538971b5b904f078$var$supsub,
    supsup: $538971b5b904f078$var$supsup,
    swArr: $538971b5b904f078$var$swArr,
    swarhk: $538971b5b904f078$var$swarhk,
    swarr: $538971b5b904f078$var$swarr,
    swarrow: $538971b5b904f078$var$swarrow,
    swnwar: $538971b5b904f078$var$swnwar,
    szli: $538971b5b904f078$var$szli,
    szlig: $538971b5b904f078$var$szlig$1,
    target: $538971b5b904f078$var$target,
    tau: $538971b5b904f078$var$tau$1,
    tbrk: $538971b5b904f078$var$tbrk,
    tcaron: $538971b5b904f078$var$tcaron,
    tcedil: $538971b5b904f078$var$tcedil,
    tcy: $538971b5b904f078$var$tcy,
    tdot: $538971b5b904f078$var$tdot,
    telrec: $538971b5b904f078$var$telrec,
    tfr: $538971b5b904f078$var$tfr,
    there4: $538971b5b904f078$var$there4$1,
    therefore: $538971b5b904f078$var$therefore,
    theta: $538971b5b904f078$var$theta$1,
    thetasym: $538971b5b904f078$var$thetasym$1,
    thetav: $538971b5b904f078$var$thetav,
    thickapprox: $538971b5b904f078$var$thickapprox,
    thicksim: $538971b5b904f078$var$thicksim,
    thinsp: $538971b5b904f078$var$thinsp$1,
    thkap: $538971b5b904f078$var$thkap,
    thksim: $538971b5b904f078$var$thksim,
    thor: $538971b5b904f078$var$thor,
    thorn: $538971b5b904f078$var$thorn$1,
    tilde: $538971b5b904f078$var$tilde$4,
    time: $538971b5b904f078$var$time,
    times: $538971b5b904f078$var$times$1,
    timesb: $538971b5b904f078$var$timesb,
    timesbar: $538971b5b904f078$var$timesbar,
    timesd: $538971b5b904f078$var$timesd,
    tint: $538971b5b904f078$var$tint,
    toea: $538971b5b904f078$var$toea,
    top: $538971b5b904f078$var$top,
    topbot: $538971b5b904f078$var$topbot,
    topcir: $538971b5b904f078$var$topcir,
    topf: $538971b5b904f078$var$topf,
    topfork: $538971b5b904f078$var$topfork,
    tosa: $538971b5b904f078$var$tosa,
    tprime: $538971b5b904f078$var$tprime,
    trade: $538971b5b904f078$var$trade$1,
    triangle: $538971b5b904f078$var$triangle,
    triangledown: $538971b5b904f078$var$triangledown,
    triangleleft: $538971b5b904f078$var$triangleleft,
    trianglelefteq: $538971b5b904f078$var$trianglelefteq,
    triangleq: $538971b5b904f078$var$triangleq,
    triangleright: $538971b5b904f078$var$triangleright,
    trianglerighteq: $538971b5b904f078$var$trianglerighteq,
    tridot: $538971b5b904f078$var$tridot,
    trie: $538971b5b904f078$var$trie,
    triminus: $538971b5b904f078$var$triminus,
    triplus: $538971b5b904f078$var$triplus,
    trisb: $538971b5b904f078$var$trisb,
    tritime: $538971b5b904f078$var$tritime,
    trpezium: $538971b5b904f078$var$trpezium,
    tscr: $538971b5b904f078$var$tscr,
    tscy: $538971b5b904f078$var$tscy,
    tshcy: $538971b5b904f078$var$tshcy,
    tstrok: $538971b5b904f078$var$tstrok,
    twixt: $538971b5b904f078$var$twixt,
    twoheadleftarrow: $538971b5b904f078$var$twoheadleftarrow,
    twoheadrightarrow: $538971b5b904f078$var$twoheadrightarrow,
    uArr: $538971b5b904f078$var$uArr$1,
    uHar: $538971b5b904f078$var$uHar,
    uacut: $538971b5b904f078$var$uacut,
    uacute: $538971b5b904f078$var$uacute$1,
    uarr: $538971b5b904f078$var$uarr$1,
    ubrcy: $538971b5b904f078$var$ubrcy,
    ubreve: $538971b5b904f078$var$ubreve,
    ucir: $538971b5b904f078$var$ucir,
    ucirc: $538971b5b904f078$var$ucirc$1,
    ucy: $538971b5b904f078$var$ucy,
    udarr: $538971b5b904f078$var$udarr,
    udblac: $538971b5b904f078$var$udblac,
    udhar: $538971b5b904f078$var$udhar,
    ufisht: $538971b5b904f078$var$ufisht,
    ufr: $538971b5b904f078$var$ufr,
    ugrav: $538971b5b904f078$var$ugrav,
    ugrave: $538971b5b904f078$var$ugrave$1,
    uharl: $538971b5b904f078$var$uharl,
    uharr: $538971b5b904f078$var$uharr,
    uhblk: $538971b5b904f078$var$uhblk,
    ulcorn: $538971b5b904f078$var$ulcorn,
    ulcorner: $538971b5b904f078$var$ulcorner,
    ulcrop: $538971b5b904f078$var$ulcrop,
    ultri: $538971b5b904f078$var$ultri,
    umacr: $538971b5b904f078$var$umacr,
    um: $538971b5b904f078$var$um,
    uml: $538971b5b904f078$var$uml$1,
    uogon: $538971b5b904f078$var$uogon,
    uopf: $538971b5b904f078$var$uopf,
    uparrow: $538971b5b904f078$var$uparrow,
    updownarrow: $538971b5b904f078$var$updownarrow,
    upharpoonleft: $538971b5b904f078$var$upharpoonleft,
    upharpoonright: $538971b5b904f078$var$upharpoonright,
    uplus: $538971b5b904f078$var$uplus,
    upsi: $538971b5b904f078$var$upsi,
    upsih: $538971b5b904f078$var$upsih$1,
    upsilon: $538971b5b904f078$var$upsilon$1,
    upuparrows: $538971b5b904f078$var$upuparrows,
    urcorn: $538971b5b904f078$var$urcorn,
    urcorner: $538971b5b904f078$var$urcorner,
    urcrop: $538971b5b904f078$var$urcrop,
    uring: $538971b5b904f078$var$uring,
    urtri: $538971b5b904f078$var$urtri,
    uscr: $538971b5b904f078$var$uscr,
    utdot: $538971b5b904f078$var$utdot,
    utilde: $538971b5b904f078$var$utilde,
    utri: $538971b5b904f078$var$utri,
    utrif: $538971b5b904f078$var$utrif,
    uuarr: $538971b5b904f078$var$uuarr,
    uum: $538971b5b904f078$var$uum,
    uuml: $538971b5b904f078$var$uuml$1,
    uwangle: $538971b5b904f078$var$uwangle,
    vArr: $538971b5b904f078$var$vArr,
    vBar: $538971b5b904f078$var$vBar,
    vBarv: $538971b5b904f078$var$vBarv,
    vDash: $538971b5b904f078$var$vDash,
    vangrt: $538971b5b904f078$var$vangrt,
    varepsilon: $538971b5b904f078$var$varepsilon,
    varkappa: $538971b5b904f078$var$varkappa,
    varnothing: $538971b5b904f078$var$varnothing,
    varphi: $538971b5b904f078$var$varphi,
    varpi: $538971b5b904f078$var$varpi,
    varpropto: $538971b5b904f078$var$varpropto,
    varr: $538971b5b904f078$var$varr,
    varrho: $538971b5b904f078$var$varrho,
    varsigma: $538971b5b904f078$var$varsigma,
    varsubsetneq: $538971b5b904f078$var$varsubsetneq,
    varsubsetneqq: $538971b5b904f078$var$varsubsetneqq,
    varsupsetneq: $538971b5b904f078$var$varsupsetneq,
    varsupsetneqq: $538971b5b904f078$var$varsupsetneqq,
    vartheta: $538971b5b904f078$var$vartheta,
    vartriangleleft: $538971b5b904f078$var$vartriangleleft,
    vartriangleright: $538971b5b904f078$var$vartriangleright,
    vcy: $538971b5b904f078$var$vcy,
    vdash: $538971b5b904f078$var$vdash,
    vee: $538971b5b904f078$var$vee,
    veebar: $538971b5b904f078$var$veebar,
    veeeq: $538971b5b904f078$var$veeeq,
    vellip: $538971b5b904f078$var$vellip,
    verbar: $538971b5b904f078$var$verbar,
    vert: $538971b5b904f078$var$vert,
    vfr: $538971b5b904f078$var$vfr,
    vltri: $538971b5b904f078$var$vltri,
    vnsub: $538971b5b904f078$var$vnsub,
    vnsup: $538971b5b904f078$var$vnsup,
    vopf: $538971b5b904f078$var$vopf,
    vprop: $538971b5b904f078$var$vprop,
    vrtri: $538971b5b904f078$var$vrtri,
    vscr: $538971b5b904f078$var$vscr,
    vsubnE: $538971b5b904f078$var$vsubnE,
    vsubne: $538971b5b904f078$var$vsubne,
    vsupnE: $538971b5b904f078$var$vsupnE,
    vsupne: $538971b5b904f078$var$vsupne,
    vzigzag: $538971b5b904f078$var$vzigzag,
    wcirc: $538971b5b904f078$var$wcirc,
    wedbar: $538971b5b904f078$var$wedbar,
    wedge: $538971b5b904f078$var$wedge,
    wedgeq: $538971b5b904f078$var$wedgeq,
    weierp: $538971b5b904f078$var$weierp$1,
    wfr: $538971b5b904f078$var$wfr,
    wopf: $538971b5b904f078$var$wopf,
    wp: $538971b5b904f078$var$wp,
    wr: $538971b5b904f078$var$wr,
    wreath: $538971b5b904f078$var$wreath,
    wscr: $538971b5b904f078$var$wscr,
    xcap: $538971b5b904f078$var$xcap,
    xcirc: $538971b5b904f078$var$xcirc,
    xcup: $538971b5b904f078$var$xcup,
    xdtri: $538971b5b904f078$var$xdtri,
    xfr: $538971b5b904f078$var$xfr,
    xhArr: $538971b5b904f078$var$xhArr,
    xharr: $538971b5b904f078$var$xharr,
    xi: $538971b5b904f078$var$xi$1,
    xlArr: $538971b5b904f078$var$xlArr,
    xlarr: $538971b5b904f078$var$xlarr,
    xmap: $538971b5b904f078$var$xmap,
    xnis: $538971b5b904f078$var$xnis,
    xodot: $538971b5b904f078$var$xodot,
    xopf: $538971b5b904f078$var$xopf,
    xoplus: $538971b5b904f078$var$xoplus,
    xotime: $538971b5b904f078$var$xotime,
    xrArr: $538971b5b904f078$var$xrArr,
    xrarr: $538971b5b904f078$var$xrarr,
    xscr: $538971b5b904f078$var$xscr,
    xsqcup: $538971b5b904f078$var$xsqcup,
    xuplus: $538971b5b904f078$var$xuplus,
    xutri: $538971b5b904f078$var$xutri,
    xvee: $538971b5b904f078$var$xvee,
    xwedge: $538971b5b904f078$var$xwedge,
    yacut: $538971b5b904f078$var$yacut,
    yacute: $538971b5b904f078$var$yacute$1,
    yacy: $538971b5b904f078$var$yacy,
    ycirc: $538971b5b904f078$var$ycirc,
    ycy: $538971b5b904f078$var$ycy,
    ye: $538971b5b904f078$var$ye,
    yen: $538971b5b904f078$var$yen$1,
    yfr: $538971b5b904f078$var$yfr,
    yicy: $538971b5b904f078$var$yicy,
    yopf: $538971b5b904f078$var$yopf,
    yscr: $538971b5b904f078$var$yscr,
    yucy: $538971b5b904f078$var$yucy,
    yum: $538971b5b904f078$var$yum,
    yuml: $538971b5b904f078$var$yuml$1,
    zacute: $538971b5b904f078$var$zacute,
    zcaron: $538971b5b904f078$var$zcaron,
    zcy: $538971b5b904f078$var$zcy,
    zdot: $538971b5b904f078$var$zdot,
    zeetrf: $538971b5b904f078$var$zeetrf,
    zeta: $538971b5b904f078$var$zeta$1,
    zfr: $538971b5b904f078$var$zfr,
    zhcy: $538971b5b904f078$var$zhcy,
    zigrarr: $538971b5b904f078$var$zigrarr,
    zopf: $538971b5b904f078$var$zopf,
    zscr: $538971b5b904f078$var$zscr,
    zwj: $538971b5b904f078$var$zwj$1,
    zwnj: $538971b5b904f078$var$zwnj$1
};
var $538971b5b904f078$var$characterEntities$1 = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    AEli: $538971b5b904f078$var$AEli,
    AElig: $538971b5b904f078$var$AElig$1,
    AM: $538971b5b904f078$var$AM,
    AMP: $538971b5b904f078$var$AMP$1,
    Aacut: $538971b5b904f078$var$Aacut,
    Aacute: $538971b5b904f078$var$Aacute$1,
    Abreve: $538971b5b904f078$var$Abreve,
    Acir: $538971b5b904f078$var$Acir,
    Acirc: $538971b5b904f078$var$Acirc$1,
    Acy: $538971b5b904f078$var$Acy,
    Afr: $538971b5b904f078$var$Afr,
    Agrav: $538971b5b904f078$var$Agrav,
    Agrave: $538971b5b904f078$var$Agrave$1,
    Alpha: $538971b5b904f078$var$Alpha$1,
    Amacr: $538971b5b904f078$var$Amacr,
    And: $538971b5b904f078$var$And,
    Aogon: $538971b5b904f078$var$Aogon,
    Aopf: $538971b5b904f078$var$Aopf,
    ApplyFunction: $538971b5b904f078$var$ApplyFunction,
    Arin: $538971b5b904f078$var$Arin,
    Aring: $538971b5b904f078$var$Aring$1,
    Ascr: $538971b5b904f078$var$Ascr,
    Assign: $538971b5b904f078$var$Assign,
    Atild: $538971b5b904f078$var$Atild,
    Atilde: $538971b5b904f078$var$Atilde$1,
    Aum: $538971b5b904f078$var$Aum,
    Auml: $538971b5b904f078$var$Auml$1,
    Backslash: $538971b5b904f078$var$Backslash,
    Barv: $538971b5b904f078$var$Barv,
    Barwed: $538971b5b904f078$var$Barwed,
    Bcy: $538971b5b904f078$var$Bcy,
    Because: $538971b5b904f078$var$Because,
    Bernoullis: $538971b5b904f078$var$Bernoullis,
    Beta: $538971b5b904f078$var$Beta$1,
    Bfr: $538971b5b904f078$var$Bfr,
    Bopf: $538971b5b904f078$var$Bopf,
    Breve: $538971b5b904f078$var$Breve,
    Bscr: $538971b5b904f078$var$Bscr,
    Bumpeq: $538971b5b904f078$var$Bumpeq,
    CHcy: $538971b5b904f078$var$CHcy,
    COP: $538971b5b904f078$var$COP,
    COPY: $538971b5b904f078$var$COPY,
    Cacute: $538971b5b904f078$var$Cacute,
    Cap: $538971b5b904f078$var$Cap,
    CapitalDifferentialD: $538971b5b904f078$var$CapitalDifferentialD,
    Cayleys: $538971b5b904f078$var$Cayleys,
    Ccaron: $538971b5b904f078$var$Ccaron,
    Ccedi: $538971b5b904f078$var$Ccedi,
    Ccedil: $538971b5b904f078$var$Ccedil$1,
    Ccirc: $538971b5b904f078$var$Ccirc,
    Cconint: $538971b5b904f078$var$Cconint,
    Cdot: $538971b5b904f078$var$Cdot,
    Cedilla: $538971b5b904f078$var$Cedilla,
    CenterDot: $538971b5b904f078$var$CenterDot,
    Cfr: $538971b5b904f078$var$Cfr,
    Chi: $538971b5b904f078$var$Chi$1,
    CircleDot: $538971b5b904f078$var$CircleDot,
    CircleMinus: $538971b5b904f078$var$CircleMinus,
    CirclePlus: $538971b5b904f078$var$CirclePlus,
    CircleTimes: $538971b5b904f078$var$CircleTimes,
    ClockwiseContourIntegral: $538971b5b904f078$var$ClockwiseContourIntegral,
    CloseCurlyDoubleQuote: $538971b5b904f078$var$CloseCurlyDoubleQuote,
    CloseCurlyQuote: $538971b5b904f078$var$CloseCurlyQuote,
    Colon: $538971b5b904f078$var$Colon,
    Colone: $538971b5b904f078$var$Colone,
    Congruent: $538971b5b904f078$var$Congruent,
    Conint: $538971b5b904f078$var$Conint,
    ContourIntegral: $538971b5b904f078$var$ContourIntegral,
    Copf: $538971b5b904f078$var$Copf,
    Coproduct: $538971b5b904f078$var$Coproduct,
    CounterClockwiseContourIntegral: $538971b5b904f078$var$CounterClockwiseContourIntegral,
    Cross: $538971b5b904f078$var$Cross,
    Cscr: $538971b5b904f078$var$Cscr,
    Cup: $538971b5b904f078$var$Cup,
    CupCap: $538971b5b904f078$var$CupCap,
    DD: $538971b5b904f078$var$DD,
    DDotrahd: $538971b5b904f078$var$DDotrahd,
    DJcy: $538971b5b904f078$var$DJcy,
    DScy: $538971b5b904f078$var$DScy,
    DZcy: $538971b5b904f078$var$DZcy,
    Dagger: $538971b5b904f078$var$Dagger$1,
    Darr: $538971b5b904f078$var$Darr,
    Dashv: $538971b5b904f078$var$Dashv,
    Dcaron: $538971b5b904f078$var$Dcaron,
    Dcy: $538971b5b904f078$var$Dcy,
    Del: $538971b5b904f078$var$Del,
    Delta: $538971b5b904f078$var$Delta$1,
    Dfr: $538971b5b904f078$var$Dfr,
    DiacriticalAcute: $538971b5b904f078$var$DiacriticalAcute,
    DiacriticalDot: $538971b5b904f078$var$DiacriticalDot,
    DiacriticalDoubleAcute: $538971b5b904f078$var$DiacriticalDoubleAcute,
    DiacriticalGrave: $538971b5b904f078$var$DiacriticalGrave,
    DiacriticalTilde: $538971b5b904f078$var$DiacriticalTilde,
    Diamond: $538971b5b904f078$var$Diamond,
    DifferentialD: $538971b5b904f078$var$DifferentialD,
    Dopf: $538971b5b904f078$var$Dopf,
    Dot: $538971b5b904f078$var$Dot,
    DotDot: $538971b5b904f078$var$DotDot,
    DotEqual: $538971b5b904f078$var$DotEqual,
    DoubleContourIntegral: $538971b5b904f078$var$DoubleContourIntegral,
    DoubleDot: $538971b5b904f078$var$DoubleDot,
    DoubleDownArrow: $538971b5b904f078$var$DoubleDownArrow,
    DoubleLeftArrow: $538971b5b904f078$var$DoubleLeftArrow,
    DoubleLeftRightArrow: $538971b5b904f078$var$DoubleLeftRightArrow,
    DoubleLeftTee: $538971b5b904f078$var$DoubleLeftTee,
    DoubleLongLeftArrow: $538971b5b904f078$var$DoubleLongLeftArrow,
    DoubleLongLeftRightArrow: $538971b5b904f078$var$DoubleLongLeftRightArrow,
    DoubleLongRightArrow: $538971b5b904f078$var$DoubleLongRightArrow,
    DoubleRightArrow: $538971b5b904f078$var$DoubleRightArrow,
    DoubleRightTee: $538971b5b904f078$var$DoubleRightTee,
    DoubleUpArrow: $538971b5b904f078$var$DoubleUpArrow,
    DoubleUpDownArrow: $538971b5b904f078$var$DoubleUpDownArrow,
    DoubleVerticalBar: $538971b5b904f078$var$DoubleVerticalBar,
    DownArrow: $538971b5b904f078$var$DownArrow,
    DownArrowBar: $538971b5b904f078$var$DownArrowBar,
    DownArrowUpArrow: $538971b5b904f078$var$DownArrowUpArrow,
    DownBreve: $538971b5b904f078$var$DownBreve,
    DownLeftRightVector: $538971b5b904f078$var$DownLeftRightVector,
    DownLeftTeeVector: $538971b5b904f078$var$DownLeftTeeVector,
    DownLeftVector: $538971b5b904f078$var$DownLeftVector,
    DownLeftVectorBar: $538971b5b904f078$var$DownLeftVectorBar,
    DownRightTeeVector: $538971b5b904f078$var$DownRightTeeVector,
    DownRightVector: $538971b5b904f078$var$DownRightVector,
    DownRightVectorBar: $538971b5b904f078$var$DownRightVectorBar,
    DownTee: $538971b5b904f078$var$DownTee,
    DownTeeArrow: $538971b5b904f078$var$DownTeeArrow,
    Downarrow: $538971b5b904f078$var$Downarrow,
    Dscr: $538971b5b904f078$var$Dscr,
    Dstrok: $538971b5b904f078$var$Dstrok,
    ENG: $538971b5b904f078$var$ENG,
    ET: $538971b5b904f078$var$ET,
    ETH: $538971b5b904f078$var$ETH$1,
    Eacut: $538971b5b904f078$var$Eacut,
    Eacute: $538971b5b904f078$var$Eacute$1,
    Ecaron: $538971b5b904f078$var$Ecaron,
    Ecir: $538971b5b904f078$var$Ecir,
    Ecirc: $538971b5b904f078$var$Ecirc$1,
    Ecy: $538971b5b904f078$var$Ecy,
    Edot: $538971b5b904f078$var$Edot,
    Efr: $538971b5b904f078$var$Efr,
    Egrav: $538971b5b904f078$var$Egrav,
    Egrave: $538971b5b904f078$var$Egrave$1,
    Element: $538971b5b904f078$var$Element,
    Emacr: $538971b5b904f078$var$Emacr,
    EmptySmallSquare: $538971b5b904f078$var$EmptySmallSquare,
    EmptyVerySmallSquare: $538971b5b904f078$var$EmptyVerySmallSquare,
    Eogon: $538971b5b904f078$var$Eogon,
    Eopf: $538971b5b904f078$var$Eopf,
    Epsilon: $538971b5b904f078$var$Epsilon$1,
    Equal: $538971b5b904f078$var$Equal,
    EqualTilde: $538971b5b904f078$var$EqualTilde,
    Equilibrium: $538971b5b904f078$var$Equilibrium,
    Escr: $538971b5b904f078$var$Escr,
    Esim: $538971b5b904f078$var$Esim,
    Eta: $538971b5b904f078$var$Eta$1,
    Eum: $538971b5b904f078$var$Eum,
    Euml: $538971b5b904f078$var$Euml$1,
    Exists: $538971b5b904f078$var$Exists,
    ExponentialE: $538971b5b904f078$var$ExponentialE,
    Fcy: $538971b5b904f078$var$Fcy,
    Ffr: $538971b5b904f078$var$Ffr,
    FilledSmallSquare: $538971b5b904f078$var$FilledSmallSquare,
    FilledVerySmallSquare: $538971b5b904f078$var$FilledVerySmallSquare,
    Fopf: $538971b5b904f078$var$Fopf,
    ForAll: $538971b5b904f078$var$ForAll,
    Fouriertrf: $538971b5b904f078$var$Fouriertrf,
    Fscr: $538971b5b904f078$var$Fscr,
    GJcy: $538971b5b904f078$var$GJcy,
    G: $538971b5b904f078$var$G,
    GT: $538971b5b904f078$var$GT$1,
    Gamma: $538971b5b904f078$var$Gamma$1,
    Gammad: $538971b5b904f078$var$Gammad,
    Gbreve: $538971b5b904f078$var$Gbreve,
    Gcedil: $538971b5b904f078$var$Gcedil,
    Gcirc: $538971b5b904f078$var$Gcirc,
    Gcy: $538971b5b904f078$var$Gcy,
    Gdot: $538971b5b904f078$var$Gdot,
    Gfr: $538971b5b904f078$var$Gfr,
    Gg: $538971b5b904f078$var$Gg,
    Gopf: $538971b5b904f078$var$Gopf,
    GreaterEqual: $538971b5b904f078$var$GreaterEqual,
    GreaterEqualLess: $538971b5b904f078$var$GreaterEqualLess,
    GreaterFullEqual: $538971b5b904f078$var$GreaterFullEqual,
    GreaterGreater: $538971b5b904f078$var$GreaterGreater,
    GreaterLess: $538971b5b904f078$var$GreaterLess,
    GreaterSlantEqual: $538971b5b904f078$var$GreaterSlantEqual,
    GreaterTilde: $538971b5b904f078$var$GreaterTilde,
    Gscr: $538971b5b904f078$var$Gscr,
    Gt: $538971b5b904f078$var$Gt,
    HARDcy: $538971b5b904f078$var$HARDcy,
    Hacek: $538971b5b904f078$var$Hacek,
    Hat: $538971b5b904f078$var$Hat,
    Hcirc: $538971b5b904f078$var$Hcirc,
    Hfr: $538971b5b904f078$var$Hfr,
    HilbertSpace: $538971b5b904f078$var$HilbertSpace,
    Hopf: $538971b5b904f078$var$Hopf,
    HorizontalLine: $538971b5b904f078$var$HorizontalLine,
    Hscr: $538971b5b904f078$var$Hscr,
    Hstrok: $538971b5b904f078$var$Hstrok,
    HumpDownHump: $538971b5b904f078$var$HumpDownHump,
    HumpEqual: $538971b5b904f078$var$HumpEqual,
    IEcy: $538971b5b904f078$var$IEcy,
    IJlig: $538971b5b904f078$var$IJlig,
    IOcy: $538971b5b904f078$var$IOcy,
    Iacut: $538971b5b904f078$var$Iacut,
    Iacute: $538971b5b904f078$var$Iacute$1,
    Icir: $538971b5b904f078$var$Icir,
    Icirc: $538971b5b904f078$var$Icirc$1,
    Icy: $538971b5b904f078$var$Icy,
    Idot: $538971b5b904f078$var$Idot,
    Ifr: $538971b5b904f078$var$Ifr,
    Igrav: $538971b5b904f078$var$Igrav,
    Igrave: $538971b5b904f078$var$Igrave$1,
    Im: $538971b5b904f078$var$Im,
    Imacr: $538971b5b904f078$var$Imacr,
    ImaginaryI: $538971b5b904f078$var$ImaginaryI,
    Implies: $538971b5b904f078$var$Implies,
    Int: $538971b5b904f078$var$Int,
    Integral: $538971b5b904f078$var$Integral,
    Intersection: $538971b5b904f078$var$Intersection,
    InvisibleComma: $538971b5b904f078$var$InvisibleComma,
    InvisibleTimes: $538971b5b904f078$var$InvisibleTimes,
    Iogon: $538971b5b904f078$var$Iogon,
    Iopf: $538971b5b904f078$var$Iopf,
    Iota: $538971b5b904f078$var$Iota$1,
    Iscr: $538971b5b904f078$var$Iscr,
    Itilde: $538971b5b904f078$var$Itilde,
    Iukcy: $538971b5b904f078$var$Iukcy,
    Ium: $538971b5b904f078$var$Ium,
    Iuml: $538971b5b904f078$var$Iuml$1,
    Jcirc: $538971b5b904f078$var$Jcirc,
    Jcy: $538971b5b904f078$var$Jcy,
    Jfr: $538971b5b904f078$var$Jfr,
    Jopf: $538971b5b904f078$var$Jopf,
    Jscr: $538971b5b904f078$var$Jscr,
    Jsercy: $538971b5b904f078$var$Jsercy,
    Jukcy: $538971b5b904f078$var$Jukcy,
    KHcy: $538971b5b904f078$var$KHcy,
    KJcy: $538971b5b904f078$var$KJcy,
    Kappa: $538971b5b904f078$var$Kappa$1,
    Kcedil: $538971b5b904f078$var$Kcedil,
    Kcy: $538971b5b904f078$var$Kcy,
    Kfr: $538971b5b904f078$var$Kfr,
    Kopf: $538971b5b904f078$var$Kopf,
    Kscr: $538971b5b904f078$var$Kscr,
    LJcy: $538971b5b904f078$var$LJcy,
    L: $538971b5b904f078$var$L,
    LT: $538971b5b904f078$var$LT$1,
    Lacute: $538971b5b904f078$var$Lacute,
    Lambda: $538971b5b904f078$var$Lambda$1,
    Lang: $538971b5b904f078$var$Lang,
    Laplacetrf: $538971b5b904f078$var$Laplacetrf,
    Larr: $538971b5b904f078$var$Larr,
    Lcaron: $538971b5b904f078$var$Lcaron,
    Lcedil: $538971b5b904f078$var$Lcedil,
    Lcy: $538971b5b904f078$var$Lcy,
    LeftAngleBracket: $538971b5b904f078$var$LeftAngleBracket,
    LeftArrow: $538971b5b904f078$var$LeftArrow,
    LeftArrowBar: $538971b5b904f078$var$LeftArrowBar,
    LeftArrowRightArrow: $538971b5b904f078$var$LeftArrowRightArrow,
    LeftCeiling: $538971b5b904f078$var$LeftCeiling,
    LeftDoubleBracket: $538971b5b904f078$var$LeftDoubleBracket,
    LeftDownTeeVector: $538971b5b904f078$var$LeftDownTeeVector,
    LeftDownVector: $538971b5b904f078$var$LeftDownVector,
    LeftDownVectorBar: $538971b5b904f078$var$LeftDownVectorBar,
    LeftFloor: $538971b5b904f078$var$LeftFloor,
    LeftRightArrow: $538971b5b904f078$var$LeftRightArrow,
    LeftRightVector: $538971b5b904f078$var$LeftRightVector,
    LeftTee: $538971b5b904f078$var$LeftTee,
    LeftTeeArrow: $538971b5b904f078$var$LeftTeeArrow,
    LeftTeeVector: $538971b5b904f078$var$LeftTeeVector,
    LeftTriangle: $538971b5b904f078$var$LeftTriangle,
    LeftTriangleBar: $538971b5b904f078$var$LeftTriangleBar,
    LeftTriangleEqual: $538971b5b904f078$var$LeftTriangleEqual,
    LeftUpDownVector: $538971b5b904f078$var$LeftUpDownVector,
    LeftUpTeeVector: $538971b5b904f078$var$LeftUpTeeVector,
    LeftUpVector: $538971b5b904f078$var$LeftUpVector,
    LeftUpVectorBar: $538971b5b904f078$var$LeftUpVectorBar,
    LeftVector: $538971b5b904f078$var$LeftVector,
    LeftVectorBar: $538971b5b904f078$var$LeftVectorBar,
    Leftarrow: $538971b5b904f078$var$Leftarrow,
    Leftrightarrow: $538971b5b904f078$var$Leftrightarrow,
    LessEqualGreater: $538971b5b904f078$var$LessEqualGreater,
    LessFullEqual: $538971b5b904f078$var$LessFullEqual,
    LessGreater: $538971b5b904f078$var$LessGreater,
    LessLess: $538971b5b904f078$var$LessLess,
    LessSlantEqual: $538971b5b904f078$var$LessSlantEqual,
    LessTilde: $538971b5b904f078$var$LessTilde,
    Lfr: $538971b5b904f078$var$Lfr,
    Ll: $538971b5b904f078$var$Ll,
    Lleftarrow: $538971b5b904f078$var$Lleftarrow,
    Lmidot: $538971b5b904f078$var$Lmidot,
    LongLeftArrow: $538971b5b904f078$var$LongLeftArrow,
    LongLeftRightArrow: $538971b5b904f078$var$LongLeftRightArrow,
    LongRightArrow: $538971b5b904f078$var$LongRightArrow,
    Longleftarrow: $538971b5b904f078$var$Longleftarrow,
    Longleftrightarrow: $538971b5b904f078$var$Longleftrightarrow,
    Longrightarrow: $538971b5b904f078$var$Longrightarrow,
    Lopf: $538971b5b904f078$var$Lopf,
    LowerLeftArrow: $538971b5b904f078$var$LowerLeftArrow,
    LowerRightArrow: $538971b5b904f078$var$LowerRightArrow,
    Lscr: $538971b5b904f078$var$Lscr,
    Lsh: $538971b5b904f078$var$Lsh,
    Lstrok: $538971b5b904f078$var$Lstrok,
    Lt: $538971b5b904f078$var$Lt,
    Mcy: $538971b5b904f078$var$Mcy,
    MediumSpace: $538971b5b904f078$var$MediumSpace,
    Mellintrf: $538971b5b904f078$var$Mellintrf,
    Mfr: $538971b5b904f078$var$Mfr,
    MinusPlus: $538971b5b904f078$var$MinusPlus,
    Mopf: $538971b5b904f078$var$Mopf,
    Mscr: $538971b5b904f078$var$Mscr,
    Mu: $538971b5b904f078$var$Mu$1,
    NJcy: $538971b5b904f078$var$NJcy,
    Nacute: $538971b5b904f078$var$Nacute,
    Ncaron: $538971b5b904f078$var$Ncaron,
    Ncedil: $538971b5b904f078$var$Ncedil,
    Ncy: $538971b5b904f078$var$Ncy,
    NegativeMediumSpace: $538971b5b904f078$var$NegativeMediumSpace,
    NegativeThickSpace: $538971b5b904f078$var$NegativeThickSpace,
    NegativeThinSpace: $538971b5b904f078$var$NegativeThinSpace,
    NegativeVeryThinSpace: $538971b5b904f078$var$NegativeVeryThinSpace,
    NestedGreaterGreater: $538971b5b904f078$var$NestedGreaterGreater,
    NestedLessLess: $538971b5b904f078$var$NestedLessLess,
    NewLine: $538971b5b904f078$var$NewLine,
    Nfr: $538971b5b904f078$var$Nfr,
    NoBreak: $538971b5b904f078$var$NoBreak,
    NonBreakingSpace: $538971b5b904f078$var$NonBreakingSpace,
    Nopf: $538971b5b904f078$var$Nopf,
    Not: $538971b5b904f078$var$Not,
    NotCongruent: $538971b5b904f078$var$NotCongruent,
    NotCupCap: $538971b5b904f078$var$NotCupCap,
    NotDoubleVerticalBar: $538971b5b904f078$var$NotDoubleVerticalBar,
    NotElement: $538971b5b904f078$var$NotElement,
    NotEqual: $538971b5b904f078$var$NotEqual,
    NotEqualTilde: $538971b5b904f078$var$NotEqualTilde,
    NotExists: $538971b5b904f078$var$NotExists,
    NotGreater: $538971b5b904f078$var$NotGreater,
    NotGreaterEqual: $538971b5b904f078$var$NotGreaterEqual,
    NotGreaterFullEqual: $538971b5b904f078$var$NotGreaterFullEqual,
    NotGreaterGreater: $538971b5b904f078$var$NotGreaterGreater,
    NotGreaterLess: $538971b5b904f078$var$NotGreaterLess,
    NotGreaterSlantEqual: $538971b5b904f078$var$NotGreaterSlantEqual,
    NotGreaterTilde: $538971b5b904f078$var$NotGreaterTilde,
    NotHumpDownHump: $538971b5b904f078$var$NotHumpDownHump,
    NotHumpEqual: $538971b5b904f078$var$NotHumpEqual,
    NotLeftTriangle: $538971b5b904f078$var$NotLeftTriangle,
    NotLeftTriangleBar: $538971b5b904f078$var$NotLeftTriangleBar,
    NotLeftTriangleEqual: $538971b5b904f078$var$NotLeftTriangleEqual,
    NotLess: $538971b5b904f078$var$NotLess,
    NotLessEqual: $538971b5b904f078$var$NotLessEqual,
    NotLessGreater: $538971b5b904f078$var$NotLessGreater,
    NotLessLess: $538971b5b904f078$var$NotLessLess,
    NotLessSlantEqual: $538971b5b904f078$var$NotLessSlantEqual,
    NotLessTilde: $538971b5b904f078$var$NotLessTilde,
    NotNestedGreaterGreater: $538971b5b904f078$var$NotNestedGreaterGreater,
    NotNestedLessLess: $538971b5b904f078$var$NotNestedLessLess,
    NotPrecedes: $538971b5b904f078$var$NotPrecedes,
    NotPrecedesEqual: $538971b5b904f078$var$NotPrecedesEqual,
    NotPrecedesSlantEqual: $538971b5b904f078$var$NotPrecedesSlantEqual,
    NotReverseElement: $538971b5b904f078$var$NotReverseElement,
    NotRightTriangle: $538971b5b904f078$var$NotRightTriangle,
    NotRightTriangleBar: $538971b5b904f078$var$NotRightTriangleBar,
    NotRightTriangleEqual: $538971b5b904f078$var$NotRightTriangleEqual,
    NotSquareSubset: $538971b5b904f078$var$NotSquareSubset,
    NotSquareSubsetEqual: $538971b5b904f078$var$NotSquareSubsetEqual,
    NotSquareSuperset: $538971b5b904f078$var$NotSquareSuperset,
    NotSquareSupersetEqual: $538971b5b904f078$var$NotSquareSupersetEqual,
    NotSubset: $538971b5b904f078$var$NotSubset,
    NotSubsetEqual: $538971b5b904f078$var$NotSubsetEqual,
    NotSucceeds: $538971b5b904f078$var$NotSucceeds,
    NotSucceedsEqual: $538971b5b904f078$var$NotSucceedsEqual,
    NotSucceedsSlantEqual: $538971b5b904f078$var$NotSucceedsSlantEqual,
    NotSucceedsTilde: $538971b5b904f078$var$NotSucceedsTilde,
    NotSuperset: $538971b5b904f078$var$NotSuperset,
    NotSupersetEqual: $538971b5b904f078$var$NotSupersetEqual,
    NotTilde: $538971b5b904f078$var$NotTilde,
    NotTildeEqual: $538971b5b904f078$var$NotTildeEqual,
    NotTildeFullEqual: $538971b5b904f078$var$NotTildeFullEqual,
    NotTildeTilde: $538971b5b904f078$var$NotTildeTilde,
    NotVerticalBar: $538971b5b904f078$var$NotVerticalBar,
    Nscr: $538971b5b904f078$var$Nscr,
    Ntild: $538971b5b904f078$var$Ntild,
    Ntilde: $538971b5b904f078$var$Ntilde$1,
    Nu: $538971b5b904f078$var$Nu$1,
    OElig: $538971b5b904f078$var$OElig$1,
    Oacut: $538971b5b904f078$var$Oacut,
    Oacute: $538971b5b904f078$var$Oacute$1,
    Ocir: $538971b5b904f078$var$Ocir,
    Ocirc: $538971b5b904f078$var$Ocirc$1,
    Ocy: $538971b5b904f078$var$Ocy,
    Odblac: $538971b5b904f078$var$Odblac,
    Ofr: $538971b5b904f078$var$Ofr,
    Ograv: $538971b5b904f078$var$Ograv,
    Ograve: $538971b5b904f078$var$Ograve$1,
    Omacr: $538971b5b904f078$var$Omacr,
    Omega: $538971b5b904f078$var$Omega$1,
    Omicron: $538971b5b904f078$var$Omicron$1,
    Oopf: $538971b5b904f078$var$Oopf,
    OpenCurlyDoubleQuote: $538971b5b904f078$var$OpenCurlyDoubleQuote,
    OpenCurlyQuote: $538971b5b904f078$var$OpenCurlyQuote,
    Or: $538971b5b904f078$var$Or,
    Oscr: $538971b5b904f078$var$Oscr,
    Oslas: $538971b5b904f078$var$Oslas,
    Oslash: $538971b5b904f078$var$Oslash$1,
    Otild: $538971b5b904f078$var$Otild,
    Otilde: $538971b5b904f078$var$Otilde$1,
    Otimes: $538971b5b904f078$var$Otimes,
    Oum: $538971b5b904f078$var$Oum,
    Ouml: $538971b5b904f078$var$Ouml$1,
    OverBar: $538971b5b904f078$var$OverBar,
    OverBrace: $538971b5b904f078$var$OverBrace,
    OverBracket: $538971b5b904f078$var$OverBracket,
    OverParenthesis: $538971b5b904f078$var$OverParenthesis,
    PartialD: $538971b5b904f078$var$PartialD,
    Pcy: $538971b5b904f078$var$Pcy,
    Pfr: $538971b5b904f078$var$Pfr,
    Phi: $538971b5b904f078$var$Phi$1,
    Pi: $538971b5b904f078$var$Pi$1,
    PlusMinus: $538971b5b904f078$var$PlusMinus,
    Poincareplane: $538971b5b904f078$var$Poincareplane,
    Popf: $538971b5b904f078$var$Popf,
    Pr: $538971b5b904f078$var$Pr,
    Precedes: $538971b5b904f078$var$Precedes,
    PrecedesEqual: $538971b5b904f078$var$PrecedesEqual,
    PrecedesSlantEqual: $538971b5b904f078$var$PrecedesSlantEqual,
    PrecedesTilde: $538971b5b904f078$var$PrecedesTilde,
    Prime: $538971b5b904f078$var$Prime$1,
    Product: $538971b5b904f078$var$Product,
    Proportion: $538971b5b904f078$var$Proportion,
    Proportional: $538971b5b904f078$var$Proportional,
    Pscr: $538971b5b904f078$var$Pscr,
    Psi: $538971b5b904f078$var$Psi$1,
    QUO: $538971b5b904f078$var$QUO,
    QUOT: $538971b5b904f078$var$QUOT,
    Qfr: $538971b5b904f078$var$Qfr,
    Qopf: $538971b5b904f078$var$Qopf,
    Qscr: $538971b5b904f078$var$Qscr,
    RBarr: $538971b5b904f078$var$RBarr,
    RE: $538971b5b904f078$var$RE,
    REG: $538971b5b904f078$var$REG,
    Racute: $538971b5b904f078$var$Racute,
    Rang: $538971b5b904f078$var$Rang,
    Rarr: $538971b5b904f078$var$Rarr,
    Rarrtl: $538971b5b904f078$var$Rarrtl,
    Rcaron: $538971b5b904f078$var$Rcaron,
    Rcedil: $538971b5b904f078$var$Rcedil,
    Rcy: $538971b5b904f078$var$Rcy,
    Re: $538971b5b904f078$var$Re,
    ReverseElement: $538971b5b904f078$var$ReverseElement,
    ReverseEquilibrium: $538971b5b904f078$var$ReverseEquilibrium,
    ReverseUpEquilibrium: $538971b5b904f078$var$ReverseUpEquilibrium,
    Rfr: $538971b5b904f078$var$Rfr,
    Rho: $538971b5b904f078$var$Rho$1,
    RightAngleBracket: $538971b5b904f078$var$RightAngleBracket,
    RightArrow: $538971b5b904f078$var$RightArrow,
    RightArrowBar: $538971b5b904f078$var$RightArrowBar,
    RightArrowLeftArrow: $538971b5b904f078$var$RightArrowLeftArrow,
    RightCeiling: $538971b5b904f078$var$RightCeiling,
    RightDoubleBracket: $538971b5b904f078$var$RightDoubleBracket,
    RightDownTeeVector: $538971b5b904f078$var$RightDownTeeVector,
    RightDownVector: $538971b5b904f078$var$RightDownVector,
    RightDownVectorBar: $538971b5b904f078$var$RightDownVectorBar,
    RightFloor: $538971b5b904f078$var$RightFloor,
    RightTee: $538971b5b904f078$var$RightTee,
    RightTeeArrow: $538971b5b904f078$var$RightTeeArrow,
    RightTeeVector: $538971b5b904f078$var$RightTeeVector,
    RightTriangle: $538971b5b904f078$var$RightTriangle,
    RightTriangleBar: $538971b5b904f078$var$RightTriangleBar,
    RightTriangleEqual: $538971b5b904f078$var$RightTriangleEqual,
    RightUpDownVector: $538971b5b904f078$var$RightUpDownVector,
    RightUpTeeVector: $538971b5b904f078$var$RightUpTeeVector,
    RightUpVector: $538971b5b904f078$var$RightUpVector,
    RightUpVectorBar: $538971b5b904f078$var$RightUpVectorBar,
    RightVector: $538971b5b904f078$var$RightVector,
    RightVectorBar: $538971b5b904f078$var$RightVectorBar,
    Rightarrow: $538971b5b904f078$var$Rightarrow,
    Ropf: $538971b5b904f078$var$Ropf,
    RoundImplies: $538971b5b904f078$var$RoundImplies,
    Rrightarrow: $538971b5b904f078$var$Rrightarrow,
    Rscr: $538971b5b904f078$var$Rscr,
    Rsh: $538971b5b904f078$var$Rsh,
    RuleDelayed: $538971b5b904f078$var$RuleDelayed,
    SHCHcy: $538971b5b904f078$var$SHCHcy,
    SHcy: $538971b5b904f078$var$SHcy,
    SOFTcy: $538971b5b904f078$var$SOFTcy,
    Sacute: $538971b5b904f078$var$Sacute,
    Sc: $538971b5b904f078$var$Sc,
    Scaron: $538971b5b904f078$var$Scaron$1,
    Scedil: $538971b5b904f078$var$Scedil,
    Scirc: $538971b5b904f078$var$Scirc,
    Scy: $538971b5b904f078$var$Scy,
    Sfr: $538971b5b904f078$var$Sfr,
    ShortDownArrow: $538971b5b904f078$var$ShortDownArrow,
    ShortLeftArrow: $538971b5b904f078$var$ShortLeftArrow,
    ShortRightArrow: $538971b5b904f078$var$ShortRightArrow,
    ShortUpArrow: $538971b5b904f078$var$ShortUpArrow,
    Sigma: $538971b5b904f078$var$Sigma$1,
    SmallCircle: $538971b5b904f078$var$SmallCircle,
    Sopf: $538971b5b904f078$var$Sopf,
    Sqrt: $538971b5b904f078$var$Sqrt,
    Square: $538971b5b904f078$var$Square,
    SquareIntersection: $538971b5b904f078$var$SquareIntersection,
    SquareSubset: $538971b5b904f078$var$SquareSubset,
    SquareSubsetEqual: $538971b5b904f078$var$SquareSubsetEqual,
    SquareSuperset: $538971b5b904f078$var$SquareSuperset,
    SquareSupersetEqual: $538971b5b904f078$var$SquareSupersetEqual,
    SquareUnion: $538971b5b904f078$var$SquareUnion,
    Sscr: $538971b5b904f078$var$Sscr,
    Star: $538971b5b904f078$var$Star,
    Sub: $538971b5b904f078$var$Sub,
    Subset: $538971b5b904f078$var$Subset,
    SubsetEqual: $538971b5b904f078$var$SubsetEqual,
    Succeeds: $538971b5b904f078$var$Succeeds,
    SucceedsEqual: $538971b5b904f078$var$SucceedsEqual,
    SucceedsSlantEqual: $538971b5b904f078$var$SucceedsSlantEqual,
    SucceedsTilde: $538971b5b904f078$var$SucceedsTilde,
    SuchThat: $538971b5b904f078$var$SuchThat,
    Sum: $538971b5b904f078$var$Sum,
    Sup: $538971b5b904f078$var$Sup,
    Superset: $538971b5b904f078$var$Superset,
    SupersetEqual: $538971b5b904f078$var$SupersetEqual,
    Supset: $538971b5b904f078$var$Supset,
    THOR: $538971b5b904f078$var$THOR,
    THORN: $538971b5b904f078$var$THORN$1,
    TRADE: $538971b5b904f078$var$TRADE,
    TSHcy: $538971b5b904f078$var$TSHcy,
    TScy: $538971b5b904f078$var$TScy,
    Tab: $538971b5b904f078$var$Tab,
    Tau: $538971b5b904f078$var$Tau$1,
    Tcaron: $538971b5b904f078$var$Tcaron,
    Tcedil: $538971b5b904f078$var$Tcedil,
    Tcy: $538971b5b904f078$var$Tcy,
    Tfr: $538971b5b904f078$var$Tfr,
    Therefore: $538971b5b904f078$var$Therefore,
    Theta: $538971b5b904f078$var$Theta$1,
    ThickSpace: $538971b5b904f078$var$ThickSpace,
    ThinSpace: $538971b5b904f078$var$ThinSpace,
    Tilde: $538971b5b904f078$var$Tilde,
    TildeEqual: $538971b5b904f078$var$TildeEqual,
    TildeFullEqual: $538971b5b904f078$var$TildeFullEqual,
    TildeTilde: $538971b5b904f078$var$TildeTilde,
    Topf: $538971b5b904f078$var$Topf,
    TripleDot: $538971b5b904f078$var$TripleDot,
    Tscr: $538971b5b904f078$var$Tscr,
    Tstrok: $538971b5b904f078$var$Tstrok,
    Uacut: $538971b5b904f078$var$Uacut,
    Uacute: $538971b5b904f078$var$Uacute$1,
    Uarr: $538971b5b904f078$var$Uarr,
    Uarrocir: $538971b5b904f078$var$Uarrocir,
    Ubrcy: $538971b5b904f078$var$Ubrcy,
    Ubreve: $538971b5b904f078$var$Ubreve,
    Ucir: $538971b5b904f078$var$Ucir,
    Ucirc: $538971b5b904f078$var$Ucirc$1,
    Ucy: $538971b5b904f078$var$Ucy,
    Udblac: $538971b5b904f078$var$Udblac,
    Ufr: $538971b5b904f078$var$Ufr,
    Ugrav: $538971b5b904f078$var$Ugrav,
    Ugrave: $538971b5b904f078$var$Ugrave$1,
    Umacr: $538971b5b904f078$var$Umacr,
    UnderBar: $538971b5b904f078$var$UnderBar,
    UnderBrace: $538971b5b904f078$var$UnderBrace,
    UnderBracket: $538971b5b904f078$var$UnderBracket,
    UnderParenthesis: $538971b5b904f078$var$UnderParenthesis,
    Union: $538971b5b904f078$var$Union,
    UnionPlus: $538971b5b904f078$var$UnionPlus,
    Uogon: $538971b5b904f078$var$Uogon,
    Uopf: $538971b5b904f078$var$Uopf,
    UpArrow: $538971b5b904f078$var$UpArrow,
    UpArrowBar: $538971b5b904f078$var$UpArrowBar,
    UpArrowDownArrow: $538971b5b904f078$var$UpArrowDownArrow,
    UpDownArrow: $538971b5b904f078$var$UpDownArrow,
    UpEquilibrium: $538971b5b904f078$var$UpEquilibrium,
    UpTee: $538971b5b904f078$var$UpTee,
    UpTeeArrow: $538971b5b904f078$var$UpTeeArrow,
    Uparrow: $538971b5b904f078$var$Uparrow,
    Updownarrow: $538971b5b904f078$var$Updownarrow,
    UpperLeftArrow: $538971b5b904f078$var$UpperLeftArrow,
    UpperRightArrow: $538971b5b904f078$var$UpperRightArrow,
    Upsi: $538971b5b904f078$var$Upsi,
    Upsilon: $538971b5b904f078$var$Upsilon$1,
    Uring: $538971b5b904f078$var$Uring,
    Uscr: $538971b5b904f078$var$Uscr,
    Utilde: $538971b5b904f078$var$Utilde,
    Uum: $538971b5b904f078$var$Uum,
    Uuml: $538971b5b904f078$var$Uuml$1,
    VDash: $538971b5b904f078$var$VDash,
    Vbar: $538971b5b904f078$var$Vbar,
    Vcy: $538971b5b904f078$var$Vcy,
    Vdash: $538971b5b904f078$var$Vdash,
    Vdashl: $538971b5b904f078$var$Vdashl,
    Vee: $538971b5b904f078$var$Vee,
    Verbar: $538971b5b904f078$var$Verbar,
    Vert: $538971b5b904f078$var$Vert,
    VerticalBar: $538971b5b904f078$var$VerticalBar,
    VerticalLine: $538971b5b904f078$var$VerticalLine,
    VerticalSeparator: $538971b5b904f078$var$VerticalSeparator,
    VerticalTilde: $538971b5b904f078$var$VerticalTilde,
    VeryThinSpace: $538971b5b904f078$var$VeryThinSpace,
    Vfr: $538971b5b904f078$var$Vfr,
    Vopf: $538971b5b904f078$var$Vopf,
    Vscr: $538971b5b904f078$var$Vscr,
    Vvdash: $538971b5b904f078$var$Vvdash,
    Wcirc: $538971b5b904f078$var$Wcirc,
    Wedge: $538971b5b904f078$var$Wedge,
    Wfr: $538971b5b904f078$var$Wfr,
    Wopf: $538971b5b904f078$var$Wopf,
    Wscr: $538971b5b904f078$var$Wscr,
    Xfr: $538971b5b904f078$var$Xfr,
    Xi: $538971b5b904f078$var$Xi$1,
    Xopf: $538971b5b904f078$var$Xopf,
    Xscr: $538971b5b904f078$var$Xscr,
    YAcy: $538971b5b904f078$var$YAcy,
    YIcy: $538971b5b904f078$var$YIcy,
    YUcy: $538971b5b904f078$var$YUcy,
    Yacut: $538971b5b904f078$var$Yacut,
    Yacute: $538971b5b904f078$var$Yacute$1,
    Ycirc: $538971b5b904f078$var$Ycirc,
    Ycy: $538971b5b904f078$var$Ycy,
    Yfr: $538971b5b904f078$var$Yfr,
    Yopf: $538971b5b904f078$var$Yopf,
    Yscr: $538971b5b904f078$var$Yscr,
    Yuml: $538971b5b904f078$var$Yuml$1,
    ZHcy: $538971b5b904f078$var$ZHcy,
    Zacute: $538971b5b904f078$var$Zacute,
    Zcaron: $538971b5b904f078$var$Zcaron,
    Zcy: $538971b5b904f078$var$Zcy,
    Zdot: $538971b5b904f078$var$Zdot,
    ZeroWidthSpace: $538971b5b904f078$var$ZeroWidthSpace,
    Zeta: $538971b5b904f078$var$Zeta$1,
    Zfr: $538971b5b904f078$var$Zfr,
    Zopf: $538971b5b904f078$var$Zopf,
    Zscr: $538971b5b904f078$var$Zscr,
    aacut: $538971b5b904f078$var$aacut,
    aacute: $538971b5b904f078$var$aacute$1,
    abreve: $538971b5b904f078$var$abreve,
    ac: $538971b5b904f078$var$ac,
    acE: $538971b5b904f078$var$acE,
    acd: $538971b5b904f078$var$acd,
    acir: $538971b5b904f078$var$acir,
    acirc: $538971b5b904f078$var$acirc$1,
    acut: $538971b5b904f078$var$acut,
    acute: $538971b5b904f078$var$acute$1,
    acy: $538971b5b904f078$var$acy,
    aeli: $538971b5b904f078$var$aeli,
    aelig: $538971b5b904f078$var$aelig$1,
    af: $538971b5b904f078$var$af,
    afr: $538971b5b904f078$var$afr,
    agrav: $538971b5b904f078$var$agrav,
    agrave: $538971b5b904f078$var$agrave$1,
    alefsym: $538971b5b904f078$var$alefsym$1,
    aleph: $538971b5b904f078$var$aleph,
    alpha: $538971b5b904f078$var$alpha$1,
    amacr: $538971b5b904f078$var$amacr,
    amalg: $538971b5b904f078$var$amalg,
    am: $538971b5b904f078$var$am,
    amp: $538971b5b904f078$var$amp$1,
    and: $538971b5b904f078$var$and$1,
    andand: $538971b5b904f078$var$andand,
    andd: $538971b5b904f078$var$andd,
    andslope: $538971b5b904f078$var$andslope,
    andv: $538971b5b904f078$var$andv,
    ang: $538971b5b904f078$var$ang$1,
    ange: $538971b5b904f078$var$ange,
    angle: $538971b5b904f078$var$angle,
    angmsd: $538971b5b904f078$var$angmsd,
    angmsdaa: $538971b5b904f078$var$angmsdaa,
    angmsdab: $538971b5b904f078$var$angmsdab,
    angmsdac: $538971b5b904f078$var$angmsdac,
    angmsdad: $538971b5b904f078$var$angmsdad,
    angmsdae: $538971b5b904f078$var$angmsdae,
    angmsdaf: $538971b5b904f078$var$angmsdaf,
    angmsdag: $538971b5b904f078$var$angmsdag,
    angmsdah: $538971b5b904f078$var$angmsdah,
    angrt: $538971b5b904f078$var$angrt,
    angrtvb: $538971b5b904f078$var$angrtvb,
    angrtvbd: $538971b5b904f078$var$angrtvbd,
    angsph: $538971b5b904f078$var$angsph,
    angst: $538971b5b904f078$var$angst,
    angzarr: $538971b5b904f078$var$angzarr,
    aogon: $538971b5b904f078$var$aogon,
    aopf: $538971b5b904f078$var$aopf,
    ap: $538971b5b904f078$var$ap,
    apE: $538971b5b904f078$var$apE,
    apacir: $538971b5b904f078$var$apacir,
    ape: $538971b5b904f078$var$ape,
    apid: $538971b5b904f078$var$apid,
    apos: $538971b5b904f078$var$apos,
    approx: $538971b5b904f078$var$approx,
    approxeq: $538971b5b904f078$var$approxeq,
    arin: $538971b5b904f078$var$arin,
    aring: $538971b5b904f078$var$aring$1,
    ascr: $538971b5b904f078$var$ascr,
    ast: $538971b5b904f078$var$ast,
    asymp: $538971b5b904f078$var$asymp$1,
    asympeq: $538971b5b904f078$var$asympeq,
    atild: $538971b5b904f078$var$atild,
    atilde: $538971b5b904f078$var$atilde$1,
    aum: $538971b5b904f078$var$aum,
    auml: $538971b5b904f078$var$auml$1,
    awconint: $538971b5b904f078$var$awconint,
    awint: $538971b5b904f078$var$awint,
    bNot: $538971b5b904f078$var$bNot,
    backcong: $538971b5b904f078$var$backcong,
    backepsilon: $538971b5b904f078$var$backepsilon,
    backprime: $538971b5b904f078$var$backprime,
    backsim: $538971b5b904f078$var$backsim,
    backsimeq: $538971b5b904f078$var$backsimeq,
    barvee: $538971b5b904f078$var$barvee,
    barwed: $538971b5b904f078$var$barwed,
    barwedge: $538971b5b904f078$var$barwedge,
    bbrk: $538971b5b904f078$var$bbrk,
    bbrktbrk: $538971b5b904f078$var$bbrktbrk,
    bcong: $538971b5b904f078$var$bcong,
    bcy: $538971b5b904f078$var$bcy,
    bdquo: $538971b5b904f078$var$bdquo$1,
    becaus: $538971b5b904f078$var$becaus,
    because: $538971b5b904f078$var$because,
    bemptyv: $538971b5b904f078$var$bemptyv,
    bepsi: $538971b5b904f078$var$bepsi,
    bernou: $538971b5b904f078$var$bernou,
    beta: $538971b5b904f078$var$beta$1,
    beth: $538971b5b904f078$var$beth,
    between: $538971b5b904f078$var$between,
    bfr: $538971b5b904f078$var$bfr,
    bigcap: $538971b5b904f078$var$bigcap,
    bigcirc: $538971b5b904f078$var$bigcirc,
    bigcup: $538971b5b904f078$var$bigcup,
    bigodot: $538971b5b904f078$var$bigodot,
    bigoplus: $538971b5b904f078$var$bigoplus,
    bigotimes: $538971b5b904f078$var$bigotimes,
    bigsqcup: $538971b5b904f078$var$bigsqcup,
    bigstar: $538971b5b904f078$var$bigstar,
    bigtriangledown: $538971b5b904f078$var$bigtriangledown,
    bigtriangleup: $538971b5b904f078$var$bigtriangleup,
    biguplus: $538971b5b904f078$var$biguplus,
    bigvee: $538971b5b904f078$var$bigvee,
    bigwedge: $538971b5b904f078$var$bigwedge,
    bkarow: $538971b5b904f078$var$bkarow,
    blacklozenge: $538971b5b904f078$var$blacklozenge,
    blacksquare: $538971b5b904f078$var$blacksquare,
    blacktriangle: $538971b5b904f078$var$blacktriangle,
    blacktriangledown: $538971b5b904f078$var$blacktriangledown,
    blacktriangleleft: $538971b5b904f078$var$blacktriangleleft,
    blacktriangleright: $538971b5b904f078$var$blacktriangleright,
    blank: $538971b5b904f078$var$blank,
    blk12: $538971b5b904f078$var$blk12,
    blk14: $538971b5b904f078$var$blk14,
    blk34: $538971b5b904f078$var$blk34,
    block: $538971b5b904f078$var$block,
    bne: $538971b5b904f078$var$bne,
    bnequiv: $538971b5b904f078$var$bnequiv,
    bnot: $538971b5b904f078$var$bnot,
    bopf: $538971b5b904f078$var$bopf,
    bot: $538971b5b904f078$var$bot,
    bottom: $538971b5b904f078$var$bottom,
    bowtie: $538971b5b904f078$var$bowtie,
    boxDL: $538971b5b904f078$var$boxDL,
    boxDR: $538971b5b904f078$var$boxDR,
    boxDl: $538971b5b904f078$var$boxDl,
    boxDr: $538971b5b904f078$var$boxDr,
    boxH: $538971b5b904f078$var$boxH,
    boxHD: $538971b5b904f078$var$boxHD,
    boxHU: $538971b5b904f078$var$boxHU,
    boxHd: $538971b5b904f078$var$boxHd,
    boxHu: $538971b5b904f078$var$boxHu,
    boxUL: $538971b5b904f078$var$boxUL,
    boxUR: $538971b5b904f078$var$boxUR,
    boxUl: $538971b5b904f078$var$boxUl,
    boxUr: $538971b5b904f078$var$boxUr,
    boxV: $538971b5b904f078$var$boxV,
    boxVH: $538971b5b904f078$var$boxVH,
    boxVL: $538971b5b904f078$var$boxVL,
    boxVR: $538971b5b904f078$var$boxVR,
    boxVh: $538971b5b904f078$var$boxVh,
    boxVl: $538971b5b904f078$var$boxVl,
    boxVr: $538971b5b904f078$var$boxVr,
    boxbox: $538971b5b904f078$var$boxbox,
    boxdL: $538971b5b904f078$var$boxdL,
    boxdR: $538971b5b904f078$var$boxdR,
    boxdl: $538971b5b904f078$var$boxdl,
    boxdr: $538971b5b904f078$var$boxdr,
    boxh: $538971b5b904f078$var$boxh,
    boxhD: $538971b5b904f078$var$boxhD,
    boxhU: $538971b5b904f078$var$boxhU,
    boxhd: $538971b5b904f078$var$boxhd,
    boxhu: $538971b5b904f078$var$boxhu,
    boxminus: $538971b5b904f078$var$boxminus,
    boxplus: $538971b5b904f078$var$boxplus,
    boxtimes: $538971b5b904f078$var$boxtimes,
    boxuL: $538971b5b904f078$var$boxuL,
    boxuR: $538971b5b904f078$var$boxuR,
    boxul: $538971b5b904f078$var$boxul,
    boxur: $538971b5b904f078$var$boxur,
    boxv: $538971b5b904f078$var$boxv,
    boxvH: $538971b5b904f078$var$boxvH,
    boxvL: $538971b5b904f078$var$boxvL,
    boxvR: $538971b5b904f078$var$boxvR,
    boxvh: $538971b5b904f078$var$boxvh,
    boxvl: $538971b5b904f078$var$boxvl,
    boxvr: $538971b5b904f078$var$boxvr,
    bprime: $538971b5b904f078$var$bprime,
    breve: $538971b5b904f078$var$breve,
    brvba: $538971b5b904f078$var$brvba,
    brvbar: $538971b5b904f078$var$brvbar$1,
    bscr: $538971b5b904f078$var$bscr,
    bsemi: $538971b5b904f078$var$bsemi,
    bsim: $538971b5b904f078$var$bsim,
    bsime: $538971b5b904f078$var$bsime,
    bsol: $538971b5b904f078$var$bsol,
    bsolb: $538971b5b904f078$var$bsolb,
    bsolhsub: $538971b5b904f078$var$bsolhsub,
    bull: $538971b5b904f078$var$bull$1,
    bullet: $538971b5b904f078$var$bullet,
    bump: $538971b5b904f078$var$bump,
    bumpE: $538971b5b904f078$var$bumpE,
    bumpe: $538971b5b904f078$var$bumpe,
    bumpeq: $538971b5b904f078$var$bumpeq,
    cacute: $538971b5b904f078$var$cacute,
    cap: $538971b5b904f078$var$cap$2,
    capand: $538971b5b904f078$var$capand,
    capbrcup: $538971b5b904f078$var$capbrcup,
    capcap: $538971b5b904f078$var$capcap,
    capcup: $538971b5b904f078$var$capcup,
    capdot: $538971b5b904f078$var$capdot,
    caps: $538971b5b904f078$var$caps,
    caret: $538971b5b904f078$var$caret,
    caron: $538971b5b904f078$var$caron,
    ccaps: $538971b5b904f078$var$ccaps,
    ccaron: $538971b5b904f078$var$ccaron,
    ccedi: $538971b5b904f078$var$ccedi,
    ccedil: $538971b5b904f078$var$ccedil$1,
    ccirc: $538971b5b904f078$var$ccirc,
    ccups: $538971b5b904f078$var$ccups,
    ccupssm: $538971b5b904f078$var$ccupssm,
    cdot: $538971b5b904f078$var$cdot,
    cedi: $538971b5b904f078$var$cedi,
    cedil: $538971b5b904f078$var$cedil$1,
    cemptyv: $538971b5b904f078$var$cemptyv,
    cen: $538971b5b904f078$var$cen,
    cent: $538971b5b904f078$var$cent$1,
    centerdot: $538971b5b904f078$var$centerdot,
    cfr: $538971b5b904f078$var$cfr,
    chcy: $538971b5b904f078$var$chcy,
    check: $538971b5b904f078$var$check,
    checkmark: $538971b5b904f078$var$checkmark,
    chi: $538971b5b904f078$var$chi$1,
    cir: $538971b5b904f078$var$cir,
    cirE: $538971b5b904f078$var$cirE,
    circ: $538971b5b904f078$var$circ$1,
    circeq: $538971b5b904f078$var$circeq,
    circlearrowleft: $538971b5b904f078$var$circlearrowleft,
    circlearrowright: $538971b5b904f078$var$circlearrowright,
    circledR: $538971b5b904f078$var$circledR,
    circledS: $538971b5b904f078$var$circledS,
    circledast: $538971b5b904f078$var$circledast,
    circledcirc: $538971b5b904f078$var$circledcirc,
    circleddash: $538971b5b904f078$var$circleddash,
    cire: $538971b5b904f078$var$cire,
    cirfnint: $538971b5b904f078$var$cirfnint,
    cirmid: $538971b5b904f078$var$cirmid,
    cirscir: $538971b5b904f078$var$cirscir,
    clubs: $538971b5b904f078$var$clubs$1,
    clubsuit: $538971b5b904f078$var$clubsuit,
    colon: $538971b5b904f078$var$colon$3,
    colone: $538971b5b904f078$var$colone,
    coloneq: $538971b5b904f078$var$coloneq,
    comma: $538971b5b904f078$var$comma$2,
    commat: $538971b5b904f078$var$commat,
    comp: $538971b5b904f078$var$comp,
    compfn: $538971b5b904f078$var$compfn,
    complement: $538971b5b904f078$var$complement,
    complexes: $538971b5b904f078$var$complexes,
    cong: $538971b5b904f078$var$cong$1,
    congdot: $538971b5b904f078$var$congdot,
    conint: $538971b5b904f078$var$conint,
    copf: $538971b5b904f078$var$copf,
    coprod: $538971b5b904f078$var$coprod,
    cop: $538971b5b904f078$var$cop,
    copy: $538971b5b904f078$var$copy$1,
    copysr: $538971b5b904f078$var$copysr,
    crarr: $538971b5b904f078$var$crarr$1,
    cross: $538971b5b904f078$var$cross,
    cscr: $538971b5b904f078$var$cscr,
    csub: $538971b5b904f078$var$csub,
    csube: $538971b5b904f078$var$csube,
    csup: $538971b5b904f078$var$csup,
    csupe: $538971b5b904f078$var$csupe,
    ctdot: $538971b5b904f078$var$ctdot,
    cudarrl: $538971b5b904f078$var$cudarrl,
    cudarrr: $538971b5b904f078$var$cudarrr,
    cuepr: $538971b5b904f078$var$cuepr,
    cuesc: $538971b5b904f078$var$cuesc,
    cularr: $538971b5b904f078$var$cularr,
    cularrp: $538971b5b904f078$var$cularrp,
    cup: $538971b5b904f078$var$cup$1,
    cupbrcap: $538971b5b904f078$var$cupbrcap,
    cupcap: $538971b5b904f078$var$cupcap,
    cupcup: $538971b5b904f078$var$cupcup,
    cupdot: $538971b5b904f078$var$cupdot,
    cupor: $538971b5b904f078$var$cupor,
    cups: $538971b5b904f078$var$cups,
    curarr: $538971b5b904f078$var$curarr,
    curarrm: $538971b5b904f078$var$curarrm,
    curlyeqprec: $538971b5b904f078$var$curlyeqprec,
    curlyeqsucc: $538971b5b904f078$var$curlyeqsucc,
    curlyvee: $538971b5b904f078$var$curlyvee,
    curlywedge: $538971b5b904f078$var$curlywedge,
    curre: $538971b5b904f078$var$curre,
    curren: $538971b5b904f078$var$curren$1,
    curvearrowleft: $538971b5b904f078$var$curvearrowleft,
    curvearrowright: $538971b5b904f078$var$curvearrowright,
    cuvee: $538971b5b904f078$var$cuvee,
    cuwed: $538971b5b904f078$var$cuwed,
    cwconint: $538971b5b904f078$var$cwconint,
    cwint: $538971b5b904f078$var$cwint,
    cylcty: $538971b5b904f078$var$cylcty,
    dArr: $538971b5b904f078$var$dArr$1,
    dHar: $538971b5b904f078$var$dHar,
    dagger: $538971b5b904f078$var$dagger$1,
    daleth: $538971b5b904f078$var$daleth,
    darr: $538971b5b904f078$var$darr$1,
    dash: $538971b5b904f078$var$dash$8,
    dashv: $538971b5b904f078$var$dashv,
    dbkarow: $538971b5b904f078$var$dbkarow,
    dblac: $538971b5b904f078$var$dblac,
    dcaron: $538971b5b904f078$var$dcaron,
    dcy: $538971b5b904f078$var$dcy,
    dd: $538971b5b904f078$var$dd$1,
    ddagger: $538971b5b904f078$var$ddagger,
    ddarr: $538971b5b904f078$var$ddarr,
    ddotseq: $538971b5b904f078$var$ddotseq,
    de: $538971b5b904f078$var$de,
    deg: $538971b5b904f078$var$deg$1,
    delta: $538971b5b904f078$var$delta$1,
    demptyv: $538971b5b904f078$var$demptyv,
    dfisht: $538971b5b904f078$var$dfisht,
    dfr: $538971b5b904f078$var$dfr,
    dharl: $538971b5b904f078$var$dharl,
    dharr: $538971b5b904f078$var$dharr,
    diam: $538971b5b904f078$var$diam,
    diamond: $538971b5b904f078$var$diamond,
    diamondsuit: $538971b5b904f078$var$diamondsuit,
    diams: $538971b5b904f078$var$diams$1,
    die: $538971b5b904f078$var$die,
    digamma: $538971b5b904f078$var$digamma,
    disin: $538971b5b904f078$var$disin,
    div: $538971b5b904f078$var$div,
    divid: $538971b5b904f078$var$divid,
    divide: $538971b5b904f078$var$divide$1,
    divideontimes: $538971b5b904f078$var$divideontimes,
    divonx: $538971b5b904f078$var$divonx,
    djcy: $538971b5b904f078$var$djcy,
    dlcorn: $538971b5b904f078$var$dlcorn,
    dlcrop: $538971b5b904f078$var$dlcrop,
    dollar: $538971b5b904f078$var$dollar,
    dopf: $538971b5b904f078$var$dopf,
    dot: $538971b5b904f078$var$dot$4,
    doteq: $538971b5b904f078$var$doteq,
    doteqdot: $538971b5b904f078$var$doteqdot,
    dotminus: $538971b5b904f078$var$dotminus,
    dotplus: $538971b5b904f078$var$dotplus,
    dotsquare: $538971b5b904f078$var$dotsquare,
    doublebarwedge: $538971b5b904f078$var$doublebarwedge,
    downarrow: $538971b5b904f078$var$downarrow,
    downdownarrows: $538971b5b904f078$var$downdownarrows,
    downharpoonleft: $538971b5b904f078$var$downharpoonleft,
    downharpoonright: $538971b5b904f078$var$downharpoonright,
    drbkarow: $538971b5b904f078$var$drbkarow,
    drcorn: $538971b5b904f078$var$drcorn,
    drcrop: $538971b5b904f078$var$drcrop,
    dscr: $538971b5b904f078$var$dscr,
    dscy: $538971b5b904f078$var$dscy,
    dsol: $538971b5b904f078$var$dsol,
    dstrok: $538971b5b904f078$var$dstrok,
    dtdot: $538971b5b904f078$var$dtdot,
    dtri: $538971b5b904f078$var$dtri,
    dtrif: $538971b5b904f078$var$dtrif,
    duarr: $538971b5b904f078$var$duarr,
    duhar: $538971b5b904f078$var$duhar,
    dwangle: $538971b5b904f078$var$dwangle,
    dzcy: $538971b5b904f078$var$dzcy,
    dzigrarr: $538971b5b904f078$var$dzigrarr,
    eDDot: $538971b5b904f078$var$eDDot,
    eDot: $538971b5b904f078$var$eDot,
    eacut: $538971b5b904f078$var$eacut,
    eacute: $538971b5b904f078$var$eacute$1,
    easter: $538971b5b904f078$var$easter,
    ecaron: $538971b5b904f078$var$ecaron,
    ecir: $538971b5b904f078$var$ecir,
    ecirc: $538971b5b904f078$var$ecirc$1,
    ecolon: $538971b5b904f078$var$ecolon,
    ecy: $538971b5b904f078$var$ecy,
    edot: $538971b5b904f078$var$edot,
    ee: $538971b5b904f078$var$ee,
    efDot: $538971b5b904f078$var$efDot,
    efr: $538971b5b904f078$var$efr,
    eg: $538971b5b904f078$var$eg,
    egrav: $538971b5b904f078$var$egrav,
    egrave: $538971b5b904f078$var$egrave$1,
    egs: $538971b5b904f078$var$egs,
    egsdot: $538971b5b904f078$var$egsdot,
    el: $538971b5b904f078$var$el,
    elinters: $538971b5b904f078$var$elinters,
    ell: $538971b5b904f078$var$ell,
    els: $538971b5b904f078$var$els,
    elsdot: $538971b5b904f078$var$elsdot,
    emacr: $538971b5b904f078$var$emacr,
    empty: $538971b5b904f078$var$empty$3,
    emptyset: $538971b5b904f078$var$emptyset,
    emptyv: $538971b5b904f078$var$emptyv,
    emsp13: $538971b5b904f078$var$emsp13,
    emsp14: $538971b5b904f078$var$emsp14,
    emsp: $538971b5b904f078$var$emsp$1,
    eng: $538971b5b904f078$var$eng,
    ensp: $538971b5b904f078$var$ensp$1,
    eogon: $538971b5b904f078$var$eogon,
    eopf: $538971b5b904f078$var$eopf,
    epar: $538971b5b904f078$var$epar,
    eparsl: $538971b5b904f078$var$eparsl,
    eplus: $538971b5b904f078$var$eplus,
    epsi: $538971b5b904f078$var$epsi,
    epsilon: $538971b5b904f078$var$epsilon$1,
    epsiv: $538971b5b904f078$var$epsiv,
    eqcirc: $538971b5b904f078$var$eqcirc,
    eqcolon: $538971b5b904f078$var$eqcolon,
    eqsim: $538971b5b904f078$var$eqsim,
    eqslantgtr: $538971b5b904f078$var$eqslantgtr,
    eqslantless: $538971b5b904f078$var$eqslantless,
    equals: $538971b5b904f078$var$equals,
    equest: $538971b5b904f078$var$equest,
    equiv: $538971b5b904f078$var$equiv$1,
    equivDD: $538971b5b904f078$var$equivDD,
    eqvparsl: $538971b5b904f078$var$eqvparsl,
    erDot: $538971b5b904f078$var$erDot,
    erarr: $538971b5b904f078$var$erarr,
    escr: $538971b5b904f078$var$escr,
    esdot: $538971b5b904f078$var$esdot,
    esim: $538971b5b904f078$var$esim,
    eta: $538971b5b904f078$var$eta$1,
    et: $538971b5b904f078$var$et,
    eth: $538971b5b904f078$var$eth$1,
    eum: $538971b5b904f078$var$eum,
    euml: $538971b5b904f078$var$euml$1,
    euro: $538971b5b904f078$var$euro$1,
    excl: $538971b5b904f078$var$excl,
    exist: $538971b5b904f078$var$exist$1,
    expectation: $538971b5b904f078$var$expectation,
    exponentiale: $538971b5b904f078$var$exponentiale,
    fallingdotseq: $538971b5b904f078$var$fallingdotseq,
    fcy: $538971b5b904f078$var$fcy,
    female: $538971b5b904f078$var$female,
    ffilig: $538971b5b904f078$var$ffilig,
    fflig: $538971b5b904f078$var$fflig,
    ffllig: $538971b5b904f078$var$ffllig,
    ffr: $538971b5b904f078$var$ffr,
    filig: $538971b5b904f078$var$filig,
    fjlig: $538971b5b904f078$var$fjlig,
    flat: $538971b5b904f078$var$flat,
    fllig: $538971b5b904f078$var$fllig,
    fltns: $538971b5b904f078$var$fltns,
    fnof: $538971b5b904f078$var$fnof$1,
    fopf: $538971b5b904f078$var$fopf,
    forall: $538971b5b904f078$var$forall$1,
    fork: $538971b5b904f078$var$fork,
    forkv: $538971b5b904f078$var$forkv,
    fpartint: $538971b5b904f078$var$fpartint,
    frac1: $538971b5b904f078$var$frac1,
    frac12: $538971b5b904f078$var$frac12$1,
    frac13: $538971b5b904f078$var$frac13,
    frac14: $538971b5b904f078$var$frac14$1,
    frac15: $538971b5b904f078$var$frac15,
    frac16: $538971b5b904f078$var$frac16,
    frac18: $538971b5b904f078$var$frac18,
    frac23: $538971b5b904f078$var$frac23,
    frac25: $538971b5b904f078$var$frac25,
    frac3: $538971b5b904f078$var$frac3,
    frac34: $538971b5b904f078$var$frac34$1,
    frac35: $538971b5b904f078$var$frac35,
    frac38: $538971b5b904f078$var$frac38,
    frac45: $538971b5b904f078$var$frac45,
    frac56: $538971b5b904f078$var$frac56,
    frac58: $538971b5b904f078$var$frac58,
    frac78: $538971b5b904f078$var$frac78,
    frasl: $538971b5b904f078$var$frasl$1,
    frown: $538971b5b904f078$var$frown,
    fscr: $538971b5b904f078$var$fscr,
    gE: $538971b5b904f078$var$gE,
    gEl: $538971b5b904f078$var$gEl,
    gacute: $538971b5b904f078$var$gacute,
    gamma: $538971b5b904f078$var$gamma$1,
    gammad: $538971b5b904f078$var$gammad,
    gap: $538971b5b904f078$var$gap,
    gbreve: $538971b5b904f078$var$gbreve,
    gcirc: $538971b5b904f078$var$gcirc,
    gcy: $538971b5b904f078$var$gcy,
    gdot: $538971b5b904f078$var$gdot,
    ge: $538971b5b904f078$var$ge$1,
    gel: $538971b5b904f078$var$gel,
    geq: $538971b5b904f078$var$geq,
    geqq: $538971b5b904f078$var$geqq,
    geqslant: $538971b5b904f078$var$geqslant,
    ges: $538971b5b904f078$var$ges,
    gescc: $538971b5b904f078$var$gescc,
    gesdot: $538971b5b904f078$var$gesdot,
    gesdoto: $538971b5b904f078$var$gesdoto,
    gesdotol: $538971b5b904f078$var$gesdotol,
    gesl: $538971b5b904f078$var$gesl,
    gesles: $538971b5b904f078$var$gesles,
    gfr: $538971b5b904f078$var$gfr,
    gg: $538971b5b904f078$var$gg,
    ggg: $538971b5b904f078$var$ggg,
    gimel: $538971b5b904f078$var$gimel,
    gjcy: $538971b5b904f078$var$gjcy,
    gl: $538971b5b904f078$var$gl,
    glE: $538971b5b904f078$var$glE,
    gla: $538971b5b904f078$var$gla,
    glj: $538971b5b904f078$var$glj,
    gnE: $538971b5b904f078$var$gnE,
    gnap: $538971b5b904f078$var$gnap,
    gnapprox: $538971b5b904f078$var$gnapprox,
    gne: $538971b5b904f078$var$gne,
    gneq: $538971b5b904f078$var$gneq,
    gneqq: $538971b5b904f078$var$gneqq,
    gnsim: $538971b5b904f078$var$gnsim,
    gopf: $538971b5b904f078$var$gopf,
    grave: $538971b5b904f078$var$grave,
    gscr: $538971b5b904f078$var$gscr,
    gsim: $538971b5b904f078$var$gsim,
    gsime: $538971b5b904f078$var$gsime,
    gsiml: $538971b5b904f078$var$gsiml,
    g: $538971b5b904f078$var$g,
    gt: $538971b5b904f078$var$gt$1,
    gtcc: $538971b5b904f078$var$gtcc,
    gtcir: $538971b5b904f078$var$gtcir,
    gtdot: $538971b5b904f078$var$gtdot,
    gtlPar: $538971b5b904f078$var$gtlPar,
    gtquest: $538971b5b904f078$var$gtquest,
    gtrapprox: $538971b5b904f078$var$gtrapprox,
    gtrarr: $538971b5b904f078$var$gtrarr,
    gtrdot: $538971b5b904f078$var$gtrdot,
    gtreqless: $538971b5b904f078$var$gtreqless,
    gtreqqless: $538971b5b904f078$var$gtreqqless,
    gtrless: $538971b5b904f078$var$gtrless,
    gtrsim: $538971b5b904f078$var$gtrsim,
    gvertneqq: $538971b5b904f078$var$gvertneqq,
    gvnE: $538971b5b904f078$var$gvnE,
    hArr: $538971b5b904f078$var$hArr$1,
    hairsp: $538971b5b904f078$var$hairsp,
    half: $538971b5b904f078$var$half,
    hamilt: $538971b5b904f078$var$hamilt,
    hardcy: $538971b5b904f078$var$hardcy,
    harr: $538971b5b904f078$var$harr$1,
    harrcir: $538971b5b904f078$var$harrcir,
    harrw: $538971b5b904f078$var$harrw,
    hbar: $538971b5b904f078$var$hbar,
    hcirc: $538971b5b904f078$var$hcirc,
    hearts: $538971b5b904f078$var$hearts$1,
    heartsuit: $538971b5b904f078$var$heartsuit,
    hellip: $538971b5b904f078$var$hellip$1,
    hercon: $538971b5b904f078$var$hercon,
    hfr: $538971b5b904f078$var$hfr,
    hksearow: $538971b5b904f078$var$hksearow,
    hkswarow: $538971b5b904f078$var$hkswarow,
    hoarr: $538971b5b904f078$var$hoarr,
    homtht: $538971b5b904f078$var$homtht,
    hookleftarrow: $538971b5b904f078$var$hookleftarrow,
    hookrightarrow: $538971b5b904f078$var$hookrightarrow,
    hopf: $538971b5b904f078$var$hopf,
    horbar: $538971b5b904f078$var$horbar,
    hscr: $538971b5b904f078$var$hscr,
    hslash: $538971b5b904f078$var$hslash,
    hstrok: $538971b5b904f078$var$hstrok,
    hybull: $538971b5b904f078$var$hybull,
    hyphen: $538971b5b904f078$var$hyphen,
    iacut: $538971b5b904f078$var$iacut,
    iacute: $538971b5b904f078$var$iacute$1,
    ic: $538971b5b904f078$var$ic,
    icir: $538971b5b904f078$var$icir,
    icirc: $538971b5b904f078$var$icirc$1,
    icy: $538971b5b904f078$var$icy,
    iecy: $538971b5b904f078$var$iecy,
    iexc: $538971b5b904f078$var$iexc,
    iexcl: $538971b5b904f078$var$iexcl$1,
    iff: $538971b5b904f078$var$iff,
    ifr: $538971b5b904f078$var$ifr,
    igrav: $538971b5b904f078$var$igrav,
    igrave: $538971b5b904f078$var$igrave$1,
    ii: $538971b5b904f078$var$ii,
    iiiint: $538971b5b904f078$var$iiiint,
    iiint: $538971b5b904f078$var$iiint,
    iinfin: $538971b5b904f078$var$iinfin,
    iiota: $538971b5b904f078$var$iiota,
    ijlig: $538971b5b904f078$var$ijlig,
    imacr: $538971b5b904f078$var$imacr,
    image: $538971b5b904f078$var$image$3,
    imagline: $538971b5b904f078$var$imagline,
    imagpart: $538971b5b904f078$var$imagpart,
    imath: $538971b5b904f078$var$imath,
    imof: $538971b5b904f078$var$imof,
    imped: $538971b5b904f078$var$imped,
    incare: $538971b5b904f078$var$incare,
    infin: $538971b5b904f078$var$infin$1,
    infintie: $538971b5b904f078$var$infintie,
    inodot: $538971b5b904f078$var$inodot,
    int: $538971b5b904f078$var$int$1,
    intcal: $538971b5b904f078$var$intcal,
    integers: $538971b5b904f078$var$integers,
    intercal: $538971b5b904f078$var$intercal,
    intlarhk: $538971b5b904f078$var$intlarhk,
    intprod: $538971b5b904f078$var$intprod,
    iocy: $538971b5b904f078$var$iocy,
    iogon: $538971b5b904f078$var$iogon,
    iopf: $538971b5b904f078$var$iopf,
    iota: $538971b5b904f078$var$iota$1,
    iprod: $538971b5b904f078$var$iprod,
    iques: $538971b5b904f078$var$iques,
    iquest: $538971b5b904f078$var$iquest$1,
    iscr: $538971b5b904f078$var$iscr,
    isin: $538971b5b904f078$var$isin$1,
    isinE: $538971b5b904f078$var$isinE,
    isindot: $538971b5b904f078$var$isindot,
    isins: $538971b5b904f078$var$isins,
    isinsv: $538971b5b904f078$var$isinsv,
    isinv: $538971b5b904f078$var$isinv,
    it: $538971b5b904f078$var$it,
    itilde: $538971b5b904f078$var$itilde,
    iukcy: $538971b5b904f078$var$iukcy,
    ium: $538971b5b904f078$var$ium,
    iuml: $538971b5b904f078$var$iuml$1,
    jcirc: $538971b5b904f078$var$jcirc,
    jcy: $538971b5b904f078$var$jcy,
    jfr: $538971b5b904f078$var$jfr,
    jmath: $538971b5b904f078$var$jmath,
    jopf: $538971b5b904f078$var$jopf,
    jscr: $538971b5b904f078$var$jscr,
    jsercy: $538971b5b904f078$var$jsercy,
    jukcy: $538971b5b904f078$var$jukcy,
    kappa: $538971b5b904f078$var$kappa$1,
    kappav: $538971b5b904f078$var$kappav,
    kcedil: $538971b5b904f078$var$kcedil,
    kcy: $538971b5b904f078$var$kcy,
    kfr: $538971b5b904f078$var$kfr,
    kgreen: $538971b5b904f078$var$kgreen,
    khcy: $538971b5b904f078$var$khcy,
    kjcy: $538971b5b904f078$var$kjcy,
    kopf: $538971b5b904f078$var$kopf,
    kscr: $538971b5b904f078$var$kscr,
    lAarr: $538971b5b904f078$var$lAarr,
    lArr: $538971b5b904f078$var$lArr$1,
    lAtail: $538971b5b904f078$var$lAtail,
    lBarr: $538971b5b904f078$var$lBarr,
    lE: $538971b5b904f078$var$lE,
    lEg: $538971b5b904f078$var$lEg,
    lHar: $538971b5b904f078$var$lHar,
    lacute: $538971b5b904f078$var$lacute,
    laemptyv: $538971b5b904f078$var$laemptyv,
    lagran: $538971b5b904f078$var$lagran,
    lambda: $538971b5b904f078$var$lambda$1,
    lang: $538971b5b904f078$var$lang$1,
    langd: $538971b5b904f078$var$langd,
    langle: $538971b5b904f078$var$langle,
    lap: $538971b5b904f078$var$lap,
    laqu: $538971b5b904f078$var$laqu,
    laquo: $538971b5b904f078$var$laquo$1,
    larr: $538971b5b904f078$var$larr$1,
    larrb: $538971b5b904f078$var$larrb,
    larrbfs: $538971b5b904f078$var$larrbfs,
    larrfs: $538971b5b904f078$var$larrfs,
    larrhk: $538971b5b904f078$var$larrhk,
    larrlp: $538971b5b904f078$var$larrlp,
    larrpl: $538971b5b904f078$var$larrpl,
    larrsim: $538971b5b904f078$var$larrsim,
    larrtl: $538971b5b904f078$var$larrtl,
    lat: $538971b5b904f078$var$lat,
    latail: $538971b5b904f078$var$latail,
    late: $538971b5b904f078$var$late,
    lates: $538971b5b904f078$var$lates,
    lbarr: $538971b5b904f078$var$lbarr,
    lbbrk: $538971b5b904f078$var$lbbrk,
    lbrace: $538971b5b904f078$var$lbrace,
    lbrack: $538971b5b904f078$var$lbrack,
    lbrke: $538971b5b904f078$var$lbrke,
    lbrksld: $538971b5b904f078$var$lbrksld,
    lbrkslu: $538971b5b904f078$var$lbrkslu,
    lcaron: $538971b5b904f078$var$lcaron,
    lcedil: $538971b5b904f078$var$lcedil,
    lceil: $538971b5b904f078$var$lceil$1,
    lcub: $538971b5b904f078$var$lcub,
    lcy: $538971b5b904f078$var$lcy,
    ldca: $538971b5b904f078$var$ldca,
    ldquo: $538971b5b904f078$var$ldquo$1,
    ldquor: $538971b5b904f078$var$ldquor,
    ldrdhar: $538971b5b904f078$var$ldrdhar,
    ldrushar: $538971b5b904f078$var$ldrushar,
    ldsh: $538971b5b904f078$var$ldsh,
    le: $538971b5b904f078$var$le$1,
    leftarrow: $538971b5b904f078$var$leftarrow,
    leftarrowtail: $538971b5b904f078$var$leftarrowtail,
    leftharpoondown: $538971b5b904f078$var$leftharpoondown,
    leftharpoonup: $538971b5b904f078$var$leftharpoonup,
    leftleftarrows: $538971b5b904f078$var$leftleftarrows,
    leftrightarrow: $538971b5b904f078$var$leftrightarrow,
    leftrightarrows: $538971b5b904f078$var$leftrightarrows,
    leftrightharpoons: $538971b5b904f078$var$leftrightharpoons,
    leftrightsquigarrow: $538971b5b904f078$var$leftrightsquigarrow,
    leftthreetimes: $538971b5b904f078$var$leftthreetimes,
    leg: $538971b5b904f078$var$leg,
    leq: $538971b5b904f078$var$leq,
    leqq: $538971b5b904f078$var$leqq,
    leqslant: $538971b5b904f078$var$leqslant,
    les: $538971b5b904f078$var$les,
    lescc: $538971b5b904f078$var$lescc,
    lesdot: $538971b5b904f078$var$lesdot,
    lesdoto: $538971b5b904f078$var$lesdoto,
    lesdotor: $538971b5b904f078$var$lesdotor,
    lesg: $538971b5b904f078$var$lesg,
    lesges: $538971b5b904f078$var$lesges,
    lessapprox: $538971b5b904f078$var$lessapprox,
    lessdot: $538971b5b904f078$var$lessdot,
    lesseqgtr: $538971b5b904f078$var$lesseqgtr,
    lesseqqgtr: $538971b5b904f078$var$lesseqqgtr,
    lessgtr: $538971b5b904f078$var$lessgtr,
    lesssim: $538971b5b904f078$var$lesssim,
    lfisht: $538971b5b904f078$var$lfisht,
    lfloor: $538971b5b904f078$var$lfloor$1,
    lfr: $538971b5b904f078$var$lfr,
    lg: $538971b5b904f078$var$lg,
    lgE: $538971b5b904f078$var$lgE,
    lhard: $538971b5b904f078$var$lhard,
    lharu: $538971b5b904f078$var$lharu,
    lharul: $538971b5b904f078$var$lharul,
    lhblk: $538971b5b904f078$var$lhblk,
    ljcy: $538971b5b904f078$var$ljcy,
    ll: $538971b5b904f078$var$ll,
    llarr: $538971b5b904f078$var$llarr,
    llcorner: $538971b5b904f078$var$llcorner,
    llhard: $538971b5b904f078$var$llhard,
    lltri: $538971b5b904f078$var$lltri,
    lmidot: $538971b5b904f078$var$lmidot,
    lmoust: $538971b5b904f078$var$lmoust,
    lmoustache: $538971b5b904f078$var$lmoustache,
    lnE: $538971b5b904f078$var$lnE,
    lnap: $538971b5b904f078$var$lnap,
    lnapprox: $538971b5b904f078$var$lnapprox,
    lne: $538971b5b904f078$var$lne,
    lneq: $538971b5b904f078$var$lneq,
    lneqq: $538971b5b904f078$var$lneqq,
    lnsim: $538971b5b904f078$var$lnsim,
    loang: $538971b5b904f078$var$loang,
    loarr: $538971b5b904f078$var$loarr,
    lobrk: $538971b5b904f078$var$lobrk,
    longleftarrow: $538971b5b904f078$var$longleftarrow,
    longleftrightarrow: $538971b5b904f078$var$longleftrightarrow,
    longmapsto: $538971b5b904f078$var$longmapsto,
    longrightarrow: $538971b5b904f078$var$longrightarrow,
    looparrowleft: $538971b5b904f078$var$looparrowleft,
    looparrowright: $538971b5b904f078$var$looparrowright,
    lopar: $538971b5b904f078$var$lopar,
    lopf: $538971b5b904f078$var$lopf,
    loplus: $538971b5b904f078$var$loplus,
    lotimes: $538971b5b904f078$var$lotimes,
    lowast: $538971b5b904f078$var$lowast$1,
    lowbar: $538971b5b904f078$var$lowbar,
    loz: $538971b5b904f078$var$loz$1,
    lozenge: $538971b5b904f078$var$lozenge,
    lozf: $538971b5b904f078$var$lozf,
    lpar: $538971b5b904f078$var$lpar,
    lparlt: $538971b5b904f078$var$lparlt,
    lrarr: $538971b5b904f078$var$lrarr,
    lrcorner: $538971b5b904f078$var$lrcorner,
    lrhar: $538971b5b904f078$var$lrhar,
    lrhard: $538971b5b904f078$var$lrhard,
    lrm: $538971b5b904f078$var$lrm$1,
    lrtri: $538971b5b904f078$var$lrtri,
    lsaquo: $538971b5b904f078$var$lsaquo$1,
    lscr: $538971b5b904f078$var$lscr,
    lsh: $538971b5b904f078$var$lsh,
    lsim: $538971b5b904f078$var$lsim,
    lsime: $538971b5b904f078$var$lsime,
    lsimg: $538971b5b904f078$var$lsimg,
    lsqb: $538971b5b904f078$var$lsqb,
    lsquo: $538971b5b904f078$var$lsquo$1,
    lsquor: $538971b5b904f078$var$lsquor,
    lstrok: $538971b5b904f078$var$lstrok,
    l: $538971b5b904f078$var$l,
    lt: $538971b5b904f078$var$lt$1,
    ltcc: $538971b5b904f078$var$ltcc,
    ltcir: $538971b5b904f078$var$ltcir,
    ltdot: $538971b5b904f078$var$ltdot,
    lthree: $538971b5b904f078$var$lthree,
    ltimes: $538971b5b904f078$var$ltimes,
    ltlarr: $538971b5b904f078$var$ltlarr,
    ltquest: $538971b5b904f078$var$ltquest,
    ltrPar: $538971b5b904f078$var$ltrPar,
    ltri: $538971b5b904f078$var$ltri,
    ltrie: $538971b5b904f078$var$ltrie,
    ltrif: $538971b5b904f078$var$ltrif,
    lurdshar: $538971b5b904f078$var$lurdshar,
    luruhar: $538971b5b904f078$var$luruhar,
    lvertneqq: $538971b5b904f078$var$lvertneqq,
    lvnE: $538971b5b904f078$var$lvnE,
    mDDot: $538971b5b904f078$var$mDDot,
    mac: $538971b5b904f078$var$mac,
    macr: $538971b5b904f078$var$macr$1,
    male: $538971b5b904f078$var$male,
    malt: $538971b5b904f078$var$malt,
    maltese: $538971b5b904f078$var$maltese,
    map: $538971b5b904f078$var$map$1,
    mapsto: $538971b5b904f078$var$mapsto,
    mapstodown: $538971b5b904f078$var$mapstodown,
    mapstoleft: $538971b5b904f078$var$mapstoleft,
    mapstoup: $538971b5b904f078$var$mapstoup,
    marker: $538971b5b904f078$var$marker,
    mcomma: $538971b5b904f078$var$mcomma,
    mcy: $538971b5b904f078$var$mcy,
    mdash: $538971b5b904f078$var$mdash$1,
    measuredangle: $538971b5b904f078$var$measuredangle,
    mfr: $538971b5b904f078$var$mfr,
    mho: $538971b5b904f078$var$mho,
    micr: $538971b5b904f078$var$micr,
    micro: $538971b5b904f078$var$micro$1,
    mid: $538971b5b904f078$var$mid,
    midast: $538971b5b904f078$var$midast,
    midcir: $538971b5b904f078$var$midcir,
    middo: $538971b5b904f078$var$middo,
    middot: $538971b5b904f078$var$middot$1,
    minus: $538971b5b904f078$var$minus$1,
    minusb: $538971b5b904f078$var$minusb,
    minusd: $538971b5b904f078$var$minusd,
    minusdu: $538971b5b904f078$var$minusdu,
    mlcp: $538971b5b904f078$var$mlcp,
    mldr: $538971b5b904f078$var$mldr,
    mnplus: $538971b5b904f078$var$mnplus,
    models: $538971b5b904f078$var$models,
    mopf: $538971b5b904f078$var$mopf,
    mp: $538971b5b904f078$var$mp,
    mscr: $538971b5b904f078$var$mscr,
    mstpos: $538971b5b904f078$var$mstpos,
    mu: $538971b5b904f078$var$mu$1,
    multimap: $538971b5b904f078$var$multimap,
    mumap: $538971b5b904f078$var$mumap,
    nGg: $538971b5b904f078$var$nGg,
    nGt: $538971b5b904f078$var$nGt,
    nGtv: $538971b5b904f078$var$nGtv,
    nLeftarrow: $538971b5b904f078$var$nLeftarrow,
    nLeftrightarrow: $538971b5b904f078$var$nLeftrightarrow,
    nLl: $538971b5b904f078$var$nLl,
    nLt: $538971b5b904f078$var$nLt,
    nLtv: $538971b5b904f078$var$nLtv,
    nRightarrow: $538971b5b904f078$var$nRightarrow,
    nVDash: $538971b5b904f078$var$nVDash,
    nVdash: $538971b5b904f078$var$nVdash,
    nabla: $538971b5b904f078$var$nabla$1,
    nacute: $538971b5b904f078$var$nacute,
    nang: $538971b5b904f078$var$nang,
    nap: $538971b5b904f078$var$nap,
    napE: $538971b5b904f078$var$napE,
    napid: $538971b5b904f078$var$napid,
    napos: $538971b5b904f078$var$napos,
    napprox: $538971b5b904f078$var$napprox,
    natur: $538971b5b904f078$var$natur,
    natural: $538971b5b904f078$var$natural,
    naturals: $538971b5b904f078$var$naturals,
    nbs: $538971b5b904f078$var$nbs,
    nbsp: $538971b5b904f078$var$nbsp$1,
    nbump: $538971b5b904f078$var$nbump,
    nbumpe: $538971b5b904f078$var$nbumpe,
    ncap: $538971b5b904f078$var$ncap,
    ncaron: $538971b5b904f078$var$ncaron,
    ncedil: $538971b5b904f078$var$ncedil,
    ncong: $538971b5b904f078$var$ncong,
    ncongdot: $538971b5b904f078$var$ncongdot,
    ncup: $538971b5b904f078$var$ncup,
    ncy: $538971b5b904f078$var$ncy,
    ndash: $538971b5b904f078$var$ndash$1,
    ne: $538971b5b904f078$var$ne$1,
    neArr: $538971b5b904f078$var$neArr,
    nearhk: $538971b5b904f078$var$nearhk,
    nearr: $538971b5b904f078$var$nearr,
    nearrow: $538971b5b904f078$var$nearrow,
    nedot: $538971b5b904f078$var$nedot,
    nequiv: $538971b5b904f078$var$nequiv,
    nesear: $538971b5b904f078$var$nesear,
    nesim: $538971b5b904f078$var$nesim,
    nexist: $538971b5b904f078$var$nexist,
    nexists: $538971b5b904f078$var$nexists,
    nfr: $538971b5b904f078$var$nfr,
    ngE: $538971b5b904f078$var$ngE,
    nge: $538971b5b904f078$var$nge,
    ngeq: $538971b5b904f078$var$ngeq,
    ngeqq: $538971b5b904f078$var$ngeqq,
    ngeqslant: $538971b5b904f078$var$ngeqslant,
    nges: $538971b5b904f078$var$nges,
    ngsim: $538971b5b904f078$var$ngsim,
    ngt: $538971b5b904f078$var$ngt,
    ngtr: $538971b5b904f078$var$ngtr,
    nhArr: $538971b5b904f078$var$nhArr,
    nharr: $538971b5b904f078$var$nharr,
    nhpar: $538971b5b904f078$var$nhpar,
    ni: $538971b5b904f078$var$ni$1,
    nis: $538971b5b904f078$var$nis,
    nisd: $538971b5b904f078$var$nisd,
    niv: $538971b5b904f078$var$niv,
    njcy: $538971b5b904f078$var$njcy,
    nlArr: $538971b5b904f078$var$nlArr,
    nlE: $538971b5b904f078$var$nlE,
    nlarr: $538971b5b904f078$var$nlarr,
    nldr: $538971b5b904f078$var$nldr,
    nle: $538971b5b904f078$var$nle,
    nleftarrow: $538971b5b904f078$var$nleftarrow,
    nleftrightarrow: $538971b5b904f078$var$nleftrightarrow,
    nleq: $538971b5b904f078$var$nleq,
    nleqq: $538971b5b904f078$var$nleqq,
    nleqslant: $538971b5b904f078$var$nleqslant,
    nles: $538971b5b904f078$var$nles,
    nless: $538971b5b904f078$var$nless,
    nlsim: $538971b5b904f078$var$nlsim,
    nlt: $538971b5b904f078$var$nlt,
    nltri: $538971b5b904f078$var$nltri,
    nltrie: $538971b5b904f078$var$nltrie,
    nmid: $538971b5b904f078$var$nmid,
    nopf: $538971b5b904f078$var$nopf,
    no: $538971b5b904f078$var$no,
    not: $538971b5b904f078$var$not$1,
    notin: $538971b5b904f078$var$notin$1,
    notinE: $538971b5b904f078$var$notinE,
    notindot: $538971b5b904f078$var$notindot,
    notinva: $538971b5b904f078$var$notinva,
    notinvb: $538971b5b904f078$var$notinvb,
    notinvc: $538971b5b904f078$var$notinvc,
    notni: $538971b5b904f078$var$notni,
    notniva: $538971b5b904f078$var$notniva,
    notnivb: $538971b5b904f078$var$notnivb,
    notnivc: $538971b5b904f078$var$notnivc,
    npar: $538971b5b904f078$var$npar,
    nparallel: $538971b5b904f078$var$nparallel,
    nparsl: $538971b5b904f078$var$nparsl,
    npart: $538971b5b904f078$var$npart,
    npolint: $538971b5b904f078$var$npolint,
    npr: $538971b5b904f078$var$npr,
    nprcue: $538971b5b904f078$var$nprcue,
    npre: $538971b5b904f078$var$npre,
    nprec: $538971b5b904f078$var$nprec,
    npreceq: $538971b5b904f078$var$npreceq,
    nrArr: $538971b5b904f078$var$nrArr,
    nrarr: $538971b5b904f078$var$nrarr,
    nrarrc: $538971b5b904f078$var$nrarrc,
    nrarrw: $538971b5b904f078$var$nrarrw,
    nrightarrow: $538971b5b904f078$var$nrightarrow,
    nrtri: $538971b5b904f078$var$nrtri,
    nrtrie: $538971b5b904f078$var$nrtrie,
    nsc: $538971b5b904f078$var$nsc,
    nsccue: $538971b5b904f078$var$nsccue,
    nsce: $538971b5b904f078$var$nsce,
    nscr: $538971b5b904f078$var$nscr,
    nshortmid: $538971b5b904f078$var$nshortmid,
    nshortparallel: $538971b5b904f078$var$nshortparallel,
    nsim: $538971b5b904f078$var$nsim,
    nsime: $538971b5b904f078$var$nsime,
    nsimeq: $538971b5b904f078$var$nsimeq,
    nsmid: $538971b5b904f078$var$nsmid,
    nspar: $538971b5b904f078$var$nspar,
    nsqsube: $538971b5b904f078$var$nsqsube,
    nsqsupe: $538971b5b904f078$var$nsqsupe,
    nsub: $538971b5b904f078$var$nsub$1,
    nsubE: $538971b5b904f078$var$nsubE,
    nsube: $538971b5b904f078$var$nsube,
    nsubset: $538971b5b904f078$var$nsubset,
    nsubseteq: $538971b5b904f078$var$nsubseteq,
    nsubseteqq: $538971b5b904f078$var$nsubseteqq,
    nsucc: $538971b5b904f078$var$nsucc,
    nsucceq: $538971b5b904f078$var$nsucceq,
    nsup: $538971b5b904f078$var$nsup,
    nsupE: $538971b5b904f078$var$nsupE,
    nsupe: $538971b5b904f078$var$nsupe,
    nsupset: $538971b5b904f078$var$nsupset,
    nsupseteq: $538971b5b904f078$var$nsupseteq,
    nsupseteqq: $538971b5b904f078$var$nsupseteqq,
    ntgl: $538971b5b904f078$var$ntgl,
    ntild: $538971b5b904f078$var$ntild,
    ntilde: $538971b5b904f078$var$ntilde$1,
    ntlg: $538971b5b904f078$var$ntlg,
    ntriangleleft: $538971b5b904f078$var$ntriangleleft,
    ntrianglelefteq: $538971b5b904f078$var$ntrianglelefteq,
    ntriangleright: $538971b5b904f078$var$ntriangleright,
    ntrianglerighteq: $538971b5b904f078$var$ntrianglerighteq,
    nu: $538971b5b904f078$var$nu$1,
    num: $538971b5b904f078$var$num,
    numero: $538971b5b904f078$var$numero,
    numsp: $538971b5b904f078$var$numsp,
    nvDash: $538971b5b904f078$var$nvDash,
    nvHarr: $538971b5b904f078$var$nvHarr,
    nvap: $538971b5b904f078$var$nvap,
    nvdash: $538971b5b904f078$var$nvdash,
    nvge: $538971b5b904f078$var$nvge,
    nvgt: $538971b5b904f078$var$nvgt,
    nvinfin: $538971b5b904f078$var$nvinfin,
    nvlArr: $538971b5b904f078$var$nvlArr,
    nvle: $538971b5b904f078$var$nvle,
    nvlt: $538971b5b904f078$var$nvlt,
    nvltrie: $538971b5b904f078$var$nvltrie,
    nvrArr: $538971b5b904f078$var$nvrArr,
    nvrtrie: $538971b5b904f078$var$nvrtrie,
    nvsim: $538971b5b904f078$var$nvsim,
    nwArr: $538971b5b904f078$var$nwArr,
    nwarhk: $538971b5b904f078$var$nwarhk,
    nwarr: $538971b5b904f078$var$nwarr,
    nwarrow: $538971b5b904f078$var$nwarrow,
    nwnear: $538971b5b904f078$var$nwnear,
    oS: $538971b5b904f078$var$oS,
    oacut: $538971b5b904f078$var$oacut,
    oacute: $538971b5b904f078$var$oacute$1,
    oast: $538971b5b904f078$var$oast,
    ocir: $538971b5b904f078$var$ocir,
    ocirc: $538971b5b904f078$var$ocirc$1,
    ocy: $538971b5b904f078$var$ocy,
    odash: $538971b5b904f078$var$odash,
    odblac: $538971b5b904f078$var$odblac,
    odiv: $538971b5b904f078$var$odiv,
    odot: $538971b5b904f078$var$odot,
    odsold: $538971b5b904f078$var$odsold,
    oelig: $538971b5b904f078$var$oelig$1,
    ofcir: $538971b5b904f078$var$ofcir,
    ofr: $538971b5b904f078$var$ofr,
    ogon: $538971b5b904f078$var$ogon,
    ograv: $538971b5b904f078$var$ograv,
    ograve: $538971b5b904f078$var$ograve$1,
    ogt: $538971b5b904f078$var$ogt,
    ohbar: $538971b5b904f078$var$ohbar,
    ohm: $538971b5b904f078$var$ohm,
    oint: $538971b5b904f078$var$oint,
    olarr: $538971b5b904f078$var$olarr,
    olcir: $538971b5b904f078$var$olcir,
    olcross: $538971b5b904f078$var$olcross,
    oline: $538971b5b904f078$var$oline$1,
    olt: $538971b5b904f078$var$olt,
    omacr: $538971b5b904f078$var$omacr,
    omega: $538971b5b904f078$var$omega$1,
    omicron: $538971b5b904f078$var$omicron$1,
    omid: $538971b5b904f078$var$omid,
    ominus: $538971b5b904f078$var$ominus,
    oopf: $538971b5b904f078$var$oopf,
    opar: $538971b5b904f078$var$opar,
    operp: $538971b5b904f078$var$operp,
    oplus: $538971b5b904f078$var$oplus$1,
    or: $538971b5b904f078$var$or$1,
    orarr: $538971b5b904f078$var$orarr,
    ord: $538971b5b904f078$var$ord,
    order: $538971b5b904f078$var$order,
    orderof: $538971b5b904f078$var$orderof,
    ordf: $538971b5b904f078$var$ordf$1,
    ordm: $538971b5b904f078$var$ordm$1,
    origof: $538971b5b904f078$var$origof,
    oror: $538971b5b904f078$var$oror,
    orslope: $538971b5b904f078$var$orslope,
    orv: $538971b5b904f078$var$orv,
    oscr: $538971b5b904f078$var$oscr,
    oslas: $538971b5b904f078$var$oslas,
    oslash: $538971b5b904f078$var$oslash$1,
    osol: $538971b5b904f078$var$osol,
    otild: $538971b5b904f078$var$otild,
    otilde: $538971b5b904f078$var$otilde$1,
    otimes: $538971b5b904f078$var$otimes$1,
    otimesas: $538971b5b904f078$var$otimesas,
    oum: $538971b5b904f078$var$oum,
    ouml: $538971b5b904f078$var$ouml$1,
    ovbar: $538971b5b904f078$var$ovbar,
    par: $538971b5b904f078$var$par,
    para: $538971b5b904f078$var$para$1,
    parallel: $538971b5b904f078$var$parallel,
    parsim: $538971b5b904f078$var$parsim,
    parsl: $538971b5b904f078$var$parsl,
    part: $538971b5b904f078$var$part$1,
    pcy: $538971b5b904f078$var$pcy,
    percnt: $538971b5b904f078$var$percnt,
    period: $538971b5b904f078$var$period,
    permil: $538971b5b904f078$var$permil$1,
    perp: $538971b5b904f078$var$perp$1,
    pertenk: $538971b5b904f078$var$pertenk,
    pfr: $538971b5b904f078$var$pfr,
    phi: $538971b5b904f078$var$phi$1,
    phiv: $538971b5b904f078$var$phiv,
    phmmat: $538971b5b904f078$var$phmmat,
    phone: $538971b5b904f078$var$phone,
    pi: $538971b5b904f078$var$pi$1,
    pitchfork: $538971b5b904f078$var$pitchfork,
    piv: $538971b5b904f078$var$piv$1,
    planck: $538971b5b904f078$var$planck,
    planckh: $538971b5b904f078$var$planckh,
    plankv: $538971b5b904f078$var$plankv,
    plus: $538971b5b904f078$var$plus,
    plusacir: $538971b5b904f078$var$plusacir,
    plusb: $538971b5b904f078$var$plusb,
    pluscir: $538971b5b904f078$var$pluscir,
    plusdo: $538971b5b904f078$var$plusdo,
    plusdu: $538971b5b904f078$var$plusdu,
    pluse: $538971b5b904f078$var$pluse,
    plusm: $538971b5b904f078$var$plusm,
    plusmn: $538971b5b904f078$var$plusmn$1,
    plussim: $538971b5b904f078$var$plussim,
    plustwo: $538971b5b904f078$var$plustwo,
    pm: $538971b5b904f078$var$pm,
    pointint: $538971b5b904f078$var$pointint,
    popf: $538971b5b904f078$var$popf,
    poun: $538971b5b904f078$var$poun,
    pound: $538971b5b904f078$var$pound$1,
    pr: $538971b5b904f078$var$pr,
    prE: $538971b5b904f078$var$prE,
    prap: $538971b5b904f078$var$prap,
    prcue: $538971b5b904f078$var$prcue,
    pre: $538971b5b904f078$var$pre,
    prec: $538971b5b904f078$var$prec,
    precapprox: $538971b5b904f078$var$precapprox,
    preccurlyeq: $538971b5b904f078$var$preccurlyeq,
    preceq: $538971b5b904f078$var$preceq,
    precnapprox: $538971b5b904f078$var$precnapprox,
    precneqq: $538971b5b904f078$var$precneqq,
    precnsim: $538971b5b904f078$var$precnsim,
    precsim: $538971b5b904f078$var$precsim,
    prime: $538971b5b904f078$var$prime$1,
    primes: $538971b5b904f078$var$primes,
    prnE: $538971b5b904f078$var$prnE,
    prnap: $538971b5b904f078$var$prnap,
    prnsim: $538971b5b904f078$var$prnsim,
    prod: $538971b5b904f078$var$prod$1,
    profalar: $538971b5b904f078$var$profalar,
    profline: $538971b5b904f078$var$profline,
    profsurf: $538971b5b904f078$var$profsurf,
    prop: $538971b5b904f078$var$prop$1,
    propto: $538971b5b904f078$var$propto,
    prsim: $538971b5b904f078$var$prsim,
    prurel: $538971b5b904f078$var$prurel,
    pscr: $538971b5b904f078$var$pscr,
    psi: $538971b5b904f078$var$psi$1,
    puncsp: $538971b5b904f078$var$puncsp,
    qfr: $538971b5b904f078$var$qfr,
    qint: $538971b5b904f078$var$qint,
    qopf: $538971b5b904f078$var$qopf,
    qprime: $538971b5b904f078$var$qprime,
    qscr: $538971b5b904f078$var$qscr,
    quaternions: $538971b5b904f078$var$quaternions,
    quatint: $538971b5b904f078$var$quatint,
    quest: $538971b5b904f078$var$quest,
    questeq: $538971b5b904f078$var$questeq,
    quo: $538971b5b904f078$var$quo,
    quot: $538971b5b904f078$var$quot$1,
    rAarr: $538971b5b904f078$var$rAarr,
    rArr: $538971b5b904f078$var$rArr$1,
    rAtail: $538971b5b904f078$var$rAtail,
    rBarr: $538971b5b904f078$var$rBarr,
    rHar: $538971b5b904f078$var$rHar,
    race: $538971b5b904f078$var$race,
    racute: $538971b5b904f078$var$racute,
    radic: $538971b5b904f078$var$radic$1,
    raemptyv: $538971b5b904f078$var$raemptyv,
    rang: $538971b5b904f078$var$rang$1,
    rangd: $538971b5b904f078$var$rangd,
    range: $538971b5b904f078$var$range,
    rangle: $538971b5b904f078$var$rangle,
    raqu: $538971b5b904f078$var$raqu,
    raquo: $538971b5b904f078$var$raquo$1,
    rarr: $538971b5b904f078$var$rarr$1,
    rarrap: $538971b5b904f078$var$rarrap,
    rarrb: $538971b5b904f078$var$rarrb,
    rarrbfs: $538971b5b904f078$var$rarrbfs,
    rarrc: $538971b5b904f078$var$rarrc,
    rarrfs: $538971b5b904f078$var$rarrfs,
    rarrhk: $538971b5b904f078$var$rarrhk,
    rarrlp: $538971b5b904f078$var$rarrlp,
    rarrpl: $538971b5b904f078$var$rarrpl,
    rarrsim: $538971b5b904f078$var$rarrsim,
    rarrtl: $538971b5b904f078$var$rarrtl,
    rarrw: $538971b5b904f078$var$rarrw,
    ratail: $538971b5b904f078$var$ratail,
    ratio: $538971b5b904f078$var$ratio,
    rationals: $538971b5b904f078$var$rationals,
    rbarr: $538971b5b904f078$var$rbarr,
    rbbrk: $538971b5b904f078$var$rbbrk,
    rbrace: $538971b5b904f078$var$rbrace,
    rbrack: $538971b5b904f078$var$rbrack,
    rbrke: $538971b5b904f078$var$rbrke,
    rbrksld: $538971b5b904f078$var$rbrksld,
    rbrkslu: $538971b5b904f078$var$rbrkslu,
    rcaron: $538971b5b904f078$var$rcaron,
    rcedil: $538971b5b904f078$var$rcedil,
    rceil: $538971b5b904f078$var$rceil$1,
    rcub: $538971b5b904f078$var$rcub,
    rcy: $538971b5b904f078$var$rcy,
    rdca: $538971b5b904f078$var$rdca,
    rdldhar: $538971b5b904f078$var$rdldhar,
    rdquo: $538971b5b904f078$var$rdquo$1,
    rdquor: $538971b5b904f078$var$rdquor,
    rdsh: $538971b5b904f078$var$rdsh,
    real: $538971b5b904f078$var$real$1,
    realine: $538971b5b904f078$var$realine,
    realpart: $538971b5b904f078$var$realpart,
    reals: $538971b5b904f078$var$reals,
    rect: $538971b5b904f078$var$rect,
    re: $538971b5b904f078$var$re$3,
    reg: $538971b5b904f078$var$reg$1,
    rfisht: $538971b5b904f078$var$rfisht,
    rfloor: $538971b5b904f078$var$rfloor$1,
    rfr: $538971b5b904f078$var$rfr,
    rhard: $538971b5b904f078$var$rhard,
    rharu: $538971b5b904f078$var$rharu,
    rharul: $538971b5b904f078$var$rharul,
    rho: $538971b5b904f078$var$rho$1,
    rhov: $538971b5b904f078$var$rhov,
    rightarrow: $538971b5b904f078$var$rightarrow,
    rightarrowtail: $538971b5b904f078$var$rightarrowtail,
    rightharpoondown: $538971b5b904f078$var$rightharpoondown,
    rightharpoonup: $538971b5b904f078$var$rightharpoonup,
    rightleftarrows: $538971b5b904f078$var$rightleftarrows,
    rightleftharpoons: $538971b5b904f078$var$rightleftharpoons,
    rightrightarrows: $538971b5b904f078$var$rightrightarrows,
    rightsquigarrow: $538971b5b904f078$var$rightsquigarrow,
    rightthreetimes: $538971b5b904f078$var$rightthreetimes,
    ring: $538971b5b904f078$var$ring,
    risingdotseq: $538971b5b904f078$var$risingdotseq,
    rlarr: $538971b5b904f078$var$rlarr,
    rlhar: $538971b5b904f078$var$rlhar,
    rlm: $538971b5b904f078$var$rlm$1,
    rmoust: $538971b5b904f078$var$rmoust,
    rmoustache: $538971b5b904f078$var$rmoustache,
    rnmid: $538971b5b904f078$var$rnmid,
    roang: $538971b5b904f078$var$roang,
    roarr: $538971b5b904f078$var$roarr,
    robrk: $538971b5b904f078$var$robrk,
    ropar: $538971b5b904f078$var$ropar,
    ropf: $538971b5b904f078$var$ropf,
    roplus: $538971b5b904f078$var$roplus,
    rotimes: $538971b5b904f078$var$rotimes,
    rpar: $538971b5b904f078$var$rpar,
    rpargt: $538971b5b904f078$var$rpargt,
    rppolint: $538971b5b904f078$var$rppolint,
    rrarr: $538971b5b904f078$var$rrarr,
    rsaquo: $538971b5b904f078$var$rsaquo$1,
    rscr: $538971b5b904f078$var$rscr,
    rsh: $538971b5b904f078$var$rsh,
    rsqb: $538971b5b904f078$var$rsqb,
    rsquo: $538971b5b904f078$var$rsquo$1,
    rsquor: $538971b5b904f078$var$rsquor,
    rthree: $538971b5b904f078$var$rthree,
    rtimes: $538971b5b904f078$var$rtimes,
    rtri: $538971b5b904f078$var$rtri,
    rtrie: $538971b5b904f078$var$rtrie,
    rtrif: $538971b5b904f078$var$rtrif,
    rtriltri: $538971b5b904f078$var$rtriltri,
    ruluhar: $538971b5b904f078$var$ruluhar,
    rx: $538971b5b904f078$var$rx,
    sacute: $538971b5b904f078$var$sacute,
    sbquo: $538971b5b904f078$var$sbquo$1,
    sc: $538971b5b904f078$var$sc,
    scE: $538971b5b904f078$var$scE,
    scap: $538971b5b904f078$var$scap,
    scaron: $538971b5b904f078$var$scaron$1,
    sccue: $538971b5b904f078$var$sccue,
    sce: $538971b5b904f078$var$sce,
    scedil: $538971b5b904f078$var$scedil,
    scirc: $538971b5b904f078$var$scirc,
    scnE: $538971b5b904f078$var$scnE,
    scnap: $538971b5b904f078$var$scnap,
    scnsim: $538971b5b904f078$var$scnsim,
    scpolint: $538971b5b904f078$var$scpolint,
    scsim: $538971b5b904f078$var$scsim,
    scy: $538971b5b904f078$var$scy,
    sdot: $538971b5b904f078$var$sdot$1,
    sdotb: $538971b5b904f078$var$sdotb,
    sdote: $538971b5b904f078$var$sdote,
    seArr: $538971b5b904f078$var$seArr,
    searhk: $538971b5b904f078$var$searhk,
    searr: $538971b5b904f078$var$searr,
    searrow: $538971b5b904f078$var$searrow,
    sec: $538971b5b904f078$var$sec,
    sect: $538971b5b904f078$var$sect$1,
    semi: $538971b5b904f078$var$semi,
    seswar: $538971b5b904f078$var$seswar,
    setminus: $538971b5b904f078$var$setminus,
    setmn: $538971b5b904f078$var$setmn,
    sext: $538971b5b904f078$var$sext,
    sfr: $538971b5b904f078$var$sfr,
    sfrown: $538971b5b904f078$var$sfrown,
    sharp: $538971b5b904f078$var$sharp,
    shchcy: $538971b5b904f078$var$shchcy,
    shcy: $538971b5b904f078$var$shcy,
    shortmid: $538971b5b904f078$var$shortmid,
    shortparallel: $538971b5b904f078$var$shortparallel,
    sh: $538971b5b904f078$var$sh,
    shy: $538971b5b904f078$var$shy$1,
    sigma: $538971b5b904f078$var$sigma$1,
    sigmaf: $538971b5b904f078$var$sigmaf$1,
    sigmav: $538971b5b904f078$var$sigmav,
    sim: $538971b5b904f078$var$sim$1,
    simdot: $538971b5b904f078$var$simdot,
    sime: $538971b5b904f078$var$sime,
    simeq: $538971b5b904f078$var$simeq,
    simg: $538971b5b904f078$var$simg,
    simgE: $538971b5b904f078$var$simgE,
    siml: $538971b5b904f078$var$siml,
    simlE: $538971b5b904f078$var$simlE,
    simne: $538971b5b904f078$var$simne,
    simplus: $538971b5b904f078$var$simplus,
    simrarr: $538971b5b904f078$var$simrarr,
    slarr: $538971b5b904f078$var$slarr,
    smallsetminus: $538971b5b904f078$var$smallsetminus,
    smashp: $538971b5b904f078$var$smashp,
    smeparsl: $538971b5b904f078$var$smeparsl,
    smid: $538971b5b904f078$var$smid,
    smile: $538971b5b904f078$var$smile,
    smt: $538971b5b904f078$var$smt,
    smte: $538971b5b904f078$var$smte,
    smtes: $538971b5b904f078$var$smtes,
    softcy: $538971b5b904f078$var$softcy,
    sol: $538971b5b904f078$var$sol,
    solb: $538971b5b904f078$var$solb,
    solbar: $538971b5b904f078$var$solbar,
    sopf: $538971b5b904f078$var$sopf,
    spades: $538971b5b904f078$var$spades$1,
    spadesuit: $538971b5b904f078$var$spadesuit,
    spar: $538971b5b904f078$var$spar,
    sqcap: $538971b5b904f078$var$sqcap,
    sqcaps: $538971b5b904f078$var$sqcaps,
    sqcup: $538971b5b904f078$var$sqcup,
    sqcups: $538971b5b904f078$var$sqcups,
    sqsub: $538971b5b904f078$var$sqsub,
    sqsube: $538971b5b904f078$var$sqsube,
    sqsubset: $538971b5b904f078$var$sqsubset,
    sqsubseteq: $538971b5b904f078$var$sqsubseteq,
    sqsup: $538971b5b904f078$var$sqsup,
    sqsupe: $538971b5b904f078$var$sqsupe,
    sqsupset: $538971b5b904f078$var$sqsupset,
    sqsupseteq: $538971b5b904f078$var$sqsupseteq,
    squ: $538971b5b904f078$var$squ,
    square: $538971b5b904f078$var$square,
    squarf: $538971b5b904f078$var$squarf,
    squf: $538971b5b904f078$var$squf,
    srarr: $538971b5b904f078$var$srarr,
    sscr: $538971b5b904f078$var$sscr,
    ssetmn: $538971b5b904f078$var$ssetmn,
    ssmile: $538971b5b904f078$var$ssmile,
    sstarf: $538971b5b904f078$var$sstarf,
    star: $538971b5b904f078$var$star,
    starf: $538971b5b904f078$var$starf,
    straightepsilon: $538971b5b904f078$var$straightepsilon,
    straightphi: $538971b5b904f078$var$straightphi,
    strns: $538971b5b904f078$var$strns,
    sub: $538971b5b904f078$var$sub$1,
    subE: $538971b5b904f078$var$subE,
    subdot: $538971b5b904f078$var$subdot,
    sube: $538971b5b904f078$var$sube$1,
    subedot: $538971b5b904f078$var$subedot,
    submult: $538971b5b904f078$var$submult,
    subnE: $538971b5b904f078$var$subnE,
    subne: $538971b5b904f078$var$subne,
    subplus: $538971b5b904f078$var$subplus,
    subrarr: $538971b5b904f078$var$subrarr,
    subset: $538971b5b904f078$var$subset,
    subseteq: $538971b5b904f078$var$subseteq,
    subseteqq: $538971b5b904f078$var$subseteqq,
    subsetneq: $538971b5b904f078$var$subsetneq,
    subsetneqq: $538971b5b904f078$var$subsetneqq,
    subsim: $538971b5b904f078$var$subsim,
    subsub: $538971b5b904f078$var$subsub,
    subsup: $538971b5b904f078$var$subsup,
    succ: $538971b5b904f078$var$succ,
    succapprox: $538971b5b904f078$var$succapprox,
    succcurlyeq: $538971b5b904f078$var$succcurlyeq,
    succeq: $538971b5b904f078$var$succeq,
    succnapprox: $538971b5b904f078$var$succnapprox,
    succneqq: $538971b5b904f078$var$succneqq,
    succnsim: $538971b5b904f078$var$succnsim,
    succsim: $538971b5b904f078$var$succsim,
    sum: $538971b5b904f078$var$sum$1,
    sung: $538971b5b904f078$var$sung,
    sup: $538971b5b904f078$var$sup$1,
    sup1: $538971b5b904f078$var$sup1$1,
    sup2: $538971b5b904f078$var$sup2$1,
    sup3: $538971b5b904f078$var$sup3$1,
    supE: $538971b5b904f078$var$supE,
    supdot: $538971b5b904f078$var$supdot,
    supdsub: $538971b5b904f078$var$supdsub,
    supe: $538971b5b904f078$var$supe$1,
    supedot: $538971b5b904f078$var$supedot,
    suphsol: $538971b5b904f078$var$suphsol,
    suphsub: $538971b5b904f078$var$suphsub,
    suplarr: $538971b5b904f078$var$suplarr,
    supmult: $538971b5b904f078$var$supmult,
    supnE: $538971b5b904f078$var$supnE,
    supne: $538971b5b904f078$var$supne,
    supplus: $538971b5b904f078$var$supplus,
    supset: $538971b5b904f078$var$supset,
    supseteq: $538971b5b904f078$var$supseteq,
    supseteqq: $538971b5b904f078$var$supseteqq,
    supsetneq: $538971b5b904f078$var$supsetneq,
    supsetneqq: $538971b5b904f078$var$supsetneqq,
    supsim: $538971b5b904f078$var$supsim,
    supsub: $538971b5b904f078$var$supsub,
    supsup: $538971b5b904f078$var$supsup,
    swArr: $538971b5b904f078$var$swArr,
    swarhk: $538971b5b904f078$var$swarhk,
    swarr: $538971b5b904f078$var$swarr,
    swarrow: $538971b5b904f078$var$swarrow,
    swnwar: $538971b5b904f078$var$swnwar,
    szli: $538971b5b904f078$var$szli,
    szlig: $538971b5b904f078$var$szlig$1,
    target: $538971b5b904f078$var$target,
    tau: $538971b5b904f078$var$tau$1,
    tbrk: $538971b5b904f078$var$tbrk,
    tcaron: $538971b5b904f078$var$tcaron,
    tcedil: $538971b5b904f078$var$tcedil,
    tcy: $538971b5b904f078$var$tcy,
    tdot: $538971b5b904f078$var$tdot,
    telrec: $538971b5b904f078$var$telrec,
    tfr: $538971b5b904f078$var$tfr,
    there4: $538971b5b904f078$var$there4$1,
    therefore: $538971b5b904f078$var$therefore,
    theta: $538971b5b904f078$var$theta$1,
    thetasym: $538971b5b904f078$var$thetasym$1,
    thetav: $538971b5b904f078$var$thetav,
    thickapprox: $538971b5b904f078$var$thickapprox,
    thicksim: $538971b5b904f078$var$thicksim,
    thinsp: $538971b5b904f078$var$thinsp$1,
    thkap: $538971b5b904f078$var$thkap,
    thksim: $538971b5b904f078$var$thksim,
    thor: $538971b5b904f078$var$thor,
    thorn: $538971b5b904f078$var$thorn$1,
    tilde: $538971b5b904f078$var$tilde$4,
    time: $538971b5b904f078$var$time,
    times: $538971b5b904f078$var$times$1,
    timesb: $538971b5b904f078$var$timesb,
    timesbar: $538971b5b904f078$var$timesbar,
    timesd: $538971b5b904f078$var$timesd,
    tint: $538971b5b904f078$var$tint,
    toea: $538971b5b904f078$var$toea,
    top: $538971b5b904f078$var$top,
    topbot: $538971b5b904f078$var$topbot,
    topcir: $538971b5b904f078$var$topcir,
    topf: $538971b5b904f078$var$topf,
    topfork: $538971b5b904f078$var$topfork,
    tosa: $538971b5b904f078$var$tosa,
    tprime: $538971b5b904f078$var$tprime,
    trade: $538971b5b904f078$var$trade$1,
    triangle: $538971b5b904f078$var$triangle,
    triangledown: $538971b5b904f078$var$triangledown,
    triangleleft: $538971b5b904f078$var$triangleleft,
    trianglelefteq: $538971b5b904f078$var$trianglelefteq,
    triangleq: $538971b5b904f078$var$triangleq,
    triangleright: $538971b5b904f078$var$triangleright,
    trianglerighteq: $538971b5b904f078$var$trianglerighteq,
    tridot: $538971b5b904f078$var$tridot,
    trie: $538971b5b904f078$var$trie,
    triminus: $538971b5b904f078$var$triminus,
    triplus: $538971b5b904f078$var$triplus,
    trisb: $538971b5b904f078$var$trisb,
    tritime: $538971b5b904f078$var$tritime,
    trpezium: $538971b5b904f078$var$trpezium,
    tscr: $538971b5b904f078$var$tscr,
    tscy: $538971b5b904f078$var$tscy,
    tshcy: $538971b5b904f078$var$tshcy,
    tstrok: $538971b5b904f078$var$tstrok,
    twixt: $538971b5b904f078$var$twixt,
    twoheadleftarrow: $538971b5b904f078$var$twoheadleftarrow,
    twoheadrightarrow: $538971b5b904f078$var$twoheadrightarrow,
    uArr: $538971b5b904f078$var$uArr$1,
    uHar: $538971b5b904f078$var$uHar,
    uacut: $538971b5b904f078$var$uacut,
    uacute: $538971b5b904f078$var$uacute$1,
    uarr: $538971b5b904f078$var$uarr$1,
    ubrcy: $538971b5b904f078$var$ubrcy,
    ubreve: $538971b5b904f078$var$ubreve,
    ucir: $538971b5b904f078$var$ucir,
    ucirc: $538971b5b904f078$var$ucirc$1,
    ucy: $538971b5b904f078$var$ucy,
    udarr: $538971b5b904f078$var$udarr,
    udblac: $538971b5b904f078$var$udblac,
    udhar: $538971b5b904f078$var$udhar,
    ufisht: $538971b5b904f078$var$ufisht,
    ufr: $538971b5b904f078$var$ufr,
    ugrav: $538971b5b904f078$var$ugrav,
    ugrave: $538971b5b904f078$var$ugrave$1,
    uharl: $538971b5b904f078$var$uharl,
    uharr: $538971b5b904f078$var$uharr,
    uhblk: $538971b5b904f078$var$uhblk,
    ulcorn: $538971b5b904f078$var$ulcorn,
    ulcorner: $538971b5b904f078$var$ulcorner,
    ulcrop: $538971b5b904f078$var$ulcrop,
    ultri: $538971b5b904f078$var$ultri,
    umacr: $538971b5b904f078$var$umacr,
    um: $538971b5b904f078$var$um,
    uml: $538971b5b904f078$var$uml$1,
    uogon: $538971b5b904f078$var$uogon,
    uopf: $538971b5b904f078$var$uopf,
    uparrow: $538971b5b904f078$var$uparrow,
    updownarrow: $538971b5b904f078$var$updownarrow,
    upharpoonleft: $538971b5b904f078$var$upharpoonleft,
    upharpoonright: $538971b5b904f078$var$upharpoonright,
    uplus: $538971b5b904f078$var$uplus,
    upsi: $538971b5b904f078$var$upsi,
    upsih: $538971b5b904f078$var$upsih$1,
    upsilon: $538971b5b904f078$var$upsilon$1,
    upuparrows: $538971b5b904f078$var$upuparrows,
    urcorn: $538971b5b904f078$var$urcorn,
    urcorner: $538971b5b904f078$var$urcorner,
    urcrop: $538971b5b904f078$var$urcrop,
    uring: $538971b5b904f078$var$uring,
    urtri: $538971b5b904f078$var$urtri,
    uscr: $538971b5b904f078$var$uscr,
    utdot: $538971b5b904f078$var$utdot,
    utilde: $538971b5b904f078$var$utilde,
    utri: $538971b5b904f078$var$utri,
    utrif: $538971b5b904f078$var$utrif,
    uuarr: $538971b5b904f078$var$uuarr,
    uum: $538971b5b904f078$var$uum,
    uuml: $538971b5b904f078$var$uuml$1,
    uwangle: $538971b5b904f078$var$uwangle,
    vArr: $538971b5b904f078$var$vArr,
    vBar: $538971b5b904f078$var$vBar,
    vBarv: $538971b5b904f078$var$vBarv,
    vDash: $538971b5b904f078$var$vDash,
    vangrt: $538971b5b904f078$var$vangrt,
    varepsilon: $538971b5b904f078$var$varepsilon,
    varkappa: $538971b5b904f078$var$varkappa,
    varnothing: $538971b5b904f078$var$varnothing,
    varphi: $538971b5b904f078$var$varphi,
    varpi: $538971b5b904f078$var$varpi,
    varpropto: $538971b5b904f078$var$varpropto,
    varr: $538971b5b904f078$var$varr,
    varrho: $538971b5b904f078$var$varrho,
    varsigma: $538971b5b904f078$var$varsigma,
    varsubsetneq: $538971b5b904f078$var$varsubsetneq,
    varsubsetneqq: $538971b5b904f078$var$varsubsetneqq,
    varsupsetneq: $538971b5b904f078$var$varsupsetneq,
    varsupsetneqq: $538971b5b904f078$var$varsupsetneqq,
    vartheta: $538971b5b904f078$var$vartheta,
    vartriangleleft: $538971b5b904f078$var$vartriangleleft,
    vartriangleright: $538971b5b904f078$var$vartriangleright,
    vcy: $538971b5b904f078$var$vcy,
    vdash: $538971b5b904f078$var$vdash,
    vee: $538971b5b904f078$var$vee,
    veebar: $538971b5b904f078$var$veebar,
    veeeq: $538971b5b904f078$var$veeeq,
    vellip: $538971b5b904f078$var$vellip,
    verbar: $538971b5b904f078$var$verbar,
    vert: $538971b5b904f078$var$vert,
    vfr: $538971b5b904f078$var$vfr,
    vltri: $538971b5b904f078$var$vltri,
    vnsub: $538971b5b904f078$var$vnsub,
    vnsup: $538971b5b904f078$var$vnsup,
    vopf: $538971b5b904f078$var$vopf,
    vprop: $538971b5b904f078$var$vprop,
    vrtri: $538971b5b904f078$var$vrtri,
    vscr: $538971b5b904f078$var$vscr,
    vsubnE: $538971b5b904f078$var$vsubnE,
    vsubne: $538971b5b904f078$var$vsubne,
    vsupnE: $538971b5b904f078$var$vsupnE,
    vsupne: $538971b5b904f078$var$vsupne,
    vzigzag: $538971b5b904f078$var$vzigzag,
    wcirc: $538971b5b904f078$var$wcirc,
    wedbar: $538971b5b904f078$var$wedbar,
    wedge: $538971b5b904f078$var$wedge,
    wedgeq: $538971b5b904f078$var$wedgeq,
    weierp: $538971b5b904f078$var$weierp$1,
    wfr: $538971b5b904f078$var$wfr,
    wopf: $538971b5b904f078$var$wopf,
    wp: $538971b5b904f078$var$wp,
    wr: $538971b5b904f078$var$wr,
    wreath: $538971b5b904f078$var$wreath,
    wscr: $538971b5b904f078$var$wscr,
    xcap: $538971b5b904f078$var$xcap,
    xcirc: $538971b5b904f078$var$xcirc,
    xcup: $538971b5b904f078$var$xcup,
    xdtri: $538971b5b904f078$var$xdtri,
    xfr: $538971b5b904f078$var$xfr,
    xhArr: $538971b5b904f078$var$xhArr,
    xharr: $538971b5b904f078$var$xharr,
    xi: $538971b5b904f078$var$xi$1,
    xlArr: $538971b5b904f078$var$xlArr,
    xlarr: $538971b5b904f078$var$xlarr,
    xmap: $538971b5b904f078$var$xmap,
    xnis: $538971b5b904f078$var$xnis,
    xodot: $538971b5b904f078$var$xodot,
    xopf: $538971b5b904f078$var$xopf,
    xoplus: $538971b5b904f078$var$xoplus,
    xotime: $538971b5b904f078$var$xotime,
    xrArr: $538971b5b904f078$var$xrArr,
    xrarr: $538971b5b904f078$var$xrarr,
    xscr: $538971b5b904f078$var$xscr,
    xsqcup: $538971b5b904f078$var$xsqcup,
    xuplus: $538971b5b904f078$var$xuplus,
    xutri: $538971b5b904f078$var$xutri,
    xvee: $538971b5b904f078$var$xvee,
    xwedge: $538971b5b904f078$var$xwedge,
    yacut: $538971b5b904f078$var$yacut,
    yacute: $538971b5b904f078$var$yacute$1,
    yacy: $538971b5b904f078$var$yacy,
    ycirc: $538971b5b904f078$var$ycirc,
    ycy: $538971b5b904f078$var$ycy,
    ye: $538971b5b904f078$var$ye,
    yen: $538971b5b904f078$var$yen$1,
    yfr: $538971b5b904f078$var$yfr,
    yicy: $538971b5b904f078$var$yicy,
    yopf: $538971b5b904f078$var$yopf,
    yscr: $538971b5b904f078$var$yscr,
    yucy: $538971b5b904f078$var$yucy,
    yum: $538971b5b904f078$var$yum,
    yuml: $538971b5b904f078$var$yuml$1,
    zacute: $538971b5b904f078$var$zacute,
    zcaron: $538971b5b904f078$var$zcaron,
    zcy: $538971b5b904f078$var$zcy,
    zdot: $538971b5b904f078$var$zdot,
    zeetrf: $538971b5b904f078$var$zeetrf,
    zeta: $538971b5b904f078$var$zeta$1,
    zfr: $538971b5b904f078$var$zfr,
    zhcy: $538971b5b904f078$var$zhcy,
    zigrarr: $538971b5b904f078$var$zigrarr,
    zopf: $538971b5b904f078$var$zopf,
    zscr: $538971b5b904f078$var$zscr,
    zwj: $538971b5b904f078$var$zwj$1,
    zwnj: $538971b5b904f078$var$zwnj$1,
    "default": $538971b5b904f078$var$index$3
});
var $538971b5b904f078$var$characterEntities = $538971b5b904f078$var$getCjsExportFromNamespace($538971b5b904f078$var$characterEntities$1);
var $538971b5b904f078$var$decodeEntity_1 = $538971b5b904f078$var$decodeEntity;
var $538971b5b904f078$var$own$c = {}.hasOwnProperty;
function $538971b5b904f078$var$decodeEntity(characters) {
    return $538971b5b904f078$var$own$c.call($538971b5b904f078$var$characterEntities, characters) ? $538971b5b904f078$var$characterEntities[characters] : false;
}
var $538971b5b904f078$var$legacy = $538971b5b904f078$var$getCjsExportFromNamespace($538971b5b904f078$var$characterEntitiesLegacy);
var $538971b5b904f078$var$invalid = $538971b5b904f078$var$getCjsExportFromNamespace($538971b5b904f078$var$characterReferenceInvalid);
var $538971b5b904f078$var$parseEntities_1 = $538971b5b904f078$var$parseEntities;
var $538971b5b904f078$var$own$b = {}.hasOwnProperty;
var $538971b5b904f078$var$fromCharCode = String.fromCharCode;
var $538971b5b904f078$var$noop = Function.prototype;
// Default settings.
var $538971b5b904f078$var$defaults$3 = {
    warning: null,
    reference: null,
    text: null,
    warningContext: null,
    referenceContext: null,
    textContext: null,
    position: {},
    additional: null,
    attribute: false,
    nonTerminated: true
};
// Characters.
var $538971b5b904f078$var$tab$e = 9; // '\t'
var $538971b5b904f078$var$lineFeed$j = 10; // '\n'
var $538971b5b904f078$var$formFeed = 12; // '\f'
var $538971b5b904f078$var$space$j = 32; // ' '
var $538971b5b904f078$var$ampersand$1 = 38; // '&'
var $538971b5b904f078$var$semicolon$1 = 59; // ';'
var $538971b5b904f078$var$lessThan$8 = 60; // '<'
var $538971b5b904f078$var$equalsTo$2 = 61; // '='
var $538971b5b904f078$var$numberSign$1 = 35; // '#'
var $538971b5b904f078$var$uppercaseX = 88; // 'X'
var $538971b5b904f078$var$lowercaseX$1 = 120; // 'x'
var $538971b5b904f078$var$replacementCharacter = 65533; // '�'
// Reference types.
var $538971b5b904f078$var$name$1 = "named";
var $538971b5b904f078$var$hexa = "hexadecimal";
var $538971b5b904f078$var$deci = "decimal";
// Map of bases.
var $538971b5b904f078$var$bases = {};
$538971b5b904f078$var$bases[$538971b5b904f078$var$hexa] = 16;
$538971b5b904f078$var$bases[$538971b5b904f078$var$deci] = 10;
// Map of types to tests.
// Each type of character reference accepts different characters.
// This test is used to detect whether a reference has ended (as the semicolon
// is not strictly needed).
var $538971b5b904f078$var$tests = {};
$538971b5b904f078$var$tests[$538971b5b904f078$var$name$1] = $538971b5b904f078$var$isAlphanumerical;
$538971b5b904f078$var$tests[$538971b5b904f078$var$deci] = $538971b5b904f078$var$isDecimal;
$538971b5b904f078$var$tests[$538971b5b904f078$var$hexa] = $538971b5b904f078$var$isHexadecimal;
// Warning types.
var $538971b5b904f078$var$namedNotTerminated = 1;
var $538971b5b904f078$var$numericNotTerminated = 2;
var $538971b5b904f078$var$namedEmpty = 3;
var $538971b5b904f078$var$numericEmpty = 4;
var $538971b5b904f078$var$namedUnknown = 5;
var $538971b5b904f078$var$numericDisallowed = 6;
var $538971b5b904f078$var$numericProhibited = 7;
// Warning messages.
var $538971b5b904f078$var$messages = {};
$538971b5b904f078$var$messages[$538971b5b904f078$var$namedNotTerminated] = "Named character references must be terminated by a semicolon";
$538971b5b904f078$var$messages[$538971b5b904f078$var$numericNotTerminated] = "Numeric character references must be terminated by a semicolon";
$538971b5b904f078$var$messages[$538971b5b904f078$var$namedEmpty] = "Named character references cannot be empty";
$538971b5b904f078$var$messages[$538971b5b904f078$var$numericEmpty] = "Numeric character references cannot be empty";
$538971b5b904f078$var$messages[$538971b5b904f078$var$namedUnknown] = "Named character references must be known";
$538971b5b904f078$var$messages[$538971b5b904f078$var$numericDisallowed] = "Numeric character references cannot be disallowed";
$538971b5b904f078$var$messages[$538971b5b904f078$var$numericProhibited] = "Numeric character references cannot be outside the permissible Unicode range";
// Wrap to ensure clean parameters are given to `parse`.
function $538971b5b904f078$var$parseEntities(value, options) {
    var settings = {};
    var option;
    var key;
    if (!options) options = {};
    for(key in $538971b5b904f078$var$defaults$3){
        option = options[key];
        settings[key] = option === null || option === undefined ? $538971b5b904f078$var$defaults$3[key] : option;
    }
    if (settings.position.indent || settings.position.start) {
        settings.indent = settings.position.indent || [];
        settings.position = settings.position.start;
    }
    return $538971b5b904f078$var$parse$7(value, settings);
}
// Parse entities.
// eslint-disable-next-line complexity
function $538971b5b904f078$var$parse$7(value, settings) {
    var additional = settings.additional;
    var nonTerminated = settings.nonTerminated;
    var handleText = settings.text;
    var handleReference = settings.reference;
    var handleWarning = settings.warning;
    var textContext = settings.textContext;
    var referenceContext = settings.referenceContext;
    var warningContext = settings.warningContext;
    var pos = settings.position;
    var indent = settings.indent || [];
    var length = value.length;
    var index = 0;
    var lines = -1;
    var column = pos.column || 1;
    var line = pos.line || 1;
    var queue = "";
    var result = [];
    var entityCharacters;
    var namedEntity;
    var terminated;
    var characters;
    var character;
    var reference;
    var following;
    var warning;
    var reason;
    var output;
    var entity;
    var begin;
    var start;
    var type;
    var test;
    var prev;
    var next;
    var diff;
    var end;
    if (typeof additional === "string") additional = additional.charCodeAt(0);
    // Cache the current point.
    prev = now();
    // Wrap `handleWarning`.
    warning = handleWarning ? parseError : $538971b5b904f078$var$noop;
    // Ensure the algorithm walks over the first character and the end
    // (inclusive).
    index--;
    length++;
    while(++index < length){
        // If the previous character was a newline.
        if (character === $538971b5b904f078$var$lineFeed$j) column = indent[lines] || 1;
        character = value.charCodeAt(index);
        if (character === $538971b5b904f078$var$ampersand$1) {
            following = value.charCodeAt(index + 1);
            // The behaviour depends on the identity of the next character.
            if (following === $538971b5b904f078$var$tab$e || following === $538971b5b904f078$var$lineFeed$j || following === $538971b5b904f078$var$formFeed || following === $538971b5b904f078$var$space$j || following === $538971b5b904f078$var$ampersand$1 || following === $538971b5b904f078$var$lessThan$8 || following !== following || additional && following === additional) {
                // Not a character reference.
                // No characters are consumed, and nothing is returned.
                // This is not an error, either.
                queue += $538971b5b904f078$var$fromCharCode(character);
                column++;
                continue;
            }
            start = index + 1;
            begin = start;
            end = start;
            if (following === $538971b5b904f078$var$numberSign$1) {
                // Numerical entity.
                end = ++begin;
                // The behaviour further depends on the next character.
                following = value.charCodeAt(end);
                if (following === $538971b5b904f078$var$uppercaseX || following === $538971b5b904f078$var$lowercaseX$1) {
                    // ASCII hex digits.
                    type = $538971b5b904f078$var$hexa;
                    end = ++begin;
                } else // ASCII digits.
                type = $538971b5b904f078$var$deci;
            } else // Named entity.
            type = $538971b5b904f078$var$name$1;
            entityCharacters = "";
            entity = "";
            characters = "";
            test = $538971b5b904f078$var$tests[type];
            end--;
            while(++end < length){
                following = value.charCodeAt(end);
                if (!test(following)) break;
                characters += $538971b5b904f078$var$fromCharCode(following);
                // Check if we can match a legacy named reference.
                // If so, we cache that as the last viable named reference.
                // This ensures we do not need to walk backwards later.
                if (type === $538971b5b904f078$var$name$1 && $538971b5b904f078$var$own$b.call($538971b5b904f078$var$legacy, characters)) {
                    entityCharacters = characters;
                    entity = $538971b5b904f078$var$legacy[characters];
                }
            }
            terminated = value.charCodeAt(end) === $538971b5b904f078$var$semicolon$1;
            if (terminated) {
                end++;
                namedEntity = type === $538971b5b904f078$var$name$1 ? $538971b5b904f078$var$decodeEntity_1(characters) : false;
                if (namedEntity) {
                    entityCharacters = characters;
                    entity = namedEntity;
                }
            }
            diff = 1 + end - start;
            if (!terminated && !nonTerminated) ;
            else if (!characters) // An empty (possible) entity is valid, unless it’s numeric (thus an
            // ampersand followed by an octothorp).
            {
                if (type !== $538971b5b904f078$var$name$1) warning($538971b5b904f078$var$numericEmpty, diff);
            } else if (type === $538971b5b904f078$var$name$1) {
                // An ampersand followed by anything unknown, and not terminated, is
                // invalid.
                if (terminated && !entity) warning($538971b5b904f078$var$namedUnknown, 1);
                else {
                    // If theres something after an entity name which is not known, cap
                    // the reference.
                    if (entityCharacters !== characters) {
                        end = begin + entityCharacters.length;
                        diff = 1 + end - begin;
                        terminated = false;
                    }
                    // If the reference is not terminated, warn.
                    if (!terminated) {
                        reason = entityCharacters ? $538971b5b904f078$var$namedNotTerminated : $538971b5b904f078$var$namedEmpty;
                        if (settings.attribute) {
                            following = value.charCodeAt(end);
                            if (following === $538971b5b904f078$var$equalsTo$2) {
                                warning(reason, diff);
                                entity = null;
                            } else if ($538971b5b904f078$var$isAlphanumerical(following)) entity = null;
                            else warning(reason, diff);
                        } else warning(reason, diff);
                    }
                }
                reference = entity;
            } else {
                if (!terminated) // All non-terminated numeric entities are not rendered, and trigger a
                // warning.
                warning($538971b5b904f078$var$numericNotTerminated, diff);
                // When terminated and number, parse as either hexadecimal or decimal.
                reference = parseInt(characters, $538971b5b904f078$var$bases[type]);
                // Trigger a warning when the parsed number is prohibited, and replace
                // with replacement character.
                if ($538971b5b904f078$var$prohibited(reference)) {
                    warning($538971b5b904f078$var$numericProhibited, diff);
                    reference = $538971b5b904f078$var$fromCharCode($538971b5b904f078$var$replacementCharacter);
                } else if (reference in $538971b5b904f078$var$invalid) {
                    // Trigger a warning when the parsed number is disallowed, and replace
                    // by an alternative.
                    warning($538971b5b904f078$var$numericDisallowed, diff);
                    reference = $538971b5b904f078$var$invalid[reference];
                } else {
                    // Parse the number.
                    output = "";
                    // Trigger a warning when the parsed number should not be used.
                    if ($538971b5b904f078$var$disallowed(reference)) warning($538971b5b904f078$var$numericDisallowed, diff);
                    // Stringify the number.
                    if (reference > 0xffff) {
                        reference -= 0x10000;
                        output += $538971b5b904f078$var$fromCharCode(reference >>> 10 | 0xd800);
                        reference = 0xdc00 | reference & 0x3ff;
                    }
                    reference = output + $538971b5b904f078$var$fromCharCode(reference);
                }
            }
            // Found it!
            // First eat the queued characters as normal text, then eat an entity.
            if (reference) {
                flush();
                prev = now();
                index = end - 1;
                column += end - start + 1;
                result.push(reference);
                next = now();
                next.offset++;
                if (handleReference) handleReference.call(referenceContext, reference, {
                    start: prev,
                    end: next
                }, value.slice(start - 1, end));
                prev = next;
            } else {
                // If we could not find a reference, queue the checked characters (as
                // normal characters), and move the pointer to their end.
                // This is possible because we can be certain neither newlines nor
                // ampersands are included.
                characters = value.slice(start - 1, end);
                queue += characters;
                column += characters.length;
                index = end - 1;
            }
        } else {
            // Handle anything other than an ampersand, including newlines and EOF.
            if (character === 10 // Line feed
            ) {
                line++;
                lines++;
                column = 0;
            }
            if (character === character) {
                queue += $538971b5b904f078$var$fromCharCode(character);
                column++;
            } else flush();
        }
    }
    // Return the reduced nodes.
    return result.join("");
    // Get current position.
    function now() {
        return {
            line: line,
            column: column,
            offset: index + (pos.offset || 0)
        };
    }
    // “Throw” a parse-error: a warning.
    function parseError(code, offset) {
        var position = now();
        position.column += offset;
        position.offset += offset;
        handleWarning.call(warningContext, $538971b5b904f078$var$messages[code], position, code);
    }
    // Flush `queue` (normal text).
    // Macro invoked before each entity and at the end of `value`.
    // Does nothing when `queue` is empty.
    function flush() {
        if (queue) {
            result.push(queue);
            if (handleText) handleText.call(textContext, queue, {
                start: prev,
                end: now()
            });
            queue = "";
        }
    }
}
// Check if `character` is outside the permissible unicode range.
function $538971b5b904f078$var$prohibited(code) {
    return code >= 0xd800 && code <= 0xdfff || code > 0x10ffff;
}
// Check if `character` is disallowed.
function $538971b5b904f078$var$disallowed(code) {
    return code >= 0x0001 && code <= 0x0008 || code === 0x000b || code >= 0x000d && code <= 0x001f || code >= 0x007f && code <= 0x009f || code >= 0xfdd0 && code <= 0xfdef || (code & 0xffff) === 0xffff || (code & 0xffff) === 0xfffe;
}
var $538971b5b904f078$var$decode = $538971b5b904f078$var$factory$3;
// Factory to create an entity decoder.
function $538971b5b904f078$var$factory$3(ctx) {
    decoder.raw = decodeRaw;
    return decoder;
    // Normalize `position` to add an `indent`.
    function normalize(position) {
        var offsets = ctx.offset;
        var line = position.line;
        var result = [];
        while(++line){
            if (!(line in offsets)) break;
            result.push((offsets[line] || 0) + 1);
        }
        return {
            start: position,
            indent: result
        };
    }
    // Decode `value` (at `position`) into text-nodes.
    function decoder(value, position, handler) {
        $538971b5b904f078$var$parseEntities_1(value, {
            position: normalize(position),
            warning: handleWarning,
            text: handler,
            reference: handler,
            textContext: ctx,
            referenceContext: ctx
        });
    }
    // Decode `value` (at `position`) into a string.
    function decodeRaw(value, position, options) {
        return $538971b5b904f078$var$parseEntities_1(value, $538971b5b904f078$var$immutable(options, {
            position: normalize(position),
            warning: handleWarning
        }));
    }
    // Handle a warning.
    // See <https://github.com/wooorm/parse-entities> for the warnings.
    function handleWarning(reason, position, code) {
        if (code !== 3) ctx.file.message(reason, position);
    }
}
var $538971b5b904f078$var$tokenizer$1 = $538971b5b904f078$var$factory$2;
// Construct a tokenizer.  This creates both `tokenizeInline` and `tokenizeBlock`.
function $538971b5b904f078$var$factory$2(type) {
    return tokenize;
    // Tokenizer for a bound `type`.
    function tokenize(value, location) {
        var self = this;
        var offset = self.offset;
        var tokens = [];
        var methods = self[type + "Methods"];
        var tokenizers = self[type + "Tokenizers"];
        var line = location.line;
        var column = location.column;
        var index;
        var length;
        var method;
        var name;
        var matched;
        var valueLength;
        // Trim white space only lines.
        if (!value) return tokens;
        // Expose on `eat`.
        eat.now = now;
        eat.file = self.file;
        // Sync initial offset.
        updatePosition("");
        // Iterate over `value`, and iterate over all tokenizers.  When one eats
        // something, re-iterate with the remaining value.  If no tokenizer eats,
        // something failed (should not happen) and an exception is thrown.
        while(value){
            index = -1;
            length = methods.length;
            matched = false;
            while(++index < length){
                name = methods[index];
                method = tokenizers[name];
                // Previously, we had constructs such as footnotes and YAML that used
                // these properties.
                // Those are now external (plus there are userland extensions), that may
                // still use them.
                if (method && /* istanbul ignore next */ (!method.onlyAtStart || self.atStart) && /* istanbul ignore next */ (!method.notInList || !self.inList) && /* istanbul ignore next */ (!method.notInBlock || !self.inBlock) && (!method.notInLink || !self.inLink)) {
                    valueLength = value.length;
                    method.apply(self, [
                        eat,
                        value
                    ]);
                    matched = valueLength !== value.length;
                    if (matched) break;
                }
            }
            /* istanbul ignore if */ if (!matched) self.file.fail(new Error("Infinite loop"), eat.now());
        }
        self.eof = now();
        return tokens;
        // Update line, column, and offset based on `value`.
        function updatePosition(subvalue) {
            var lastIndex = -1;
            var index = subvalue.indexOf("\n");
            while(index !== -1){
                line++;
                lastIndex = index;
                index = subvalue.indexOf("\n", index + 1);
            }
            if (lastIndex === -1) column += subvalue.length;
            else column = subvalue.length - lastIndex;
            if (line in offset) {
                if (lastIndex !== -1) column += offset[line];
                else if (column <= offset[line]) column = offset[line] + 1;
            }
        }
        // Get offset.  Called before the first character is eaten to retrieve the
        // range’s offsets.
        function getOffset() {
            var indentation = [];
            var pos = line + 1;
            // Done.  Called when the last character is eaten to retrieve the range’s
            // offsets.
            return function() {
                var last = line + 1;
                while(pos < last){
                    indentation.push((offset[pos] || 0) + 1);
                    pos++;
                }
                return indentation;
            };
        }
        // Get the current position.
        function now() {
            var pos = {
                line: line,
                column: column
            };
            pos.offset = self.toOffset(pos);
            return pos;
        }
        // Store position information for a node.
        function Position(start) {
            this.start = start;
            this.end = now();
        }
        // Throw when a value is incorrectly eaten.  This shouldn’t happen but will
        // throw on new, incorrect rules.
        function validateEat(subvalue) {
            /* istanbul ignore if */ if (value.slice(0, subvalue.length) !== subvalue) // Capture stack-trace.
            self.file.fail(new Error("Incorrectly eaten value: please report this warning on https://git.io/vg5Ft"), now());
        }
        // Mark position and patch `node.position`.
        function position() {
            var before = now();
            return update;
            // Add the position to a node.
            function update(node, indent) {
                var previous = node.position;
                var start = previous ? previous.start : before;
                var combined = [];
                var n = previous && previous.end.line;
                var l = before.line;
                node.position = new Position(start);
                // If there was already a `position`, this node was merged.  Fixing
                // `start` wasn’t hard, but the indent is different.  Especially
                // because some information, the indent between `n` and `l` wasn’t
                // tracked.  Luckily, that space is (should be?) empty, so we can
                // safely check for it now.
                if (previous && indent && previous.indent) {
                    combined = previous.indent;
                    if (n < l) {
                        while(++n < l)combined.push((offset[n] || 0) + 1);
                        combined.push(before.column);
                    }
                    indent = combined.concat(indent);
                }
                node.position.indent = indent || [];
                return node;
            }
        }
        // Add `node` to `parent`s children or to `tokens`.  Performs merges where
        // possible.
        function add(node, parent) {
            var children = parent ? parent.children : tokens;
            var previous = children[children.length - 1];
            var fn;
            if (previous && node.type === previous.type && (node.type === "text" || node.type === "blockquote") && $538971b5b904f078$var$mergeable(previous) && $538971b5b904f078$var$mergeable(node)) {
                fn = node.type === "text" ? $538971b5b904f078$var$mergeText : $538971b5b904f078$var$mergeBlockquote;
                node = fn.call(self, previous, node);
            }
            if (node !== previous) children.push(node);
            if (self.atStart && tokens.length !== 0) self.exitStart();
            return node;
        }
        // Remove `subvalue` from `value`.  `subvalue` must be at the start of
        // `value`.
        function eat(subvalue) {
            var indent = getOffset();
            var pos = position();
            var current = now();
            validateEat(subvalue);
            apply.reset = reset;
            reset.test = test;
            apply.test = test;
            value = value.slice(subvalue.length);
            updatePosition(subvalue);
            indent = indent();
            return apply;
            // Add the given arguments, add `position` to the returned node, and
            // return the node.
            function apply(node, parent) {
                return pos(add(pos(node), parent), indent);
            }
            // Functions just like apply, but resets the content: the line and
            // column are reversed, and the eaten value is re-added.   This is
            // useful for nodes with a single type of content, such as lists and
            // tables.  See `apply` above for what parameters are expected.
            function reset() {
                var node = apply.apply(null, arguments);
                line = current.line;
                column = current.column;
                value = subvalue + value;
                return node;
            }
            // Test the position, after eating, and reverse to a not-eaten state.
            function test() {
                var result = pos({});
                line = current.line;
                column = current.column;
                value = subvalue + value;
                return result.position;
            }
        }
    }
}
// Check whether a node is mergeable with adjacent nodes.
function $538971b5b904f078$var$mergeable(node) {
    var start;
    var end;
    if (node.type !== "text" || !node.position) return true;
    start = node.position.start;
    end = node.position.end;
    // Only merge nodes which occupy the same size as their `value`.
    return start.line !== end.line || end.column - start.column === node.value.length;
}
// Merge two text nodes: `node` into `prev`.
function $538971b5b904f078$var$mergeText(previous, node) {
    previous.value += node.value;
    return previous;
}
// Merge two blockquotes: `node` into `prev`, unless in CommonMark or gfm modes.
function $538971b5b904f078$var$mergeBlockquote(previous, node) {
    if (this.options.commonmark || this.options.gfm) return node;
    previous.children = previous.children.concat(node.children);
    return previous;
}
var $538971b5b904f078$var$markdownEscapes = $538971b5b904f078$var$escapes$1;
var $538971b5b904f078$var$defaults$2 = [
    "\\",
    "`",
    "*",
    "{",
    "}",
    "[",
    "]",
    "(",
    ")",
    "#",
    "+",
    "-",
    ".",
    "!",
    "_",
    ">"
];
var $538971b5b904f078$var$gfm = $538971b5b904f078$var$defaults$2.concat([
    "~",
    "|"
]);
var $538971b5b904f078$var$commonmark = $538971b5b904f078$var$gfm.concat([
    "\n",
    '"',
    "$",
    "%",
    "&",
    "'",
    ",",
    "/",
    ":",
    ";",
    "<",
    "=",
    "?",
    "@",
    "^"
]);
$538971b5b904f078$var$escapes$1.default = $538971b5b904f078$var$defaults$2;
$538971b5b904f078$var$escapes$1.gfm = $538971b5b904f078$var$gfm;
$538971b5b904f078$var$escapes$1.commonmark = $538971b5b904f078$var$commonmark;
// Get markdown escapes.
function $538971b5b904f078$var$escapes$1(options) {
    var settings = options || {};
    if (settings.commonmark) return $538971b5b904f078$var$commonmark;
    return settings.gfm ? $538971b5b904f078$var$gfm : $538971b5b904f078$var$defaults$2;
}
var $538971b5b904f078$var$blockElements = [
    "address",
    "article",
    "aside",
    "base",
    "basefont",
    "blockquote",
    "body",
    "caption",
    "center",
    "col",
    "colgroup",
    "dd",
    "details",
    "dialog",
    "dir",
    "div",
    "dl",
    "dt",
    "fieldset",
    "figcaption",
    "figure",
    "footer",
    "form",
    "frame",
    "frameset",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "head",
    "header",
    "hgroup",
    "hr",
    "html",
    "iframe",
    "legend",
    "li",
    "link",
    "main",
    "menu",
    "menuitem",
    "meta",
    "nav",
    "noframes",
    "ol",
    "optgroup",
    "option",
    "p",
    "param",
    "pre",
    "section",
    "source",
    "title",
    "summary",
    "table",
    "tbody",
    "td",
    "tfoot",
    "th",
    "thead",
    "title",
    "tr",
    "track",
    "ul"
];
var $538971b5b904f078$var$defaults$1 = {
    position: true,
    gfm: true,
    commonmark: false,
    pedantic: false,
    blocks: $538971b5b904f078$var$blockElements
};
var $538971b5b904f078$var$setOptions_1 = $538971b5b904f078$var$setOptions;
function $538971b5b904f078$var$setOptions(options) {
    var self = this;
    var current = self.options;
    var key;
    var value;
    if (options == null) options = {};
    else if (typeof options === "object") options = $538971b5b904f078$var$immutable(options);
    else throw new Error("Invalid value `" + options + "` for setting `options`");
    for(key in $538971b5b904f078$var$defaults$1){
        value = options[key];
        if (value == null) value = current[key];
        if (key !== "blocks" && typeof value !== "boolean" || key === "blocks" && typeof value !== "object") throw new Error("Invalid value `" + value + "` for setting `options." + key + "`");
        options[key] = value;
    }
    self.options = options;
    self.escape = $538971b5b904f078$var$markdownEscapes(options);
    return self;
}
var $538971b5b904f078$var$convert_1 = $538971b5b904f078$var$convert$1;
function $538971b5b904f078$var$convert$1(test) {
    if (test == null) return $538971b5b904f078$var$ok$1;
    if (typeof test === "string") return $538971b5b904f078$var$typeFactory$1(test);
    if (typeof test === "object") return "length" in test ? $538971b5b904f078$var$anyFactory$1(test) : $538971b5b904f078$var$allFactory(test);
    if (typeof test === "function") return test;
    throw new Error("Expected function, string, or object as test");
}
// Utility assert each property in `test` is represented in `node`, and each
// values are strictly equal.
function $538971b5b904f078$var$allFactory(test) {
    return all;
    function all(node) {
        var key;
        for(key in test){
            if (node[key] !== test[key]) return false;
        }
        return true;
    }
}
function $538971b5b904f078$var$anyFactory$1(tests) {
    var checks = [];
    var index = -1;
    while(++index < tests.length)checks[index] = $538971b5b904f078$var$convert$1(tests[index]);
    return any;
    function any() {
        var index = -1;
        while(++index < checks.length){
            if (checks[index].apply(this, arguments)) return true;
        }
        return false;
    }
}
// Utility to convert a string into a function which checks a given node’s type
// for said string.
function $538971b5b904f078$var$typeFactory$1(test) {
    return type;
    function type(node) {
        return Boolean(node && node.type === test);
    }
}
// Utility to return true.
function $538971b5b904f078$var$ok$1() {
    return true;
}
var $538971b5b904f078$var$color_1 = $538971b5b904f078$var$color;
function $538971b5b904f078$var$color(d) {
    return "\x1b[33m" + d + "\x1b[39m";
}
var $538971b5b904f078$var$unistUtilVisitParents = $538971b5b904f078$var$visitParents;
var $538971b5b904f078$var$CONTINUE$1 = true;
var $538971b5b904f078$var$SKIP$1 = "skip";
var $538971b5b904f078$var$EXIT$1 = false;
$538971b5b904f078$var$visitParents.CONTINUE = $538971b5b904f078$var$CONTINUE$1;
$538971b5b904f078$var$visitParents.SKIP = $538971b5b904f078$var$SKIP$1;
$538971b5b904f078$var$visitParents.EXIT = $538971b5b904f078$var$EXIT$1;
function $538971b5b904f078$var$visitParents(tree, test, visitor, reverse) {
    var step;
    var is;
    if (typeof test === "function" && typeof visitor !== "function") {
        reverse = visitor;
        visitor = test;
        test = null;
    }
    is = $538971b5b904f078$var$convert_1(test);
    step = reverse ? -1 : 1;
    factory(tree, null, [])();
    function factory(node, index, parents) {
        var value = typeof node === "object" && node !== null ? node : {};
        var name;
        if (typeof value.type === "string") {
            name = typeof value.tagName === "string" ? value.tagName : typeof value.name === "string" ? value.name : undefined;
            visit.displayName = "node (" + $538971b5b904f078$var$color_1(value.type + (name ? "<" + name + ">" : "")) + ")";
        }
        return visit;
        function visit() {
            var grandparents = parents.concat(node);
            var result = [];
            var subresult;
            var offset;
            if (!test || is(node, index, parents[parents.length - 1] || null)) {
                result = $538971b5b904f078$var$toResult(visitor(node, parents));
                if (result[0] === $538971b5b904f078$var$EXIT$1) return result;
            }
            if (node.children && result[0] !== $538971b5b904f078$var$SKIP$1) {
                offset = (reverse ? node.children.length : -1) + step;
                while(offset > -1 && offset < node.children.length){
                    subresult = factory(node.children[offset], offset, grandparents)();
                    if (subresult[0] === $538971b5b904f078$var$EXIT$1) return subresult;
                    offset = typeof subresult[1] === "number" ? subresult[1] : offset + step;
                }
            }
            return result;
        }
    }
}
function $538971b5b904f078$var$toResult(value) {
    if (value !== null && typeof value === "object" && "length" in value) return value;
    if (typeof value === "number") return [
        $538971b5b904f078$var$CONTINUE$1,
        value
    ];
    return [
        value
    ];
}
var $538971b5b904f078$var$unistUtilVisit = $538971b5b904f078$var$visit;
var $538971b5b904f078$var$CONTINUE = $538971b5b904f078$var$unistUtilVisitParents.CONTINUE;
var $538971b5b904f078$var$SKIP = $538971b5b904f078$var$unistUtilVisitParents.SKIP;
var $538971b5b904f078$var$EXIT = $538971b5b904f078$var$unistUtilVisitParents.EXIT;
$538971b5b904f078$var$visit.CONTINUE = $538971b5b904f078$var$CONTINUE;
$538971b5b904f078$var$visit.SKIP = $538971b5b904f078$var$SKIP;
$538971b5b904f078$var$visit.EXIT = $538971b5b904f078$var$EXIT;
function $538971b5b904f078$var$visit(tree, test, visitor, reverse) {
    if (typeof test === "function" && typeof visitor !== "function") {
        reverse = visitor;
        visitor = test;
        test = null;
    }
    $538971b5b904f078$var$unistUtilVisitParents(tree, test, overload, reverse);
    function overload(node, parents) {
        var parent = parents[parents.length - 1];
        var index = parent ? parent.children.indexOf(node) : null;
        return visitor(node, index, parent);
    }
}
var $538971b5b904f078$var$unistUtilRemovePosition = $538971b5b904f078$var$removePosition;
function $538971b5b904f078$var$removePosition(node, force) {
    $538971b5b904f078$var$unistUtilVisit(node, force ? $538971b5b904f078$var$hard : $538971b5b904f078$var$soft);
    return node;
}
function $538971b5b904f078$var$hard(node) {
    delete node.position;
}
function $538971b5b904f078$var$soft(node) {
    node.position = undefined;
}
var $538971b5b904f078$var$parse_1$2 = $538971b5b904f078$var$parse$6;
var $538971b5b904f078$var$lineFeed$i = "\n";
var $538971b5b904f078$var$lineBreaksExpression = /\r\n|\r/g;
// Parse the bound file.
function $538971b5b904f078$var$parse$6() {
    var self = this;
    var value = String(self.file);
    var start = {
        line: 1,
        column: 1,
        offset: 0
    };
    var content = $538971b5b904f078$var$immutable(start);
    var node;
    // Clean non-unix newlines: `\r\n` and `\r` are all changed to `\n`.
    // This should not affect positional information.
    value = value.replace($538971b5b904f078$var$lineBreaksExpression, $538971b5b904f078$var$lineFeed$i);
    // BOM.
    if (value.charCodeAt(0) === 0xfeff) {
        value = value.slice(1);
        content.column++;
        content.offset++;
    }
    node = {
        type: "root",
        children: self.tokenizeBlock(value, content),
        position: {
            start: start,
            end: self.eof || $538971b5b904f078$var$immutable(start)
        }
    };
    if (!self.options.position) $538971b5b904f078$var$unistUtilRemovePosition(node, true);
    return node;
}
// A line containing no characters, or a line containing only spaces (U+0020) or
// tabs (U+0009), is called a blank line.
// See <https://spec.commonmark.org/0.29/#blank-line>.
var $538971b5b904f078$var$reBlankLine = /^[ \t]*(\n|$)/;
// Note that though blank lines play a special role in lists to determine
// whether the list is tight or loose
// (<https://spec.commonmark.org/0.29/#blank-lines>), it’s done by the list
// tokenizer and this blank line tokenizer does not have to be responsible for
// that.
// Therefore, configs such as `blankLine.notInList` do not have to be set here.
var $538971b5b904f078$var$blankLine_1 = $538971b5b904f078$var$blankLine;
function $538971b5b904f078$var$blankLine(eat, value, silent) {
    var match;
    var subvalue = "";
    var index = 0;
    var length = value.length;
    while(index < length){
        match = $538971b5b904f078$var$reBlankLine.exec(value.slice(index));
        if (match == null) break;
        index += match[0].length;
        subvalue += match[0];
    }
    if (subvalue === "") return;
    /* istanbul ignore if - never used (yet) */ if (silent) return true;
    eat(subvalue);
}
/*!
 * repeat-string <https://github.com/jonschlinkert/repeat-string>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */ /**
 * Results cache
 */ var $538971b5b904f078$var$res = "";
var $538971b5b904f078$var$cache;
/**
 * Expose `repeat`
 */ var $538971b5b904f078$var$repeatString = $538971b5b904f078$var$repeat$1;
/**
 * Repeat the given `string` the specified `number`
 * of times.
 *
 * **Example:**
 *
 * ```js
 * var repeat = require('repeat-string');
 * repeat('A', 5);
 * //=> AAAAA
 * ```
 *
 * @param {String} `string` The string to repeat
 * @param {Number} `number` The number of times to repeat the string
 * @return {String} Repeated string
 * @api public
 */ function $538971b5b904f078$var$repeat$1(str, num) {
    if (typeof str !== "string") throw new TypeError("expected a string");
    // cover common, quick use cases
    if (num === 1) return str;
    if (num === 2) return str + str;
    var max = str.length * num;
    if ($538971b5b904f078$var$cache !== str || typeof $538971b5b904f078$var$cache === "undefined") {
        $538971b5b904f078$var$cache = str;
        $538971b5b904f078$var$res = "";
    } else if ($538971b5b904f078$var$res.length >= max) return $538971b5b904f078$var$res.substr(0, max);
    while(max > $538971b5b904f078$var$res.length && num > 1){
        if (num & 1) $538971b5b904f078$var$res += str;
        num >>= 1;
        str += str;
    }
    $538971b5b904f078$var$res += str;
    $538971b5b904f078$var$res = $538971b5b904f078$var$res.substr(0, max);
    return $538971b5b904f078$var$res;
}
var $538971b5b904f078$var$trimTrailingLines_1 = $538971b5b904f078$var$trimTrailingLines;
var $538971b5b904f078$var$line = "\n";
// Remove final newline characters from `value`.
function $538971b5b904f078$var$trimTrailingLines(value) {
    var val = String(value);
    var index = val.length;
    while(val.charAt(--index) === $538971b5b904f078$var$line);
    return val.slice(0, index + 1);
}
var $538971b5b904f078$var$codeIndented = $538971b5b904f078$var$indentedCode$1;
var $538971b5b904f078$var$lineFeed$h = "\n";
var $538971b5b904f078$var$tab$d = "	";
var $538971b5b904f078$var$space$i = " ";
var $538971b5b904f078$var$tabSize$4 = 4;
var $538971b5b904f078$var$codeIndent = $538971b5b904f078$var$repeatString($538971b5b904f078$var$space$i, $538971b5b904f078$var$tabSize$4);
function $538971b5b904f078$var$indentedCode$1(eat, value, silent) {
    var index = -1;
    var length = value.length;
    var subvalue = "";
    var content = "";
    var subvalueQueue = "";
    var contentQueue = "";
    var character;
    var blankQueue;
    var indent;
    while(++index < length){
        character = value.charAt(index);
        if (indent) {
            indent = false;
            subvalue += subvalueQueue;
            content += contentQueue;
            subvalueQueue = "";
            contentQueue = "";
            if (character === $538971b5b904f078$var$lineFeed$h) {
                subvalueQueue = character;
                contentQueue = character;
            } else {
                subvalue += character;
                content += character;
                while(++index < length){
                    character = value.charAt(index);
                    if (!character || character === $538971b5b904f078$var$lineFeed$h) {
                        contentQueue = character;
                        subvalueQueue = character;
                        break;
                    }
                    subvalue += character;
                    content += character;
                }
            }
        } else if (character === $538971b5b904f078$var$space$i && value.charAt(index + 1) === character && value.charAt(index + 2) === character && value.charAt(index + 3) === character) {
            subvalueQueue += $538971b5b904f078$var$codeIndent;
            index += 3;
            indent = true;
        } else if (character === $538971b5b904f078$var$tab$d) {
            subvalueQueue += character;
            indent = true;
        } else {
            blankQueue = "";
            while(character === $538971b5b904f078$var$tab$d || character === $538971b5b904f078$var$space$i){
                blankQueue += character;
                character = value.charAt(++index);
            }
            if (character !== $538971b5b904f078$var$lineFeed$h) break;
            subvalueQueue += blankQueue + character;
            contentQueue += character;
        }
    }
    if (content) {
        if (silent) return true;
        return eat(subvalue)({
            type: "code",
            lang: null,
            meta: null,
            value: $538971b5b904f078$var$trimTrailingLines_1(content)
        });
    }
}
var $538971b5b904f078$var$codeFenced = $538971b5b904f078$var$fencedCode;
var $538971b5b904f078$var$lineFeed$g = "\n";
var $538971b5b904f078$var$tab$c = "	";
var $538971b5b904f078$var$space$h = " ";
var $538971b5b904f078$var$tilde$3 = "~";
var $538971b5b904f078$var$graveAccent$2 = "`";
var $538971b5b904f078$var$minFenceCount = 3;
var $538971b5b904f078$var$tabSize$3 = 4;
function $538971b5b904f078$var$fencedCode(eat, value, silent) {
    var self = this;
    var gfm = self.options.gfm;
    var length = value.length + 1;
    var index = 0;
    var subvalue = "";
    var fenceCount;
    var marker;
    var character;
    var flag;
    var lang;
    var meta;
    var queue;
    var content;
    var exdentedContent;
    var closing;
    var exdentedClosing;
    var indent;
    var now;
    if (!gfm) return;
    // Eat initial spacing.
    while(index < length){
        character = value.charAt(index);
        if (character !== $538971b5b904f078$var$space$h && character !== $538971b5b904f078$var$tab$c) break;
        subvalue += character;
        index++;
    }
    indent = index;
    // Eat the fence.
    character = value.charAt(index);
    if (character !== $538971b5b904f078$var$tilde$3 && character !== $538971b5b904f078$var$graveAccent$2) return;
    index++;
    marker = character;
    fenceCount = 1;
    subvalue += character;
    while(index < length){
        character = value.charAt(index);
        if (character !== marker) break;
        subvalue += character;
        fenceCount++;
        index++;
    }
    if (fenceCount < $538971b5b904f078$var$minFenceCount) return;
    // Eat spacing before flag.
    while(index < length){
        character = value.charAt(index);
        if (character !== $538971b5b904f078$var$space$h && character !== $538971b5b904f078$var$tab$c) break;
        subvalue += character;
        index++;
    }
    // Eat flag.
    flag = "";
    queue = "";
    while(index < length){
        character = value.charAt(index);
        if (character === $538971b5b904f078$var$lineFeed$g || marker === $538971b5b904f078$var$graveAccent$2 && character === marker) break;
        if (character === $538971b5b904f078$var$space$h || character === $538971b5b904f078$var$tab$c) queue += character;
        else {
            flag += queue + character;
            queue = "";
        }
        index++;
    }
    character = value.charAt(index);
    if (character && character !== $538971b5b904f078$var$lineFeed$g) return;
    if (silent) return true;
    now = eat.now();
    now.column += subvalue.length;
    now.offset += subvalue.length;
    subvalue += flag;
    flag = self.decode.raw(self.unescape(flag), now);
    if (queue) subvalue += queue;
    queue = "";
    closing = "";
    exdentedClosing = "";
    content = "";
    exdentedContent = "";
    var skip = true;
    // Eat content.
    while(index < length){
        character = value.charAt(index);
        content += closing;
        exdentedContent += exdentedClosing;
        closing = "";
        exdentedClosing = "";
        if (character !== $538971b5b904f078$var$lineFeed$g) {
            content += character;
            exdentedClosing += character;
            index++;
            continue;
        }
        // The first line feed is ignored. Others aren’t.
        if (skip) {
            subvalue += character;
            skip = false;
        } else {
            closing += character;
            exdentedClosing += character;
        }
        queue = "";
        index++;
        while(index < length){
            character = value.charAt(index);
            if (character !== $538971b5b904f078$var$space$h) break;
            queue += character;
            index++;
        }
        closing += queue;
        exdentedClosing += queue.slice(indent);
        if (queue.length >= $538971b5b904f078$var$tabSize$3) continue;
        queue = "";
        while(index < length){
            character = value.charAt(index);
            if (character !== marker) break;
            queue += character;
            index++;
        }
        closing += queue;
        exdentedClosing += queue;
        if (queue.length < fenceCount) continue;
        queue = "";
        while(index < length){
            character = value.charAt(index);
            if (character !== $538971b5b904f078$var$space$h && character !== $538971b5b904f078$var$tab$c) break;
            closing += character;
            exdentedClosing += character;
            index++;
        }
        if (!character || character === $538971b5b904f078$var$lineFeed$g) break;
    }
    subvalue += content + closing;
    // Get lang and meta from the flag.
    index = -1;
    length = flag.length;
    while(++index < length){
        character = flag.charAt(index);
        if (character === $538971b5b904f078$var$space$h || character === $538971b5b904f078$var$tab$c) {
            if (!lang) lang = flag.slice(0, index);
        } else if (lang) {
            meta = flag.slice(index);
            break;
        }
    }
    return eat(subvalue)({
        type: "code",
        lang: lang || flag || null,
        meta: meta || null,
        value: exdentedContent
    });
}
var $538971b5b904f078$var$trim_1 = $538971b5b904f078$var$createCommonjsModule(function(module, exports) {
    exports = module.exports = trim;
    function trim(str) {
        return str.replace(/^\s*|\s*$/g, "");
    }
    exports.left = function(str) {
        return str.replace(/^\s*/, "");
    };
    exports.right = function(str) {
        return str.replace(/\s*$/, "");
    };
});
$538971b5b904f078$var$trim_1.left;
$538971b5b904f078$var$trim_1.right;
var $538971b5b904f078$var$interrupt_1 = $538971b5b904f078$var$interrupt;
function $538971b5b904f078$var$interrupt(interruptors, tokenizers, ctx, parameters) {
    var length = interruptors.length;
    var index = -1;
    var interruptor;
    var config;
    while(++index < length){
        interruptor = interruptors[index];
        config = interruptor[1] || {};
        if (config.pedantic !== undefined && config.pedantic !== ctx.options.pedantic) continue;
        if (config.commonmark !== undefined && config.commonmark !== ctx.options.commonmark) continue;
        if (tokenizers[interruptor[0]].apply(ctx, parameters)) return true;
    }
    return false;
}
var $538971b5b904f078$var$blockquote_1$1 = $538971b5b904f078$var$blockquote$1;
var $538971b5b904f078$var$lineFeed$f = "\n";
var $538971b5b904f078$var$tab$b = "	";
var $538971b5b904f078$var$space$g = " ";
var $538971b5b904f078$var$greaterThan$4 = ">";
function $538971b5b904f078$var$blockquote$1(eat, value, silent) {
    var self = this;
    var offsets = self.offset;
    var tokenizers = self.blockTokenizers;
    var interruptors = self.interruptBlockquote;
    var now = eat.now();
    var currentLine = now.line;
    var length = value.length;
    var values = [];
    var contents = [];
    var indents = [];
    var add;
    var index = 0;
    var character;
    var rest;
    var nextIndex;
    var content;
    var line;
    var startIndex;
    var prefixed;
    var exit;
    while(index < length){
        character = value.charAt(index);
        if (character !== $538971b5b904f078$var$space$g && character !== $538971b5b904f078$var$tab$b) break;
        index++;
    }
    if (value.charAt(index) !== $538971b5b904f078$var$greaterThan$4) return;
    if (silent) return true;
    index = 0;
    while(index < length){
        nextIndex = value.indexOf($538971b5b904f078$var$lineFeed$f, index);
        startIndex = index;
        prefixed = false;
        if (nextIndex === -1) nextIndex = length;
        while(index < length){
            character = value.charAt(index);
            if (character !== $538971b5b904f078$var$space$g && character !== $538971b5b904f078$var$tab$b) break;
            index++;
        }
        if (value.charAt(index) === $538971b5b904f078$var$greaterThan$4) {
            index++;
            prefixed = true;
            if (value.charAt(index) === $538971b5b904f078$var$space$g) index++;
        } else index = startIndex;
        content = value.slice(index, nextIndex);
        if (!prefixed && !$538971b5b904f078$var$trim_1(content)) {
            index = startIndex;
            break;
        }
        if (!prefixed) {
            rest = value.slice(index);
            // Check if the following code contains a possible block.
            if ($538971b5b904f078$var$interrupt_1(interruptors, tokenizers, self, [
                eat,
                rest,
                true
            ])) break;
        }
        line = startIndex === index ? content : value.slice(startIndex, nextIndex);
        indents.push(index - startIndex);
        values.push(line);
        contents.push(content);
        index = nextIndex + 1;
    }
    index = -1;
    length = indents.length;
    add = eat(values.join($538971b5b904f078$var$lineFeed$f));
    while(++index < length){
        offsets[currentLine] = (offsets[currentLine] || 0) + indents[index];
        currentLine++;
    }
    exit = self.enterBlock();
    contents = self.tokenizeBlock(contents.join($538971b5b904f078$var$lineFeed$f), now);
    exit();
    return add({
        type: "blockquote",
        children: contents
    });
}
var $538971b5b904f078$var$headingAtx = $538971b5b904f078$var$atxHeading;
var $538971b5b904f078$var$lineFeed$e = "\n";
var $538971b5b904f078$var$tab$a = "	";
var $538971b5b904f078$var$space$f = " ";
var $538971b5b904f078$var$numberSign = "#";
var $538971b5b904f078$var$maxFenceCount = 6;
function $538971b5b904f078$var$atxHeading(eat, value, silent) {
    var self = this;
    var pedantic = self.options.pedantic;
    var length = value.length + 1;
    var index = -1;
    var now = eat.now();
    var subvalue = "";
    var content = "";
    var character;
    var queue;
    var depth;
    // Eat initial spacing.
    while(++index < length){
        character = value.charAt(index);
        if (character !== $538971b5b904f078$var$space$f && character !== $538971b5b904f078$var$tab$a) {
            index--;
            break;
        }
        subvalue += character;
    }
    // Eat hashes.
    depth = 0;
    while(++index <= length){
        character = value.charAt(index);
        if (character !== $538971b5b904f078$var$numberSign) {
            index--;
            break;
        }
        subvalue += character;
        depth++;
    }
    if (depth > $538971b5b904f078$var$maxFenceCount) return;
    if (!depth || !pedantic && value.charAt(index + 1) === $538971b5b904f078$var$numberSign) return;
    length = value.length + 1;
    // Eat intermediate white-space.
    queue = "";
    while(++index < length){
        character = value.charAt(index);
        if (character !== $538971b5b904f078$var$space$f && character !== $538971b5b904f078$var$tab$a) {
            index--;
            break;
        }
        queue += character;
    }
    // Exit when not in pedantic mode without spacing.
    if (!pedantic && queue.length === 0 && character && character !== $538971b5b904f078$var$lineFeed$e) return;
    if (silent) return true;
    // Eat content.
    subvalue += queue;
    queue = "";
    content = "";
    while(++index < length){
        character = value.charAt(index);
        if (!character || character === $538971b5b904f078$var$lineFeed$e) break;
        if (character !== $538971b5b904f078$var$space$f && character !== $538971b5b904f078$var$tab$a && character !== $538971b5b904f078$var$numberSign) {
            content += queue + character;
            queue = "";
            continue;
        }
        while(character === $538971b5b904f078$var$space$f || character === $538971b5b904f078$var$tab$a){
            queue += character;
            character = value.charAt(++index);
        }
        // `#` without a queue is part of the content.
        if (!pedantic && content && !queue && character === $538971b5b904f078$var$numberSign) {
            content += character;
            continue;
        }
        while(character === $538971b5b904f078$var$numberSign){
            queue += character;
            character = value.charAt(++index);
        }
        while(character === $538971b5b904f078$var$space$f || character === $538971b5b904f078$var$tab$a){
            queue += character;
            character = value.charAt(++index);
        }
        index--;
    }
    now.column += subvalue.length;
    now.offset += subvalue.length;
    subvalue += content + queue;
    return eat(subvalue)({
        type: "heading",
        depth: depth,
        children: self.tokenizeInline(content, now)
    });
}
var $538971b5b904f078$var$thematicBreak_1$1 = $538971b5b904f078$var$thematicBreak$1;
var $538971b5b904f078$var$tab$9 = "	";
var $538971b5b904f078$var$lineFeed$d = "\n";
var $538971b5b904f078$var$space$e = " ";
var $538971b5b904f078$var$asterisk$4 = "*";
var $538971b5b904f078$var$dash$7 = "-";
var $538971b5b904f078$var$underscore$6 = "_";
var $538971b5b904f078$var$maxCount = 3;
function $538971b5b904f078$var$thematicBreak$1(eat, value, silent) {
    var index = -1;
    var length = value.length + 1;
    var subvalue = "";
    var character;
    var marker;
    var markerCount;
    var queue;
    while(++index < length){
        character = value.charAt(index);
        if (character !== $538971b5b904f078$var$tab$9 && character !== $538971b5b904f078$var$space$e) break;
        subvalue += character;
    }
    if (character !== $538971b5b904f078$var$asterisk$4 && character !== $538971b5b904f078$var$dash$7 && character !== $538971b5b904f078$var$underscore$6) return;
    marker = character;
    subvalue += character;
    markerCount = 1;
    queue = "";
    while(++index < length){
        character = value.charAt(index);
        if (character === marker) {
            markerCount++;
            subvalue += queue + marker;
            queue = "";
        } else if (character === $538971b5b904f078$var$space$e) queue += character;
        else if (markerCount >= $538971b5b904f078$var$maxCount && (!character || character === $538971b5b904f078$var$lineFeed$d)) {
            subvalue += queue;
            if (silent) return true;
            return eat(subvalue)({
                type: "thematicBreak"
            });
        } else return;
    }
}
var $538971b5b904f078$var$getIndentation = $538971b5b904f078$var$indentation$1;
var $538971b5b904f078$var$tab$8 = "	";
var $538971b5b904f078$var$space$d = " ";
var $538971b5b904f078$var$spaceSize = 1;
var $538971b5b904f078$var$tabSize$2 = 4;
// Gets indentation information for a line.
function $538971b5b904f078$var$indentation$1(value) {
    var index = 0;
    var indent = 0;
    var character = value.charAt(index);
    var stops = {};
    var size;
    var lastIndent = 0;
    while(character === $538971b5b904f078$var$tab$8 || character === $538971b5b904f078$var$space$d){
        size = character === $538971b5b904f078$var$tab$8 ? $538971b5b904f078$var$tabSize$2 : $538971b5b904f078$var$spaceSize;
        indent += size;
        if (size > 1) indent = Math.floor(indent / size) * size;
        while(lastIndent < indent)stops[++lastIndent] = index;
        character = value.charAt(++index);
    }
    return {
        indent: indent,
        stops: stops
    };
}
var $538971b5b904f078$var$removeIndentation = $538971b5b904f078$var$indentation;
var $538971b5b904f078$var$lineFeed$c = "\n";
var $538971b5b904f078$var$space$c = " ";
var $538971b5b904f078$var$exclamationMark$4 = "!";
// Remove the minimum indent from every line in `value`.  Supports both tab,
// spaced, and mixed indentation (as well as possible).
function $538971b5b904f078$var$indentation(value, maximum) {
    var values = value.split($538971b5b904f078$var$lineFeed$c);
    var position = values.length + 1;
    var minIndent = Infinity;
    var matrix = [];
    var index;
    var indentation;
    var stops;
    values.unshift($538971b5b904f078$var$repeatString($538971b5b904f078$var$space$c, maximum) + $538971b5b904f078$var$exclamationMark$4);
    while(position--){
        indentation = $538971b5b904f078$var$getIndentation(values[position]);
        matrix[position] = indentation.stops;
        if ($538971b5b904f078$var$trim_1(values[position]).length === 0) continue;
        if (indentation.indent) {
            if (indentation.indent > 0 && indentation.indent < minIndent) minIndent = indentation.indent;
        } else {
            minIndent = Infinity;
            break;
        }
    }
    if (minIndent !== Infinity) {
        position = values.length;
        while(position--){
            stops = matrix[position];
            index = minIndent;
            while(index && !(index in stops))index--;
            values[position] = values[position].slice(stops[index] + 1);
        }
    }
    values.shift();
    return values.join($538971b5b904f078$var$lineFeed$c);
}
var $538971b5b904f078$var$list_1$1 = $538971b5b904f078$var$list$1;
var $538971b5b904f078$var$asterisk$3 = "*";
var $538971b5b904f078$var$underscore$5 = "_";
var $538971b5b904f078$var$plusSign$2 = "+";
var $538971b5b904f078$var$dash$6 = "-";
var $538971b5b904f078$var$dot$3 = ".";
var $538971b5b904f078$var$space$b = " ";
var $538971b5b904f078$var$lineFeed$b = "\n";
var $538971b5b904f078$var$tab$7 = "	";
var $538971b5b904f078$var$rightParenthesis$3 = ")";
var $538971b5b904f078$var$lowercaseX = "x";
var $538971b5b904f078$var$tabSize$1 = 4;
var $538971b5b904f078$var$looseListItemExpression = /\n\n(?!\s*$)/;
var $538971b5b904f078$var$taskItemExpression = /^\[([ X\tx])][ \t]/;
var $538971b5b904f078$var$bulletExpression = /^([ \t]*)([*+-]|\d+[.)])( {1,4}(?! )| |\t|$|(?=\n))([^\n]*)/;
var $538971b5b904f078$var$pedanticBulletExpression = /^([ \t]*)([*+-]|\d+[.)])([ \t]+)/;
var $538971b5b904f078$var$initialIndentExpression = /^( {1,4}|\t)?/gm;
function $538971b5b904f078$var$list$1(eat, value, silent) {
    var self = this;
    var commonmark = self.options.commonmark;
    var pedantic = self.options.pedantic;
    var tokenizers = self.blockTokenizers;
    var interuptors = self.interruptList;
    var index = 0;
    var length = value.length;
    var start = null;
    var size;
    var queue;
    var ordered;
    var character;
    var marker;
    var nextIndex;
    var startIndex;
    var prefixed;
    var currentMarker;
    var content;
    var line;
    var previousEmpty;
    var empty;
    var items;
    var allLines;
    var emptyLines;
    var item;
    var enterTop;
    var exitBlockquote;
    var spread = false;
    var node;
    var now;
    var end;
    var indented;
    while(index < length){
        character = value.charAt(index);
        if (character !== $538971b5b904f078$var$tab$7 && character !== $538971b5b904f078$var$space$b) break;
        index++;
    }
    character = value.charAt(index);
    if (character === $538971b5b904f078$var$asterisk$3 || character === $538971b5b904f078$var$plusSign$2 || character === $538971b5b904f078$var$dash$6) {
        marker = character;
        ordered = false;
    } else {
        ordered = true;
        queue = "";
        while(index < length){
            character = value.charAt(index);
            if (!$538971b5b904f078$var$isDecimal(character)) break;
            queue += character;
            index++;
        }
        character = value.charAt(index);
        if (!queue || !(character === $538971b5b904f078$var$dot$3 || commonmark && character === $538971b5b904f078$var$rightParenthesis$3)) return;
        /* Slightly abusing `silent` mode, whose goal is to make interrupting
     * paragraphs work.
     * Well, that’s exactly what we want to do here: don’t interrupt:
     * 2. here, because the “list” doesn’t start with `1`. */ if (silent && queue !== "1") return;
        start = parseInt(queue, 10);
        marker = character;
    }
    character = value.charAt(++index);
    if (character !== $538971b5b904f078$var$space$b && character !== $538971b5b904f078$var$tab$7 && (pedantic || character !== $538971b5b904f078$var$lineFeed$b && character !== "")) return;
    if (silent) return true;
    index = 0;
    items = [];
    allLines = [];
    emptyLines = [];
    while(index < length){
        nextIndex = value.indexOf($538971b5b904f078$var$lineFeed$b, index);
        startIndex = index;
        prefixed = false;
        indented = false;
        if (nextIndex === -1) nextIndex = length;
        size = 0;
        while(index < length){
            character = value.charAt(index);
            if (character === $538971b5b904f078$var$tab$7) size += $538971b5b904f078$var$tabSize$1 - size % $538971b5b904f078$var$tabSize$1;
            else if (character === $538971b5b904f078$var$space$b) size++;
            else break;
            index++;
        }
        if (item && size >= item.indent) indented = true;
        character = value.charAt(index);
        currentMarker = null;
        if (!indented) {
            if (character === $538971b5b904f078$var$asterisk$3 || character === $538971b5b904f078$var$plusSign$2 || character === $538971b5b904f078$var$dash$6) {
                currentMarker = character;
                index++;
                size++;
            } else {
                queue = "";
                while(index < length){
                    character = value.charAt(index);
                    if (!$538971b5b904f078$var$isDecimal(character)) break;
                    queue += character;
                    index++;
                }
                character = value.charAt(index);
                index++;
                if (queue && (character === $538971b5b904f078$var$dot$3 || commonmark && character === $538971b5b904f078$var$rightParenthesis$3)) {
                    currentMarker = character;
                    size += queue.length + 1;
                }
            }
            if (currentMarker) {
                character = value.charAt(index);
                if (character === $538971b5b904f078$var$tab$7) {
                    size += $538971b5b904f078$var$tabSize$1 - size % $538971b5b904f078$var$tabSize$1;
                    index++;
                } else if (character === $538971b5b904f078$var$space$b) {
                    end = index + $538971b5b904f078$var$tabSize$1;
                    while(index < end){
                        if (value.charAt(index) !== $538971b5b904f078$var$space$b) break;
                        index++;
                        size++;
                    }
                    if (index === end && value.charAt(index) === $538971b5b904f078$var$space$b) {
                        index -= $538971b5b904f078$var$tabSize$1 - 1;
                        size -= $538971b5b904f078$var$tabSize$1 - 1;
                    }
                } else if (character !== $538971b5b904f078$var$lineFeed$b && character !== "") currentMarker = null;
            }
        }
        if (currentMarker) {
            if (!pedantic && marker !== currentMarker) break;
            prefixed = true;
        } else {
            if (!commonmark && !indented && value.charAt(startIndex) === $538971b5b904f078$var$space$b) indented = true;
            else if (commonmark && item) indented = size >= item.indent || size > $538971b5b904f078$var$tabSize$1;
            prefixed = false;
            index = startIndex;
        }
        line = value.slice(startIndex, nextIndex);
        content = startIndex === index ? line : value.slice(index, nextIndex);
        if (currentMarker === $538971b5b904f078$var$asterisk$3 || currentMarker === $538971b5b904f078$var$underscore$5 || currentMarker === $538971b5b904f078$var$dash$6) {
            if (tokenizers.thematicBreak.call(self, eat, line, true)) break;
        }
        previousEmpty = empty;
        empty = !prefixed && !$538971b5b904f078$var$trim_1(content).length;
        if (indented && item) {
            item.value = item.value.concat(emptyLines, line);
            allLines = allLines.concat(emptyLines, line);
            emptyLines = [];
        } else if (prefixed) {
            if (emptyLines.length !== 0) {
                spread = true;
                item.value.push("");
                item.trail = emptyLines.concat();
            }
            item = {
                value: [
                    line
                ],
                indent: size,
                trail: []
            };
            items.push(item);
            allLines = allLines.concat(emptyLines, line);
            emptyLines = [];
        } else if (empty) {
            if (previousEmpty && !commonmark) break;
            emptyLines.push(line);
        } else {
            if (previousEmpty) break;
            if ($538971b5b904f078$var$interrupt_1(interuptors, tokenizers, self, [
                eat,
                line,
                true
            ])) break;
            item.value = item.value.concat(emptyLines, line);
            allLines = allLines.concat(emptyLines, line);
            emptyLines = [];
        }
        index = nextIndex + 1;
    }
    node = eat(allLines.join($538971b5b904f078$var$lineFeed$b)).reset({
        type: "list",
        ordered: ordered,
        start: start,
        spread: spread,
        children: []
    });
    enterTop = self.enterList();
    exitBlockquote = self.enterBlock();
    index = -1;
    length = items.length;
    while(++index < length){
        item = items[index].value.join($538971b5b904f078$var$lineFeed$b);
        now = eat.now();
        eat(item)($538971b5b904f078$var$listItem$2(self, item, now), node);
        item = items[index].trail.join($538971b5b904f078$var$lineFeed$b);
        if (index !== length - 1) item += $538971b5b904f078$var$lineFeed$b;
        eat(item);
    }
    enterTop();
    exitBlockquote();
    return node;
}
function $538971b5b904f078$var$listItem$2(ctx, value, position) {
    var offsets = ctx.offset;
    var fn = ctx.options.pedantic ? $538971b5b904f078$var$pedanticListItem : $538971b5b904f078$var$normalListItem;
    var checked = null;
    var task;
    var indent;
    value = fn.apply(null, arguments);
    if (ctx.options.gfm) {
        task = value.match($538971b5b904f078$var$taskItemExpression);
        if (task) {
            indent = task[0].length;
            checked = task[1].toLowerCase() === $538971b5b904f078$var$lowercaseX;
            offsets[position.line] += indent;
            value = value.slice(indent);
        }
    }
    return {
        type: "listItem",
        spread: $538971b5b904f078$var$looseListItemExpression.test(value),
        checked: checked,
        children: ctx.tokenizeBlock(value, position)
    };
}
// Create a list-item using overly simple mechanics.
function $538971b5b904f078$var$pedanticListItem(ctx, value, position) {
    var offsets = ctx.offset;
    var line = position.line;
    // Remove the list-item’s bullet.
    value = value.replace($538971b5b904f078$var$pedanticBulletExpression, replacer);
    // The initial line was also matched by the below, so we reset the `line`.
    line = position.line;
    return value.replace($538971b5b904f078$var$initialIndentExpression, replacer);
    // A simple replacer which removed all matches, and adds their length to
    // `offset`.
    function replacer($0) {
        offsets[line] = (offsets[line] || 0) + $0.length;
        line++;
        return "";
    }
}
// Create a list-item using sane mechanics.
function $538971b5b904f078$var$normalListItem(ctx, value, position) {
    var offsets = ctx.offset;
    var line = position.line;
    var max;
    var bullet;
    var rest;
    var lines;
    var trimmedLines;
    var index;
    var length;
    // Remove the list-item’s bullet.
    value = value.replace($538971b5b904f078$var$bulletExpression, replacer);
    lines = value.split($538971b5b904f078$var$lineFeed$b);
    trimmedLines = $538971b5b904f078$var$removeIndentation(value, $538971b5b904f078$var$getIndentation(max).indent).split($538971b5b904f078$var$lineFeed$b);
    // We replaced the initial bullet with something else above, which was used
    // to trick `removeIndentation` into removing some more characters when
    // possible.  However, that could result in the initial line to be stripped
    // more than it should be.
    trimmedLines[0] = rest;
    offsets[line] = (offsets[line] || 0) + bullet.length;
    line++;
    index = 0;
    length = lines.length;
    while(++index < length){
        offsets[line] = (offsets[line] || 0) + lines[index].length - trimmedLines[index].length;
        line++;
    }
    return trimmedLines.join($538971b5b904f078$var$lineFeed$b);
    /* eslint-disable-next-line max-params */ function replacer($0, $1, $2, $3, $4) {
        bullet = $1 + $2 + $3;
        rest = $4;
        // Make sure that the first nine numbered list items can indent with an
        // extra space.  That is, when the bullet did not receive an extra final
        // space.
        if (Number($2) < 10 && bullet.length % 2 === 1) $2 = $538971b5b904f078$var$space$b + $2;
        max = $1 + $538971b5b904f078$var$repeatString($538971b5b904f078$var$space$b, $2.length) + $3;
        return max + rest;
    }
}
var $538971b5b904f078$var$headingSetext = $538971b5b904f078$var$setextHeading;
var $538971b5b904f078$var$lineFeed$a = "\n";
var $538971b5b904f078$var$tab$6 = "	";
var $538971b5b904f078$var$space$a = " ";
var $538971b5b904f078$var$equalsTo$1 = "=";
var $538971b5b904f078$var$dash$5 = "-";
var $538971b5b904f078$var$maxIndent = 3;
var $538971b5b904f078$var$equalsToDepth = 1;
var $538971b5b904f078$var$dashDepth = 2;
function $538971b5b904f078$var$setextHeading(eat, value, silent) {
    var self = this;
    var now = eat.now();
    var length = value.length;
    var index = -1;
    var subvalue = "";
    var content;
    var queue;
    var character;
    var marker;
    var depth;
    // Eat initial indentation.
    while(++index < length){
        character = value.charAt(index);
        if (character !== $538971b5b904f078$var$space$a || index >= $538971b5b904f078$var$maxIndent) {
            index--;
            break;
        }
        subvalue += character;
    }
    // Eat content.
    content = "";
    queue = "";
    while(++index < length){
        character = value.charAt(index);
        if (character === $538971b5b904f078$var$lineFeed$a) {
            index--;
            break;
        }
        if (character === $538971b5b904f078$var$space$a || character === $538971b5b904f078$var$tab$6) queue += character;
        else {
            content += queue + character;
            queue = "";
        }
    }
    now.column += subvalue.length;
    now.offset += subvalue.length;
    subvalue += content + queue;
    // Ensure the content is followed by a newline and a valid marker.
    character = value.charAt(++index);
    marker = value.charAt(++index);
    if (character !== $538971b5b904f078$var$lineFeed$a || marker !== $538971b5b904f078$var$equalsTo$1 && marker !== $538971b5b904f078$var$dash$5) return;
    subvalue += character;
    // Eat Setext-line.
    queue = marker;
    depth = marker === $538971b5b904f078$var$equalsTo$1 ? $538971b5b904f078$var$equalsToDepth : $538971b5b904f078$var$dashDepth;
    while(++index < length){
        character = value.charAt(index);
        if (character !== marker) {
            if (character !== $538971b5b904f078$var$lineFeed$a) return;
            index--;
            break;
        }
        queue += character;
    }
    if (silent) return true;
    return eat(subvalue + queue)({
        type: "heading",
        depth: depth,
        children: self.tokenizeInline(content, now)
    });
}
var $538971b5b904f078$var$attributeName$2 = "[a-zA-Z_:][a-zA-Z0-9:._-]*";
var $538971b5b904f078$var$unquoted$2 = "[^\"'=<>`\\u0000-\\u0020]+";
var $538971b5b904f078$var$singleQuoted$2 = "'[^']*'";
var $538971b5b904f078$var$doubleQuoted$2 = '"[^"]*"';
var $538971b5b904f078$var$attributeValue$2 = "(?:" + $538971b5b904f078$var$unquoted$2 + "|" + $538971b5b904f078$var$singleQuoted$2 + "|" + $538971b5b904f078$var$doubleQuoted$2 + ")";
var $538971b5b904f078$var$attribute$2 = "(?:\\s+" + $538971b5b904f078$var$attributeName$2 + "(?:\\s*=\\s*" + $538971b5b904f078$var$attributeValue$2 + ")?)";
var $538971b5b904f078$var$openTag$1 = "<[A-Za-z][A-Za-z0-9\\-]*" + $538971b5b904f078$var$attribute$2 + "*\\s*\\/?>";
var $538971b5b904f078$var$closeTag$1 = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>";
var $538971b5b904f078$var$comment$1 = "<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->";
var $538971b5b904f078$var$processing = "<[?].*?[?]>";
var $538971b5b904f078$var$declaration = "<![A-Za-z]+\\s+[^>]*>";
var $538971b5b904f078$var$cdata = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>";
var $538971b5b904f078$var$openCloseTag$2 = new RegExp("^(?:" + $538971b5b904f078$var$openTag$1 + "|" + $538971b5b904f078$var$closeTag$1 + ")");
var $538971b5b904f078$var$tag$2 = new RegExp("^(?:" + $538971b5b904f078$var$openTag$1 + "|" + $538971b5b904f078$var$closeTag$1 + "|" + $538971b5b904f078$var$comment$1 + "|" + $538971b5b904f078$var$processing + "|" + $538971b5b904f078$var$declaration + "|" + $538971b5b904f078$var$cdata + ")");
var $538971b5b904f078$var$html$4 = {
    openCloseTag: $538971b5b904f078$var$openCloseTag$2,
    tag: $538971b5b904f078$var$tag$2
};
var $538971b5b904f078$var$openCloseTag$1 = $538971b5b904f078$var$html$4.openCloseTag;
var $538971b5b904f078$var$htmlBlock = $538971b5b904f078$var$blockHtml$1;
var $538971b5b904f078$var$tab$5 = "	";
var $538971b5b904f078$var$space$9 = " ";
var $538971b5b904f078$var$lineFeed$9 = "\n";
var $538971b5b904f078$var$lessThan$7 = "<";
var $538971b5b904f078$var$rawOpenExpression$1 = /^<(script|pre|style)(?=(\s|>|$))/i;
var $538971b5b904f078$var$rawCloseExpression$1 = /<\/(script|pre|style)>/i;
var $538971b5b904f078$var$commentOpenExpression$1 = /^<!--/;
var $538971b5b904f078$var$commentCloseExpression$1 = /-->/;
var $538971b5b904f078$var$instructionOpenExpression$1 = /^<\?/;
var $538971b5b904f078$var$instructionCloseExpression$1 = /\?>/;
var $538971b5b904f078$var$directiveOpenExpression$1 = /^<![A-Za-z]/;
var $538971b5b904f078$var$directiveCloseExpression$1 = />/;
var $538971b5b904f078$var$cdataOpenExpression$1 = /^<!\[CDATA\[/;
var $538971b5b904f078$var$cdataCloseExpression$1 = /]]>/;
var $538971b5b904f078$var$elementCloseExpression$1 = /^$/;
var $538971b5b904f078$var$otherElementOpenExpression$1 = new RegExp($538971b5b904f078$var$openCloseTag$1.source + "\\s*$");
function $538971b5b904f078$var$blockHtml$1(eat, value, silent) {
    var self = this;
    var blocks = self.options.blocks.join("|");
    var elementOpenExpression = new RegExp("^</?(" + blocks + ")(?=(\\s|/?>|$))", "i");
    var length = value.length;
    var index = 0;
    var next;
    var line;
    var offset;
    var character;
    var count;
    var sequence;
    var subvalue;
    var sequences = [
        [
            $538971b5b904f078$var$rawOpenExpression$1,
            $538971b5b904f078$var$rawCloseExpression$1,
            true
        ],
        [
            $538971b5b904f078$var$commentOpenExpression$1,
            $538971b5b904f078$var$commentCloseExpression$1,
            true
        ],
        [
            $538971b5b904f078$var$instructionOpenExpression$1,
            $538971b5b904f078$var$instructionCloseExpression$1,
            true
        ],
        [
            $538971b5b904f078$var$directiveOpenExpression$1,
            $538971b5b904f078$var$directiveCloseExpression$1,
            true
        ],
        [
            $538971b5b904f078$var$cdataOpenExpression$1,
            $538971b5b904f078$var$cdataCloseExpression$1,
            true
        ],
        [
            elementOpenExpression,
            $538971b5b904f078$var$elementCloseExpression$1,
            true
        ],
        [
            $538971b5b904f078$var$otherElementOpenExpression$1,
            $538971b5b904f078$var$elementCloseExpression$1,
            false
        ]
    ];
    // Eat initial spacing.
    while(index < length){
        character = value.charAt(index);
        if (character !== $538971b5b904f078$var$tab$5 && character !== $538971b5b904f078$var$space$9) break;
        index++;
    }
    if (value.charAt(index) !== $538971b5b904f078$var$lessThan$7) return;
    next = value.indexOf($538971b5b904f078$var$lineFeed$9, index + 1);
    next = next === -1 ? length : next;
    line = value.slice(index, next);
    offset = -1;
    count = sequences.length;
    while(++offset < count)if (sequences[offset][0].test(line)) {
        sequence = sequences[offset];
        break;
    }
    if (!sequence) return;
    if (silent) return sequence[2];
    index = next;
    if (!sequence[1].test(line)) while(index < length){
        next = value.indexOf($538971b5b904f078$var$lineFeed$9, index + 1);
        next = next === -1 ? length : next;
        line = value.slice(index + 1, next);
        if (sequence[1].test(line)) {
            if (line) index = next;
            break;
        }
        index = next;
    }
    subvalue = value.slice(0, index);
    return eat(subvalue)({
        type: "html",
        value: subvalue
    });
}
var $538971b5b904f078$var$isWhitespaceCharacter = $538971b5b904f078$var$whitespace$1;
var $538971b5b904f078$var$fromCode$1 = String.fromCharCode;
var $538971b5b904f078$var$re$2 = /\s/;
// Check if the given character code, or the character code at the first
// character, is a whitespace character.
function $538971b5b904f078$var$whitespace$1(character) {
    return $538971b5b904f078$var$re$2.test(typeof character === "number" ? $538971b5b904f078$var$fromCode$1(character) : character.charAt(0));
}
var $538971b5b904f078$var$collapseWhiteSpace = $538971b5b904f078$var$collapse;
// `collapse(' \t\nbar \nbaz\t') // ' bar baz '`
function $538971b5b904f078$var$collapse(value) {
    return String(value).replace(/\s+/g, " ");
}
var $538971b5b904f078$var$normalize_1$1 = $538971b5b904f078$var$normalize$1;
// Normalize an identifier.  Collapses multiple white space characters into a
// single space, and removes casing.
function $538971b5b904f078$var$normalize$1(value) {
    return $538971b5b904f078$var$collapseWhiteSpace(value).toLowerCase();
}
var $538971b5b904f078$var$definition_1 = $538971b5b904f078$var$definition;
var $538971b5b904f078$var$quotationMark$2 = '"';
var $538971b5b904f078$var$apostrophe$3 = "'";
var $538971b5b904f078$var$backslash$6 = "\\";
var $538971b5b904f078$var$lineFeed$8 = "\n";
var $538971b5b904f078$var$tab$4 = "	";
var $538971b5b904f078$var$space$8 = " ";
var $538971b5b904f078$var$leftSquareBracket$2 = "[";
var $538971b5b904f078$var$rightSquareBracket$2 = "]";
var $538971b5b904f078$var$leftParenthesis$1 = "(";
var $538971b5b904f078$var$rightParenthesis$2 = ")";
var $538971b5b904f078$var$colon$2 = ":";
var $538971b5b904f078$var$lessThan$6 = "<";
var $538971b5b904f078$var$greaterThan$3 = ">";
function $538971b5b904f078$var$definition(eat, value, silent) {
    var self = this;
    var commonmark = self.options.commonmark;
    var index = 0;
    var length = value.length;
    var subvalue = "";
    var beforeURL;
    var beforeTitle;
    var queue;
    var character;
    var test;
    var identifier;
    var url;
    var title;
    while(index < length){
        character = value.charAt(index);
        if (character !== $538971b5b904f078$var$space$8 && character !== $538971b5b904f078$var$tab$4) break;
        subvalue += character;
        index++;
    }
    character = value.charAt(index);
    if (character !== $538971b5b904f078$var$leftSquareBracket$2) return;
    index++;
    subvalue += character;
    queue = "";
    while(index < length){
        character = value.charAt(index);
        if (character === $538971b5b904f078$var$rightSquareBracket$2) break;
        else if (character === $538971b5b904f078$var$backslash$6) {
            queue += character;
            index++;
            character = value.charAt(index);
        }
        queue += character;
        index++;
    }
    if (!queue || value.charAt(index) !== $538971b5b904f078$var$rightSquareBracket$2 || value.charAt(index + 1) !== $538971b5b904f078$var$colon$2) return;
    identifier = queue;
    subvalue += queue + $538971b5b904f078$var$rightSquareBracket$2 + $538971b5b904f078$var$colon$2;
    index = subvalue.length;
    queue = "";
    while(index < length){
        character = value.charAt(index);
        if (character !== $538971b5b904f078$var$tab$4 && character !== $538971b5b904f078$var$space$8 && character !== $538971b5b904f078$var$lineFeed$8) break;
        subvalue += character;
        index++;
    }
    character = value.charAt(index);
    queue = "";
    beforeURL = subvalue;
    if (character === $538971b5b904f078$var$lessThan$6) {
        index++;
        while(index < length){
            character = value.charAt(index);
            if (!$538971b5b904f078$var$isEnclosedURLCharacter(character)) break;
            queue += character;
            index++;
        }
        character = value.charAt(index);
        if (character === $538971b5b904f078$var$isEnclosedURLCharacter.delimiter) {
            subvalue += $538971b5b904f078$var$lessThan$6 + queue + character;
            index++;
        } else {
            if (commonmark) return;
            index -= queue.length + 1;
            queue = "";
        }
    }
    if (!queue) {
        while(index < length){
            character = value.charAt(index);
            if (!$538971b5b904f078$var$isUnclosedURLCharacter(character)) break;
            queue += character;
            index++;
        }
        subvalue += queue;
    }
    if (!queue) return;
    url = queue;
    queue = "";
    while(index < length){
        character = value.charAt(index);
        if (character !== $538971b5b904f078$var$tab$4 && character !== $538971b5b904f078$var$space$8 && character !== $538971b5b904f078$var$lineFeed$8) break;
        queue += character;
        index++;
    }
    character = value.charAt(index);
    test = null;
    if (character === $538971b5b904f078$var$quotationMark$2) test = $538971b5b904f078$var$quotationMark$2;
    else if (character === $538971b5b904f078$var$apostrophe$3) test = $538971b5b904f078$var$apostrophe$3;
    else if (character === $538971b5b904f078$var$leftParenthesis$1) test = $538971b5b904f078$var$rightParenthesis$2;
    if (!test) {
        queue = "";
        index = subvalue.length;
    } else if (queue) {
        subvalue += queue + character;
        index = subvalue.length;
        queue = "";
        while(index < length){
            character = value.charAt(index);
            if (character === test) break;
            if (character === $538971b5b904f078$var$lineFeed$8) {
                index++;
                character = value.charAt(index);
                if (character === $538971b5b904f078$var$lineFeed$8 || character === test) return;
                queue += $538971b5b904f078$var$lineFeed$8;
            }
            queue += character;
            index++;
        }
        character = value.charAt(index);
        if (character !== test) return;
        beforeTitle = subvalue;
        subvalue += queue + character;
        index++;
        title = queue;
        queue = "";
    } else return;
    while(index < length){
        character = value.charAt(index);
        if (character !== $538971b5b904f078$var$tab$4 && character !== $538971b5b904f078$var$space$8) break;
        subvalue += character;
        index++;
    }
    character = value.charAt(index);
    if (!character || character === $538971b5b904f078$var$lineFeed$8) {
        if (silent) return true;
        beforeURL = eat(beforeURL).test().end;
        url = self.decode.raw(self.unescape(url), beforeURL, {
            nonTerminated: false
        });
        if (title) {
            beforeTitle = eat(beforeTitle).test().end;
            title = self.decode.raw(self.unescape(title), beforeTitle);
        }
        return eat(subvalue)({
            type: "definition",
            identifier: $538971b5b904f078$var$normalize_1$1(identifier),
            label: identifier,
            title: title || null,
            url: url
        });
    }
}
// Check if `character` can be inside an enclosed URI.
function $538971b5b904f078$var$isEnclosedURLCharacter(character) {
    return character !== $538971b5b904f078$var$greaterThan$3 && character !== $538971b5b904f078$var$leftSquareBracket$2 && character !== $538971b5b904f078$var$rightSquareBracket$2;
}
$538971b5b904f078$var$isEnclosedURLCharacter.delimiter = $538971b5b904f078$var$greaterThan$3;
// Check if `character` can be inside an unclosed URI.
function $538971b5b904f078$var$isUnclosedURLCharacter(character) {
    return character !== $538971b5b904f078$var$leftSquareBracket$2 && character !== $538971b5b904f078$var$rightSquareBracket$2 && !$538971b5b904f078$var$isWhitespaceCharacter(character);
}
var $538971b5b904f078$var$table_1$1 = $538971b5b904f078$var$table$1;
var $538971b5b904f078$var$tab$3 = "	";
var $538971b5b904f078$var$lineFeed$7 = "\n";
var $538971b5b904f078$var$space$7 = " ";
var $538971b5b904f078$var$dash$4 = "-";
var $538971b5b904f078$var$colon$1 = ":";
var $538971b5b904f078$var$backslash$5 = "\\";
var $538971b5b904f078$var$verticalBar = "|";
var $538971b5b904f078$var$minColumns = 1;
var $538971b5b904f078$var$minRows = 2;
var $538971b5b904f078$var$left = "left";
var $538971b5b904f078$var$center = "center";
var $538971b5b904f078$var$right = "right";
function $538971b5b904f078$var$table$1(eat, value, silent) {
    var self = this;
    var index;
    var alignments;
    var alignment;
    var subvalue;
    var row;
    var length;
    var lines;
    var queue;
    var character;
    var hasDash;
    var align;
    var cell;
    var preamble;
    var now;
    var position;
    var lineCount;
    var line;
    var rows;
    var table;
    var lineIndex;
    var pipeIndex;
    var first;
    // Exit when not in gfm-mode.
    if (!self.options.gfm) return;
    // Get the rows.
    // Detecting tables soon is hard, so there are some checks for performance
    // here, such as the minimum number of rows, and allowed characters in the
    // alignment row.
    index = 0;
    lineCount = 0;
    length = value.length + 1;
    lines = [];
    while(index < length){
        lineIndex = value.indexOf($538971b5b904f078$var$lineFeed$7, index);
        pipeIndex = value.indexOf($538971b5b904f078$var$verticalBar, index + 1);
        if (lineIndex === -1) lineIndex = value.length;
        if (pipeIndex === -1 || pipeIndex > lineIndex) {
            if (lineCount < $538971b5b904f078$var$minRows) return;
            break;
        }
        lines.push(value.slice(index, lineIndex));
        lineCount++;
        index = lineIndex + 1;
    }
    // Parse the alignment row.
    subvalue = lines.join($538971b5b904f078$var$lineFeed$7);
    alignments = lines.splice(1, 1)[0] || [];
    index = 0;
    length = alignments.length;
    lineCount--;
    alignment = false;
    align = [];
    while(index < length){
        character = alignments.charAt(index);
        if (character === $538971b5b904f078$var$verticalBar) {
            hasDash = null;
            if (alignment === false) {
                if (first === false) return;
            } else {
                align.push(alignment);
                alignment = false;
            }
            first = false;
        } else if (character === $538971b5b904f078$var$dash$4) {
            hasDash = true;
            alignment = alignment || null;
        } else if (character === $538971b5b904f078$var$colon$1) {
            if (alignment === $538971b5b904f078$var$left) alignment = $538971b5b904f078$var$center;
            else if (hasDash && alignment === null) alignment = $538971b5b904f078$var$right;
            else alignment = $538971b5b904f078$var$left;
        } else if (!$538971b5b904f078$var$isWhitespaceCharacter(character)) return;
        index++;
    }
    if (alignment !== false) align.push(alignment);
    // Exit when without enough columns.
    if (align.length < $538971b5b904f078$var$minColumns) return;
    /* istanbul ignore if - never used (yet) */ if (silent) return true;
    // Parse the rows.
    position = -1;
    rows = [];
    table = eat(subvalue).reset({
        type: "table",
        align: align,
        children: rows
    });
    while(++position < lineCount){
        line = lines[position];
        row = {
            type: "tableRow",
            children: []
        };
        // Eat a newline character when this is not the first row.
        if (position) eat($538971b5b904f078$var$lineFeed$7);
        // Eat the row.
        eat(line).reset(row, table);
        length = line.length + 1;
        index = 0;
        queue = "";
        cell = "";
        preamble = true;
        while(index < length){
            character = line.charAt(index);
            if (character === $538971b5b904f078$var$tab$3 || character === $538971b5b904f078$var$space$7) {
                if (cell) queue += character;
                else eat(character);
                index++;
                continue;
            }
            if (character === "" || character === $538971b5b904f078$var$verticalBar) {
                if (preamble) eat(character);
                else {
                    if ((cell || character) && !preamble) {
                        subvalue = cell;
                        if (queue.length > 1) {
                            if (character) {
                                subvalue += queue.slice(0, -1);
                                queue = queue.charAt(queue.length - 1);
                            } else {
                                subvalue += queue;
                                queue = "";
                            }
                        }
                        now = eat.now();
                        eat(subvalue)({
                            type: "tableCell",
                            children: self.tokenizeInline(cell, now)
                        }, row);
                    }
                    eat(queue + character);
                    queue = "";
                    cell = "";
                }
            } else {
                if (queue) {
                    cell += queue;
                    queue = "";
                }
                cell += character;
                if (character === $538971b5b904f078$var$backslash$5 && index !== length - 2) {
                    cell += line.charAt(index + 1);
                    index++;
                }
            }
            preamble = false;
            index++;
        }
        // Eat the alignment row.
        if (!position) eat($538971b5b904f078$var$lineFeed$7 + alignments);
    }
    return table;
}
var $538971b5b904f078$var$paragraph_1$1 = $538971b5b904f078$var$paragraph$1;
var $538971b5b904f078$var$tab$2 = "	";
var $538971b5b904f078$var$lineFeed$6 = "\n";
var $538971b5b904f078$var$space$6 = " ";
var $538971b5b904f078$var$tabSize = 4;
// Tokenise paragraph.
function $538971b5b904f078$var$paragraph$1(eat, value, silent) {
    var self = this;
    var settings = self.options;
    var commonmark = settings.commonmark;
    var tokenizers = self.blockTokenizers;
    var interruptors = self.interruptParagraph;
    var index = value.indexOf($538971b5b904f078$var$lineFeed$6);
    var length = value.length;
    var position;
    var subvalue;
    var character;
    var size;
    var now;
    while(index < length){
        // Eat everything if there’s no following newline.
        if (index === -1) {
            index = length;
            break;
        }
        // Stop if the next character is NEWLINE.
        if (value.charAt(index + 1) === $538971b5b904f078$var$lineFeed$6) break;
        // In commonmark-mode, following indented lines are part of the paragraph.
        if (commonmark) {
            size = 0;
            position = index + 1;
            while(position < length){
                character = value.charAt(position);
                if (character === $538971b5b904f078$var$tab$2) {
                    size = $538971b5b904f078$var$tabSize;
                    break;
                } else if (character === $538971b5b904f078$var$space$6) size++;
                else break;
                position++;
            }
            if (size >= $538971b5b904f078$var$tabSize && character !== $538971b5b904f078$var$lineFeed$6) {
                index = value.indexOf($538971b5b904f078$var$lineFeed$6, index + 1);
                continue;
            }
        }
        subvalue = value.slice(index + 1);
        // Check if the following code contains a possible block.
        if ($538971b5b904f078$var$interrupt_1(interruptors, tokenizers, self, [
            eat,
            subvalue,
            true
        ])) break;
        position = index;
        index = value.indexOf($538971b5b904f078$var$lineFeed$6, index + 1);
        if (index !== -1 && $538971b5b904f078$var$trim_1(value.slice(position, index)) === "") {
            index = position;
            break;
        }
    }
    subvalue = value.slice(0, index);
    /* istanbul ignore if - never used (yet) */ if (silent) return true;
    now = eat.now();
    subvalue = $538971b5b904f078$var$trimTrailingLines_1(subvalue);
    return eat(subvalue)({
        type: "paragraph",
        children: self.tokenizeInline(subvalue, now)
    });
}
var $538971b5b904f078$var$_escape$1 = $538971b5b904f078$var$locate$9;
function $538971b5b904f078$var$locate$9(value, fromIndex) {
    return value.indexOf("\\", fromIndex);
}
var $538971b5b904f078$var$_escape = $538971b5b904f078$var$escape$1;
$538971b5b904f078$var$escape$1.locator = $538971b5b904f078$var$_escape$1;
var $538971b5b904f078$var$lineFeed$5 = "\n";
var $538971b5b904f078$var$backslash$4 = "\\";
function $538971b5b904f078$var$escape$1(eat, value, silent) {
    var self = this;
    var character;
    var node;
    if (value.charAt(0) === $538971b5b904f078$var$backslash$4) {
        character = value.charAt(1);
        if (self.escape.indexOf(character) !== -1) {
            /* istanbul ignore if - never used (yet) */ if (silent) return true;
            if (character === $538971b5b904f078$var$lineFeed$5) node = {
                type: "break"
            };
            else node = {
                type: "text",
                value: character
            };
            return eat($538971b5b904f078$var$backslash$4 + character)(node);
        }
    }
}
var $538971b5b904f078$var$tag$1 = $538971b5b904f078$var$locate$8;
function $538971b5b904f078$var$locate$8(value, fromIndex) {
    return value.indexOf("<", fromIndex);
}
var $538971b5b904f078$var$autoLink_1 = $538971b5b904f078$var$autoLink;
$538971b5b904f078$var$autoLink.locator = $538971b5b904f078$var$tag$1;
$538971b5b904f078$var$autoLink.notInLink = true;
var $538971b5b904f078$var$lessThan$5 = "<";
var $538971b5b904f078$var$greaterThan$2 = ">";
var $538971b5b904f078$var$atSign$1 = "@";
var $538971b5b904f078$var$slash$3 = "/";
var $538971b5b904f078$var$mailto = "mailto:";
var $538971b5b904f078$var$mailtoLength = $538971b5b904f078$var$mailto.length;
function $538971b5b904f078$var$autoLink(eat, value, silent) {
    var self = this;
    var subvalue = "";
    var length = value.length;
    var index = 0;
    var queue = "";
    var hasAtCharacter = false;
    var link = "";
    var character;
    var now;
    var content;
    var tokenizers;
    var exit;
    if (value.charAt(0) !== $538971b5b904f078$var$lessThan$5) return;
    index++;
    subvalue = $538971b5b904f078$var$lessThan$5;
    while(index < length){
        character = value.charAt(index);
        if ($538971b5b904f078$var$isWhitespaceCharacter(character) || character === $538971b5b904f078$var$greaterThan$2 || character === $538971b5b904f078$var$atSign$1 || character === ":" && value.charAt(index + 1) === $538971b5b904f078$var$slash$3) break;
        queue += character;
        index++;
    }
    if (!queue) return;
    link += queue;
    queue = "";
    character = value.charAt(index);
    link += character;
    index++;
    if (character === $538971b5b904f078$var$atSign$1) hasAtCharacter = true;
    else {
        if (character !== ":" || value.charAt(index + 1) !== $538971b5b904f078$var$slash$3) return;
        link += $538971b5b904f078$var$slash$3;
        index++;
    }
    while(index < length){
        character = value.charAt(index);
        if ($538971b5b904f078$var$isWhitespaceCharacter(character) || character === $538971b5b904f078$var$greaterThan$2) break;
        queue += character;
        index++;
    }
    character = value.charAt(index);
    if (!queue || character !== $538971b5b904f078$var$greaterThan$2) return;
    /* istanbul ignore if - never used (yet) */ if (silent) return true;
    link += queue;
    content = link;
    subvalue += link + character;
    now = eat.now();
    now.column++;
    now.offset++;
    if (hasAtCharacter) {
        if (link.slice(0, $538971b5b904f078$var$mailtoLength).toLowerCase() === $538971b5b904f078$var$mailto) {
            content = content.slice($538971b5b904f078$var$mailtoLength);
            now.column += $538971b5b904f078$var$mailtoLength;
            now.offset += $538971b5b904f078$var$mailtoLength;
        } else link = $538971b5b904f078$var$mailto + link;
    }
    // Temporarily remove all tokenizers except text in autolinks.
    tokenizers = self.inlineTokenizers;
    self.inlineTokenizers = {
        text: tokenizers.text
    };
    exit = self.enterLink();
    content = self.tokenizeInline(content, now);
    self.inlineTokenizers = tokenizers;
    exit();
    return eat(subvalue)({
        type: "link",
        title: null,
        url: $538971b5b904f078$var$parseEntities_1(link, {
            nonTerminated: false
        }),
        children: content
    });
}
var $538971b5b904f078$var$ccount_1 = $538971b5b904f078$var$ccount;
function $538971b5b904f078$var$ccount(value, character) {
    var val = String(value);
    var count = 0;
    var index;
    if (typeof character !== "string" || character.length !== 1) throw new Error("Expected character");
    index = val.indexOf(character);
    while(index !== -1){
        count++;
        index = val.indexOf(character, index + 1);
    }
    return count;
}
var $538971b5b904f078$var$url$1 = $538971b5b904f078$var$locate$7;
var $538971b5b904f078$var$values = [
    "www.",
    "http://",
    "https://"
];
function $538971b5b904f078$var$locate$7(value, fromIndex) {
    var min = -1;
    var index;
    var length;
    var position;
    if (!this.options.gfm) return min;
    length = $538971b5b904f078$var$values.length;
    index = -1;
    while(++index < length){
        position = value.indexOf($538971b5b904f078$var$values[index], fromIndex);
        if (position !== -1 && (min === -1 || position < min)) min = position;
    }
    return min;
}
var $538971b5b904f078$var$url_1 = $538971b5b904f078$var$url;
$538971b5b904f078$var$url.locator = $538971b5b904f078$var$url$1;
$538971b5b904f078$var$url.notInLink = true;
var $538971b5b904f078$var$exclamationMark$3 = 33; // '!'
var $538971b5b904f078$var$ampersand = 38; // '&'
var $538971b5b904f078$var$rightParenthesis$1 = 41; // ')'
var $538971b5b904f078$var$asterisk$2 = 42; // '*'
var $538971b5b904f078$var$comma$1 = 44; // ','
var $538971b5b904f078$var$dash$3 = 45; // '-'
var $538971b5b904f078$var$dot$2 = 46; // '.'
var $538971b5b904f078$var$colon = 58; // ':'
var $538971b5b904f078$var$semicolon = 59; // ';'
var $538971b5b904f078$var$questionMark$1 = 63; // '?'
var $538971b5b904f078$var$lessThan$4 = 60; // '<'
var $538971b5b904f078$var$underscore$4 = 95; // '_'
var $538971b5b904f078$var$tilde$2 = 126; // '~'
var $538971b5b904f078$var$leftParenthesisCharacter = "(";
var $538971b5b904f078$var$rightParenthesisCharacter = ")";
function $538971b5b904f078$var$url(eat, value, silent) {
    var self = this;
    var gfm = self.options.gfm;
    var tokenizers = self.inlineTokenizers;
    var length = value.length;
    var previousDot = -1;
    var protocolless = false;
    var dots;
    var lastTwoPartsStart;
    var start;
    var index;
    var pathStart;
    var path;
    var code;
    var end;
    var leftCount;
    var rightCount;
    var content;
    var children;
    var url;
    var exit;
    if (!gfm) return;
    // `WWW.` doesn’t work.
    if (value.slice(0, 4) === "www.") {
        protocolless = true;
        index = 4;
    } else if (value.slice(0, 7).toLowerCase() === "http://") index = 7;
    else if (value.slice(0, 8).toLowerCase() === "https://") index = 8;
    else return;
    // Act as if the starting boundary is a dot.
    previousDot = index - 1;
    // Parse a valid domain.
    start = index;
    dots = [];
    while(index < length){
        code = value.charCodeAt(index);
        if (code === $538971b5b904f078$var$dot$2) {
            // Dots may not appear after each other.
            if (previousDot === index - 1) break;
            dots.push(index);
            previousDot = index;
            index++;
            continue;
        }
        if ($538971b5b904f078$var$isDecimal(code) || $538971b5b904f078$var$isAlphabetical(code) || code === $538971b5b904f078$var$dash$3 || code === $538971b5b904f078$var$underscore$4) {
            index++;
            continue;
        }
        break;
    }
    // Ignore a final dot:
    if (code === $538971b5b904f078$var$dot$2) {
        dots.pop();
        index--;
    }
    // If there are not dots, exit.
    if (dots[0] === undefined) return;
    // If there is an underscore in the last two domain parts, exit:
    // `www.example.c_m` and `www.ex_ample.com` are not OK, but
    // `www.sub_domain.example.com` is.
    lastTwoPartsStart = dots.length < 2 ? start : dots[dots.length - 2] + 1;
    if (value.slice(lastTwoPartsStart, index).indexOf("_") !== -1) return;
    /* istanbul ignore if - never used (yet) */ if (silent) return true;
    end = index;
    pathStart = index;
    // Parse a path.
    while(index < length){
        code = value.charCodeAt(index);
        if ($538971b5b904f078$var$isWhitespaceCharacter(code) || code === $538971b5b904f078$var$lessThan$4) break;
        index++;
        if (code === $538971b5b904f078$var$exclamationMark$3 || code === $538971b5b904f078$var$asterisk$2 || code === $538971b5b904f078$var$comma$1 || code === $538971b5b904f078$var$dot$2 || code === $538971b5b904f078$var$colon || code === $538971b5b904f078$var$questionMark$1 || code === $538971b5b904f078$var$underscore$4 || code === $538971b5b904f078$var$tilde$2) ;
        else end = index;
    }
    index = end;
    // If the path ends in a closing paren, and the count of closing parens is
    // higher than the opening count, then remove the supefluous closing parens.
    if (value.charCodeAt(index - 1) === $538971b5b904f078$var$rightParenthesis$1) {
        path = value.slice(pathStart, index);
        leftCount = $538971b5b904f078$var$ccount_1(path, $538971b5b904f078$var$leftParenthesisCharacter);
        rightCount = $538971b5b904f078$var$ccount_1(path, $538971b5b904f078$var$rightParenthesisCharacter);
        while(rightCount > leftCount){
            index = pathStart + path.lastIndexOf($538971b5b904f078$var$rightParenthesisCharacter);
            path = value.slice(pathStart, index);
            rightCount--;
        }
    }
    if (value.charCodeAt(index - 1) === $538971b5b904f078$var$semicolon) {
        // GitHub doesn’t document this, but final semicolons aren’t paret of the
        // URL either.
        index--;
        // // If the path ends in what looks like an entity, it’s not part of the path.
        if ($538971b5b904f078$var$isAlphabetical(value.charCodeAt(index - 1))) {
            end = index - 2;
            while($538971b5b904f078$var$isAlphabetical(value.charCodeAt(end)))end--;
            if (value.charCodeAt(end) === $538971b5b904f078$var$ampersand) index = end;
        }
    }
    content = value.slice(0, index);
    url = $538971b5b904f078$var$parseEntities_1(content, {
        nonTerminated: false
    });
    if (protocolless) url = "http://" + url;
    exit = self.enterLink();
    // Temporarily remove all tokenizers except text in url.
    self.inlineTokenizers = {
        text: tokenizers.text
    };
    children = self.tokenizeInline(content, eat.now());
    self.inlineTokenizers = tokenizers;
    exit();
    return eat(content)({
        type: "link",
        title: null,
        url: url,
        children: children
    });
}
var $538971b5b904f078$var$plusSign$1 = 43; // '+'
var $538971b5b904f078$var$dash$2 = 45; // '-'
var $538971b5b904f078$var$dot$1 = 46; // '.'
var $538971b5b904f078$var$underscore$3 = 95; // '_'
var $538971b5b904f078$var$email$1 = $538971b5b904f078$var$locate$6;
// See: <https://github.github.com/gfm/#extended-email-autolink>
function $538971b5b904f078$var$locate$6(value, fromIndex) {
    var self = this;
    var at;
    var position;
    if (!this.options.gfm) return -1;
    at = value.indexOf("@", fromIndex);
    if (at === -1) return -1;
    position = at;
    if (position === fromIndex || !$538971b5b904f078$var$isGfmAtext(value.charCodeAt(position - 1))) return $538971b5b904f078$var$locate$6.call(self, value, at + 1);
    while(position > fromIndex && $538971b5b904f078$var$isGfmAtext(value.charCodeAt(position - 1)))position--;
    return position;
}
function $538971b5b904f078$var$isGfmAtext(code) {
    return $538971b5b904f078$var$isDecimal(code) || $538971b5b904f078$var$isAlphabetical(code) || code === $538971b5b904f078$var$plusSign$1 || code === $538971b5b904f078$var$dash$2 || code === $538971b5b904f078$var$dot$1 || code === $538971b5b904f078$var$underscore$3;
}
var $538971b5b904f078$var$email_1 = $538971b5b904f078$var$email;
$538971b5b904f078$var$email.locator = $538971b5b904f078$var$email$1;
$538971b5b904f078$var$email.notInLink = true;
var $538971b5b904f078$var$plusSign = 43; // '+'
var $538971b5b904f078$var$dash$1 = 45; // '-'
var $538971b5b904f078$var$dot = 46; // '.'
var $538971b5b904f078$var$atSign = 64; // '@'
var $538971b5b904f078$var$underscore$2 = 95; // '_'
function $538971b5b904f078$var$email(eat, value, silent) {
    var self = this;
    var gfm = self.options.gfm;
    var tokenizers = self.inlineTokenizers;
    var index = 0;
    var length = value.length;
    var firstDot = -1;
    var code;
    var content;
    var children;
    var exit;
    if (!gfm) return;
    code = value.charCodeAt(index);
    while($538971b5b904f078$var$isDecimal(code) || $538971b5b904f078$var$isAlphabetical(code) || code === $538971b5b904f078$var$plusSign || code === $538971b5b904f078$var$dash$1 || code === $538971b5b904f078$var$dot || code === $538971b5b904f078$var$underscore$2)code = value.charCodeAt(++index);
    if (index === 0) return;
    if (code !== $538971b5b904f078$var$atSign) return;
    index++;
    while(index < length){
        code = value.charCodeAt(index);
        if ($538971b5b904f078$var$isDecimal(code) || $538971b5b904f078$var$isAlphabetical(code) || code === $538971b5b904f078$var$dash$1 || code === $538971b5b904f078$var$dot || code === $538971b5b904f078$var$underscore$2) {
            index++;
            if (firstDot === -1 && code === $538971b5b904f078$var$dot) firstDot = index;
            continue;
        }
        break;
    }
    if (firstDot === -1 || firstDot === index || code === $538971b5b904f078$var$dash$1 || code === $538971b5b904f078$var$underscore$2) return;
    if (code === $538971b5b904f078$var$dot) index--;
    content = value.slice(0, index);
    /* istanbul ignore if - never used (yet) */ if (silent) return true;
    exit = self.enterLink();
    // Temporarily remove all tokenizers except text in url.
    self.inlineTokenizers = {
        text: tokenizers.text
    };
    children = self.tokenizeInline(content, eat.now());
    self.inlineTokenizers = tokenizers;
    exit();
    return eat(content)({
        type: "link",
        title: null,
        url: "mailto:" + $538971b5b904f078$var$parseEntities_1(content, {
            nonTerminated: false
        }),
        children: children
    });
}
var $538971b5b904f078$var$tag = $538971b5b904f078$var$html$4.tag;
var $538971b5b904f078$var$htmlInline = $538971b5b904f078$var$inlineHTML;
$538971b5b904f078$var$inlineHTML.locator = $538971b5b904f078$var$tag$1;
var $538971b5b904f078$var$lessThan$3 = "<";
var $538971b5b904f078$var$questionMark = "?";
var $538971b5b904f078$var$exclamationMark$2 = "!";
var $538971b5b904f078$var$slash$2 = "/";
var $538971b5b904f078$var$htmlLinkOpenExpression = /^<a /i;
var $538971b5b904f078$var$htmlLinkCloseExpression = /^<\/a>/i;
function $538971b5b904f078$var$inlineHTML(eat, value, silent) {
    var self = this;
    var length = value.length;
    var character;
    var subvalue;
    if (value.charAt(0) !== $538971b5b904f078$var$lessThan$3 || length < 3) return;
    character = value.charAt(1);
    if (!$538971b5b904f078$var$isAlphabetical(character) && character !== $538971b5b904f078$var$questionMark && character !== $538971b5b904f078$var$exclamationMark$2 && character !== $538971b5b904f078$var$slash$2) return;
    subvalue = value.match($538971b5b904f078$var$tag);
    if (!subvalue) return;
    /* istanbul ignore if - not used yet. */ if (silent) return true;
    subvalue = subvalue[0];
    if (!self.inLink && $538971b5b904f078$var$htmlLinkOpenExpression.test(subvalue)) self.inLink = true;
    else if (self.inLink && $538971b5b904f078$var$htmlLinkCloseExpression.test(subvalue)) self.inLink = false;
    return eat(subvalue)({
        type: "html",
        value: subvalue
    });
}
var $538971b5b904f078$var$link$3 = $538971b5b904f078$var$locate$5;
function $538971b5b904f078$var$locate$5(value, fromIndex) {
    var link = value.indexOf("[", fromIndex);
    var image = value.indexOf("![", fromIndex);
    if (image === -1) return link;
    // Link can never be `-1` if an image is found, so we don’t need to check
    // for that :)
    return link < image ? link : image;
}
var $538971b5b904f078$var$link_1$1 = $538971b5b904f078$var$link$2;
$538971b5b904f078$var$link$2.locator = $538971b5b904f078$var$link$3;
var $538971b5b904f078$var$lineFeed$4 = "\n";
var $538971b5b904f078$var$exclamationMark$1 = "!";
var $538971b5b904f078$var$quotationMark$1 = '"';
var $538971b5b904f078$var$apostrophe$2 = "'";
var $538971b5b904f078$var$leftParenthesis = "(";
var $538971b5b904f078$var$rightParenthesis = ")";
var $538971b5b904f078$var$lessThan$2 = "<";
var $538971b5b904f078$var$greaterThan$1 = ">";
var $538971b5b904f078$var$leftSquareBracket$1 = "[";
var $538971b5b904f078$var$backslash$3 = "\\";
var $538971b5b904f078$var$rightSquareBracket$1 = "]";
var $538971b5b904f078$var$graveAccent$1 = "`";
function $538971b5b904f078$var$link$2(eat, value, silent) {
    var self = this;
    var subvalue = "";
    var index = 0;
    var character = value.charAt(0);
    var pedantic = self.options.pedantic;
    var commonmark = self.options.commonmark;
    var gfm = self.options.gfm;
    var closed;
    var count;
    var opening;
    var beforeURL;
    var beforeTitle;
    var subqueue;
    var hasMarker;
    var isImage;
    var content;
    var marker;
    var length;
    var title;
    var depth;
    var queue;
    var url;
    var now;
    var exit;
    var node;
    // Detect whether this is an image.
    if (character === $538971b5b904f078$var$exclamationMark$1) {
        isImage = true;
        subvalue = character;
        character = value.charAt(++index);
    }
    // Eat the opening.
    if (character !== $538971b5b904f078$var$leftSquareBracket$1) return;
    // Exit when this is a link and we’re already inside a link.
    if (!isImage && self.inLink) return;
    subvalue += character;
    queue = "";
    index++;
    // Eat the content.
    length = value.length;
    now = eat.now();
    depth = 0;
    now.column += index;
    now.offset += index;
    while(index < length){
        character = value.charAt(index);
        subqueue = character;
        if (character === $538971b5b904f078$var$graveAccent$1) {
            // Inline-code in link content.
            count = 1;
            while(value.charAt(index + 1) === $538971b5b904f078$var$graveAccent$1){
                subqueue += character;
                index++;
                count++;
            }
            if (!opening) opening = count;
            else if (count >= opening) opening = 0;
        } else if (character === $538971b5b904f078$var$backslash$3) {
            // Allow brackets to be escaped.
            index++;
            subqueue += value.charAt(index);
        } else if ((!opening || gfm) && character === $538971b5b904f078$var$leftSquareBracket$1) // In GFM mode, brackets in code still count.  In all other modes,
        // they don’t.
        depth++;
        else if ((!opening || gfm) && character === $538971b5b904f078$var$rightSquareBracket$1) {
            if (depth) depth--;
            else {
                if (value.charAt(index + 1) !== $538971b5b904f078$var$leftParenthesis) return;
                subqueue += $538971b5b904f078$var$leftParenthesis;
                closed = true;
                index++;
                break;
            }
        }
        queue += subqueue;
        subqueue = "";
        index++;
    }
    // Eat the content closing.
    if (!closed) return;
    content = queue;
    subvalue += queue + subqueue;
    index++;
    // Eat white-space.
    while(index < length){
        character = value.charAt(index);
        if (!$538971b5b904f078$var$isWhitespaceCharacter(character)) break;
        subvalue += character;
        index++;
    }
    // Eat the URL.
    character = value.charAt(index);
    queue = "";
    beforeURL = subvalue;
    if (character === $538971b5b904f078$var$lessThan$2) {
        index++;
        beforeURL += $538971b5b904f078$var$lessThan$2;
        while(index < length){
            character = value.charAt(index);
            if (character === $538971b5b904f078$var$greaterThan$1) break;
            if (commonmark && character === $538971b5b904f078$var$lineFeed$4) return;
            queue += character;
            index++;
        }
        if (value.charAt(index) !== $538971b5b904f078$var$greaterThan$1) return;
        subvalue += $538971b5b904f078$var$lessThan$2 + queue + $538971b5b904f078$var$greaterThan$1;
        url = queue;
        index++;
    } else {
        character = null;
        subqueue = "";
        while(index < length){
            character = value.charAt(index);
            if (subqueue && (character === $538971b5b904f078$var$quotationMark$1 || character === $538971b5b904f078$var$apostrophe$2 || commonmark && character === $538971b5b904f078$var$leftParenthesis)) break;
            if ($538971b5b904f078$var$isWhitespaceCharacter(character)) {
                if (!pedantic) break;
                subqueue += character;
            } else {
                if (character === $538971b5b904f078$var$leftParenthesis) depth++;
                else if (character === $538971b5b904f078$var$rightParenthesis) {
                    if (depth === 0) break;
                    depth--;
                }
                queue += subqueue;
                subqueue = "";
                if (character === $538971b5b904f078$var$backslash$3) {
                    queue += $538971b5b904f078$var$backslash$3;
                    character = value.charAt(++index);
                }
                queue += character;
            }
            index++;
        }
        subvalue += queue;
        url = queue;
        index = subvalue.length;
    }
    // Eat white-space.
    queue = "";
    while(index < length){
        character = value.charAt(index);
        if (!$538971b5b904f078$var$isWhitespaceCharacter(character)) break;
        queue += character;
        index++;
    }
    character = value.charAt(index);
    subvalue += queue;
    // Eat the title.
    if (queue && (character === $538971b5b904f078$var$quotationMark$1 || character === $538971b5b904f078$var$apostrophe$2 || commonmark && character === $538971b5b904f078$var$leftParenthesis)) {
        index++;
        subvalue += character;
        queue = "";
        marker = character === $538971b5b904f078$var$leftParenthesis ? $538971b5b904f078$var$rightParenthesis : character;
        beforeTitle = subvalue;
        // In commonmark-mode, things are pretty easy: the marker cannot occur
        // inside the title.  Non-commonmark does, however, support nested
        // delimiters.
        if (commonmark) {
            while(index < length){
                character = value.charAt(index);
                if (character === marker) break;
                if (character === $538971b5b904f078$var$backslash$3) {
                    queue += $538971b5b904f078$var$backslash$3;
                    character = value.charAt(++index);
                }
                index++;
                queue += character;
            }
            character = value.charAt(index);
            if (character !== marker) return;
            title = queue;
            subvalue += queue + character;
            index++;
            while(index < length){
                character = value.charAt(index);
                if (!$538971b5b904f078$var$isWhitespaceCharacter(character)) break;
                subvalue += character;
                index++;
            }
        } else {
            subqueue = "";
            while(index < length){
                character = value.charAt(index);
                if (character === marker) {
                    if (hasMarker) {
                        queue += marker + subqueue;
                        subqueue = "";
                    }
                    hasMarker = true;
                } else if (!hasMarker) queue += character;
                else if (character === $538971b5b904f078$var$rightParenthesis) {
                    subvalue += queue + marker + subqueue;
                    title = queue;
                    break;
                } else if ($538971b5b904f078$var$isWhitespaceCharacter(character)) subqueue += character;
                else {
                    queue += marker + subqueue + character;
                    subqueue = "";
                    hasMarker = false;
                }
                index++;
            }
        }
    }
    if (value.charAt(index) !== $538971b5b904f078$var$rightParenthesis) return;
    /* istanbul ignore if - never used (yet) */ if (silent) return true;
    subvalue += $538971b5b904f078$var$rightParenthesis;
    url = self.decode.raw(self.unescape(url), eat(beforeURL).test().end, {
        nonTerminated: false
    });
    if (title) {
        beforeTitle = eat(beforeTitle).test().end;
        title = self.decode.raw(self.unescape(title), beforeTitle);
    }
    node = {
        type: isImage ? "image" : "link",
        title: title || null,
        url: url
    };
    if (isImage) node.alt = self.decode.raw(self.unescape(content), now) || null;
    else {
        exit = self.enterLink();
        node.children = self.tokenizeInline(content, now);
        exit();
    }
    return eat(subvalue)(node);
}
var $538971b5b904f078$var$reference_1 = $538971b5b904f078$var$reference;
$538971b5b904f078$var$reference.locator = $538971b5b904f078$var$link$3;
var $538971b5b904f078$var$link$1 = "link";
var $538971b5b904f078$var$image$2 = "image";
var $538971b5b904f078$var$shortcut = "shortcut";
var $538971b5b904f078$var$collapsed = "collapsed";
var $538971b5b904f078$var$full = "full";
var $538971b5b904f078$var$exclamationMark = "!";
var $538971b5b904f078$var$leftSquareBracket = "[";
var $538971b5b904f078$var$backslash$2 = "\\";
var $538971b5b904f078$var$rightSquareBracket = "]";
function $538971b5b904f078$var$reference(eat, value, silent) {
    var self = this;
    var commonmark = self.options.commonmark;
    var character = value.charAt(0);
    var index = 0;
    var length = value.length;
    var subvalue = "";
    var intro = "";
    var type = $538971b5b904f078$var$link$1;
    var referenceType = $538971b5b904f078$var$shortcut;
    var content;
    var identifier;
    var now;
    var node;
    var exit;
    var queue;
    var bracketed;
    var depth;
    // Check whether we’re eating an image.
    if (character === $538971b5b904f078$var$exclamationMark) {
        type = $538971b5b904f078$var$image$2;
        intro = character;
        character = value.charAt(++index);
    }
    if (character !== $538971b5b904f078$var$leftSquareBracket) return;
    index++;
    intro += character;
    queue = "";
    // Eat the text.
    depth = 0;
    while(index < length){
        character = value.charAt(index);
        if (character === $538971b5b904f078$var$leftSquareBracket) {
            bracketed = true;
            depth++;
        } else if (character === $538971b5b904f078$var$rightSquareBracket) {
            if (!depth) break;
            depth--;
        }
        if (character === $538971b5b904f078$var$backslash$2) {
            queue += $538971b5b904f078$var$backslash$2;
            character = value.charAt(++index);
        }
        queue += character;
        index++;
    }
    subvalue = queue;
    content = queue;
    character = value.charAt(index);
    if (character !== $538971b5b904f078$var$rightSquareBracket) return;
    index++;
    subvalue += character;
    queue = "";
    if (!commonmark) // The original markdown syntax definition explicitly allows for whitespace
    // between the link text and link label; commonmark departs from this, in
    // part to improve support for shortcut reference links
    while(index < length){
        character = value.charAt(index);
        if (!$538971b5b904f078$var$isWhitespaceCharacter(character)) break;
        queue += character;
        index++;
    }
    character = value.charAt(index);
    if (character === $538971b5b904f078$var$leftSquareBracket) {
        identifier = "";
        queue += character;
        index++;
        while(index < length){
            character = value.charAt(index);
            if (character === $538971b5b904f078$var$leftSquareBracket || character === $538971b5b904f078$var$rightSquareBracket) break;
            if (character === $538971b5b904f078$var$backslash$2) {
                identifier += $538971b5b904f078$var$backslash$2;
                character = value.charAt(++index);
            }
            identifier += character;
            index++;
        }
        character = value.charAt(index);
        if (character === $538971b5b904f078$var$rightSquareBracket) {
            referenceType = identifier ? $538971b5b904f078$var$full : $538971b5b904f078$var$collapsed;
            queue += identifier + character;
            index++;
        } else identifier = "";
        subvalue += queue;
        queue = "";
    } else {
        if (!content) return;
        identifier = content;
    }
    // Brackets cannot be inside the identifier.
    if (referenceType !== $538971b5b904f078$var$full && bracketed) return;
    subvalue = intro + subvalue;
    if (type === $538971b5b904f078$var$link$1 && self.inLink) return null;
    /* istanbul ignore if - never used (yet) */ if (silent) return true;
    now = eat.now();
    now.column += intro.length;
    now.offset += intro.length;
    identifier = referenceType === $538971b5b904f078$var$full ? identifier : content;
    node = {
        type: type + "Reference",
        identifier: $538971b5b904f078$var$normalize_1$1(identifier),
        label: identifier,
        referenceType: referenceType
    };
    if (type === $538971b5b904f078$var$link$1) {
        exit = self.enterLink();
        node.children = self.tokenizeInline(content, now);
        exit();
    } else node.alt = self.decode.raw(self.unescape(content), now) || null;
    return eat(subvalue)(node);
}
var $538971b5b904f078$var$strong$2 = $538971b5b904f078$var$locate$4;
function $538971b5b904f078$var$locate$4(value, fromIndex) {
    var asterisk = value.indexOf("**", fromIndex);
    var underscore = value.indexOf("__", fromIndex);
    if (underscore === -1) return asterisk;
    if (asterisk === -1) return underscore;
    return underscore < asterisk ? underscore : asterisk;
}
var $538971b5b904f078$var$strong_1$1 = $538971b5b904f078$var$strong$1;
$538971b5b904f078$var$strong$1.locator = $538971b5b904f078$var$strong$2;
var $538971b5b904f078$var$backslash$1 = "\\";
var $538971b5b904f078$var$asterisk$1 = "*";
var $538971b5b904f078$var$underscore$1 = "_";
function $538971b5b904f078$var$strong$1(eat, value, silent) {
    var self = this;
    var index = 0;
    var character = value.charAt(index);
    var now;
    var pedantic;
    var marker;
    var queue;
    var subvalue;
    var length;
    var previous;
    if (character !== $538971b5b904f078$var$asterisk$1 && character !== $538971b5b904f078$var$underscore$1 || value.charAt(++index) !== character) return;
    pedantic = self.options.pedantic;
    marker = character;
    subvalue = marker + marker;
    length = value.length;
    index++;
    queue = "";
    character = "";
    if (pedantic && $538971b5b904f078$var$isWhitespaceCharacter(value.charAt(index))) return;
    while(index < length){
        previous = character;
        character = value.charAt(index);
        if (character === marker && value.charAt(index + 1) === marker && (!pedantic || !$538971b5b904f078$var$isWhitespaceCharacter(previous))) {
            character = value.charAt(index + 2);
            if (character !== marker) {
                if (!$538971b5b904f078$var$trim_1(queue)) return;
                /* istanbul ignore if - never used (yet) */ if (silent) return true;
                now = eat.now();
                now.column += 2;
                now.offset += 2;
                return eat(subvalue + queue + subvalue)({
                    type: "strong",
                    children: self.tokenizeInline(queue, now)
                });
            }
        }
        if (!pedantic && character === $538971b5b904f078$var$backslash$1) {
            queue += character;
            character = value.charAt(++index);
        }
        queue += character;
        index++;
    }
}
var $538971b5b904f078$var$isWordCharacter = $538971b5b904f078$var$wordCharacter;
var $538971b5b904f078$var$fromCode = String.fromCharCode;
var $538971b5b904f078$var$re$1 = /\w/;
// Check if the given character code, or the character code at the first
// character, is a word character.
function $538971b5b904f078$var$wordCharacter(character) {
    return $538971b5b904f078$var$re$1.test(typeof character === "number" ? $538971b5b904f078$var$fromCode(character) : character.charAt(0));
}
var $538971b5b904f078$var$emphasis$2 = $538971b5b904f078$var$locate$3;
function $538971b5b904f078$var$locate$3(value, fromIndex) {
    var asterisk = value.indexOf("*", fromIndex);
    var underscore = value.indexOf("_", fromIndex);
    if (underscore === -1) return asterisk;
    if (asterisk === -1) return underscore;
    return underscore < asterisk ? underscore : asterisk;
}
var $538971b5b904f078$var$emphasis_1$1 = $538971b5b904f078$var$emphasis$1;
$538971b5b904f078$var$emphasis$1.locator = $538971b5b904f078$var$emphasis$2;
var $538971b5b904f078$var$asterisk = "*";
var $538971b5b904f078$var$underscore = "_";
var $538971b5b904f078$var$backslash = "\\";
function $538971b5b904f078$var$emphasis$1(eat, value, silent) {
    var self = this;
    var index = 0;
    var character = value.charAt(index);
    var now;
    var pedantic;
    var marker;
    var queue;
    var subvalue;
    var length;
    var previous;
    if (character !== $538971b5b904f078$var$asterisk && character !== $538971b5b904f078$var$underscore) return;
    pedantic = self.options.pedantic;
    subvalue = character;
    marker = character;
    length = value.length;
    index++;
    queue = "";
    character = "";
    if (pedantic && $538971b5b904f078$var$isWhitespaceCharacter(value.charAt(index))) return;
    while(index < length){
        previous = character;
        character = value.charAt(index);
        if (character === marker && (!pedantic || !$538971b5b904f078$var$isWhitespaceCharacter(previous))) {
            character = value.charAt(++index);
            if (character !== marker) {
                if (!$538971b5b904f078$var$trim_1(queue) || previous === marker) return;
                if (!pedantic && marker === $538971b5b904f078$var$underscore && $538971b5b904f078$var$isWordCharacter(character)) {
                    queue += marker;
                    continue;
                }
                /* istanbul ignore if - never used (yet) */ if (silent) return true;
                now = eat.now();
                now.column++;
                now.offset++;
                return eat(subvalue + queue + marker)({
                    type: "emphasis",
                    children: self.tokenizeInline(queue, now)
                });
            }
            queue += marker;
        }
        if (!pedantic && character === $538971b5b904f078$var$backslash) {
            queue += character;
            character = value.charAt(++index);
        }
        queue += character;
        index++;
    }
}
var $538971b5b904f078$var$_delete$2 = $538971b5b904f078$var$locate$2;
function $538971b5b904f078$var$locate$2(value, fromIndex) {
    return value.indexOf("~~", fromIndex);
}
var $538971b5b904f078$var$_delete$1 = $538971b5b904f078$var$strikethrough$1;
$538971b5b904f078$var$strikethrough$1.locator = $538971b5b904f078$var$_delete$2;
var $538971b5b904f078$var$tilde$1 = "~";
var $538971b5b904f078$var$fence$1 = "~~";
function $538971b5b904f078$var$strikethrough$1(eat, value, silent) {
    var self = this;
    var character = "";
    var previous = "";
    var preceding = "";
    var subvalue = "";
    var index;
    var length;
    var now;
    if (!self.options.gfm || value.charAt(0) !== $538971b5b904f078$var$tilde$1 || value.charAt(1) !== $538971b5b904f078$var$tilde$1 || $538971b5b904f078$var$isWhitespaceCharacter(value.charAt(2))) return;
    index = 1;
    length = value.length;
    now = eat.now();
    now.column += 2;
    now.offset += 2;
    while(++index < length){
        character = value.charAt(index);
        if (character === $538971b5b904f078$var$tilde$1 && previous === $538971b5b904f078$var$tilde$1 && (!preceding || !$538971b5b904f078$var$isWhitespaceCharacter(preceding))) {
            /* istanbul ignore if - never used (yet) */ if (silent) return true;
            return eat($538971b5b904f078$var$fence$1 + subvalue + $538971b5b904f078$var$fence$1)({
                type: "delete",
                children: self.tokenizeInline(subvalue, now)
            });
        }
        subvalue += previous;
        preceding = previous;
        previous = character;
    }
}
var $538971b5b904f078$var$codeInline$1 = $538971b5b904f078$var$locate$1;
function $538971b5b904f078$var$locate$1(value, fromIndex) {
    return value.indexOf("`", fromIndex);
}
var $538971b5b904f078$var$codeInline = $538971b5b904f078$var$inlineCode$1;
$538971b5b904f078$var$inlineCode$1.locator = $538971b5b904f078$var$codeInline$1;
var $538971b5b904f078$var$lineFeed$3 = 10; //  '\n'
var $538971b5b904f078$var$space$5 = 32; // ' '
var $538971b5b904f078$var$graveAccent = 96; //  '`'
function $538971b5b904f078$var$inlineCode$1(eat, value, silent) {
    var length = value.length;
    var index = 0;
    var openingFenceEnd;
    var closingFenceStart;
    var closingFenceEnd;
    var code;
    var next;
    var found;
    while(index < length){
        if (value.charCodeAt(index) !== $538971b5b904f078$var$graveAccent) break;
        index++;
    }
    if (index === 0 || index === length) return;
    openingFenceEnd = index;
    next = value.charCodeAt(index);
    while(index < length){
        code = next;
        next = value.charCodeAt(index + 1);
        if (code === $538971b5b904f078$var$graveAccent) {
            if (closingFenceStart === undefined) closingFenceStart = index;
            closingFenceEnd = index + 1;
            if (next !== $538971b5b904f078$var$graveAccent && closingFenceEnd - closingFenceStart === openingFenceEnd) {
                found = true;
                break;
            }
        } else if (closingFenceStart !== undefined) {
            closingFenceStart = undefined;
            closingFenceEnd = undefined;
        }
        index++;
    }
    if (!found) return;
    /* istanbul ignore if - never used (yet) */ if (silent) return true;
    // Remove the initial and final space (or line feed), iff they exist and there
    // are non-space characters in the content.
    index = openingFenceEnd;
    length = closingFenceStart;
    code = value.charCodeAt(index);
    next = value.charCodeAt(length - 1);
    found = false;
    if (length - index > 2 && (code === $538971b5b904f078$var$space$5 || code === $538971b5b904f078$var$lineFeed$3) && (next === $538971b5b904f078$var$space$5 || next === $538971b5b904f078$var$lineFeed$3)) {
        index++;
        length--;
        while(index < length){
            code = value.charCodeAt(index);
            if (code !== $538971b5b904f078$var$space$5 && code !== $538971b5b904f078$var$lineFeed$3) {
                found = true;
                break;
            }
            index++;
        }
        if (found === true) {
            openingFenceEnd++;
            closingFenceStart--;
        }
    }
    return eat(value.slice(0, closingFenceEnd))({
        type: "inlineCode",
        value: value.slice(openingFenceEnd, closingFenceStart)
    });
}
var $538971b5b904f078$var$_break$2 = $538971b5b904f078$var$locate;
function $538971b5b904f078$var$locate(value, fromIndex) {
    var index = value.indexOf("\n", fromIndex);
    while(index > fromIndex){
        if (value.charAt(index - 1) !== " ") break;
        index--;
    }
    return index;
}
var $538971b5b904f078$var$_break$1 = $538971b5b904f078$var$hardBreak$1;
$538971b5b904f078$var$hardBreak$1.locator = $538971b5b904f078$var$_break$2;
var $538971b5b904f078$var$space$4 = " ";
var $538971b5b904f078$var$lineFeed$2 = "\n";
var $538971b5b904f078$var$minBreakLength = 2;
function $538971b5b904f078$var$hardBreak$1(eat, value, silent) {
    var length = value.length;
    var index = -1;
    var queue = "";
    var character;
    while(++index < length){
        character = value.charAt(index);
        if (character === $538971b5b904f078$var$lineFeed$2) {
            if (index < $538971b5b904f078$var$minBreakLength) return;
            /* istanbul ignore if - never used (yet) */ if (silent) return true;
            queue += character;
            return eat(queue)({
                type: "break"
            });
        }
        if (character !== $538971b5b904f078$var$space$4) return;
        queue += character;
    }
}
var $538971b5b904f078$var$text_1$2 = $538971b5b904f078$var$text$3;
function $538971b5b904f078$var$text$3(eat, value, silent) {
    var self = this;
    var methods;
    var tokenizers;
    var index;
    var length;
    var subvalue;
    var position;
    var tokenizer;
    var name;
    var min;
    var now;
    /* istanbul ignore if - never used (yet) */ if (silent) return true;
    methods = self.inlineMethods;
    length = methods.length;
    tokenizers = self.inlineTokenizers;
    index = -1;
    min = value.length;
    while(++index < length){
        name = methods[index];
        if (name === "text" || !tokenizers[name]) continue;
        tokenizer = tokenizers[name].locator;
        if (!tokenizer) eat.file.fail("Missing locator: `" + name + "`");
        position = tokenizer.call(self, value, 1);
        if (position !== -1 && position < min) min = position;
    }
    subvalue = value.slice(0, min);
    now = eat.now();
    self.decode(subvalue, now, handler);
    function handler(content, position, source) {
        eat(source || content)({
            type: "text",
            value: content
        });
    }
}
var $538971b5b904f078$var$parser$1 = $538971b5b904f078$var$Parser;
function $538971b5b904f078$var$Parser(doc, file) {
    this.file = file;
    this.offset = {};
    this.options = $538971b5b904f078$var$immutable(this.options);
    this.setOptions({});
    this.inList = false;
    this.inBlock = false;
    this.inLink = false;
    this.atStart = true;
    this.toOffset = $538971b5b904f078$var$vfileLocation(file).toOffset;
    this.unescape = $538971b5b904f078$var$_unescape(this, "escape");
    this.decode = $538971b5b904f078$var$decode(this);
}
var $538971b5b904f078$var$proto$3 = $538971b5b904f078$var$Parser.prototype;
// Expose core.
$538971b5b904f078$var$proto$3.setOptions = $538971b5b904f078$var$setOptions_1;
$538971b5b904f078$var$proto$3.parse = $538971b5b904f078$var$parse_1$2;
// Expose `defaults`.
$538971b5b904f078$var$proto$3.options = $538971b5b904f078$var$defaults$1;
// Enter and exit helpers.
$538971b5b904f078$var$proto$3.exitStart = $538971b5b904f078$var$stateToggle("atStart", true);
$538971b5b904f078$var$proto$3.enterList = $538971b5b904f078$var$stateToggle("inList", false);
$538971b5b904f078$var$proto$3.enterLink = $538971b5b904f078$var$stateToggle("inLink", false);
$538971b5b904f078$var$proto$3.enterBlock = $538971b5b904f078$var$stateToggle("inBlock", false);
// Nodes that can interupt a paragraph:
//
// ```markdown
// A paragraph, followed by a thematic break.
// ___
// ```
//
// In the above example, the thematic break “interupts” the paragraph.
$538971b5b904f078$var$proto$3.interruptParagraph = [
    [
        "thematicBreak"
    ],
    [
        "list"
    ],
    [
        "atxHeading"
    ],
    [
        "fencedCode"
    ],
    [
        "blockquote"
    ],
    [
        "html"
    ],
    [
        "setextHeading",
        {
            commonmark: false
        }
    ],
    [
        "definition",
        {
            commonmark: false
        }
    ]
];
// Nodes that can interupt a list:
//
// ```markdown
// - One
// ___
// ```
//
// In the above example, the thematic break “interupts” the list.
$538971b5b904f078$var$proto$3.interruptList = [
    [
        "atxHeading",
        {
            pedantic: false
        }
    ],
    [
        "fencedCode",
        {
            pedantic: false
        }
    ],
    [
        "thematicBreak",
        {
            pedantic: false
        }
    ],
    [
        "definition",
        {
            commonmark: false
        }
    ]
];
// Nodes that can interupt a blockquote:
//
// ```markdown
// > A paragraph.
// ___
// ```
//
// In the above example, the thematic break “interupts” the blockquote.
$538971b5b904f078$var$proto$3.interruptBlockquote = [
    [
        "indentedCode",
        {
            commonmark: true
        }
    ],
    [
        "fencedCode",
        {
            commonmark: true
        }
    ],
    [
        "atxHeading",
        {
            commonmark: true
        }
    ],
    [
        "setextHeading",
        {
            commonmark: true
        }
    ],
    [
        "thematicBreak",
        {
            commonmark: true
        }
    ],
    [
        "html",
        {
            commonmark: true
        }
    ],
    [
        "list",
        {
            commonmark: true
        }
    ],
    [
        "definition",
        {
            commonmark: false
        }
    ]
];
// Handlers.
$538971b5b904f078$var$proto$3.blockTokenizers = {
    blankLine: $538971b5b904f078$var$blankLine_1,
    indentedCode: $538971b5b904f078$var$codeIndented,
    fencedCode: $538971b5b904f078$var$codeFenced,
    blockquote: $538971b5b904f078$var$blockquote_1$1,
    atxHeading: $538971b5b904f078$var$headingAtx,
    thematicBreak: $538971b5b904f078$var$thematicBreak_1$1,
    list: $538971b5b904f078$var$list_1$1,
    setextHeading: $538971b5b904f078$var$headingSetext,
    html: $538971b5b904f078$var$htmlBlock,
    definition: $538971b5b904f078$var$definition_1,
    table: $538971b5b904f078$var$table_1$1,
    paragraph: $538971b5b904f078$var$paragraph_1$1
};
$538971b5b904f078$var$proto$3.inlineTokenizers = {
    escape: $538971b5b904f078$var$_escape,
    autoLink: $538971b5b904f078$var$autoLink_1,
    url: $538971b5b904f078$var$url_1,
    email: $538971b5b904f078$var$email_1,
    html: $538971b5b904f078$var$htmlInline,
    link: $538971b5b904f078$var$link_1$1,
    reference: $538971b5b904f078$var$reference_1,
    strong: $538971b5b904f078$var$strong_1$1,
    emphasis: $538971b5b904f078$var$emphasis_1$1,
    deletion: $538971b5b904f078$var$_delete$1,
    code: $538971b5b904f078$var$codeInline,
    break: $538971b5b904f078$var$_break$1,
    text: $538971b5b904f078$var$text_1$2
};
// Expose precedence.
$538971b5b904f078$var$proto$3.blockMethods = $538971b5b904f078$var$keys$1($538971b5b904f078$var$proto$3.blockTokenizers);
$538971b5b904f078$var$proto$3.inlineMethods = $538971b5b904f078$var$keys$1($538971b5b904f078$var$proto$3.inlineTokenizers);
// Tokenizers.
$538971b5b904f078$var$proto$3.tokenizeBlock = $538971b5b904f078$var$tokenizer$1("block");
$538971b5b904f078$var$proto$3.tokenizeInline = $538971b5b904f078$var$tokenizer$1("inline");
$538971b5b904f078$var$proto$3.tokenizeFactory = $538971b5b904f078$var$tokenizer$1;
// Get all keys in `value`.
function $538971b5b904f078$var$keys$1(value) {
    var result = [];
    var key;
    for(key in value)result.push(key);
    return result;
}
var $538971b5b904f078$var$remarkParse = $538971b5b904f078$var$parse$5;
$538971b5b904f078$var$parse$5.Parser = $538971b5b904f078$var$parser$1;
function $538971b5b904f078$var$parse$5(options) {
    var settings = this.data("settings");
    var Local = $538971b5b904f078$var$unherit_1($538971b5b904f078$var$parser$1);
    Local.prototype.options = $538971b5b904f078$var$immutable(Local.prototype.options, settings, options);
    this.Parser = Local;
}
var $538971b5b904f078$var$mdastUtilDefinitions$1 = $538971b5b904f078$var$getDefinitionFactory$1;
var $538971b5b904f078$var$own$a = {}.hasOwnProperty;
// Get a definition in `node` by `identifier`.
function $538971b5b904f078$var$getDefinitionFactory$1(node, options) {
    return $538971b5b904f078$var$getterFactory$1($538971b5b904f078$var$gather$1(node, options));
}
// Gather all definitions in `node`
function $538971b5b904f078$var$gather$1(node, options) {
    var cache = {};
    if (!node || !node.type) throw new Error("mdast-util-definitions expected node");
    $538971b5b904f078$var$unistUtilVisit(node, "definition", options && options.commonmark ? commonmark : normal);
    return cache;
    function commonmark(definition) {
        var id = $538971b5b904f078$var$normalise$1(definition.identifier);
        if (!$538971b5b904f078$var$own$a.call(cache, id)) cache[id] = definition;
    }
    function normal(definition) {
        cache[$538971b5b904f078$var$normalise$1(definition.identifier)] = definition;
    }
}
// Factory to get a node from the given definition-cache.
function $538971b5b904f078$var$getterFactory$1(cache) {
    return getter;
    // Get a node from the bound definition-cache.
    function getter(identifier) {
        var id = identifier && $538971b5b904f078$var$normalise$1(identifier);
        return id && $538971b5b904f078$var$own$a.call(cache, id) ? cache[id] : null;
    }
}
function $538971b5b904f078$var$normalise$1(identifier) {
    return identifier.toUpperCase();
}
var $538971b5b904f078$var$parse_1$1 = $538971b5b904f078$var$parse$4;
var $538971b5b904f078$var$stringify_1$1 = $538971b5b904f078$var$stringify$3;
var $538971b5b904f078$var$empty$2 = "";
var $538971b5b904f078$var$space$3 = " ";
var $538971b5b904f078$var$whiteSpace$1 = /[ \t\n\r\f]+/g;
function $538971b5b904f078$var$parse$4(value) {
    var input = String(value || $538971b5b904f078$var$empty$2).trim();
    return input === $538971b5b904f078$var$empty$2 ? [] : input.split($538971b5b904f078$var$whiteSpace$1);
}
function $538971b5b904f078$var$stringify$3(values) {
    return values.join($538971b5b904f078$var$space$3).trim();
}
var $538971b5b904f078$var$spaceSeparatedTokens = {
    parse: $538971b5b904f078$var$parse_1$1,
    stringify: $538971b5b904f078$var$stringify_1$1
};
var $538971b5b904f078$var$isAbsoluteUrl = (url)=>{
    if (typeof url !== "string") throw new TypeError(`Expected a \`string\`, got \`${typeof url}\``);
    // Don't match Windows paths `c:\`
    if (/^[a-zA-Z]:\\/.test(url)) return false;
    // Scheme: https://tools.ietf.org/html/rfc3986#section-3.1
    // Absolute URL: https://tools.ietf.org/html/rfc3986#section-4.3
    return /^[a-zA-Z][a-zA-Z\d+\-.]*:/.test(url);
};
var $538971b5b904f078$var$spaceSeparated$4 = $538971b5b904f078$var$spaceSeparatedTokens.parse;
var $538971b5b904f078$var$remarkExternalLinks = $538971b5b904f078$var$externalLinks;
var $538971b5b904f078$var$defaultTarget = "_blank";
var $538971b5b904f078$var$defaultRel = [
    "nofollow",
    "noopener",
    "noreferrer"
];
var $538971b5b904f078$var$defaultProtocols = [
    "http",
    "https"
];
function $538971b5b904f078$var$externalLinks(options) {
    var settings = options || {};
    var target = settings.target;
    var rel = settings.rel;
    var protocols = settings.protocols || $538971b5b904f078$var$defaultProtocols;
    var content = settings.content;
    var contentProperties = settings.contentProperties || {};
    if (typeof rel === "string") rel = $538971b5b904f078$var$spaceSeparated$4(rel);
    if (content && typeof content === "object" && !("length" in content)) content = [
        content
    ];
    return transform;
    function transform(tree) {
        var definition = $538971b5b904f078$var$mdastUtilDefinitions$1(tree);
        $538971b5b904f078$var$unistUtilVisit(tree, [
            "link",
            "linkReference"
        ], visitor);
        function visitor(node) {
            var ctx = node.type === "link" ? node : definition(node.identifier);
            var protocol;
            var data;
            var props;
            if (!ctx) return;
            protocol = ctx.url.slice(0, ctx.url.indexOf(":"));
            if ($538971b5b904f078$var$isAbsoluteUrl(ctx.url) && protocols.indexOf(protocol) !== -1) {
                data = node.data || (node.data = {});
                props = data.hProperties || (data.hProperties = {});
                if (target !== false) props.target = target || $538971b5b904f078$var$defaultTarget;
                if (rel !== false) props.rel = (rel || $538971b5b904f078$var$defaultRel).concat();
                if (content) // `fragment` is not a known mdast node, but unknown nodes with
                // children are handled as elements by `mdast-util-to-hast`:
                // See: <https://github.com/syntax-tree/mdast-util-to-hast#notes>.
                node.children.push({
                    type: "fragment",
                    children: [],
                    data: {
                        hName: "span",
                        hProperties: $538971b5b904f078$var$extend$2(true, contentProperties),
                        hChildren: $538971b5b904f078$var$extend$2(true, content)
                    }
                });
            }
        }
    }
}
var $538971b5b904f078$var$format = $538971b5b904f078$var$createCommonjsModule(function(module) {
    (function() {
        //// Export the API
        var namespace;
        namespace = module.exports = format;
        namespace.format = format;
        namespace.vsprintf = vsprintf;
        if (typeof console !== "undefined" && typeof console.log === "function") namespace.printf = printf;
        function printf() {
            console.log(format.apply(null, arguments));
        }
        function vsprintf(fmt, replacements) {
            return format.apply(null, [
                fmt
            ].concat(replacements));
        }
        function format(fmt) {
            var argIndex = 1 // skip initial format argument
            , args = [].slice.call(arguments), i = 0, n = fmt.length, result = "", c, escaped = false, arg, tmp, leadingZero = false, precision, nextArg = function() {
                return args[argIndex++];
            }, slurpNumber = function() {
                var digits = "";
                while(/\d/.test(fmt[i])){
                    digits += fmt[i++];
                    c = fmt[i];
                }
                return digits.length > 0 ? parseInt(digits) : null;
            };
            for(; i < n; ++i){
                c = fmt[i];
                if (escaped) {
                    escaped = false;
                    if (c == ".") {
                        leadingZero = false;
                        c = fmt[++i];
                    } else if (c == "0" && fmt[i + 1] == ".") {
                        leadingZero = true;
                        i += 2;
                        c = fmt[i];
                    } else leadingZero = true;
                    precision = slurpNumber();
                    switch(c){
                        case "b":
                            result += parseInt(nextArg(), 10).toString(2);
                            break;
                        case "c":
                            arg = nextArg();
                            if (typeof arg === "string" || arg instanceof String) result += arg;
                            else result += String.fromCharCode(parseInt(arg, 10));
                            break;
                        case "d":
                            result += parseInt(nextArg(), 10);
                            break;
                        case "f":
                            tmp = String(parseFloat(nextArg()).toFixed(precision || 6));
                            result += leadingZero ? tmp : tmp.replace(/^0/, "");
                            break;
                        case "j":
                            result += JSON.stringify(nextArg());
                            break;
                        case "o":
                            result += "0" + parseInt(nextArg(), 10).toString(8);
                            break;
                        case "s":
                            result += nextArg();
                            break;
                        case "x":
                            result += "0x" + parseInt(nextArg(), 10).toString(16);
                            break;
                        case "X":
                            result += "0x" + parseInt(nextArg(), 10).toString(16).toUpperCase();
                            break;
                        default:
                            result += c;
                            break;
                    }
                } else if (c === "%") escaped = true;
                else result += c;
            }
            return result;
        }
    })();
});
var $538971b5b904f078$var$fault = $538971b5b904f078$var$create$3(Error);
var $538971b5b904f078$var$fault_1 = $538971b5b904f078$var$fault;
$538971b5b904f078$var$fault.eval = $538971b5b904f078$var$create$3(EvalError);
$538971b5b904f078$var$fault.range = $538971b5b904f078$var$create$3(RangeError);
$538971b5b904f078$var$fault.reference = $538971b5b904f078$var$create$3(ReferenceError);
$538971b5b904f078$var$fault.syntax = $538971b5b904f078$var$create$3(SyntaxError);
$538971b5b904f078$var$fault.type = $538971b5b904f078$var$create$3(TypeError);
$538971b5b904f078$var$fault.uri = $538971b5b904f078$var$create$3(URIError);
$538971b5b904f078$var$fault.create = $538971b5b904f078$var$create$3;
// Create a new `EConstructor`, with the formatted `format` as a first argument.
function $538971b5b904f078$var$create$3(EConstructor) {
    FormattedError.displayName = EConstructor.displayName || EConstructor.name;
    return FormattedError;
    function FormattedError(format$1) {
        if (format$1) format$1 = $538971b5b904f078$var$format.apply(null, arguments);
        return new EConstructor(format$1);
    }
}
var $538971b5b904f078$var$matters_1 = $538971b5b904f078$var$matters;
var $538971b5b904f078$var$own$9 = {}.hasOwnProperty;
var $538971b5b904f078$var$markers = {
    yaml: "-",
    toml: "+"
};
function $538971b5b904f078$var$matters(options) {
    var results = [];
    var index = -1;
    var length;
    // One preset or matter.
    if (typeof options === "string" || !("length" in options)) options = [
        options
    ];
    length = options.length;
    while(++index < length)results[index] = $538971b5b904f078$var$matter(options[index]);
    return results;
}
function $538971b5b904f078$var$matter(option) {
    var result = option;
    if (typeof result === "string") {
        if (!$538971b5b904f078$var$own$9.call($538971b5b904f078$var$markers, result)) throw $538971b5b904f078$var$fault_1("Missing matter definition for `%s`", result);
        result = {
            type: result,
            marker: $538971b5b904f078$var$markers[result]
        };
    } else if (typeof result !== "object") throw $538971b5b904f078$var$fault_1("Expected matter to be an object, not `%j`", result);
    if (!$538971b5b904f078$var$own$9.call(result, "type")) throw $538971b5b904f078$var$fault_1("Missing `type` in matter `%j`", result);
    if (!$538971b5b904f078$var$own$9.call(result, "fence") && !$538971b5b904f078$var$own$9.call(result, "marker")) throw $538971b5b904f078$var$fault_1("Missing `marker` or `fence` in matter `%j`", result);
    return result;
}
var $538971b5b904f078$var$fence_1 = $538971b5b904f078$var$fence;
function $538971b5b904f078$var$fence(matter, prop) {
    var marker;
    if (matter.marker) {
        marker = $538971b5b904f078$var$pick(matter.marker, prop);
        return marker + marker + marker;
    }
    return $538971b5b904f078$var$pick(matter.fence, prop);
}
function $538971b5b904f078$var$pick(schema, prop) {
    return typeof schema === "string" ? schema : schema[prop];
}
var $538971b5b904f078$var$parse$3 = $538971b5b904f078$var$create$2;
function $538971b5b904f078$var$create$2(matter) {
    var name = matter.type + "FrontMatter";
    var open = $538971b5b904f078$var$fence_1(matter, "open");
    var close = $538971b5b904f078$var$fence_1(matter, "close");
    var newline = "\n";
    var anywhere = matter.anywhere;
    frontmatter.displayName = name;
    frontmatter.onlyAtStart = typeof anywhere === "boolean" ? !anywhere : true;
    return [
        name,
        frontmatter
    ];
    function frontmatter(eat, value, silent) {
        var index = open.length;
        var offset;
        if (value.slice(0, index) !== open || value.charAt(index) !== newline) return;
        offset = value.indexOf(close, index);
        while(offset !== -1 && value.charAt(offset - 1) !== newline){
            index = offset + close.length;
            offset = value.indexOf(close, index);
        }
        if (offset !== -1) {
            /* istanbul ignore if - never used (yet) */ if (silent) return true;
            return eat(value.slice(0, offset + close.length))({
                type: matter.type,
                value: value.slice(open.length + 1, offset - 1)
            });
        }
    }
}
var $538971b5b904f078$var$compile = $538971b5b904f078$var$create$1;
function $538971b5b904f078$var$create$1(matter) {
    var type = matter.type;
    var open = $538971b5b904f078$var$fence_1(matter, "open");
    var close = $538971b5b904f078$var$fence_1(matter, "close");
    frontmatter.displayName = type + "FrontMatter";
    return [
        type,
        frontmatter
    ];
    function frontmatter(node) {
        return open + (node.value ? "\n" + node.value : "") + "\n" + close;
    }
}
var $538971b5b904f078$var$remarkFrontmatter = $538971b5b904f078$var$frontmatter;
function $538971b5b904f078$var$frontmatter(options) {
    var parser = this.Parser;
    var compiler = this.Compiler;
    var config = $538971b5b904f078$var$matters_1(options || [
        "yaml"
    ]);
    if ($538971b5b904f078$var$isRemarkParser(parser)) $538971b5b904f078$var$attachParser(parser, config);
    if ($538971b5b904f078$var$isRemarkCompiler(compiler)) $538971b5b904f078$var$attachCompiler(compiler, config);
}
function $538971b5b904f078$var$attachParser(parser, matters) {
    var proto = parser.prototype;
    var tokenizers = $538971b5b904f078$var$wrap$1($538971b5b904f078$var$parse$3, matters);
    var names = [];
    var key;
    for(key in tokenizers)names.push(key);
    proto.blockMethods = names.concat(proto.blockMethods);
    proto.blockTokenizers = Object.assign({}, tokenizers, proto.blockTokenizers);
}
function $538971b5b904f078$var$attachCompiler(compiler, matters) {
    var proto = compiler.prototype;
    proto.visitors = Object.assign({}, $538971b5b904f078$var$wrap$1($538971b5b904f078$var$compile, matters), proto.visitors);
}
function $538971b5b904f078$var$wrap$1(func, matters) {
    var result = {};
    var length = matters.length;
    var index = -1;
    var tuple;
    while(++index < length){
        tuple = func(matters[index]);
        result[tuple[0]] = tuple[1];
    }
    return result;
}
function $538971b5b904f078$var$isRemarkParser(parser) {
    return Boolean(parser && parser.prototype && parser.prototype.blockTokenizers);
}
function $538971b5b904f078$var$isRemarkCompiler(compiler) {
    return Boolean(compiler && compiler.prototype && compiler.prototype.visitors);
}
var $538971b5b904f078$var$unistBuilder = $538971b5b904f078$var$u;
function $538971b5b904f078$var$u(type, props, value) {
    var node;
    if ((value === null || value === undefined) && (typeof props !== "object" || Array.isArray(props))) {
        value = props;
        props = {};
    }
    node = Object.assign({
        type: String(type)
    }, props);
    if (Array.isArray(value)) node.children = value;
    else if (value !== null && value !== undefined) node.value = String(value);
    return node;
}
var $538971b5b904f078$var$start = $538971b5b904f078$var$factory$1("start");
var $538971b5b904f078$var$end = $538971b5b904f078$var$factory$1("end");
var $538971b5b904f078$var$unistUtilPosition = $538971b5b904f078$var$position;
$538971b5b904f078$var$position.start = $538971b5b904f078$var$start;
$538971b5b904f078$var$position.end = $538971b5b904f078$var$end;
function $538971b5b904f078$var$position(node) {
    return {
        start: $538971b5b904f078$var$start(node),
        end: $538971b5b904f078$var$end(node)
    };
}
function $538971b5b904f078$var$factory$1(type) {
    point.displayName = type;
    return point;
    function point(node) {
        var point = node && node.position && node.position[type] || {};
        return {
            line: point.line || null,
            column: point.column || null,
            offset: isNaN(point.offset) ? null : point.offset
        };
    }
}
var $538971b5b904f078$var$unistUtilGenerated = $538971b5b904f078$var$generated;
function $538971b5b904f078$var$generated(node) {
    var position = $538971b5b904f078$var$optional($538971b5b904f078$var$optional(node).position);
    var start = $538971b5b904f078$var$optional(position.start);
    var end = $538971b5b904f078$var$optional(position.end);
    return !start.line || !start.column || !end.line || !end.column;
}
function $538971b5b904f078$var$optional(value) {
    return value && typeof value === "object" ? value : {};
}
var $538971b5b904f078$var$mdastUtilDefinitions = $538971b5b904f078$var$getDefinitionFactory;
var $538971b5b904f078$var$own$8 = {}.hasOwnProperty;
// Get a definition in `node` by `identifier`.
function $538971b5b904f078$var$getDefinitionFactory(node, options) {
    return $538971b5b904f078$var$getterFactory($538971b5b904f078$var$gather(node, options));
}
// Gather all definitions in `node`
function $538971b5b904f078$var$gather(node, options) {
    var cache = {};
    if (!node || !node.type) throw new Error("mdast-util-definitions expected node");
    $538971b5b904f078$var$unistUtilVisit(node, "definition", options && options.commonmark ? commonmark : normal);
    return cache;
    function commonmark(definition) {
        var id = $538971b5b904f078$var$normalise(definition.identifier);
        if (!$538971b5b904f078$var$own$8.call(cache, id)) cache[id] = definition;
    }
    function normal(definition) {
        cache[$538971b5b904f078$var$normalise(definition.identifier)] = definition;
    }
}
// Factory to get a node from the given definition-cache.
function $538971b5b904f078$var$getterFactory(cache) {
    return getter;
    // Get a node from the bound definition-cache.
    function getter(identifier) {
        var id = identifier && $538971b5b904f078$var$normalise(identifier);
        return id && $538971b5b904f078$var$own$8.call(cache, id) ? cache[id] : null;
    }
}
function $538971b5b904f078$var$normalise(identifier) {
    return identifier.toUpperCase();
}
var $538971b5b904f078$var$all_1$1 = $538971b5b904f078$var$all$2;
function $538971b5b904f078$var$all$2(h, parent) {
    var nodes = parent.children || [];
    var length = nodes.length;
    var values = [];
    var index = -1;
    var result;
    var head;
    while(++index < length){
        result = $538971b5b904f078$var$one_1$1(h, nodes[index], parent);
        if (result) {
            if (index && nodes[index - 1].type === "break") {
                if (result.value) result.value = result.value.replace(/^\s+/, "");
                head = result.children && result.children[0];
                if (head && head.value) head.value = head.value.replace(/^\s+/, "");
            }
            values = values.concat(result);
        }
    }
    return values;
}
var $538971b5b904f078$var$one_1$1 = $538971b5b904f078$var$one$2;
var $538971b5b904f078$var$own$7 = {}.hasOwnProperty;
// Transform an unknown node.
function $538971b5b904f078$var$unknown(h, node) {
    if ($538971b5b904f078$var$text$2(node)) return h.augment(node, $538971b5b904f078$var$unistBuilder("text", node.value));
    return h(node, "div", $538971b5b904f078$var$all_1$1(h, node));
}
// Visit a node.
function $538971b5b904f078$var$one$2(h, node, parent) {
    var type = node && node.type;
    var fn = $538971b5b904f078$var$own$7.call(h.handlers, type) ? h.handlers[type] : h.unknownHandler;
    // Fail on non-nodes.
    if (!type) throw new Error("Expected node, got `" + node + "`");
    return (typeof fn === "function" ? fn : $538971b5b904f078$var$unknown)(h, node, parent);
}
// Check if the node should be renderered as a text node.
function $538971b5b904f078$var$text$2(node) {
    var data = node.data || {};
    if ($538971b5b904f078$var$own$7.call(data, "hName") || $538971b5b904f078$var$own$7.call(data, "hProperties") || $538971b5b904f078$var$own$7.call(data, "hChildren")) return false;
    return "value" in node;
}
var $538971b5b904f078$var$thematicBreak_1 = $538971b5b904f078$var$thematicBreak;
function $538971b5b904f078$var$thematicBreak(h, node) {
    return h(node, "hr");
}
var $538971b5b904f078$var$wrap_1 = $538971b5b904f078$var$wrap;
// Wrap `nodes` with line feeds between each entry.
// Optionally adds line feeds at the start and end.
function $538971b5b904f078$var$wrap(nodes, loose) {
    var result = [];
    var index = -1;
    var length = nodes.length;
    if (loose) result.push($538971b5b904f078$var$unistBuilder("text", "\n"));
    while(++index < length){
        if (index) result.push($538971b5b904f078$var$unistBuilder("text", "\n"));
        result.push(nodes[index]);
    }
    if (loose && nodes.length !== 0) result.push($538971b5b904f078$var$unistBuilder("text", "\n"));
    return result;
}
var $538971b5b904f078$var$list_1 = $538971b5b904f078$var$list;
function $538971b5b904f078$var$list(h, node) {
    var props = {};
    var name = node.ordered ? "ol" : "ul";
    var items;
    var index = -1;
    var length;
    if (typeof node.start === "number" && node.start !== 1) props.start = node.start;
    items = $538971b5b904f078$var$all_1$1(h, node);
    length = items.length;
    // Like GitHub, add a class for custom styling.
    while(++index < length)if (items[index].properties.className && items[index].properties.className.indexOf("task-list-item") !== -1) {
        props.className = [
            "contains-task-list"
        ];
        break;
    }
    return h(node, name, props, $538971b5b904f078$var$wrap_1(items, true));
}
var $538971b5b904f078$var$footer = $538971b5b904f078$var$generateFootnotes;
function $538971b5b904f078$var$generateFootnotes(h) {
    var footnoteById = h.footnoteById;
    var footnoteOrder = h.footnoteOrder;
    var length = footnoteOrder.length;
    var index = -1;
    var listItems = [];
    var def;
    var backReference;
    var content;
    var tail;
    while(++index < length){
        def = footnoteById[footnoteOrder[index].toUpperCase()];
        if (!def) continue;
        content = def.children.concat();
        tail = content[content.length - 1];
        backReference = {
            type: "link",
            url: "#fnref-" + def.identifier,
            data: {
                hProperties: {
                    className: [
                        "footnote-backref"
                    ]
                }
            },
            children: [
                {
                    type: "text",
                    value: "\u21A9"
                }
            ]
        };
        if (!tail || tail.type !== "paragraph") {
            tail = {
                type: "paragraph",
                children: []
            };
            content.push(tail);
        }
        tail.children.push(backReference);
        listItems.push({
            type: "listItem",
            data: {
                hProperties: {
                    id: "fn-" + def.identifier
                }
            },
            children: content,
            position: def.position
        });
    }
    if (listItems.length === 0) return null;
    return h(null, "div", {
        className: [
            "footnotes"
        ]
    }, $538971b5b904f078$var$wrap_1([
        $538971b5b904f078$var$thematicBreak_1(h),
        $538971b5b904f078$var$list_1(h, {
            type: "list",
            ordered: true,
            children: listItems
        })
    ], true));
}
var $538971b5b904f078$var$blockquote_1 = $538971b5b904f078$var$blockquote;
function $538971b5b904f078$var$blockquote(h, node) {
    return h(node, "blockquote", $538971b5b904f078$var$wrap_1($538971b5b904f078$var$all_1$1(h, node), true));
}
var $538971b5b904f078$var$_break = $538971b5b904f078$var$hardBreak;
function $538971b5b904f078$var$hardBreak(h, node) {
    return [
        h(node, "br"),
        $538971b5b904f078$var$unistBuilder("text", "\n")
    ];
}
var $538971b5b904f078$var$detab_1 = $538971b5b904f078$var$detab;
var $538971b5b904f078$var$tab$1 = 0x09;
var $538971b5b904f078$var$lineFeed$1 = 0x0a;
var $538971b5b904f078$var$carriageReturn = 0x0d;
// Replace tabs with spaces, being smart about which column the tab is at and
// which size should be used.
function $538971b5b904f078$var$detab(value, size) {
    var string = typeof value === "string";
    var length = string && value.length;
    var start = 0;
    var index = -1;
    var column = -1;
    var tabSize = size || 4;
    var results = [];
    var code;
    var add;
    if (!string) throw new Error("detab expected string");
    while(++index < length){
        code = value.charCodeAt(index);
        if (code === $538971b5b904f078$var$tab$1) {
            add = tabSize - (column + 1) % tabSize;
            column += add;
            results.push(value.slice(start, index) + $538971b5b904f078$var$repeatString(" ", add));
            start = index + 1;
        } else if (code === $538971b5b904f078$var$lineFeed$1 || code === $538971b5b904f078$var$carriageReturn) column = -1;
        else column++;
    }
    results.push(value.slice(start));
    return results.join("");
}
var $538971b5b904f078$var$code_1 = $538971b5b904f078$var$code;
function $538971b5b904f078$var$code(h, node) {
    var value = node.value ? $538971b5b904f078$var$detab_1(node.value + "\n") : "";
    var lang = node.lang && node.lang.match(/^[^ \t]+(?=[ \t]|$)/);
    var props = {};
    if (lang) props.className = [
        "language-" + lang
    ];
    return h(node.position, "pre", [
        h(node, "code", props, [
            $538971b5b904f078$var$unistBuilder("text", value)
        ])
    ]);
}
var $538971b5b904f078$var$_delete = $538971b5b904f078$var$strikethrough;
function $538971b5b904f078$var$strikethrough(h, node) {
    return h(node, "del", $538971b5b904f078$var$all_1$1(h, node));
}
var $538971b5b904f078$var$emphasis_1 = $538971b5b904f078$var$emphasis;
function $538971b5b904f078$var$emphasis(h, node) {
    return h(node, "em", $538971b5b904f078$var$all_1$1(h, node));
}
var $538971b5b904f078$var$footnoteReference_1 = $538971b5b904f078$var$footnoteReference;
function $538971b5b904f078$var$footnoteReference(h, node) {
    var footnoteOrder = h.footnoteOrder;
    var identifier = String(node.identifier);
    if (footnoteOrder.indexOf(identifier) === -1) footnoteOrder.push(identifier);
    return h(node.position, "sup", {
        id: "fnref-" + identifier
    }, [
        h(node, "a", {
            href: "#fn-" + identifier,
            className: [
                "footnote-ref"
            ]
        }, [
            $538971b5b904f078$var$unistBuilder("text", node.label || identifier)
        ])
    ]);
}
var $538971b5b904f078$var$footnote_1 = $538971b5b904f078$var$footnote;
function $538971b5b904f078$var$footnote(h, node) {
    var footnoteById = h.footnoteById;
    var footnoteOrder = h.footnoteOrder;
    var identifier = 1;
    while(identifier in footnoteById)identifier++;
    identifier = String(identifier);
    // No need to check if `identifier` exists in `footnoteOrder`, it’s guaranteed
    // to not exist because we just generated it.
    footnoteOrder.push(identifier);
    footnoteById[identifier] = {
        type: "footnoteDefinition",
        identifier: identifier,
        children: [
            {
                type: "paragraph",
                children: node.children
            }
        ],
        position: node.position
    };
    return $538971b5b904f078$var$footnoteReference_1(h, {
        type: "footnoteReference",
        identifier: identifier,
        position: node.position
    });
}
var $538971b5b904f078$var$heading_1 = $538971b5b904f078$var$heading;
function $538971b5b904f078$var$heading(h, node) {
    return h(node, "h" + node.depth, $538971b5b904f078$var$all_1$1(h, node));
}
var $538971b5b904f078$var$html_1$1 = $538971b5b904f078$var$html$3;
// Return either a `raw` node in dangerous mode, otherwise nothing.
function $538971b5b904f078$var$html$3(h, node) {
    return h.dangerous ? h.augment(node, $538971b5b904f078$var$unistBuilder("raw", node.value)) : null;
}
var $538971b5b904f078$var$encodeCache = {};
// Create a lookup array where anything but characters in `chars` string
// and alphanumeric chars is percent-encoded.
//
function $538971b5b904f078$var$getEncodeCache(exclude) {
    var i, ch, cache = $538971b5b904f078$var$encodeCache[exclude];
    if (cache) return cache;
    cache = $538971b5b904f078$var$encodeCache[exclude] = [];
    for(i = 0; i < 128; i++){
        ch = String.fromCharCode(i);
        if (/^[0-9a-z]$/i.test(ch)) // always allow unencoded alphanumeric characters
        cache.push(ch);
        else cache.push("%" + ("0" + i.toString(16).toUpperCase()).slice(-2));
    }
    for(i = 0; i < exclude.length; i++)cache[exclude.charCodeAt(i)] = exclude[i];
    return cache;
}
// Encode unsafe characters with percent-encoding, skipping already
// encoded sequences.
//
//  - string       - string to encode
//  - exclude      - list of characters to ignore (in addition to a-zA-Z0-9)
//  - keepEscaped  - don't encode '%' in a correct escape sequence (default: true)
//
function $538971b5b904f078$var$encode$1(string, exclude, keepEscaped) {
    var i, l, code, nextCode, cache, result = "";
    if (typeof exclude !== "string") {
        // encode(string, keepEscaped)
        keepEscaped = exclude;
        exclude = $538971b5b904f078$var$encode$1.defaultChars;
    }
    if (typeof keepEscaped === "undefined") keepEscaped = true;
    cache = $538971b5b904f078$var$getEncodeCache(exclude);
    for(i = 0, l = string.length; i < l; i++){
        code = string.charCodeAt(i);
        if (keepEscaped && code === 0x25 /* % */  && i + 2 < l) {
            if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {
                result += string.slice(i, i + 3);
                i += 2;
                continue;
            }
        }
        if (code < 128) {
            result += cache[code];
            continue;
        }
        if (code >= 0xD800 && code <= 0xDFFF) {
            if (code >= 0xD800 && code <= 0xDBFF && i + 1 < l) {
                nextCode = string.charCodeAt(i + 1);
                if (nextCode >= 0xDC00 && nextCode <= 0xDFFF) {
                    result += encodeURIComponent(string[i] + string[i + 1]);
                    i++;
                    continue;
                }
            }
            result += "%EF%BF%BD";
            continue;
        }
        result += encodeURIComponent(string[i]);
    }
    return result;
}
$538971b5b904f078$var$encode$1.defaultChars = ";/?:@&=+$,-_.!~*'()#";
$538971b5b904f078$var$encode$1.componentChars = "-_.!~*'()";
var $538971b5b904f078$var$encode_1 = $538971b5b904f078$var$encode$1;
var $538971b5b904f078$var$revert_1 = $538971b5b904f078$var$revert;
// Return the content of a reference without definition as Markdown.
function $538971b5b904f078$var$revert(h, node) {
    var subtype = node.referenceType;
    var suffix = "]";
    var contents;
    var head;
    var tail;
    if (subtype === "collapsed") suffix += "[]";
    else if (subtype === "full") suffix += "[" + (node.label || node.identifier) + "]";
    if (node.type === "imageReference") return $538971b5b904f078$var$unistBuilder("text", "![" + node.alt + suffix);
    contents = $538971b5b904f078$var$all_1$1(h, node);
    head = contents[0];
    if (head && head.type === "text") head.value = "[" + head.value;
    else contents.unshift($538971b5b904f078$var$unistBuilder("text", "["));
    tail = contents[contents.length - 1];
    if (tail && tail.type === "text") tail.value += suffix;
    else contents.push($538971b5b904f078$var$unistBuilder("text", suffix));
    return contents;
}
var $538971b5b904f078$var$imageReference_1 = $538971b5b904f078$var$imageReference;
function $538971b5b904f078$var$imageReference(h, node) {
    var def = h.definition(node.identifier);
    var props;
    if (!def) return $538971b5b904f078$var$revert_1(h, node);
    props = {
        src: $538971b5b904f078$var$encode_1(def.url || ""),
        alt: node.alt
    };
    if (def.title !== null && def.title !== undefined) props.title = def.title;
    return h(node, "img", props);
}
var $538971b5b904f078$var$image_1 = $538971b5b904f078$var$image$1;
function $538971b5b904f078$var$image$1(h, node) {
    var props = {
        src: $538971b5b904f078$var$encode_1(node.url),
        alt: node.alt
    };
    if (node.title !== null && node.title !== undefined) props.title = node.title;
    return h(node, "img", props);
}
var $538971b5b904f078$var$inlineCode_1 = $538971b5b904f078$var$inlineCode;
function $538971b5b904f078$var$inlineCode(h, node) {
    return h(node, "code", [
        $538971b5b904f078$var$unistBuilder("text", $538971b5b904f078$var$collapseWhiteSpace(node.value))
    ]);
}
var $538971b5b904f078$var$linkReference_1 = $538971b5b904f078$var$linkReference;
function $538971b5b904f078$var$linkReference(h, node) {
    var def = h.definition(node.identifier);
    var props;
    if (!def) return $538971b5b904f078$var$revert_1(h, node);
    props = {
        href: $538971b5b904f078$var$encode_1(def.url || "")
    };
    if (def.title !== null && def.title !== undefined) props.title = def.title;
    return h(node, "a", props, $538971b5b904f078$var$all_1$1(h, node));
}
var $538971b5b904f078$var$link_1 = $538971b5b904f078$var$link;
function $538971b5b904f078$var$link(h, node) {
    var props = {
        href: $538971b5b904f078$var$encode_1(node.url)
    };
    if (node.title !== null && node.title !== undefined) props.title = node.title;
    return h(node, "a", props, $538971b5b904f078$var$all_1$1(h, node));
}
var $538971b5b904f078$var$listItem_1 = $538971b5b904f078$var$listItem$1;
function $538971b5b904f078$var$listItem$1(h, node, parent) {
    var children = node.children;
    var head = children[0];
    var raw = $538971b5b904f078$var$all_1$1(h, node);
    var loose = parent ? $538971b5b904f078$var$listLoose(parent) : $538971b5b904f078$var$listItemLoose(node);
    var props = {};
    var result;
    var container;
    var index;
    var length;
    var child;
    // Tight lists should not render `paragraph` nodes as `p` elements.
    if (loose) result = raw;
    else {
        result = [];
        length = raw.length;
        index = -1;
        while(++index < length){
            child = raw[index];
            if (child.tagName === "p") result = result.concat(child.children);
            else result.push(child);
        }
    }
    if (typeof node.checked === "boolean") {
        if (loose && (!head || head.type !== "paragraph")) result.unshift(h(null, "p", []));
        container = loose ? result[0].children : result;
        if (container.length !== 0) container.unshift($538971b5b904f078$var$unistBuilder("text", " "));
        container.unshift(h(null, "input", {
            type: "checkbox",
            checked: node.checked,
            disabled: true
        }));
        // According to github-markdown-css, this class hides bullet.
        // See: <https://github.com/sindresorhus/github-markdown-css>.
        props.className = [
            "task-list-item"
        ];
    }
    if (loose && result.length !== 0) result = $538971b5b904f078$var$wrap_1(result, true);
    return h(node, "li", props, result);
}
function $538971b5b904f078$var$listLoose(node) {
    var loose = node.spread;
    var children = node.children;
    var length = children.length;
    var index = -1;
    while(!loose && ++index < length)loose = $538971b5b904f078$var$listItemLoose(children[index]);
    return loose;
}
function $538971b5b904f078$var$listItemLoose(node) {
    var spread = node.spread;
    return spread === undefined || spread === null ? node.children.length > 1 : spread;
}
var $538971b5b904f078$var$paragraph_1 = $538971b5b904f078$var$paragraph;
function $538971b5b904f078$var$paragraph(h, node) {
    return h(node, "p", $538971b5b904f078$var$all_1$1(h, node));
}
var $538971b5b904f078$var$root_1 = $538971b5b904f078$var$root;
function $538971b5b904f078$var$root(h, node) {
    return h.augment(node, $538971b5b904f078$var$unistBuilder("root", $538971b5b904f078$var$wrap_1($538971b5b904f078$var$all_1$1(h, node))));
}
var $538971b5b904f078$var$strong_1 = $538971b5b904f078$var$strong;
function $538971b5b904f078$var$strong(h, node) {
    return h(node, "strong", $538971b5b904f078$var$all_1$1(h, node));
}
var $538971b5b904f078$var$table_1 = $538971b5b904f078$var$table;
function $538971b5b904f078$var$table(h, node) {
    var rows = node.children;
    var index = rows.length;
    var align = node.align;
    var alignLength = align.length;
    var result = [];
    var pos;
    var row;
    var out;
    var name;
    var cell;
    while(index--){
        row = rows[index].children;
        name = index === 0 ? "th" : "td";
        pos = alignLength;
        out = [];
        while(pos--){
            cell = row[pos];
            out[pos] = h(cell, name, {
                align: align[pos]
            }, cell ? $538971b5b904f078$var$all_1$1(h, cell) : []);
        }
        result[index] = h(rows[index], "tr", $538971b5b904f078$var$wrap_1(out, true));
    }
    return h(node, "table", $538971b5b904f078$var$wrap_1([
        h(result[0].position, "thead", $538971b5b904f078$var$wrap_1([
            result[0]
        ], true)),
        h({
            start: $538971b5b904f078$var$unistUtilPosition.start(result[1]),
            end: $538971b5b904f078$var$unistUtilPosition.end(result[result.length - 1])
        }, "tbody", $538971b5b904f078$var$wrap_1(result.slice(1), true))
    ], true));
}
var $538971b5b904f078$var$trimLines_1 = $538971b5b904f078$var$trimLines;
var $538971b5b904f078$var$ws = /[ \t]*\n+[ \t]*/g;
var $538971b5b904f078$var$newline$1 = "\n";
function $538971b5b904f078$var$trimLines(value) {
    return String(value).replace($538971b5b904f078$var$ws, $538971b5b904f078$var$newline$1);
}
var $538971b5b904f078$var$text_1$1 = $538971b5b904f078$var$text$1;
function $538971b5b904f078$var$text$1(h, node) {
    return h.augment(node, $538971b5b904f078$var$unistBuilder("text", $538971b5b904f078$var$trimLines_1(node.value)));
}
var $538971b5b904f078$var$handlers$1 = {
    blockquote: $538971b5b904f078$var$blockquote_1,
    break: $538971b5b904f078$var$_break,
    code: $538971b5b904f078$var$code_1,
    delete: $538971b5b904f078$var$_delete,
    emphasis: $538971b5b904f078$var$emphasis_1,
    footnoteReference: $538971b5b904f078$var$footnoteReference_1,
    footnote: $538971b5b904f078$var$footnote_1,
    heading: $538971b5b904f078$var$heading_1,
    html: $538971b5b904f078$var$html_1$1,
    imageReference: $538971b5b904f078$var$imageReference_1,
    image: $538971b5b904f078$var$image_1,
    inlineCode: $538971b5b904f078$var$inlineCode_1,
    linkReference: $538971b5b904f078$var$linkReference_1,
    link: $538971b5b904f078$var$link_1,
    listItem: $538971b5b904f078$var$listItem_1,
    list: $538971b5b904f078$var$list_1,
    paragraph: $538971b5b904f078$var$paragraph_1,
    root: $538971b5b904f078$var$root_1,
    strong: $538971b5b904f078$var$strong_1,
    table: $538971b5b904f078$var$table_1,
    text: $538971b5b904f078$var$text_1$1,
    thematicBreak: $538971b5b904f078$var$thematicBreak_1,
    toml: $538971b5b904f078$var$ignore,
    yaml: $538971b5b904f078$var$ignore,
    definition: $538971b5b904f078$var$ignore,
    footnoteDefinition: $538971b5b904f078$var$ignore
};
// Return nothing for nodes that are ignored.
function $538971b5b904f078$var$ignore() {
    return null;
}
var $538971b5b904f078$var$lib$2 = $538971b5b904f078$var$toHast;
var $538971b5b904f078$var$own$6 = {}.hasOwnProperty;
var $538971b5b904f078$var$deprecationWarningIssued = false;
// Factory to transform.
function $538971b5b904f078$var$factory(tree, options) {
    var settings = options || {};
    // Issue a warning if the deprecated tag 'allowDangerousHTML' is used
    if (settings.allowDangerousHTML !== undefined && !$538971b5b904f078$var$deprecationWarningIssued) {
        $538971b5b904f078$var$deprecationWarningIssued = true;
        console.warn("mdast-util-to-hast: deprecation: `allowDangerousHTML` is nonstandard, use `allowDangerousHtml` instead");
    }
    var dangerous = settings.allowDangerousHtml || settings.allowDangerousHTML;
    var footnoteById = {};
    h.dangerous = dangerous;
    h.definition = $538971b5b904f078$var$mdastUtilDefinitions(tree, settings);
    h.footnoteById = footnoteById;
    h.footnoteOrder = [];
    h.augment = augment;
    h.handlers = Object.assign({}, $538971b5b904f078$var$handlers$1, settings.handlers);
    h.unknownHandler = settings.unknownHandler;
    $538971b5b904f078$var$unistUtilVisit(tree, "footnoteDefinition", onfootnotedefinition);
    return h;
    // Finalise the created `right`, a hast node, from `left`, an mdast node.
    function augment(left, right) {
        var data;
        var ctx;
        // Handle `data.hName`, `data.hProperties, `data.hChildren`.
        if (left && "data" in left) {
            data = left.data;
            if (right.type === "element" && data.hName) right.tagName = data.hName;
            if (right.type === "element" && data.hProperties) right.properties = Object.assign({}, right.properties, data.hProperties);
            if (right.children && data.hChildren) right.children = data.hChildren;
        }
        ctx = left && left.position ? left : {
            position: left
        };
        if (!$538971b5b904f078$var$unistUtilGenerated(ctx)) right.position = {
            start: $538971b5b904f078$var$unistUtilPosition.start(ctx),
            end: $538971b5b904f078$var$unistUtilPosition.end(ctx)
        };
        return right;
    }
    // Create an element for `node`.
    function h(node, tagName, props, children) {
        if ((children === undefined || children === null) && typeof props === "object" && "length" in props) {
            children = props;
            props = {};
        }
        return augment(node, {
            type: "element",
            tagName: tagName,
            properties: props || {},
            children: children || []
        });
    }
    function onfootnotedefinition(definition) {
        var id = String(definition.identifier).toUpperCase();
        // Mimick CM behavior of link definitions.
        // See: <https://github.com/syntax-tree/mdast-util-definitions/blob/8d48e57/index.js#L26>.
        if (!$538971b5b904f078$var$own$6.call(footnoteById, id)) footnoteById[id] = definition;
    }
}
// Transform `tree`, which is an mdast node, to a hast node.
function $538971b5b904f078$var$toHast(tree, options) {
    var h = $538971b5b904f078$var$factory(tree, options);
    var node = $538971b5b904f078$var$one_1$1(h, tree);
    var foot = $538971b5b904f078$var$footer(h);
    if (foot) node.children = node.children.concat($538971b5b904f078$var$unistBuilder("text", "\n"), foot);
    return node;
}
var $538971b5b904f078$var$mdastUtilToHast = $538971b5b904f078$var$lib$2;
var $538971b5b904f078$var$remarkRehype = $538971b5b904f078$var$remark2rehype;
// Attacher.
// If a destination is given, runs the destination with the new hast tree
// (bridge mode).
// Without destination, returns the tree: further plugins run on that tree
// (mutate mode).
function $538971b5b904f078$var$remark2rehype(destination, options) {
    if (destination && !destination.process) {
        options = destination;
        destination = null;
    }
    return destination ? $538971b5b904f078$var$bridge(destination, options) : $538971b5b904f078$var$mutate(options);
}
// Bridge mode.
// Runs the destination with the new hast tree.
function $538971b5b904f078$var$bridge(destination, options) {
    return transformer;
    function transformer(node, file, next) {
        destination.run($538971b5b904f078$var$mdastUtilToHast(node, options), file, done);
        function done(err) {
            next(err);
        }
    }
}
// Mutate-mode.
// Further transformers run on the hast tree.
function $538971b5b904f078$var$mutate(options) {
    return transformer;
    function transformer(node) {
        return $538971b5b904f078$var$mdastUtilToHast(node, options);
    }
}
var $538971b5b904f078$var$schema$1 = $538971b5b904f078$var$Schema$2;
var $538971b5b904f078$var$proto$2 = $538971b5b904f078$var$Schema$2.prototype;
$538971b5b904f078$var$proto$2.space = null;
$538971b5b904f078$var$proto$2.normal = {};
$538971b5b904f078$var$proto$2.property = {};
function $538971b5b904f078$var$Schema$2(property, normal, space) {
    this.property = property;
    this.normal = normal;
    if (space) this.space = space;
}
var $538971b5b904f078$var$merge_1 = $538971b5b904f078$var$merge$1;
function $538971b5b904f078$var$merge$1(definitions) {
    var length = definitions.length;
    var property = [];
    var normal = [];
    var index = -1;
    var info;
    var space;
    while(++index < length){
        info = definitions[index];
        property.push(info.property);
        normal.push(info.normal);
        space = info.space;
    }
    return new $538971b5b904f078$var$schema$1($538971b5b904f078$var$immutable.apply(null, property), $538971b5b904f078$var$immutable.apply(null, normal), space);
}
var $538971b5b904f078$var$normalize_1 = $538971b5b904f078$var$normalize;
function $538971b5b904f078$var$normalize(value) {
    return value.toLowerCase();
}
var $538971b5b904f078$var$info = $538971b5b904f078$var$Info;
var $538971b5b904f078$var$proto$1 = $538971b5b904f078$var$Info.prototype;
$538971b5b904f078$var$proto$1.space = null;
$538971b5b904f078$var$proto$1.attribute = null;
$538971b5b904f078$var$proto$1.property = null;
$538971b5b904f078$var$proto$1.boolean = false;
$538971b5b904f078$var$proto$1.booleanish = false;
$538971b5b904f078$var$proto$1.overloadedBoolean = false;
$538971b5b904f078$var$proto$1.number = false;
$538971b5b904f078$var$proto$1.commaSeparated = false;
$538971b5b904f078$var$proto$1.spaceSeparated = false;
$538971b5b904f078$var$proto$1.commaOrSpaceSeparated = false;
$538971b5b904f078$var$proto$1.mustUseProperty = false;
$538971b5b904f078$var$proto$1.defined = false;
function $538971b5b904f078$var$Info(property, attribute) {
    this.property = property;
    this.attribute = attribute;
}
var $538971b5b904f078$var$powers = 0;
var $538971b5b904f078$var$boolean_1 = $538971b5b904f078$var$increment();
var $538971b5b904f078$var$booleanish$2 = $538971b5b904f078$var$increment();
var $538971b5b904f078$var$overloadedBoolean$1 = $538971b5b904f078$var$increment();
var $538971b5b904f078$var$number$3 = $538971b5b904f078$var$increment();
var $538971b5b904f078$var$spaceSeparated$3 = $538971b5b904f078$var$increment();
var $538971b5b904f078$var$commaSeparated$2 = $538971b5b904f078$var$increment();
var $538971b5b904f078$var$commaOrSpaceSeparated$1 = $538971b5b904f078$var$increment();
function $538971b5b904f078$var$increment() {
    return Math.pow(2, ++$538971b5b904f078$var$powers);
}
var $538971b5b904f078$var$types = {
    boolean: $538971b5b904f078$var$boolean_1,
    booleanish: $538971b5b904f078$var$booleanish$2,
    overloadedBoolean: $538971b5b904f078$var$overloadedBoolean$1,
    number: $538971b5b904f078$var$number$3,
    spaceSeparated: $538971b5b904f078$var$spaceSeparated$3,
    commaSeparated: $538971b5b904f078$var$commaSeparated$2,
    commaOrSpaceSeparated: $538971b5b904f078$var$commaOrSpaceSeparated$1
};
var $538971b5b904f078$var$definedInfo = $538971b5b904f078$var$DefinedInfo;
$538971b5b904f078$var$DefinedInfo.prototype = new $538971b5b904f078$var$info();
$538971b5b904f078$var$DefinedInfo.prototype.defined = true;
var $538971b5b904f078$var$checks = [
    "boolean",
    "booleanish",
    "overloadedBoolean",
    "number",
    "commaSeparated",
    "spaceSeparated",
    "commaOrSpaceSeparated"
];
var $538971b5b904f078$var$checksLength = $538971b5b904f078$var$checks.length;
function $538971b5b904f078$var$DefinedInfo(property, attribute, mask, space) {
    var index = -1;
    var check;
    $538971b5b904f078$var$mark$1(this, "space", space);
    $538971b5b904f078$var$info.call(this, property, attribute);
    while(++index < $538971b5b904f078$var$checksLength){
        check = $538971b5b904f078$var$checks[index];
        $538971b5b904f078$var$mark$1(this, check, (mask & $538971b5b904f078$var$types[check]) === $538971b5b904f078$var$types[check]);
    }
}
function $538971b5b904f078$var$mark$1(values, key, value) {
    if (value) values[key] = value;
}
var $538971b5b904f078$var$create_1 = $538971b5b904f078$var$create;
function $538971b5b904f078$var$create(definition) {
    var space = definition.space;
    var mustUseProperty = definition.mustUseProperty || [];
    var attributes = definition.attributes || {};
    var props = definition.properties;
    var transform = definition.transform;
    var property = {};
    var normal = {};
    var prop;
    var info;
    for(prop in props){
        info = new $538971b5b904f078$var$definedInfo(prop, transform(attributes, prop), props[prop], space);
        if (mustUseProperty.indexOf(prop) !== -1) info.mustUseProperty = true;
        property[prop] = info;
        normal[$538971b5b904f078$var$normalize_1(prop)] = prop;
        normal[$538971b5b904f078$var$normalize_1(info.attribute)] = prop;
    }
    return new $538971b5b904f078$var$schema$1(property, normal, space);
}
var $538971b5b904f078$var$xlink = $538971b5b904f078$var$create_1({
    space: "xlink",
    transform: $538971b5b904f078$var$xlinkTransform,
    properties: {
        xLinkActuate: null,
        xLinkArcRole: null,
        xLinkHref: null,
        xLinkRole: null,
        xLinkShow: null,
        xLinkTitle: null,
        xLinkType: null
    }
});
function $538971b5b904f078$var$xlinkTransform(_, prop) {
    return "xlink:" + prop.slice(5).toLowerCase();
}
var $538971b5b904f078$var$xml = $538971b5b904f078$var$create_1({
    space: "xml",
    transform: $538971b5b904f078$var$xmlTransform,
    properties: {
        xmlLang: null,
        xmlBase: null,
        xmlSpace: null
    }
});
function $538971b5b904f078$var$xmlTransform(_, prop) {
    return "xml:" + prop.slice(3).toLowerCase();
}
var $538971b5b904f078$var$caseSensitiveTransform_1 = $538971b5b904f078$var$caseSensitiveTransform;
function $538971b5b904f078$var$caseSensitiveTransform(attributes, attribute) {
    return attribute in attributes ? attributes[attribute] : attribute;
}
var $538971b5b904f078$var$caseInsensitiveTransform_1 = $538971b5b904f078$var$caseInsensitiveTransform;
function $538971b5b904f078$var$caseInsensitiveTransform(attributes, property) {
    return $538971b5b904f078$var$caseSensitiveTransform_1(attributes, property.toLowerCase());
}
var $538971b5b904f078$var$xmlns = $538971b5b904f078$var$create_1({
    space: "xmlns",
    attributes: {
        xmlnsxlink: "xmlns:xlink"
    },
    transform: $538971b5b904f078$var$caseInsensitiveTransform_1,
    properties: {
        xmlns: null,
        xmlnsXLink: null
    }
});
var $538971b5b904f078$var$booleanish$1 = $538971b5b904f078$var$types.booleanish;
var $538971b5b904f078$var$number$2 = $538971b5b904f078$var$types.number;
var $538971b5b904f078$var$spaceSeparated$2 = $538971b5b904f078$var$types.spaceSeparated;
var $538971b5b904f078$var$aria = $538971b5b904f078$var$create_1({
    transform: $538971b5b904f078$var$ariaTransform,
    properties: {
        ariaActiveDescendant: null,
        ariaAtomic: $538971b5b904f078$var$booleanish$1,
        ariaAutoComplete: null,
        ariaBusy: $538971b5b904f078$var$booleanish$1,
        ariaChecked: $538971b5b904f078$var$booleanish$1,
        ariaColCount: $538971b5b904f078$var$number$2,
        ariaColIndex: $538971b5b904f078$var$number$2,
        ariaColSpan: $538971b5b904f078$var$number$2,
        ariaControls: $538971b5b904f078$var$spaceSeparated$2,
        ariaCurrent: null,
        ariaDescribedBy: $538971b5b904f078$var$spaceSeparated$2,
        ariaDetails: null,
        ariaDisabled: $538971b5b904f078$var$booleanish$1,
        ariaDropEffect: $538971b5b904f078$var$spaceSeparated$2,
        ariaErrorMessage: null,
        ariaExpanded: $538971b5b904f078$var$booleanish$1,
        ariaFlowTo: $538971b5b904f078$var$spaceSeparated$2,
        ariaGrabbed: $538971b5b904f078$var$booleanish$1,
        ariaHasPopup: null,
        ariaHidden: $538971b5b904f078$var$booleanish$1,
        ariaInvalid: null,
        ariaKeyShortcuts: null,
        ariaLabel: null,
        ariaLabelledBy: $538971b5b904f078$var$spaceSeparated$2,
        ariaLevel: $538971b5b904f078$var$number$2,
        ariaLive: null,
        ariaModal: $538971b5b904f078$var$booleanish$1,
        ariaMultiLine: $538971b5b904f078$var$booleanish$1,
        ariaMultiSelectable: $538971b5b904f078$var$booleanish$1,
        ariaOrientation: null,
        ariaOwns: $538971b5b904f078$var$spaceSeparated$2,
        ariaPlaceholder: null,
        ariaPosInSet: $538971b5b904f078$var$number$2,
        ariaPressed: $538971b5b904f078$var$booleanish$1,
        ariaReadOnly: $538971b5b904f078$var$booleanish$1,
        ariaRelevant: null,
        ariaRequired: $538971b5b904f078$var$booleanish$1,
        ariaRoleDescription: $538971b5b904f078$var$spaceSeparated$2,
        ariaRowCount: $538971b5b904f078$var$number$2,
        ariaRowIndex: $538971b5b904f078$var$number$2,
        ariaRowSpan: $538971b5b904f078$var$number$2,
        ariaSelected: $538971b5b904f078$var$booleanish$1,
        ariaSetSize: $538971b5b904f078$var$number$2,
        ariaSort: null,
        ariaValueMax: $538971b5b904f078$var$number$2,
        ariaValueMin: $538971b5b904f078$var$number$2,
        ariaValueNow: $538971b5b904f078$var$number$2,
        ariaValueText: null,
        role: null
    }
});
function $538971b5b904f078$var$ariaTransform(_, prop) {
    return prop === "role" ? prop : "aria-" + prop.slice(4).toLowerCase();
}
var $538971b5b904f078$var$boolean$1 = $538971b5b904f078$var$types.boolean;
var $538971b5b904f078$var$overloadedBoolean = $538971b5b904f078$var$types.overloadedBoolean;
var $538971b5b904f078$var$booleanish = $538971b5b904f078$var$types.booleanish;
var $538971b5b904f078$var$number$1 = $538971b5b904f078$var$types.number;
var $538971b5b904f078$var$spaceSeparated$1 = $538971b5b904f078$var$types.spaceSeparated;
var $538971b5b904f078$var$commaSeparated$1 = $538971b5b904f078$var$types.commaSeparated;
var $538971b5b904f078$var$html$2 = $538971b5b904f078$var$create_1({
    space: "html",
    attributes: {
        acceptcharset: "accept-charset",
        classname: "class",
        htmlfor: "for",
        httpequiv: "http-equiv"
    },
    transform: $538971b5b904f078$var$caseInsensitiveTransform_1,
    mustUseProperty: [
        "checked",
        "multiple",
        "muted",
        "selected"
    ],
    properties: {
        // Standard Properties.
        abbr: null,
        accept: $538971b5b904f078$var$commaSeparated$1,
        acceptCharset: $538971b5b904f078$var$spaceSeparated$1,
        accessKey: $538971b5b904f078$var$spaceSeparated$1,
        action: null,
        allow: null,
        allowFullScreen: $538971b5b904f078$var$boolean$1,
        allowPaymentRequest: $538971b5b904f078$var$boolean$1,
        allowUserMedia: $538971b5b904f078$var$boolean$1,
        alt: null,
        as: null,
        async: $538971b5b904f078$var$boolean$1,
        autoCapitalize: null,
        autoComplete: $538971b5b904f078$var$spaceSeparated$1,
        autoFocus: $538971b5b904f078$var$boolean$1,
        autoPlay: $538971b5b904f078$var$boolean$1,
        capture: $538971b5b904f078$var$boolean$1,
        charSet: null,
        checked: $538971b5b904f078$var$boolean$1,
        cite: null,
        className: $538971b5b904f078$var$spaceSeparated$1,
        cols: $538971b5b904f078$var$number$1,
        colSpan: null,
        content: null,
        contentEditable: $538971b5b904f078$var$booleanish,
        controls: $538971b5b904f078$var$boolean$1,
        controlsList: $538971b5b904f078$var$spaceSeparated$1,
        coords: $538971b5b904f078$var$number$1 | $538971b5b904f078$var$commaSeparated$1,
        crossOrigin: null,
        data: null,
        dateTime: null,
        decoding: null,
        default: $538971b5b904f078$var$boolean$1,
        defer: $538971b5b904f078$var$boolean$1,
        dir: null,
        dirName: null,
        disabled: $538971b5b904f078$var$boolean$1,
        download: $538971b5b904f078$var$overloadedBoolean,
        draggable: $538971b5b904f078$var$booleanish,
        encType: null,
        enterKeyHint: null,
        form: null,
        formAction: null,
        formEncType: null,
        formMethod: null,
        formNoValidate: $538971b5b904f078$var$boolean$1,
        formTarget: null,
        headers: $538971b5b904f078$var$spaceSeparated$1,
        height: $538971b5b904f078$var$number$1,
        hidden: $538971b5b904f078$var$boolean$1,
        high: $538971b5b904f078$var$number$1,
        href: null,
        hrefLang: null,
        htmlFor: $538971b5b904f078$var$spaceSeparated$1,
        httpEquiv: $538971b5b904f078$var$spaceSeparated$1,
        id: null,
        imageSizes: null,
        imageSrcSet: $538971b5b904f078$var$commaSeparated$1,
        inputMode: null,
        integrity: null,
        is: null,
        isMap: $538971b5b904f078$var$boolean$1,
        itemId: null,
        itemProp: $538971b5b904f078$var$spaceSeparated$1,
        itemRef: $538971b5b904f078$var$spaceSeparated$1,
        itemScope: $538971b5b904f078$var$boolean$1,
        itemType: $538971b5b904f078$var$spaceSeparated$1,
        kind: null,
        label: null,
        lang: null,
        language: null,
        list: null,
        loop: $538971b5b904f078$var$boolean$1,
        low: $538971b5b904f078$var$number$1,
        manifest: null,
        max: null,
        maxLength: $538971b5b904f078$var$number$1,
        media: null,
        method: null,
        min: null,
        minLength: $538971b5b904f078$var$number$1,
        multiple: $538971b5b904f078$var$boolean$1,
        muted: $538971b5b904f078$var$boolean$1,
        name: null,
        nonce: null,
        noModule: $538971b5b904f078$var$boolean$1,
        noValidate: $538971b5b904f078$var$boolean$1,
        onAbort: null,
        onAfterPrint: null,
        onAuxClick: null,
        onBeforePrint: null,
        onBeforeUnload: null,
        onBlur: null,
        onCancel: null,
        onCanPlay: null,
        onCanPlayThrough: null,
        onChange: null,
        onClick: null,
        onClose: null,
        onContextMenu: null,
        onCopy: null,
        onCueChange: null,
        onCut: null,
        onDblClick: null,
        onDrag: null,
        onDragEnd: null,
        onDragEnter: null,
        onDragExit: null,
        onDragLeave: null,
        onDragOver: null,
        onDragStart: null,
        onDrop: null,
        onDurationChange: null,
        onEmptied: null,
        onEnded: null,
        onError: null,
        onFocus: null,
        onFormData: null,
        onHashChange: null,
        onInput: null,
        onInvalid: null,
        onKeyDown: null,
        onKeyPress: null,
        onKeyUp: null,
        onLanguageChange: null,
        onLoad: null,
        onLoadedData: null,
        onLoadedMetadata: null,
        onLoadEnd: null,
        onLoadStart: null,
        onMessage: null,
        onMessageError: null,
        onMouseDown: null,
        onMouseEnter: null,
        onMouseLeave: null,
        onMouseMove: null,
        onMouseOut: null,
        onMouseOver: null,
        onMouseUp: null,
        onOffline: null,
        onOnline: null,
        onPageHide: null,
        onPageShow: null,
        onPaste: null,
        onPause: null,
        onPlay: null,
        onPlaying: null,
        onPopState: null,
        onProgress: null,
        onRateChange: null,
        onRejectionHandled: null,
        onReset: null,
        onResize: null,
        onScroll: null,
        onSecurityPolicyViolation: null,
        onSeeked: null,
        onSeeking: null,
        onSelect: null,
        onSlotChange: null,
        onStalled: null,
        onStorage: null,
        onSubmit: null,
        onSuspend: null,
        onTimeUpdate: null,
        onToggle: null,
        onUnhandledRejection: null,
        onUnload: null,
        onVolumeChange: null,
        onWaiting: null,
        onWheel: null,
        open: $538971b5b904f078$var$boolean$1,
        optimum: $538971b5b904f078$var$number$1,
        pattern: null,
        ping: $538971b5b904f078$var$spaceSeparated$1,
        placeholder: null,
        playsInline: $538971b5b904f078$var$boolean$1,
        poster: null,
        preload: null,
        readOnly: $538971b5b904f078$var$boolean$1,
        referrerPolicy: null,
        rel: $538971b5b904f078$var$spaceSeparated$1,
        required: $538971b5b904f078$var$boolean$1,
        reversed: $538971b5b904f078$var$boolean$1,
        rows: $538971b5b904f078$var$number$1,
        rowSpan: $538971b5b904f078$var$number$1,
        sandbox: $538971b5b904f078$var$spaceSeparated$1,
        scope: null,
        scoped: $538971b5b904f078$var$boolean$1,
        seamless: $538971b5b904f078$var$boolean$1,
        selected: $538971b5b904f078$var$boolean$1,
        shape: null,
        size: $538971b5b904f078$var$number$1,
        sizes: null,
        slot: null,
        span: $538971b5b904f078$var$number$1,
        spellCheck: $538971b5b904f078$var$booleanish,
        src: null,
        srcDoc: null,
        srcLang: null,
        srcSet: $538971b5b904f078$var$commaSeparated$1,
        start: $538971b5b904f078$var$number$1,
        step: null,
        style: null,
        tabIndex: $538971b5b904f078$var$number$1,
        target: null,
        title: null,
        translate: null,
        type: null,
        typeMustMatch: $538971b5b904f078$var$boolean$1,
        useMap: null,
        value: $538971b5b904f078$var$booleanish,
        width: $538971b5b904f078$var$number$1,
        wrap: null,
        // Legacy.
        // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
        align: null,
        aLink: null,
        archive: $538971b5b904f078$var$spaceSeparated$1,
        axis: null,
        background: null,
        bgColor: null,
        border: $538971b5b904f078$var$number$1,
        borderColor: null,
        bottomMargin: $538971b5b904f078$var$number$1,
        cellPadding: null,
        cellSpacing: null,
        char: null,
        charOff: null,
        classId: null,
        clear: null,
        code: null,
        codeBase: null,
        codeType: null,
        color: null,
        compact: $538971b5b904f078$var$boolean$1,
        declare: $538971b5b904f078$var$boolean$1,
        event: null,
        face: null,
        frame: null,
        frameBorder: null,
        hSpace: $538971b5b904f078$var$number$1,
        leftMargin: $538971b5b904f078$var$number$1,
        link: null,
        longDesc: null,
        lowSrc: null,
        marginHeight: $538971b5b904f078$var$number$1,
        marginWidth: $538971b5b904f078$var$number$1,
        noResize: $538971b5b904f078$var$boolean$1,
        noHref: $538971b5b904f078$var$boolean$1,
        noShade: $538971b5b904f078$var$boolean$1,
        noWrap: $538971b5b904f078$var$boolean$1,
        object: null,
        profile: null,
        prompt: null,
        rev: null,
        rightMargin: $538971b5b904f078$var$number$1,
        rules: null,
        scheme: null,
        scrolling: $538971b5b904f078$var$booleanish,
        standby: null,
        summary: null,
        text: null,
        topMargin: $538971b5b904f078$var$number$1,
        valueType: null,
        version: null,
        vAlign: null,
        vLink: null,
        vSpace: $538971b5b904f078$var$number$1,
        // Non-standard Properties.
        allowTransparency: null,
        autoCorrect: null,
        autoSave: null,
        disablePictureInPicture: $538971b5b904f078$var$boolean$1,
        disableRemotePlayback: $538971b5b904f078$var$boolean$1,
        prefix: null,
        property: null,
        results: $538971b5b904f078$var$number$1,
        security: null,
        unselectable: null
    }
});
var $538971b5b904f078$var$html_1 = $538971b5b904f078$var$merge_1([
    $538971b5b904f078$var$xml,
    $538971b5b904f078$var$xlink,
    $538971b5b904f078$var$xmlns,
    $538971b5b904f078$var$aria,
    $538971b5b904f078$var$html$2
]);
var $538971b5b904f078$var$boolean = $538971b5b904f078$var$types.boolean;
var $538971b5b904f078$var$number = $538971b5b904f078$var$types.number;
var $538971b5b904f078$var$spaceSeparated = $538971b5b904f078$var$types.spaceSeparated;
var $538971b5b904f078$var$commaSeparated = $538971b5b904f078$var$types.commaSeparated;
var $538971b5b904f078$var$commaOrSpaceSeparated = $538971b5b904f078$var$types.commaOrSpaceSeparated;
var $538971b5b904f078$var$svg = $538971b5b904f078$var$create_1({
    space: "svg",
    attributes: {
        accentHeight: "accent-height",
        alignmentBaseline: "alignment-baseline",
        arabicForm: "arabic-form",
        baselineShift: "baseline-shift",
        capHeight: "cap-height",
        className: "class",
        clipPath: "clip-path",
        clipRule: "clip-rule",
        colorInterpolation: "color-interpolation",
        colorInterpolationFilters: "color-interpolation-filters",
        colorProfile: "color-profile",
        colorRendering: "color-rendering",
        crossOrigin: "crossorigin",
        dataType: "datatype",
        dominantBaseline: "dominant-baseline",
        enableBackground: "enable-background",
        fillOpacity: "fill-opacity",
        fillRule: "fill-rule",
        floodColor: "flood-color",
        floodOpacity: "flood-opacity",
        fontFamily: "font-family",
        fontSize: "font-size",
        fontSizeAdjust: "font-size-adjust",
        fontStretch: "font-stretch",
        fontStyle: "font-style",
        fontVariant: "font-variant",
        fontWeight: "font-weight",
        glyphName: "glyph-name",
        glyphOrientationHorizontal: "glyph-orientation-horizontal",
        glyphOrientationVertical: "glyph-orientation-vertical",
        hrefLang: "hreflang",
        horizAdvX: "horiz-adv-x",
        horizOriginX: "horiz-origin-x",
        horizOriginY: "horiz-origin-y",
        imageRendering: "image-rendering",
        letterSpacing: "letter-spacing",
        lightingColor: "lighting-color",
        markerEnd: "marker-end",
        markerMid: "marker-mid",
        markerStart: "marker-start",
        navDown: "nav-down",
        navDownLeft: "nav-down-left",
        navDownRight: "nav-down-right",
        navLeft: "nav-left",
        navNext: "nav-next",
        navPrev: "nav-prev",
        navRight: "nav-right",
        navUp: "nav-up",
        navUpLeft: "nav-up-left",
        navUpRight: "nav-up-right",
        onAbort: "onabort",
        onActivate: "onactivate",
        onAfterPrint: "onafterprint",
        onBeforePrint: "onbeforeprint",
        onBegin: "onbegin",
        onCancel: "oncancel",
        onCanPlay: "oncanplay",
        onCanPlayThrough: "oncanplaythrough",
        onChange: "onchange",
        onClick: "onclick",
        onClose: "onclose",
        onCopy: "oncopy",
        onCueChange: "oncuechange",
        onCut: "oncut",
        onDblClick: "ondblclick",
        onDrag: "ondrag",
        onDragEnd: "ondragend",
        onDragEnter: "ondragenter",
        onDragExit: "ondragexit",
        onDragLeave: "ondragleave",
        onDragOver: "ondragover",
        onDragStart: "ondragstart",
        onDrop: "ondrop",
        onDurationChange: "ondurationchange",
        onEmptied: "onemptied",
        onEnd: "onend",
        onEnded: "onended",
        onError: "onerror",
        onFocus: "onfocus",
        onFocusIn: "onfocusin",
        onFocusOut: "onfocusout",
        onHashChange: "onhashchange",
        onInput: "oninput",
        onInvalid: "oninvalid",
        onKeyDown: "onkeydown",
        onKeyPress: "onkeypress",
        onKeyUp: "onkeyup",
        onLoad: "onload",
        onLoadedData: "onloadeddata",
        onLoadedMetadata: "onloadedmetadata",
        onLoadStart: "onloadstart",
        onMessage: "onmessage",
        onMouseDown: "onmousedown",
        onMouseEnter: "onmouseenter",
        onMouseLeave: "onmouseleave",
        onMouseMove: "onmousemove",
        onMouseOut: "onmouseout",
        onMouseOver: "onmouseover",
        onMouseUp: "onmouseup",
        onMouseWheel: "onmousewheel",
        onOffline: "onoffline",
        onOnline: "ononline",
        onPageHide: "onpagehide",
        onPageShow: "onpageshow",
        onPaste: "onpaste",
        onPause: "onpause",
        onPlay: "onplay",
        onPlaying: "onplaying",
        onPopState: "onpopstate",
        onProgress: "onprogress",
        onRateChange: "onratechange",
        onRepeat: "onrepeat",
        onReset: "onreset",
        onResize: "onresize",
        onScroll: "onscroll",
        onSeeked: "onseeked",
        onSeeking: "onseeking",
        onSelect: "onselect",
        onShow: "onshow",
        onStalled: "onstalled",
        onStorage: "onstorage",
        onSubmit: "onsubmit",
        onSuspend: "onsuspend",
        onTimeUpdate: "ontimeupdate",
        onToggle: "ontoggle",
        onUnload: "onunload",
        onVolumeChange: "onvolumechange",
        onWaiting: "onwaiting",
        onZoom: "onzoom",
        overlinePosition: "overline-position",
        overlineThickness: "overline-thickness",
        paintOrder: "paint-order",
        panose1: "panose-1",
        pointerEvents: "pointer-events",
        referrerPolicy: "referrerpolicy",
        renderingIntent: "rendering-intent",
        shapeRendering: "shape-rendering",
        stopColor: "stop-color",
        stopOpacity: "stop-opacity",
        strikethroughPosition: "strikethrough-position",
        strikethroughThickness: "strikethrough-thickness",
        strokeDashArray: "stroke-dasharray",
        strokeDashOffset: "stroke-dashoffset",
        strokeLineCap: "stroke-linecap",
        strokeLineJoin: "stroke-linejoin",
        strokeMiterLimit: "stroke-miterlimit",
        strokeOpacity: "stroke-opacity",
        strokeWidth: "stroke-width",
        tabIndex: "tabindex",
        textAnchor: "text-anchor",
        textDecoration: "text-decoration",
        textRendering: "text-rendering",
        typeOf: "typeof",
        underlinePosition: "underline-position",
        underlineThickness: "underline-thickness",
        unicodeBidi: "unicode-bidi",
        unicodeRange: "unicode-range",
        unitsPerEm: "units-per-em",
        vAlphabetic: "v-alphabetic",
        vHanging: "v-hanging",
        vIdeographic: "v-ideographic",
        vMathematical: "v-mathematical",
        vectorEffect: "vector-effect",
        vertAdvY: "vert-adv-y",
        vertOriginX: "vert-origin-x",
        vertOriginY: "vert-origin-y",
        wordSpacing: "word-spacing",
        writingMode: "writing-mode",
        xHeight: "x-height",
        // These were camelcased in Tiny. Now lowercased in SVG 2
        playbackOrder: "playbackorder",
        timelineBegin: "timelinebegin"
    },
    transform: $538971b5b904f078$var$caseSensitiveTransform_1,
    properties: {
        about: $538971b5b904f078$var$commaOrSpaceSeparated,
        accentHeight: $538971b5b904f078$var$number,
        accumulate: null,
        additive: null,
        alignmentBaseline: null,
        alphabetic: $538971b5b904f078$var$number,
        amplitude: $538971b5b904f078$var$number,
        arabicForm: null,
        ascent: $538971b5b904f078$var$number,
        attributeName: null,
        attributeType: null,
        azimuth: $538971b5b904f078$var$number,
        bandwidth: null,
        baselineShift: null,
        baseFrequency: null,
        baseProfile: null,
        bbox: null,
        begin: null,
        bias: $538971b5b904f078$var$number,
        by: null,
        calcMode: null,
        capHeight: $538971b5b904f078$var$number,
        className: $538971b5b904f078$var$spaceSeparated,
        clip: null,
        clipPath: null,
        clipPathUnits: null,
        clipRule: null,
        color: null,
        colorInterpolation: null,
        colorInterpolationFilters: null,
        colorProfile: null,
        colorRendering: null,
        content: null,
        contentScriptType: null,
        contentStyleType: null,
        crossOrigin: null,
        cursor: null,
        cx: null,
        cy: null,
        d: null,
        dataType: null,
        defaultAction: null,
        descent: $538971b5b904f078$var$number,
        diffuseConstant: $538971b5b904f078$var$number,
        direction: null,
        display: null,
        dur: null,
        divisor: $538971b5b904f078$var$number,
        dominantBaseline: null,
        download: $538971b5b904f078$var$boolean,
        dx: null,
        dy: null,
        edgeMode: null,
        editable: null,
        elevation: $538971b5b904f078$var$number,
        enableBackground: null,
        end: null,
        event: null,
        exponent: $538971b5b904f078$var$number,
        externalResourcesRequired: null,
        fill: null,
        fillOpacity: $538971b5b904f078$var$number,
        fillRule: null,
        filter: null,
        filterRes: null,
        filterUnits: null,
        floodColor: null,
        floodOpacity: null,
        focusable: null,
        focusHighlight: null,
        fontFamily: null,
        fontSize: null,
        fontSizeAdjust: null,
        fontStretch: null,
        fontStyle: null,
        fontVariant: null,
        fontWeight: null,
        format: null,
        fr: null,
        from: null,
        fx: null,
        fy: null,
        g1: $538971b5b904f078$var$commaSeparated,
        g2: $538971b5b904f078$var$commaSeparated,
        glyphName: $538971b5b904f078$var$commaSeparated,
        glyphOrientationHorizontal: null,
        glyphOrientationVertical: null,
        glyphRef: null,
        gradientTransform: null,
        gradientUnits: null,
        handler: null,
        hanging: $538971b5b904f078$var$number,
        hatchContentUnits: null,
        hatchUnits: null,
        height: null,
        href: null,
        hrefLang: null,
        horizAdvX: $538971b5b904f078$var$number,
        horizOriginX: $538971b5b904f078$var$number,
        horizOriginY: $538971b5b904f078$var$number,
        id: null,
        ideographic: $538971b5b904f078$var$number,
        imageRendering: null,
        initialVisibility: null,
        in: null,
        in2: null,
        intercept: $538971b5b904f078$var$number,
        k: $538971b5b904f078$var$number,
        k1: $538971b5b904f078$var$number,
        k2: $538971b5b904f078$var$number,
        k3: $538971b5b904f078$var$number,
        k4: $538971b5b904f078$var$number,
        kernelMatrix: $538971b5b904f078$var$commaOrSpaceSeparated,
        kernelUnitLength: null,
        keyPoints: null,
        keySplines: null,
        keyTimes: null,
        kerning: null,
        lang: null,
        lengthAdjust: null,
        letterSpacing: null,
        lightingColor: null,
        limitingConeAngle: $538971b5b904f078$var$number,
        local: null,
        markerEnd: null,
        markerMid: null,
        markerStart: null,
        markerHeight: null,
        markerUnits: null,
        markerWidth: null,
        mask: null,
        maskContentUnits: null,
        maskUnits: null,
        mathematical: null,
        max: null,
        media: null,
        mediaCharacterEncoding: null,
        mediaContentEncodings: null,
        mediaSize: $538971b5b904f078$var$number,
        mediaTime: null,
        method: null,
        min: null,
        mode: null,
        name: null,
        navDown: null,
        navDownLeft: null,
        navDownRight: null,
        navLeft: null,
        navNext: null,
        navPrev: null,
        navRight: null,
        navUp: null,
        navUpLeft: null,
        navUpRight: null,
        numOctaves: null,
        observer: null,
        offset: null,
        onAbort: null,
        onActivate: null,
        onAfterPrint: null,
        onBeforePrint: null,
        onBegin: null,
        onCancel: null,
        onCanPlay: null,
        onCanPlayThrough: null,
        onChange: null,
        onClick: null,
        onClose: null,
        onCopy: null,
        onCueChange: null,
        onCut: null,
        onDblClick: null,
        onDrag: null,
        onDragEnd: null,
        onDragEnter: null,
        onDragExit: null,
        onDragLeave: null,
        onDragOver: null,
        onDragStart: null,
        onDrop: null,
        onDurationChange: null,
        onEmptied: null,
        onEnd: null,
        onEnded: null,
        onError: null,
        onFocus: null,
        onFocusIn: null,
        onFocusOut: null,
        onHashChange: null,
        onInput: null,
        onInvalid: null,
        onKeyDown: null,
        onKeyPress: null,
        onKeyUp: null,
        onLoad: null,
        onLoadedData: null,
        onLoadedMetadata: null,
        onLoadStart: null,
        onMessage: null,
        onMouseDown: null,
        onMouseEnter: null,
        onMouseLeave: null,
        onMouseMove: null,
        onMouseOut: null,
        onMouseOver: null,
        onMouseUp: null,
        onMouseWheel: null,
        onOffline: null,
        onOnline: null,
        onPageHide: null,
        onPageShow: null,
        onPaste: null,
        onPause: null,
        onPlay: null,
        onPlaying: null,
        onPopState: null,
        onProgress: null,
        onRateChange: null,
        onRepeat: null,
        onReset: null,
        onResize: null,
        onScroll: null,
        onSeeked: null,
        onSeeking: null,
        onSelect: null,
        onShow: null,
        onStalled: null,
        onStorage: null,
        onSubmit: null,
        onSuspend: null,
        onTimeUpdate: null,
        onToggle: null,
        onUnload: null,
        onVolumeChange: null,
        onWaiting: null,
        onZoom: null,
        opacity: null,
        operator: null,
        order: null,
        orient: null,
        orientation: null,
        origin: null,
        overflow: null,
        overlay: null,
        overlinePosition: $538971b5b904f078$var$number,
        overlineThickness: $538971b5b904f078$var$number,
        paintOrder: null,
        panose1: null,
        path: null,
        pathLength: $538971b5b904f078$var$number,
        patternContentUnits: null,
        patternTransform: null,
        patternUnits: null,
        phase: null,
        ping: $538971b5b904f078$var$spaceSeparated,
        pitch: null,
        playbackOrder: null,
        pointerEvents: null,
        points: null,
        pointsAtX: $538971b5b904f078$var$number,
        pointsAtY: $538971b5b904f078$var$number,
        pointsAtZ: $538971b5b904f078$var$number,
        preserveAlpha: null,
        preserveAspectRatio: null,
        primitiveUnits: null,
        propagate: null,
        property: $538971b5b904f078$var$commaOrSpaceSeparated,
        r: null,
        radius: null,
        referrerPolicy: null,
        refX: null,
        refY: null,
        rel: $538971b5b904f078$var$commaOrSpaceSeparated,
        rev: $538971b5b904f078$var$commaOrSpaceSeparated,
        renderingIntent: null,
        repeatCount: null,
        repeatDur: null,
        requiredExtensions: $538971b5b904f078$var$commaOrSpaceSeparated,
        requiredFeatures: $538971b5b904f078$var$commaOrSpaceSeparated,
        requiredFonts: $538971b5b904f078$var$commaOrSpaceSeparated,
        requiredFormats: $538971b5b904f078$var$commaOrSpaceSeparated,
        resource: null,
        restart: null,
        result: null,
        rotate: null,
        rx: null,
        ry: null,
        scale: null,
        seed: null,
        shapeRendering: null,
        side: null,
        slope: null,
        snapshotTime: null,
        specularConstant: $538971b5b904f078$var$number,
        specularExponent: $538971b5b904f078$var$number,
        spreadMethod: null,
        spacing: null,
        startOffset: null,
        stdDeviation: null,
        stemh: null,
        stemv: null,
        stitchTiles: null,
        stopColor: null,
        stopOpacity: null,
        strikethroughPosition: $538971b5b904f078$var$number,
        strikethroughThickness: $538971b5b904f078$var$number,
        string: null,
        stroke: null,
        strokeDashArray: $538971b5b904f078$var$commaOrSpaceSeparated,
        strokeDashOffset: null,
        strokeLineCap: null,
        strokeLineJoin: null,
        strokeMiterLimit: $538971b5b904f078$var$number,
        strokeOpacity: $538971b5b904f078$var$number,
        strokeWidth: null,
        style: null,
        surfaceScale: $538971b5b904f078$var$number,
        syncBehavior: null,
        syncBehaviorDefault: null,
        syncMaster: null,
        syncTolerance: null,
        syncToleranceDefault: null,
        systemLanguage: $538971b5b904f078$var$commaOrSpaceSeparated,
        tabIndex: $538971b5b904f078$var$number,
        tableValues: null,
        target: null,
        targetX: $538971b5b904f078$var$number,
        targetY: $538971b5b904f078$var$number,
        textAnchor: null,
        textDecoration: null,
        textRendering: null,
        textLength: null,
        timelineBegin: null,
        title: null,
        transformBehavior: null,
        type: null,
        typeOf: $538971b5b904f078$var$commaOrSpaceSeparated,
        to: null,
        transform: null,
        u1: null,
        u2: null,
        underlinePosition: $538971b5b904f078$var$number,
        underlineThickness: $538971b5b904f078$var$number,
        unicode: null,
        unicodeBidi: null,
        unicodeRange: null,
        unitsPerEm: $538971b5b904f078$var$number,
        values: null,
        vAlphabetic: $538971b5b904f078$var$number,
        vMathematical: $538971b5b904f078$var$number,
        vectorEffect: null,
        vHanging: $538971b5b904f078$var$number,
        vIdeographic: $538971b5b904f078$var$number,
        version: null,
        vertAdvY: $538971b5b904f078$var$number,
        vertOriginX: $538971b5b904f078$var$number,
        vertOriginY: $538971b5b904f078$var$number,
        viewBox: null,
        viewTarget: null,
        visibility: null,
        width: null,
        widths: null,
        wordSpacing: null,
        writingMode: null,
        x: null,
        x1: null,
        x2: null,
        xChannelSelector: null,
        xHeight: $538971b5b904f078$var$number,
        y: null,
        y1: null,
        y2: null,
        yChannelSelector: null,
        z: null,
        zoomAndPan: null
    }
});
var $538971b5b904f078$var$svg_1 = $538971b5b904f078$var$merge_1([
    $538971b5b904f078$var$xml,
    $538971b5b904f078$var$xlink,
    $538971b5b904f078$var$xmlns,
    $538971b5b904f078$var$aria,
    $538971b5b904f078$var$svg
]);
var $538971b5b904f078$var$index$2 = [
    "area",
    "base",
    "basefont",
    "bgsound",
    "br",
    "col",
    "command",
    "embed",
    "frame",
    "hr",
    "image",
    "img",
    "input",
    "isindex",
    "keygen",
    "link",
    "menuitem",
    "meta",
    "nextid",
    "param",
    "source",
    "track",
    "wbr"
];
var $538971b5b904f078$var$htmlVoidElements = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    "default": $538971b5b904f078$var$index$2
});
var $538971b5b904f078$var$unistUtilIs = $538971b5b904f078$var$is;
// Assert if `test` passes for `node`.   When a `parent` node is known the
// `index` of node.
// eslint-disable-next-line max-params
function $538971b5b904f078$var$is(test, node, index, parent, context) {
    var hasParent = parent !== null && parent !== undefined;
    var hasIndex = index !== null && index !== undefined;
    var check = $538971b5b904f078$var$convert(test);
    if (hasIndex && (typeof index !== "number" || index < 0 || index === Infinity)) throw new Error("Expected positive finite index or child node");
    if (hasParent && (!$538971b5b904f078$var$is(null, parent) || !parent.children)) throw new Error("Expected parent node");
    if (!node || !node.type || typeof node.type !== "string") return false;
    if (hasParent !== hasIndex) throw new Error("Expected both parent and index");
    return Boolean(check.call(context, node, index, parent));
}
function $538971b5b904f078$var$convert(test) {
    if (typeof test === "string") return $538971b5b904f078$var$typeFactory(test);
    if (test === null || test === undefined) return $538971b5b904f078$var$ok;
    if (typeof test === "object") return ("length" in test ? $538971b5b904f078$var$anyFactory : $538971b5b904f078$var$matchesFactory)(test);
    if (typeof test === "function") return test;
    throw new Error("Expected function, string, or object as test");
}
function $538971b5b904f078$var$convertAll(tests) {
    var results = [];
    var length = tests.length;
    var index = -1;
    while(++index < length)results[index] = $538971b5b904f078$var$convert(tests[index]);
    return results;
}
// Utility assert each property in `test` is represented in `node`, and each
// values are strictly equal.
function $538971b5b904f078$var$matchesFactory(test) {
    return matches;
    function matches(node) {
        var key;
        for(key in test){
            if (node[key] !== test[key]) return false;
        }
        return true;
    }
}
function $538971b5b904f078$var$anyFactory(tests) {
    var checks = $538971b5b904f078$var$convertAll(tests);
    var length = checks.length;
    return matches;
    function matches() {
        var index = -1;
        while(++index < length){
            if (checks[index].apply(this, arguments)) return true;
        }
        return false;
    }
}
// Utility to convert a string into a function which checks a given node’s type
// for said string.
function $538971b5b904f078$var$typeFactory(test) {
    return type;
    function type(node) {
        return Boolean(node && node.type === test);
    }
}
// Utility to return true.
function $538971b5b904f078$var$ok() {
    return true;
}
var $538971b5b904f078$var$hastUtilIsElement = $538971b5b904f078$var$isElement;
// Check if if `node` is an `element` and, if `tagNames` is given, `node`
// matches them `tagNames`.
function $538971b5b904f078$var$isElement(node, tagNames) {
    var name;
    if (!(tagNames === null || tagNames === undefined || typeof tagNames === "string" || typeof tagNames === "object" && tagNames.length !== 0)) throw new Error("Expected `string` or `Array.<string>` for `tagNames`, not `" + tagNames + "`");
    if (!node || typeof node !== "object" || node.type !== "element" || typeof node.tagName !== "string") return false;
    if (tagNames === null || tagNames === undefined) return true;
    name = node.tagName;
    if (typeof tagNames === "string") return name === tagNames;
    return tagNames.indexOf(name) !== -1;
}
var $538971b5b904f078$var$hastUtilWhitespace = $538971b5b904f078$var$interElementWhiteSpace;
// HTML white-space expression.
// See <https://html.spec.whatwg.org/#space-character>.
var $538971b5b904f078$var$re = /[ \t\n\f\r]/g;
function $538971b5b904f078$var$interElementWhiteSpace(node) {
    var value;
    if (node && typeof node === "object" && node.type === "text") value = node.value || "";
    else if (typeof node === "string") value = node;
    else return false;
    return value.replace($538971b5b904f078$var$re, "") === "";
}
var $538971b5b904f078$var$before$1 = $538971b5b904f078$var$siblings(-1);
var $538971b5b904f078$var$after$2 = $538971b5b904f078$var$siblings(1);
/* Factory to check siblings in a direction. */ function $538971b5b904f078$var$siblings(increment) {
    return sibling;
    /* Find applicable siblings in a direction.   */ function sibling(parent, index, includeWhiteSpace) {
        var siblings = parent && parent.children;
        var next;
        index += increment;
        next = siblings && siblings[index];
        if (!includeWhiteSpace) while(next && $538971b5b904f078$var$hastUtilWhitespace(next)){
            index += increment;
            next = siblings[index];
        }
        return next;
    }
}
var $538971b5b904f078$var$siblings_1 = {
    before: $538971b5b904f078$var$before$1,
    after: $538971b5b904f078$var$after$2
};
var $538971b5b904f078$var$after$1 = $538971b5b904f078$var$siblings_1.after;
var $538971b5b904f078$var$first_1 = $538971b5b904f078$var$first;
/* Get the first child in `parent`. */ function $538971b5b904f078$var$first(parent, includeWhiteSpace) {
    return $538971b5b904f078$var$after$1(parent, -1, includeWhiteSpace);
}
var $538971b5b904f078$var$place_1 = $538971b5b904f078$var$place;
/* Get the position of `node` in `parent`. */ function $538971b5b904f078$var$place(parent, child) {
    return parent && parent.children && parent.children.indexOf(child);
}
var $538971b5b904f078$var$whiteSpaceLeft_1 = $538971b5b904f078$var$whiteSpaceLeft;
/* Check if `node` starts with white-space. */ function $538971b5b904f078$var$whiteSpaceLeft(node) {
    return $538971b5b904f078$var$unistUtilIs("text", node) && $538971b5b904f078$var$hastUtilWhitespace(node.value.charAt(0));
}
var $538971b5b904f078$var$omission_1 = $538971b5b904f078$var$omission$1;
var $538971b5b904f078$var$own$5 = {}.hasOwnProperty;
/* Factory to check if a given node can have a tag omitted. */ function $538971b5b904f078$var$omission$1(handlers) {
    return omit;
    /* Check if a given node can have a tag omitted.   */ function omit(node, index, parent) {
        var name = node.tagName;
        var fn = $538971b5b904f078$var$own$5.call(handlers, name) ? handlers[name] : false;
        return fn ? fn(node, index, parent) : false;
    }
}
var $538971b5b904f078$var$after = $538971b5b904f078$var$siblings_1.after;
var $538971b5b904f078$var$optionGroup = "optgroup";
var $538971b5b904f078$var$options = [
    "option"
].concat($538971b5b904f078$var$optionGroup);
var $538971b5b904f078$var$dataListItem = [
    "dt",
    "dd"
];
var $538971b5b904f078$var$listItem = "li";
var $538971b5b904f078$var$menuContent = [
    "menuitem",
    "hr",
    "menu"
];
var $538971b5b904f078$var$ruby = [
    "rp",
    "rt"
];
var $538971b5b904f078$var$tableContainer = [
    "tbody",
    "tfoot"
];
var $538971b5b904f078$var$tableRow$1 = "tr";
var $538971b5b904f078$var$tableCell = [
    "td",
    "th"
];
var $538971b5b904f078$var$confusingParagraphParent = [
    "a",
    "audio",
    "del",
    "ins",
    "map",
    "noscript",
    "video"
];
var $538971b5b904f078$var$clearParagraphSibling = [
    "address",
    "article",
    "aside",
    "blockquote",
    "details",
    "div",
    "dl",
    "fieldset",
    "figcaption",
    "figure",
    "footer",
    "form",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "header",
    "hgroup",
    "hr",
    "main",
    "menu",
    "nav",
    "ol",
    "p",
    "pre",
    "section",
    "table",
    "ul"
];
var $538971b5b904f078$var$closing$1 = $538971b5b904f078$var$omission_1({
    html: $538971b5b904f078$var$html$1,
    head: $538971b5b904f078$var$headOrColgroupOrCaption,
    body: $538971b5b904f078$var$body$1,
    p: $538971b5b904f078$var$p,
    li: $538971b5b904f078$var$li,
    dt: $538971b5b904f078$var$dt,
    dd: $538971b5b904f078$var$dd,
    rt: $538971b5b904f078$var$rubyElement,
    rp: $538971b5b904f078$var$rubyElement,
    optgroup: $538971b5b904f078$var$optgroup,
    option: $538971b5b904f078$var$option,
    menuitem: $538971b5b904f078$var$menuitem,
    colgroup: $538971b5b904f078$var$headOrColgroupOrCaption,
    caption: $538971b5b904f078$var$headOrColgroupOrCaption,
    thead: $538971b5b904f078$var$thead,
    tbody: $538971b5b904f078$var$tbody$1,
    tfoot: $538971b5b904f078$var$tfoot,
    tr: $538971b5b904f078$var$tr,
    td: $538971b5b904f078$var$cells,
    th: $538971b5b904f078$var$cells
});
/* Macro for `</head>`, `</colgroup>`, and `</caption>`. */ function $538971b5b904f078$var$headOrColgroupOrCaption(node, index, parent) {
    var next = $538971b5b904f078$var$after(parent, index, true);
    return !next || !$538971b5b904f078$var$unistUtilIs("comment", next) && !$538971b5b904f078$var$whiteSpaceLeft_1(next);
}
/* Whether to omit `</html>`. */ function $538971b5b904f078$var$html$1(node, index, parent) {
    var next = $538971b5b904f078$var$after(parent, index);
    return !next || !$538971b5b904f078$var$unistUtilIs("comment", next);
}
/* Whether to omit `</body>`. */ function $538971b5b904f078$var$body$1(node, index, parent) {
    var next = $538971b5b904f078$var$after(parent, index);
    return !next || !$538971b5b904f078$var$unistUtilIs("comment", next);
}
/* Whether to omit `</p>`. */ function $538971b5b904f078$var$p(node, index, parent) {
    var next = $538971b5b904f078$var$after(parent, index);
    return next ? $538971b5b904f078$var$hastUtilIsElement(next, $538971b5b904f078$var$clearParagraphSibling) : !parent || !$538971b5b904f078$var$hastUtilIsElement(parent, $538971b5b904f078$var$confusingParagraphParent);
}
/* Whether to omit `</li>`. */ function $538971b5b904f078$var$li(node, index, parent) {
    var next = $538971b5b904f078$var$after(parent, index);
    return !next || $538971b5b904f078$var$hastUtilIsElement(next, $538971b5b904f078$var$listItem);
}
/* Whether to omit `</dt>`. */ function $538971b5b904f078$var$dt(node, index, parent) {
    var next = $538971b5b904f078$var$after(parent, index);
    return next && $538971b5b904f078$var$hastUtilIsElement(next, $538971b5b904f078$var$dataListItem);
}
/* Whether to omit `</dd>`. */ function $538971b5b904f078$var$dd(node, index, parent) {
    var next = $538971b5b904f078$var$after(parent, index);
    return !next || $538971b5b904f078$var$hastUtilIsElement(next, $538971b5b904f078$var$dataListItem);
}
/* Whether to omit `</rt>` or `</rp>`. */ function $538971b5b904f078$var$rubyElement(node, index, parent) {
    var next = $538971b5b904f078$var$after(parent, index);
    return !next || $538971b5b904f078$var$hastUtilIsElement(next, $538971b5b904f078$var$ruby);
}
/* Whether to omit `</optgroup>`. */ function $538971b5b904f078$var$optgroup(node, index, parent) {
    var next = $538971b5b904f078$var$after(parent, index);
    return !next || $538971b5b904f078$var$hastUtilIsElement(next, $538971b5b904f078$var$optionGroup);
}
/* Whether to omit `</option>`. */ function $538971b5b904f078$var$option(node, index, parent) {
    var next = $538971b5b904f078$var$after(parent, index);
    return !next || $538971b5b904f078$var$hastUtilIsElement(next, $538971b5b904f078$var$options);
}
/* Whether to omit `</menuitem>`. */ function $538971b5b904f078$var$menuitem(node, index, parent) {
    var next = $538971b5b904f078$var$after(parent, index);
    return !next || $538971b5b904f078$var$hastUtilIsElement(next, $538971b5b904f078$var$menuContent);
}
/* Whether to omit `</thead>`. */ function $538971b5b904f078$var$thead(node, index, parent) {
    var next = $538971b5b904f078$var$after(parent, index);
    return next && $538971b5b904f078$var$hastUtilIsElement(next, $538971b5b904f078$var$tableContainer);
}
/* Whether to omit `</tbody>`. */ function $538971b5b904f078$var$tbody$1(node, index, parent) {
    var next = $538971b5b904f078$var$after(parent, index);
    return !next || $538971b5b904f078$var$hastUtilIsElement(next, $538971b5b904f078$var$tableContainer);
}
/* Whether to omit `</tfoot>`. */ function $538971b5b904f078$var$tfoot(node, index, parent) {
    return !$538971b5b904f078$var$after(parent, index);
}
/* Whether to omit `</tr>`. */ function $538971b5b904f078$var$tr(node, index, parent) {
    var next = $538971b5b904f078$var$after(parent, index);
    return !next || $538971b5b904f078$var$hastUtilIsElement(next, $538971b5b904f078$var$tableRow$1);
}
/* Whether to omit `</td>` or `</th>`. */ function $538971b5b904f078$var$cells(node, index, parent) {
    var next = $538971b5b904f078$var$after(parent, index);
    return !next || $538971b5b904f078$var$hastUtilIsElement(next, $538971b5b904f078$var$tableCell);
}
var $538971b5b904f078$var$before = $538971b5b904f078$var$siblings_1.before;
var $538971b5b904f078$var$own$4 = {}.hasOwnProperty;
var $538971b5b904f078$var$uniqueHeadMetadata = [
    "title",
    "base"
];
var $538971b5b904f078$var$meta = [
    "meta",
    "link",
    "script",
    "style",
    "template"
];
var $538971b5b904f078$var$tableContainers = [
    "thead",
    "tbody"
];
var $538971b5b904f078$var$tableRow = "tr";
var $538971b5b904f078$var$opening$1 = $538971b5b904f078$var$omission_1({
    html: $538971b5b904f078$var$html,
    head: $538971b5b904f078$var$head,
    body: $538971b5b904f078$var$body,
    colgroup: $538971b5b904f078$var$colgroup,
    tbody: $538971b5b904f078$var$tbody
});
/* Whether to omit `<html>`. */ function $538971b5b904f078$var$html(node) {
    var head = $538971b5b904f078$var$first_1(node);
    return !head || !$538971b5b904f078$var$unistUtilIs("comment", head);
}
/* Whether to omit `<head>`. */ function $538971b5b904f078$var$head(node) {
    var children = node.children;
    var length = children.length;
    var map = {};
    var index = -1;
    var child;
    var name;
    while(++index < length){
        child = children[index];
        name = child.tagName;
        if ($538971b5b904f078$var$hastUtilIsElement(child, $538971b5b904f078$var$uniqueHeadMetadata)) {
            if ($538971b5b904f078$var$own$4.call(map, name)) return false;
            map[name] = true;
        }
    }
    return Boolean(length);
}
/* Whether to omit `<body>`. */ function $538971b5b904f078$var$body(node) {
    var head = $538971b5b904f078$var$first_1(node, true);
    return !head || !$538971b5b904f078$var$unistUtilIs("comment", head) && !$538971b5b904f078$var$whiteSpaceLeft_1(head) && !$538971b5b904f078$var$hastUtilIsElement(head, $538971b5b904f078$var$meta);
}
/* Whether to omit `<colgroup>`.
 * The spec describes some logic for the opening tag,
 * but it’s easier to implement in the closing tag, to
 * the same effect, so we handle it there instead. */ function $538971b5b904f078$var$colgroup(node, index, parent) {
    var prev = $538971b5b904f078$var$before(parent, index);
    var head = $538971b5b904f078$var$first_1(node, true);
    /* Previous colgroup was already omitted. */ if ($538971b5b904f078$var$hastUtilIsElement(prev, "colgroup") && $538971b5b904f078$var$closing$1(prev, $538971b5b904f078$var$place_1(parent, prev), parent)) return false;
    return head && $538971b5b904f078$var$hastUtilIsElement(head, "col");
}
/* Whether to omit `<tbody>`. */ function $538971b5b904f078$var$tbody(node, index, parent) {
    var prev = $538971b5b904f078$var$before(parent, index);
    var head = $538971b5b904f078$var$first_1(node);
    /* Previous table section was already omitted. */ if ($538971b5b904f078$var$hastUtilIsElement(prev, $538971b5b904f078$var$tableContainers) && $538971b5b904f078$var$closing$1(prev, $538971b5b904f078$var$place_1(parent, prev), parent)) return false;
    return head && $538971b5b904f078$var$hastUtilIsElement(head, $538971b5b904f078$var$tableRow);
}
var $538971b5b904f078$var$opening = $538971b5b904f078$var$opening$1;
var $538971b5b904f078$var$closing = $538971b5b904f078$var$closing$1;
var $538971b5b904f078$var$omission = {
    opening: $538971b5b904f078$var$opening,
    closing: $538971b5b904f078$var$closing
};
var $538971b5b904f078$var$index$1 = [
    "script",
    "style",
    "pre",
    "textarea"
];
var $538971b5b904f078$var$htmlWhitespaceSensitiveTagNames = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    "default": $538971b5b904f078$var$index$1
});
var $538971b5b904f078$var$sensitive = $538971b5b904f078$var$getCjsExportFromNamespace($538971b5b904f078$var$htmlWhitespaceSensitiveTagNames);
var $538971b5b904f078$var$all_1 = $538971b5b904f078$var$all$1;
/* Stringify all children of `parent`. */ function $538971b5b904f078$var$all$1(ctx, parent) {
    var children = parent && parent.children;
    var length = children && children.length;
    var index = -1;
    var results = [];
    let printWidthOffset = 0;
    let innerTextLength = 0;
    while(++index < length){
        innerTextLength = $538971b5b904f078$var$getInnerTextLength(children[index]);
        results[index] = $538971b5b904f078$var$one_1(ctx, children[index], index, parent, printWidthOffset, innerTextLength);
        printWidthOffset = results[index].replace(/\n+/g, "").length;
    }
    return results.join("");
}
/**
 * Returns the text lenght of the first line of the first child.
 * Whitespace sensitive elements are ignored.
 * @param {*} node
 */ function $538971b5b904f078$var$getInnerTextLength(node) {
    // ignore style, script, pre, textarea elements
    if ($538971b5b904f078$var$sensitive.indexOf(node.tagName) !== -1) return 0;
    if (!node.children || !node.children.length) return 0;
    var child = node.children[0];
    if (child.type === "text" || child.type === "comment") return child.value.split("\n")[0].length;
    return 0;
}
var $538971b5b904f078$var$text_1 = $538971b5b904f078$var$text;
/* Stringify `text`. */ function $538971b5b904f078$var$text(ctx, node, index, parent) {
    var value = node.value;
    return value;
}
var $538971b5b904f078$var$data = "data";
var $538971b5b904f078$var$find_1 = $538971b5b904f078$var$find;
var $538971b5b904f078$var$valid = /^data[-\w.:]+$/i;
var $538971b5b904f078$var$dash = /-[a-z]/g;
var $538971b5b904f078$var$cap$1 = /[A-Z]/g;
function $538971b5b904f078$var$find(schema, value) {
    var normal = $538971b5b904f078$var$normalize_1(value);
    var prop = value;
    var Type = $538971b5b904f078$var$info;
    if (normal in schema.normal) return schema.property[schema.normal[normal]];
    if (normal.length > 4 && normal.slice(0, 4) === $538971b5b904f078$var$data && $538971b5b904f078$var$valid.test(value)) {
        // Attribute or property.
        if (value.charAt(4) === "-") prop = $538971b5b904f078$var$datasetToProperty(value);
        else value = $538971b5b904f078$var$datasetToAttribute(value);
        Type = $538971b5b904f078$var$definedInfo;
    }
    return new Type(prop, value);
}
function $538971b5b904f078$var$datasetToProperty(attribute) {
    var value = attribute.slice(5).replace($538971b5b904f078$var$dash, $538971b5b904f078$var$camelcase);
    return $538971b5b904f078$var$data + value.charAt(0).toUpperCase() + value.slice(1);
}
function $538971b5b904f078$var$datasetToAttribute(property) {
    var value = property.slice(4);
    if ($538971b5b904f078$var$dash.test(value)) return property;
    value = value.replace($538971b5b904f078$var$cap$1, $538971b5b904f078$var$kebab);
    if (value.charAt(0) !== "-") value = "-" + value;
    return $538971b5b904f078$var$data + value;
}
function $538971b5b904f078$var$kebab($0) {
    return "-" + $0.toLowerCase();
}
function $538971b5b904f078$var$camelcase($0) {
    return $0.charAt(1).toUpperCase();
}
var $538971b5b904f078$var$parse_1 = $538971b5b904f078$var$parse$2;
var $538971b5b904f078$var$stringify_1 = $538971b5b904f078$var$stringify$2;
var $538971b5b904f078$var$comma = ",";
var $538971b5b904f078$var$space$2 = " ";
var $538971b5b904f078$var$empty$1 = "";
// Parse comma-separated tokens to an array.
function $538971b5b904f078$var$parse$2(value) {
    var values = [];
    var input = String(value || $538971b5b904f078$var$empty$1);
    var index = input.indexOf($538971b5b904f078$var$comma);
    var lastIndex = 0;
    var end = false;
    var val;
    while(!end){
        if (index === -1) {
            index = input.length;
            end = true;
        }
        val = input.slice(lastIndex, index).trim();
        if (val || !end) values.push(val);
        lastIndex = index + 1;
        index = input.indexOf($538971b5b904f078$var$comma, lastIndex);
    }
    return values;
}
// Compile an array to comma-separated tokens.
// `options.padLeft` (default: `true`) pads a space left of each token, and
// `options.padRight` (default: `false`) pads a space to the right of each token.
function $538971b5b904f078$var$stringify$2(values, options) {
    var settings = options || {};
    var left = settings.padLeft === false ? $538971b5b904f078$var$empty$1 : $538971b5b904f078$var$space$2;
    var right = settings.padRight ? $538971b5b904f078$var$space$2 : $538971b5b904f078$var$empty$1;
    // Ensure the last empty entry is seen.
    if (values[values.length - 1] === $538971b5b904f078$var$empty$1) values = values.concat($538971b5b904f078$var$empty$1);
    return values.join(right + $538971b5b904f078$var$comma + left).trim();
}
var $538971b5b904f078$var$commaSeparatedTokens = {
    parse: $538971b5b904f078$var$parse_1,
    stringify: $538971b5b904f078$var$stringify_1
};
var $538971b5b904f078$var$nbsp = "\xa0";
var $538971b5b904f078$var$iexcl = "\xa1";
var $538971b5b904f078$var$cent = "\xa2";
var $538971b5b904f078$var$pound = "\xa3";
var $538971b5b904f078$var$curren = "\xa4";
var $538971b5b904f078$var$yen = "\xa5";
var $538971b5b904f078$var$brvbar = "\xa6";
var $538971b5b904f078$var$sect = "\xa7";
var $538971b5b904f078$var$uml = "\xa8";
var $538971b5b904f078$var$copy = "\xa9";
var $538971b5b904f078$var$ordf = "\xaa";
var $538971b5b904f078$var$laquo = "\xab";
var $538971b5b904f078$var$not = "\xac";
var $538971b5b904f078$var$shy = "\xad";
var $538971b5b904f078$var$reg = "\xae";
var $538971b5b904f078$var$macr = "\xaf";
var $538971b5b904f078$var$deg = "\xb0";
var $538971b5b904f078$var$plusmn = "\xb1";
var $538971b5b904f078$var$sup2 = "\xb2";
var $538971b5b904f078$var$sup3 = "\xb3";
var $538971b5b904f078$var$acute = "\xb4";
var $538971b5b904f078$var$micro = "\xb5";
var $538971b5b904f078$var$para = "\xb6";
var $538971b5b904f078$var$middot = "\xb7";
var $538971b5b904f078$var$cedil = "\xb8";
var $538971b5b904f078$var$sup1 = "\xb9";
var $538971b5b904f078$var$ordm = "\xba";
var $538971b5b904f078$var$raquo = "\xbb";
var $538971b5b904f078$var$frac14 = "\xbc";
var $538971b5b904f078$var$frac12 = "\xbd";
var $538971b5b904f078$var$frac34 = "\xbe";
var $538971b5b904f078$var$iquest = "\xbf";
var $538971b5b904f078$var$Agrave = "\xc0";
var $538971b5b904f078$var$Aacute = "\xc1";
var $538971b5b904f078$var$Acirc = "\xc2";
var $538971b5b904f078$var$Atilde = "\xc3";
var $538971b5b904f078$var$Auml = "\xc4";
var $538971b5b904f078$var$Aring = "\xc5";
var $538971b5b904f078$var$AElig = "\xc6";
var $538971b5b904f078$var$Ccedil = "\xc7";
var $538971b5b904f078$var$Egrave = "\xc8";
var $538971b5b904f078$var$Eacute = "\xc9";
var $538971b5b904f078$var$Ecirc = "\xca";
var $538971b5b904f078$var$Euml = "\xcb";
var $538971b5b904f078$var$Igrave = "\xcc";
var $538971b5b904f078$var$Iacute = "\xcd";
var $538971b5b904f078$var$Icirc = "\xce";
var $538971b5b904f078$var$Iuml = "\xcf";
var $538971b5b904f078$var$ETH = "\xd0";
var $538971b5b904f078$var$Ntilde = "\xd1";
var $538971b5b904f078$var$Ograve = "\xd2";
var $538971b5b904f078$var$Oacute = "\xd3";
var $538971b5b904f078$var$Ocirc = "\xd4";
var $538971b5b904f078$var$Otilde = "\xd5";
var $538971b5b904f078$var$Ouml = "\xd6";
var $538971b5b904f078$var$times = "\xd7";
var $538971b5b904f078$var$Oslash = "\xd8";
var $538971b5b904f078$var$Ugrave = "\xd9";
var $538971b5b904f078$var$Uacute = "\xda";
var $538971b5b904f078$var$Ucirc = "\xdb";
var $538971b5b904f078$var$Uuml = "\xdc";
var $538971b5b904f078$var$Yacute = "\xdd";
var $538971b5b904f078$var$THORN = "\xde";
var $538971b5b904f078$var$szlig = "\xdf";
var $538971b5b904f078$var$agrave = "\xe0";
var $538971b5b904f078$var$aacute = "\xe1";
var $538971b5b904f078$var$acirc = "\xe2";
var $538971b5b904f078$var$atilde = "\xe3";
var $538971b5b904f078$var$auml = "\xe4";
var $538971b5b904f078$var$aring = "\xe5";
var $538971b5b904f078$var$aelig = "\xe6";
var $538971b5b904f078$var$ccedil = "\xe7";
var $538971b5b904f078$var$egrave = "\xe8";
var $538971b5b904f078$var$eacute = "\xe9";
var $538971b5b904f078$var$ecirc = "\xea";
var $538971b5b904f078$var$euml = "\xeb";
var $538971b5b904f078$var$igrave = "\xec";
var $538971b5b904f078$var$iacute = "\xed";
var $538971b5b904f078$var$icirc = "\xee";
var $538971b5b904f078$var$iuml = "\xef";
var $538971b5b904f078$var$eth = "\xf0";
var $538971b5b904f078$var$ntilde = "\xf1";
var $538971b5b904f078$var$ograve = "\xf2";
var $538971b5b904f078$var$oacute = "\xf3";
var $538971b5b904f078$var$ocirc = "\xf4";
var $538971b5b904f078$var$otilde = "\xf5";
var $538971b5b904f078$var$ouml = "\xf6";
var $538971b5b904f078$var$divide = "\xf7";
var $538971b5b904f078$var$oslash = "\xf8";
var $538971b5b904f078$var$ugrave = "\xf9";
var $538971b5b904f078$var$uacute = "\xfa";
var $538971b5b904f078$var$ucirc = "\xfb";
var $538971b5b904f078$var$uuml = "\xfc";
var $538971b5b904f078$var$yacute = "\xfd";
var $538971b5b904f078$var$thorn = "\xfe";
var $538971b5b904f078$var$yuml = "\xff";
var $538971b5b904f078$var$fnof = "\u0192";
var $538971b5b904f078$var$Alpha = "\u0391";
var $538971b5b904f078$var$Beta = "\u0392";
var $538971b5b904f078$var$Gamma = "\u0393";
var $538971b5b904f078$var$Delta = "\u0394";
var $538971b5b904f078$var$Epsilon = "\u0395";
var $538971b5b904f078$var$Zeta = "\u0396";
var $538971b5b904f078$var$Eta = "\u0397";
var $538971b5b904f078$var$Theta = "\u0398";
var $538971b5b904f078$var$Iota = "\u0399";
var $538971b5b904f078$var$Kappa = "\u039A";
var $538971b5b904f078$var$Lambda = "\u039B";
var $538971b5b904f078$var$Mu = "\u039C";
var $538971b5b904f078$var$Nu = "\u039D";
var $538971b5b904f078$var$Xi = "\u039E";
var $538971b5b904f078$var$Omicron = "\u039F";
var $538971b5b904f078$var$Pi = "\u03A0";
var $538971b5b904f078$var$Rho = "\u03A1";
var $538971b5b904f078$var$Sigma = "\u03A3";
var $538971b5b904f078$var$Tau = "\u03A4";
var $538971b5b904f078$var$Upsilon = "\u03A5";
var $538971b5b904f078$var$Phi = "\u03A6";
var $538971b5b904f078$var$Chi = "\u03A7";
var $538971b5b904f078$var$Psi = "\u03A8";
var $538971b5b904f078$var$Omega = "\u03A9";
var $538971b5b904f078$var$alpha = "\u03B1";
var $538971b5b904f078$var$beta = "\u03B2";
var $538971b5b904f078$var$gamma = "\u03B3";
var $538971b5b904f078$var$delta = "\u03B4";
var $538971b5b904f078$var$epsilon = "\u03B5";
var $538971b5b904f078$var$zeta = "\u03B6";
var $538971b5b904f078$var$eta = "\u03B7";
var $538971b5b904f078$var$theta = "\u03B8";
var $538971b5b904f078$var$iota = "\u03B9";
var $538971b5b904f078$var$kappa = "\u03BA";
var $538971b5b904f078$var$lambda = "\u03BB";
var $538971b5b904f078$var$mu = "\u03BC";
var $538971b5b904f078$var$nu = "\u03BD";
var $538971b5b904f078$var$xi = "\u03BE";
var $538971b5b904f078$var$omicron = "\u03BF";
var $538971b5b904f078$var$pi = "\u03C0";
var $538971b5b904f078$var$rho = "\u03C1";
var $538971b5b904f078$var$sigmaf = "\u03C2";
var $538971b5b904f078$var$sigma = "\u03C3";
var $538971b5b904f078$var$tau = "\u03C4";
var $538971b5b904f078$var$upsilon = "\u03C5";
var $538971b5b904f078$var$phi = "\u03C6";
var $538971b5b904f078$var$chi = "\u03C7";
var $538971b5b904f078$var$psi = "\u03C8";
var $538971b5b904f078$var$omega = "\u03C9";
var $538971b5b904f078$var$thetasym = "\u03D1";
var $538971b5b904f078$var$upsih = "\u03D2";
var $538971b5b904f078$var$piv = "\u03D6";
var $538971b5b904f078$var$bull = "\u2022";
var $538971b5b904f078$var$hellip = "\u2026";
var $538971b5b904f078$var$prime = "\u2032";
var $538971b5b904f078$var$Prime = "\u2033";
var $538971b5b904f078$var$oline = "\u203E";
var $538971b5b904f078$var$frasl = "\u2044";
var $538971b5b904f078$var$weierp = "\u2118";
var $538971b5b904f078$var$image = "\u2111";
var $538971b5b904f078$var$real = "\u211C";
var $538971b5b904f078$var$trade = "\u2122";
var $538971b5b904f078$var$alefsym = "\u2135";
var $538971b5b904f078$var$larr = "\u2190";
var $538971b5b904f078$var$uarr = "\u2191";
var $538971b5b904f078$var$rarr = "\u2192";
var $538971b5b904f078$var$darr = "\u2193";
var $538971b5b904f078$var$harr = "\u2194";
var $538971b5b904f078$var$crarr = "\u21B5";
var $538971b5b904f078$var$lArr = "\u21D0";
var $538971b5b904f078$var$uArr = "\u21D1";
var $538971b5b904f078$var$rArr = "\u21D2";
var $538971b5b904f078$var$dArr = "\u21D3";
var $538971b5b904f078$var$hArr = "\u21D4";
var $538971b5b904f078$var$forall = "\u2200";
var $538971b5b904f078$var$part = "\u2202";
var $538971b5b904f078$var$exist = "\u2203";
var $538971b5b904f078$var$empty = "\u2205";
var $538971b5b904f078$var$nabla = "\u2207";
var $538971b5b904f078$var$isin = "\u2208";
var $538971b5b904f078$var$notin = "\u2209";
var $538971b5b904f078$var$ni = "\u220B";
var $538971b5b904f078$var$prod = "\u220F";
var $538971b5b904f078$var$sum = "\u2211";
var $538971b5b904f078$var$minus = "\u2212";
var $538971b5b904f078$var$lowast = "\u2217";
var $538971b5b904f078$var$radic = "\u221A";
var $538971b5b904f078$var$prop = "\u221D";
var $538971b5b904f078$var$infin = "\u221E";
var $538971b5b904f078$var$ang = "\u2220";
var $538971b5b904f078$var$and = "\u2227";
var $538971b5b904f078$var$or = "\u2228";
var $538971b5b904f078$var$cap = "\u2229";
var $538971b5b904f078$var$cup = "\u222A";
var $538971b5b904f078$var$int = "\u222B";
var $538971b5b904f078$var$there4 = "\u2234";
var $538971b5b904f078$var$sim = "\u223C";
var $538971b5b904f078$var$cong = "\u2245";
var $538971b5b904f078$var$asymp = "\u2248";
var $538971b5b904f078$var$ne = "\u2260";
var $538971b5b904f078$var$equiv = "\u2261";
var $538971b5b904f078$var$le = "\u2264";
var $538971b5b904f078$var$ge = "\u2265";
var $538971b5b904f078$var$sub = "\u2282";
var $538971b5b904f078$var$sup = "\u2283";
var $538971b5b904f078$var$nsub = "\u2284";
var $538971b5b904f078$var$sube = "\u2286";
var $538971b5b904f078$var$supe = "\u2287";
var $538971b5b904f078$var$oplus = "\u2295";
var $538971b5b904f078$var$otimes = "\u2297";
var $538971b5b904f078$var$perp = "\u22A5";
var $538971b5b904f078$var$sdot = "\u22C5";
var $538971b5b904f078$var$lceil = "\u2308";
var $538971b5b904f078$var$rceil = "\u2309";
var $538971b5b904f078$var$lfloor = "\u230A";
var $538971b5b904f078$var$rfloor = "\u230B";
var $538971b5b904f078$var$lang = "\u2329";
var $538971b5b904f078$var$rang = "\u232A";
var $538971b5b904f078$var$loz = "\u25CA";
var $538971b5b904f078$var$spades = "\u2660";
var $538971b5b904f078$var$clubs = "\u2663";
var $538971b5b904f078$var$hearts = "\u2665";
var $538971b5b904f078$var$diams = "\u2666";
var $538971b5b904f078$var$quot = '"';
var $538971b5b904f078$var$amp = "&";
var $538971b5b904f078$var$lt = "<";
var $538971b5b904f078$var$gt = ">";
var $538971b5b904f078$var$OElig = "\u0152";
var $538971b5b904f078$var$oelig = "\u0153";
var $538971b5b904f078$var$Scaron = "\u0160";
var $538971b5b904f078$var$scaron = "\u0161";
var $538971b5b904f078$var$Yuml = "\u0178";
var $538971b5b904f078$var$circ = "\u02C6";
var $538971b5b904f078$var$tilde = "\u02DC";
var $538971b5b904f078$var$ensp = "\u2002";
var $538971b5b904f078$var$emsp = "\u2003";
var $538971b5b904f078$var$thinsp = "\u2009";
var $538971b5b904f078$var$zwnj = "\u200C";
var $538971b5b904f078$var$zwj = "\u200D";
var $538971b5b904f078$var$lrm = "\u200E";
var $538971b5b904f078$var$rlm = "\u200F";
var $538971b5b904f078$var$ndash = "\u2013";
var $538971b5b904f078$var$mdash = "\u2014";
var $538971b5b904f078$var$lsquo = "\u2018";
var $538971b5b904f078$var$rsquo = "\u2019";
var $538971b5b904f078$var$sbquo = "\u201A";
var $538971b5b904f078$var$ldquo = "\u201C";
var $538971b5b904f078$var$rdquo = "\u201D";
var $538971b5b904f078$var$bdquo = "\u201E";
var $538971b5b904f078$var$dagger = "\u2020";
var $538971b5b904f078$var$Dagger = "\u2021";
var $538971b5b904f078$var$permil = "\u2030";
var $538971b5b904f078$var$lsaquo = "\u2039";
var $538971b5b904f078$var$rsaquo = "\u203A";
var $538971b5b904f078$var$euro = "\u20AC";
var $538971b5b904f078$var$index = {
    nbsp: $538971b5b904f078$var$nbsp,
    iexcl: $538971b5b904f078$var$iexcl,
    cent: $538971b5b904f078$var$cent,
    pound: $538971b5b904f078$var$pound,
    curren: $538971b5b904f078$var$curren,
    yen: $538971b5b904f078$var$yen,
    brvbar: $538971b5b904f078$var$brvbar,
    sect: $538971b5b904f078$var$sect,
    uml: $538971b5b904f078$var$uml,
    copy: $538971b5b904f078$var$copy,
    ordf: $538971b5b904f078$var$ordf,
    laquo: $538971b5b904f078$var$laquo,
    not: $538971b5b904f078$var$not,
    shy: $538971b5b904f078$var$shy,
    reg: $538971b5b904f078$var$reg,
    macr: $538971b5b904f078$var$macr,
    deg: $538971b5b904f078$var$deg,
    plusmn: $538971b5b904f078$var$plusmn,
    sup2: $538971b5b904f078$var$sup2,
    sup3: $538971b5b904f078$var$sup3,
    acute: $538971b5b904f078$var$acute,
    micro: $538971b5b904f078$var$micro,
    para: $538971b5b904f078$var$para,
    middot: $538971b5b904f078$var$middot,
    cedil: $538971b5b904f078$var$cedil,
    sup1: $538971b5b904f078$var$sup1,
    ordm: $538971b5b904f078$var$ordm,
    raquo: $538971b5b904f078$var$raquo,
    frac14: $538971b5b904f078$var$frac14,
    frac12: $538971b5b904f078$var$frac12,
    frac34: $538971b5b904f078$var$frac34,
    iquest: $538971b5b904f078$var$iquest,
    Agrave: $538971b5b904f078$var$Agrave,
    Aacute: $538971b5b904f078$var$Aacute,
    Acirc: $538971b5b904f078$var$Acirc,
    Atilde: $538971b5b904f078$var$Atilde,
    Auml: $538971b5b904f078$var$Auml,
    Aring: $538971b5b904f078$var$Aring,
    AElig: $538971b5b904f078$var$AElig,
    Ccedil: $538971b5b904f078$var$Ccedil,
    Egrave: $538971b5b904f078$var$Egrave,
    Eacute: $538971b5b904f078$var$Eacute,
    Ecirc: $538971b5b904f078$var$Ecirc,
    Euml: $538971b5b904f078$var$Euml,
    Igrave: $538971b5b904f078$var$Igrave,
    Iacute: $538971b5b904f078$var$Iacute,
    Icirc: $538971b5b904f078$var$Icirc,
    Iuml: $538971b5b904f078$var$Iuml,
    ETH: $538971b5b904f078$var$ETH,
    Ntilde: $538971b5b904f078$var$Ntilde,
    Ograve: $538971b5b904f078$var$Ograve,
    Oacute: $538971b5b904f078$var$Oacute,
    Ocirc: $538971b5b904f078$var$Ocirc,
    Otilde: $538971b5b904f078$var$Otilde,
    Ouml: $538971b5b904f078$var$Ouml,
    times: $538971b5b904f078$var$times,
    Oslash: $538971b5b904f078$var$Oslash,
    Ugrave: $538971b5b904f078$var$Ugrave,
    Uacute: $538971b5b904f078$var$Uacute,
    Ucirc: $538971b5b904f078$var$Ucirc,
    Uuml: $538971b5b904f078$var$Uuml,
    Yacute: $538971b5b904f078$var$Yacute,
    THORN: $538971b5b904f078$var$THORN,
    szlig: $538971b5b904f078$var$szlig,
    agrave: $538971b5b904f078$var$agrave,
    aacute: $538971b5b904f078$var$aacute,
    acirc: $538971b5b904f078$var$acirc,
    atilde: $538971b5b904f078$var$atilde,
    auml: $538971b5b904f078$var$auml,
    aring: $538971b5b904f078$var$aring,
    aelig: $538971b5b904f078$var$aelig,
    ccedil: $538971b5b904f078$var$ccedil,
    egrave: $538971b5b904f078$var$egrave,
    eacute: $538971b5b904f078$var$eacute,
    ecirc: $538971b5b904f078$var$ecirc,
    euml: $538971b5b904f078$var$euml,
    igrave: $538971b5b904f078$var$igrave,
    iacute: $538971b5b904f078$var$iacute,
    icirc: $538971b5b904f078$var$icirc,
    iuml: $538971b5b904f078$var$iuml,
    eth: $538971b5b904f078$var$eth,
    ntilde: $538971b5b904f078$var$ntilde,
    ograve: $538971b5b904f078$var$ograve,
    oacute: $538971b5b904f078$var$oacute,
    ocirc: $538971b5b904f078$var$ocirc,
    otilde: $538971b5b904f078$var$otilde,
    ouml: $538971b5b904f078$var$ouml,
    divide: $538971b5b904f078$var$divide,
    oslash: $538971b5b904f078$var$oslash,
    ugrave: $538971b5b904f078$var$ugrave,
    uacute: $538971b5b904f078$var$uacute,
    ucirc: $538971b5b904f078$var$ucirc,
    uuml: $538971b5b904f078$var$uuml,
    yacute: $538971b5b904f078$var$yacute,
    thorn: $538971b5b904f078$var$thorn,
    yuml: $538971b5b904f078$var$yuml,
    fnof: $538971b5b904f078$var$fnof,
    Alpha: $538971b5b904f078$var$Alpha,
    Beta: $538971b5b904f078$var$Beta,
    Gamma: $538971b5b904f078$var$Gamma,
    Delta: $538971b5b904f078$var$Delta,
    Epsilon: $538971b5b904f078$var$Epsilon,
    Zeta: $538971b5b904f078$var$Zeta,
    Eta: $538971b5b904f078$var$Eta,
    Theta: $538971b5b904f078$var$Theta,
    Iota: $538971b5b904f078$var$Iota,
    Kappa: $538971b5b904f078$var$Kappa,
    Lambda: $538971b5b904f078$var$Lambda,
    Mu: $538971b5b904f078$var$Mu,
    Nu: $538971b5b904f078$var$Nu,
    Xi: $538971b5b904f078$var$Xi,
    Omicron: $538971b5b904f078$var$Omicron,
    Pi: $538971b5b904f078$var$Pi,
    Rho: $538971b5b904f078$var$Rho,
    Sigma: $538971b5b904f078$var$Sigma,
    Tau: $538971b5b904f078$var$Tau,
    Upsilon: $538971b5b904f078$var$Upsilon,
    Phi: $538971b5b904f078$var$Phi,
    Chi: $538971b5b904f078$var$Chi,
    Psi: $538971b5b904f078$var$Psi,
    Omega: $538971b5b904f078$var$Omega,
    alpha: $538971b5b904f078$var$alpha,
    beta: $538971b5b904f078$var$beta,
    gamma: $538971b5b904f078$var$gamma,
    delta: $538971b5b904f078$var$delta,
    epsilon: $538971b5b904f078$var$epsilon,
    zeta: $538971b5b904f078$var$zeta,
    eta: $538971b5b904f078$var$eta,
    theta: $538971b5b904f078$var$theta,
    iota: $538971b5b904f078$var$iota,
    kappa: $538971b5b904f078$var$kappa,
    lambda: $538971b5b904f078$var$lambda,
    mu: $538971b5b904f078$var$mu,
    nu: $538971b5b904f078$var$nu,
    xi: $538971b5b904f078$var$xi,
    omicron: $538971b5b904f078$var$omicron,
    pi: $538971b5b904f078$var$pi,
    rho: $538971b5b904f078$var$rho,
    sigmaf: $538971b5b904f078$var$sigmaf,
    sigma: $538971b5b904f078$var$sigma,
    tau: $538971b5b904f078$var$tau,
    upsilon: $538971b5b904f078$var$upsilon,
    phi: $538971b5b904f078$var$phi,
    chi: $538971b5b904f078$var$chi,
    psi: $538971b5b904f078$var$psi,
    omega: $538971b5b904f078$var$omega,
    thetasym: $538971b5b904f078$var$thetasym,
    upsih: $538971b5b904f078$var$upsih,
    piv: $538971b5b904f078$var$piv,
    bull: $538971b5b904f078$var$bull,
    hellip: $538971b5b904f078$var$hellip,
    prime: $538971b5b904f078$var$prime,
    Prime: $538971b5b904f078$var$Prime,
    oline: $538971b5b904f078$var$oline,
    frasl: $538971b5b904f078$var$frasl,
    weierp: $538971b5b904f078$var$weierp,
    image: $538971b5b904f078$var$image,
    real: $538971b5b904f078$var$real,
    trade: $538971b5b904f078$var$trade,
    alefsym: $538971b5b904f078$var$alefsym,
    larr: $538971b5b904f078$var$larr,
    uarr: $538971b5b904f078$var$uarr,
    rarr: $538971b5b904f078$var$rarr,
    darr: $538971b5b904f078$var$darr,
    harr: $538971b5b904f078$var$harr,
    crarr: $538971b5b904f078$var$crarr,
    lArr: $538971b5b904f078$var$lArr,
    uArr: $538971b5b904f078$var$uArr,
    rArr: $538971b5b904f078$var$rArr,
    dArr: $538971b5b904f078$var$dArr,
    hArr: $538971b5b904f078$var$hArr,
    forall: $538971b5b904f078$var$forall,
    part: $538971b5b904f078$var$part,
    exist: $538971b5b904f078$var$exist,
    empty: $538971b5b904f078$var$empty,
    nabla: $538971b5b904f078$var$nabla,
    isin: $538971b5b904f078$var$isin,
    notin: $538971b5b904f078$var$notin,
    ni: $538971b5b904f078$var$ni,
    prod: $538971b5b904f078$var$prod,
    sum: $538971b5b904f078$var$sum,
    minus: $538971b5b904f078$var$minus,
    lowast: $538971b5b904f078$var$lowast,
    radic: $538971b5b904f078$var$radic,
    prop: $538971b5b904f078$var$prop,
    infin: $538971b5b904f078$var$infin,
    ang: $538971b5b904f078$var$ang,
    and: $538971b5b904f078$var$and,
    or: $538971b5b904f078$var$or,
    cap: $538971b5b904f078$var$cap,
    cup: $538971b5b904f078$var$cup,
    int: $538971b5b904f078$var$int,
    there4: $538971b5b904f078$var$there4,
    sim: $538971b5b904f078$var$sim,
    cong: $538971b5b904f078$var$cong,
    asymp: $538971b5b904f078$var$asymp,
    ne: $538971b5b904f078$var$ne,
    equiv: $538971b5b904f078$var$equiv,
    le: $538971b5b904f078$var$le,
    ge: $538971b5b904f078$var$ge,
    sub: $538971b5b904f078$var$sub,
    sup: $538971b5b904f078$var$sup,
    nsub: $538971b5b904f078$var$nsub,
    sube: $538971b5b904f078$var$sube,
    supe: $538971b5b904f078$var$supe,
    oplus: $538971b5b904f078$var$oplus,
    otimes: $538971b5b904f078$var$otimes,
    perp: $538971b5b904f078$var$perp,
    sdot: $538971b5b904f078$var$sdot,
    lceil: $538971b5b904f078$var$lceil,
    rceil: $538971b5b904f078$var$rceil,
    lfloor: $538971b5b904f078$var$lfloor,
    rfloor: $538971b5b904f078$var$rfloor,
    lang: $538971b5b904f078$var$lang,
    rang: $538971b5b904f078$var$rang,
    loz: $538971b5b904f078$var$loz,
    spades: $538971b5b904f078$var$spades,
    clubs: $538971b5b904f078$var$clubs,
    hearts: $538971b5b904f078$var$hearts,
    diams: $538971b5b904f078$var$diams,
    quot: $538971b5b904f078$var$quot,
    amp: $538971b5b904f078$var$amp,
    lt: $538971b5b904f078$var$lt,
    gt: $538971b5b904f078$var$gt,
    OElig: $538971b5b904f078$var$OElig,
    oelig: $538971b5b904f078$var$oelig,
    Scaron: $538971b5b904f078$var$Scaron,
    scaron: $538971b5b904f078$var$scaron,
    Yuml: $538971b5b904f078$var$Yuml,
    circ: $538971b5b904f078$var$circ,
    tilde: $538971b5b904f078$var$tilde,
    ensp: $538971b5b904f078$var$ensp,
    emsp: $538971b5b904f078$var$emsp,
    thinsp: $538971b5b904f078$var$thinsp,
    zwnj: $538971b5b904f078$var$zwnj,
    zwj: $538971b5b904f078$var$zwj,
    lrm: $538971b5b904f078$var$lrm,
    rlm: $538971b5b904f078$var$rlm,
    ndash: $538971b5b904f078$var$ndash,
    mdash: $538971b5b904f078$var$mdash,
    lsquo: $538971b5b904f078$var$lsquo,
    rsquo: $538971b5b904f078$var$rsquo,
    sbquo: $538971b5b904f078$var$sbquo,
    ldquo: $538971b5b904f078$var$ldquo,
    rdquo: $538971b5b904f078$var$rdquo,
    bdquo: $538971b5b904f078$var$bdquo,
    dagger: $538971b5b904f078$var$dagger,
    Dagger: $538971b5b904f078$var$Dagger,
    permil: $538971b5b904f078$var$permil,
    lsaquo: $538971b5b904f078$var$lsaquo,
    rsaquo: $538971b5b904f078$var$rsaquo,
    euro: $538971b5b904f078$var$euro
};
var $538971b5b904f078$var$characterEntitiesHtml4 = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    nbsp: $538971b5b904f078$var$nbsp,
    iexcl: $538971b5b904f078$var$iexcl,
    cent: $538971b5b904f078$var$cent,
    pound: $538971b5b904f078$var$pound,
    curren: $538971b5b904f078$var$curren,
    yen: $538971b5b904f078$var$yen,
    brvbar: $538971b5b904f078$var$brvbar,
    sect: $538971b5b904f078$var$sect,
    uml: $538971b5b904f078$var$uml,
    copy: $538971b5b904f078$var$copy,
    ordf: $538971b5b904f078$var$ordf,
    laquo: $538971b5b904f078$var$laquo,
    not: $538971b5b904f078$var$not,
    shy: $538971b5b904f078$var$shy,
    reg: $538971b5b904f078$var$reg,
    macr: $538971b5b904f078$var$macr,
    deg: $538971b5b904f078$var$deg,
    plusmn: $538971b5b904f078$var$plusmn,
    sup2: $538971b5b904f078$var$sup2,
    sup3: $538971b5b904f078$var$sup3,
    acute: $538971b5b904f078$var$acute,
    micro: $538971b5b904f078$var$micro,
    para: $538971b5b904f078$var$para,
    middot: $538971b5b904f078$var$middot,
    cedil: $538971b5b904f078$var$cedil,
    sup1: $538971b5b904f078$var$sup1,
    ordm: $538971b5b904f078$var$ordm,
    raquo: $538971b5b904f078$var$raquo,
    frac14: $538971b5b904f078$var$frac14,
    frac12: $538971b5b904f078$var$frac12,
    frac34: $538971b5b904f078$var$frac34,
    iquest: $538971b5b904f078$var$iquest,
    Agrave: $538971b5b904f078$var$Agrave,
    Aacute: $538971b5b904f078$var$Aacute,
    Acirc: $538971b5b904f078$var$Acirc,
    Atilde: $538971b5b904f078$var$Atilde,
    Auml: $538971b5b904f078$var$Auml,
    Aring: $538971b5b904f078$var$Aring,
    AElig: $538971b5b904f078$var$AElig,
    Ccedil: $538971b5b904f078$var$Ccedil,
    Egrave: $538971b5b904f078$var$Egrave,
    Eacute: $538971b5b904f078$var$Eacute,
    Ecirc: $538971b5b904f078$var$Ecirc,
    Euml: $538971b5b904f078$var$Euml,
    Igrave: $538971b5b904f078$var$Igrave,
    Iacute: $538971b5b904f078$var$Iacute,
    Icirc: $538971b5b904f078$var$Icirc,
    Iuml: $538971b5b904f078$var$Iuml,
    ETH: $538971b5b904f078$var$ETH,
    Ntilde: $538971b5b904f078$var$Ntilde,
    Ograve: $538971b5b904f078$var$Ograve,
    Oacute: $538971b5b904f078$var$Oacute,
    Ocirc: $538971b5b904f078$var$Ocirc,
    Otilde: $538971b5b904f078$var$Otilde,
    Ouml: $538971b5b904f078$var$Ouml,
    times: $538971b5b904f078$var$times,
    Oslash: $538971b5b904f078$var$Oslash,
    Ugrave: $538971b5b904f078$var$Ugrave,
    Uacute: $538971b5b904f078$var$Uacute,
    Ucirc: $538971b5b904f078$var$Ucirc,
    Uuml: $538971b5b904f078$var$Uuml,
    Yacute: $538971b5b904f078$var$Yacute,
    THORN: $538971b5b904f078$var$THORN,
    szlig: $538971b5b904f078$var$szlig,
    agrave: $538971b5b904f078$var$agrave,
    aacute: $538971b5b904f078$var$aacute,
    acirc: $538971b5b904f078$var$acirc,
    atilde: $538971b5b904f078$var$atilde,
    auml: $538971b5b904f078$var$auml,
    aring: $538971b5b904f078$var$aring,
    aelig: $538971b5b904f078$var$aelig,
    ccedil: $538971b5b904f078$var$ccedil,
    egrave: $538971b5b904f078$var$egrave,
    eacute: $538971b5b904f078$var$eacute,
    ecirc: $538971b5b904f078$var$ecirc,
    euml: $538971b5b904f078$var$euml,
    igrave: $538971b5b904f078$var$igrave,
    iacute: $538971b5b904f078$var$iacute,
    icirc: $538971b5b904f078$var$icirc,
    iuml: $538971b5b904f078$var$iuml,
    eth: $538971b5b904f078$var$eth,
    ntilde: $538971b5b904f078$var$ntilde,
    ograve: $538971b5b904f078$var$ograve,
    oacute: $538971b5b904f078$var$oacute,
    ocirc: $538971b5b904f078$var$ocirc,
    otilde: $538971b5b904f078$var$otilde,
    ouml: $538971b5b904f078$var$ouml,
    divide: $538971b5b904f078$var$divide,
    oslash: $538971b5b904f078$var$oslash,
    ugrave: $538971b5b904f078$var$ugrave,
    uacute: $538971b5b904f078$var$uacute,
    ucirc: $538971b5b904f078$var$ucirc,
    uuml: $538971b5b904f078$var$uuml,
    yacute: $538971b5b904f078$var$yacute,
    thorn: $538971b5b904f078$var$thorn,
    yuml: $538971b5b904f078$var$yuml,
    fnof: $538971b5b904f078$var$fnof,
    Alpha: $538971b5b904f078$var$Alpha,
    Beta: $538971b5b904f078$var$Beta,
    Gamma: $538971b5b904f078$var$Gamma,
    Delta: $538971b5b904f078$var$Delta,
    Epsilon: $538971b5b904f078$var$Epsilon,
    Zeta: $538971b5b904f078$var$Zeta,
    Eta: $538971b5b904f078$var$Eta,
    Theta: $538971b5b904f078$var$Theta,
    Iota: $538971b5b904f078$var$Iota,
    Kappa: $538971b5b904f078$var$Kappa,
    Lambda: $538971b5b904f078$var$Lambda,
    Mu: $538971b5b904f078$var$Mu,
    Nu: $538971b5b904f078$var$Nu,
    Xi: $538971b5b904f078$var$Xi,
    Omicron: $538971b5b904f078$var$Omicron,
    Pi: $538971b5b904f078$var$Pi,
    Rho: $538971b5b904f078$var$Rho,
    Sigma: $538971b5b904f078$var$Sigma,
    Tau: $538971b5b904f078$var$Tau,
    Upsilon: $538971b5b904f078$var$Upsilon,
    Phi: $538971b5b904f078$var$Phi,
    Chi: $538971b5b904f078$var$Chi,
    Psi: $538971b5b904f078$var$Psi,
    Omega: $538971b5b904f078$var$Omega,
    alpha: $538971b5b904f078$var$alpha,
    beta: $538971b5b904f078$var$beta,
    gamma: $538971b5b904f078$var$gamma,
    delta: $538971b5b904f078$var$delta,
    epsilon: $538971b5b904f078$var$epsilon,
    zeta: $538971b5b904f078$var$zeta,
    eta: $538971b5b904f078$var$eta,
    theta: $538971b5b904f078$var$theta,
    iota: $538971b5b904f078$var$iota,
    kappa: $538971b5b904f078$var$kappa,
    lambda: $538971b5b904f078$var$lambda,
    mu: $538971b5b904f078$var$mu,
    nu: $538971b5b904f078$var$nu,
    xi: $538971b5b904f078$var$xi,
    omicron: $538971b5b904f078$var$omicron,
    pi: $538971b5b904f078$var$pi,
    rho: $538971b5b904f078$var$rho,
    sigmaf: $538971b5b904f078$var$sigmaf,
    sigma: $538971b5b904f078$var$sigma,
    tau: $538971b5b904f078$var$tau,
    upsilon: $538971b5b904f078$var$upsilon,
    phi: $538971b5b904f078$var$phi,
    chi: $538971b5b904f078$var$chi,
    psi: $538971b5b904f078$var$psi,
    omega: $538971b5b904f078$var$omega,
    thetasym: $538971b5b904f078$var$thetasym,
    upsih: $538971b5b904f078$var$upsih,
    piv: $538971b5b904f078$var$piv,
    bull: $538971b5b904f078$var$bull,
    hellip: $538971b5b904f078$var$hellip,
    prime: $538971b5b904f078$var$prime,
    Prime: $538971b5b904f078$var$Prime,
    oline: $538971b5b904f078$var$oline,
    frasl: $538971b5b904f078$var$frasl,
    weierp: $538971b5b904f078$var$weierp,
    image: $538971b5b904f078$var$image,
    real: $538971b5b904f078$var$real,
    trade: $538971b5b904f078$var$trade,
    alefsym: $538971b5b904f078$var$alefsym,
    larr: $538971b5b904f078$var$larr,
    uarr: $538971b5b904f078$var$uarr,
    rarr: $538971b5b904f078$var$rarr,
    darr: $538971b5b904f078$var$darr,
    harr: $538971b5b904f078$var$harr,
    crarr: $538971b5b904f078$var$crarr,
    lArr: $538971b5b904f078$var$lArr,
    uArr: $538971b5b904f078$var$uArr,
    rArr: $538971b5b904f078$var$rArr,
    dArr: $538971b5b904f078$var$dArr,
    hArr: $538971b5b904f078$var$hArr,
    forall: $538971b5b904f078$var$forall,
    part: $538971b5b904f078$var$part,
    exist: $538971b5b904f078$var$exist,
    empty: $538971b5b904f078$var$empty,
    nabla: $538971b5b904f078$var$nabla,
    isin: $538971b5b904f078$var$isin,
    notin: $538971b5b904f078$var$notin,
    ni: $538971b5b904f078$var$ni,
    prod: $538971b5b904f078$var$prod,
    sum: $538971b5b904f078$var$sum,
    minus: $538971b5b904f078$var$minus,
    lowast: $538971b5b904f078$var$lowast,
    radic: $538971b5b904f078$var$radic,
    prop: $538971b5b904f078$var$prop,
    infin: $538971b5b904f078$var$infin,
    ang: $538971b5b904f078$var$ang,
    and: $538971b5b904f078$var$and,
    or: $538971b5b904f078$var$or,
    cap: $538971b5b904f078$var$cap,
    cup: $538971b5b904f078$var$cup,
    int: $538971b5b904f078$var$int,
    there4: $538971b5b904f078$var$there4,
    sim: $538971b5b904f078$var$sim,
    cong: $538971b5b904f078$var$cong,
    asymp: $538971b5b904f078$var$asymp,
    ne: $538971b5b904f078$var$ne,
    equiv: $538971b5b904f078$var$equiv,
    le: $538971b5b904f078$var$le,
    ge: $538971b5b904f078$var$ge,
    sub: $538971b5b904f078$var$sub,
    sup: $538971b5b904f078$var$sup,
    nsub: $538971b5b904f078$var$nsub,
    sube: $538971b5b904f078$var$sube,
    supe: $538971b5b904f078$var$supe,
    oplus: $538971b5b904f078$var$oplus,
    otimes: $538971b5b904f078$var$otimes,
    perp: $538971b5b904f078$var$perp,
    sdot: $538971b5b904f078$var$sdot,
    lceil: $538971b5b904f078$var$lceil,
    rceil: $538971b5b904f078$var$rceil,
    lfloor: $538971b5b904f078$var$lfloor,
    rfloor: $538971b5b904f078$var$rfloor,
    lang: $538971b5b904f078$var$lang,
    rang: $538971b5b904f078$var$rang,
    loz: $538971b5b904f078$var$loz,
    spades: $538971b5b904f078$var$spades,
    clubs: $538971b5b904f078$var$clubs,
    hearts: $538971b5b904f078$var$hearts,
    diams: $538971b5b904f078$var$diams,
    quot: $538971b5b904f078$var$quot,
    amp: $538971b5b904f078$var$amp,
    lt: $538971b5b904f078$var$lt,
    gt: $538971b5b904f078$var$gt,
    OElig: $538971b5b904f078$var$OElig,
    oelig: $538971b5b904f078$var$oelig,
    Scaron: $538971b5b904f078$var$Scaron,
    scaron: $538971b5b904f078$var$scaron,
    Yuml: $538971b5b904f078$var$Yuml,
    circ: $538971b5b904f078$var$circ,
    tilde: $538971b5b904f078$var$tilde,
    ensp: $538971b5b904f078$var$ensp,
    emsp: $538971b5b904f078$var$emsp,
    thinsp: $538971b5b904f078$var$thinsp,
    zwnj: $538971b5b904f078$var$zwnj,
    zwj: $538971b5b904f078$var$zwj,
    lrm: $538971b5b904f078$var$lrm,
    rlm: $538971b5b904f078$var$rlm,
    ndash: $538971b5b904f078$var$ndash,
    mdash: $538971b5b904f078$var$mdash,
    lsquo: $538971b5b904f078$var$lsquo,
    rsquo: $538971b5b904f078$var$rsquo,
    sbquo: $538971b5b904f078$var$sbquo,
    ldquo: $538971b5b904f078$var$ldquo,
    rdquo: $538971b5b904f078$var$rdquo,
    bdquo: $538971b5b904f078$var$bdquo,
    dagger: $538971b5b904f078$var$dagger,
    Dagger: $538971b5b904f078$var$Dagger,
    permil: $538971b5b904f078$var$permil,
    lsaquo: $538971b5b904f078$var$lsaquo,
    rsaquo: $538971b5b904f078$var$rsaquo,
    euro: $538971b5b904f078$var$euro,
    "default": $538971b5b904f078$var$index
});
var $538971b5b904f078$var$dangerous$1 = [
    "cent",
    "copy",
    "divide",
    "gt",
    "lt",
    "not",
    "para",
    "times"
];
var $538971b5b904f078$var$dangerous$2 = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    "default": $538971b5b904f078$var$dangerous$1
});
var $538971b5b904f078$var$entities = $538971b5b904f078$var$getCjsExportFromNamespace($538971b5b904f078$var$characterEntitiesHtml4);
var $538971b5b904f078$var$dangerous = $538971b5b904f078$var$getCjsExportFromNamespace($538971b5b904f078$var$dangerous$2);
var $538971b5b904f078$var$decimal = $538971b5b904f078$var$isDecimal;
var $538971b5b904f078$var$stringifyEntities = $538971b5b904f078$var$encode;
$538971b5b904f078$var$encode.escape = $538971b5b904f078$var$escape;
var $538971b5b904f078$var$own$3 = {}.hasOwnProperty;
// List of enforced escapes.
var $538971b5b904f078$var$escapes = [
    '"',
    "'",
    "<",
    ">",
    "&",
    "`"
];
// Map of characters to names.
var $538971b5b904f078$var$characters = $538971b5b904f078$var$construct();
// Default escapes.
var $538971b5b904f078$var$defaultEscapes = $538971b5b904f078$var$toExpression($538971b5b904f078$var$escapes);
// Surrogate pairs.
var $538971b5b904f078$var$surrogatePair = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
// Non-ASCII characters.
// eslint-disable-next-line no-control-regex, unicorn/no-hex-escape
var $538971b5b904f078$var$bmp = /[\x01-\t\x0B\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g;
// Encode special characters in `value`.
function $538971b5b904f078$var$encode(value, options) {
    var settings = options || {};
    var subset = settings.subset;
    var set = subset ? $538971b5b904f078$var$toExpression(subset) : $538971b5b904f078$var$defaultEscapes;
    var escapeOnly = settings.escapeOnly;
    var omit = settings.omitOptionalSemicolons;
    value = value.replace(set, replace);
    if (subset || escapeOnly) return value;
    return value.replace($538971b5b904f078$var$surrogatePair, replaceSurrogatePair).replace($538971b5b904f078$var$bmp, replace);
    function replaceSurrogatePair(pair, pos, val) {
        return $538971b5b904f078$var$toHexReference((pair.charCodeAt(0) - 0xd800) * 0x400 + pair.charCodeAt(1) - 0xdc00 + 0x10000, val.charAt(pos + 2), omit);
    }
    function replace(char, pos, val) {
        return $538971b5b904f078$var$one$1(char, val.charAt(pos + 1), settings);
    }
}
// Shortcut to escape special characters in HTML.
function $538971b5b904f078$var$escape(value) {
    return $538971b5b904f078$var$encode(value, {
        escapeOnly: true,
        useNamedReferences: true
    });
}
// Encode `char` according to `options`.
function $538971b5b904f078$var$one$1(char, next, options) {
    var shortest = options.useShortestReferences;
    var omit = options.omitOptionalSemicolons;
    var named;
    var code;
    var numeric;
    var decimal;
    if ((shortest || options.useNamedReferences) && $538971b5b904f078$var$own$3.call($538971b5b904f078$var$characters, char)) named = $538971b5b904f078$var$toNamed($538971b5b904f078$var$characters[char], next, omit, options.attribute);
    if (shortest || !named) {
        code = char.charCodeAt(0);
        numeric = $538971b5b904f078$var$toHexReference(code, next, omit);
        // Use the shortest numeric reference when requested.
        // A simple algorithm would use decimal for all code points under 100, as
        // those are shorter than hexadecimal:
        //
        // * `&#99;` vs `&#x63;` (decimal shorter)
        // * `&#100;` vs `&#x64;` (equal)
        //
        // However, because we take `next` into consideration when `omit` is used,
        // And it would be possible that decimals are shorter on bigger values as
        // well if `next` is hexadecimal but not decimal, we instead compare both.
        if (shortest) {
            decimal = $538971b5b904f078$var$toDecimalReference(code, next, omit);
            if (decimal.length < numeric.length) numeric = decimal;
        }
    }
    if (named && (!shortest || named.length < numeric.length)) return named;
    return numeric;
}
// Transform `code` into an entity.
function $538971b5b904f078$var$toNamed(name, next, omit, attribute) {
    var value = "&" + name;
    if (omit && $538971b5b904f078$var$own$3.call($538971b5b904f078$var$legacy, name) && $538971b5b904f078$var$dangerous.indexOf(name) === -1 && (!attribute || next && next !== "=" && !$538971b5b904f078$var$isAlphanumerical(next))) return value;
    return value + ";";
}
// Transform `code` into a hexadecimal character reference.
function $538971b5b904f078$var$toHexReference(code, next, omit) {
    var value = "&#x" + code.toString(16).toUpperCase();
    return omit && next && !$538971b5b904f078$var$isHexadecimal(next) ? value : value + ";";
}
// Transform `code` into a decimal character reference.
function $538971b5b904f078$var$toDecimalReference(code, next, omit) {
    var value = "&#" + String(code);
    return omit && next && !$538971b5b904f078$var$decimal(next) ? value : value + ";";
}
// Create an expression for `characters`.
function $538971b5b904f078$var$toExpression(characters) {
    return new RegExp("[" + characters.join("") + "]", "g");
}
// Construct the map.
function $538971b5b904f078$var$construct() {
    var chars = {};
    var name;
    for(name in $538971b5b904f078$var$entities)chars[$538971b5b904f078$var$entities[name]] = name;
    return chars;
}
// Characters.
var $538971b5b904f078$var$NULL = "\0";
var $538971b5b904f078$var$AMP = "&";
var $538971b5b904f078$var$SP = " ";
var $538971b5b904f078$var$TB = "	";
var $538971b5b904f078$var$GR = "`";
var $538971b5b904f078$var$DQ$1 = '"';
var $538971b5b904f078$var$SQ$1 = "'";
var $538971b5b904f078$var$EQ = "=";
var $538971b5b904f078$var$LT = "<";
var $538971b5b904f078$var$GT = ">";
var $538971b5b904f078$var$SO = "/";
var $538971b5b904f078$var$LF = "\n";
var $538971b5b904f078$var$CR = "\r";
var $538971b5b904f078$var$FF = "\f";
var $538971b5b904f078$var$whitespace = [
    $538971b5b904f078$var$SP,
    $538971b5b904f078$var$TB,
    $538971b5b904f078$var$LF,
    $538971b5b904f078$var$CR,
    $538971b5b904f078$var$FF
];
// https://html.spec.whatwg.org/#attribute-name-state
var $538971b5b904f078$var$name = $538971b5b904f078$var$whitespace.concat($538971b5b904f078$var$AMP, $538971b5b904f078$var$SO, $538971b5b904f078$var$GT, $538971b5b904f078$var$EQ);
// https://html.spec.whatwg.org/#attribute-value-(unquoted)-state
var $538971b5b904f078$var$unquoted$1 = $538971b5b904f078$var$whitespace.concat($538971b5b904f078$var$AMP, $538971b5b904f078$var$GT);
var $538971b5b904f078$var$unquotedSafe = $538971b5b904f078$var$unquoted$1.concat($538971b5b904f078$var$NULL, $538971b5b904f078$var$DQ$1, $538971b5b904f078$var$SQ$1, $538971b5b904f078$var$LT, $538971b5b904f078$var$EQ, $538971b5b904f078$var$GR);
// https://html.spec.whatwg.org/#attribute-value-(single-quoted)-state
var $538971b5b904f078$var$singleQuoted$1 = [
    $538971b5b904f078$var$AMP,
    $538971b5b904f078$var$SQ$1
];
// https://html.spec.whatwg.org/#attribute-value-(double-quoted)-state
var $538971b5b904f078$var$doubleQuoted$1 = [
    $538971b5b904f078$var$AMP,
    $538971b5b904f078$var$DQ$1
];
// Maps of subsets. Each value is a matrix of tuples.
// The first value causes parse errors, the second is valid.
// Of both values, the first value is unsafe, and the second is safe.
var $538971b5b904f078$var$constants = {
    name: [
        [
            $538971b5b904f078$var$name,
            $538971b5b904f078$var$name.concat($538971b5b904f078$var$DQ$1, $538971b5b904f078$var$SQ$1, $538971b5b904f078$var$GR)
        ],
        [
            $538971b5b904f078$var$name.concat($538971b5b904f078$var$NULL, $538971b5b904f078$var$DQ$1, $538971b5b904f078$var$SQ$1, $538971b5b904f078$var$LT),
            $538971b5b904f078$var$name.concat($538971b5b904f078$var$NULL, $538971b5b904f078$var$DQ$1, $538971b5b904f078$var$SQ$1, $538971b5b904f078$var$LT, $538971b5b904f078$var$GR)
        ]
    ],
    unquoted: [
        [
            $538971b5b904f078$var$unquoted$1,
            $538971b5b904f078$var$unquotedSafe
        ],
        [
            $538971b5b904f078$var$unquotedSafe,
            $538971b5b904f078$var$unquotedSafe
        ]
    ],
    single: [
        [
            $538971b5b904f078$var$singleQuoted$1,
            $538971b5b904f078$var$singleQuoted$1.concat($538971b5b904f078$var$DQ$1, $538971b5b904f078$var$GR)
        ],
        [
            $538971b5b904f078$var$singleQuoted$1.concat($538971b5b904f078$var$NULL),
            $538971b5b904f078$var$singleQuoted$1.concat($538971b5b904f078$var$NULL, $538971b5b904f078$var$DQ$1, $538971b5b904f078$var$GR)
        ]
    ],
    double: [
        [
            $538971b5b904f078$var$doubleQuoted$1,
            $538971b5b904f078$var$doubleQuoted$1.concat($538971b5b904f078$var$SQ$1, $538971b5b904f078$var$GR)
        ],
        [
            $538971b5b904f078$var$doubleQuoted$1.concat($538971b5b904f078$var$NULL),
            $538971b5b904f078$var$doubleQuoted$1.concat($538971b5b904f078$var$NULL, $538971b5b904f078$var$SQ$1, $538971b5b904f078$var$GR)
        ]
    ]
};
var $538971b5b904f078$var$spaces = $538971b5b904f078$var$spaceSeparatedTokens.stringify;
var $538971b5b904f078$var$commas = $538971b5b904f078$var$commaSeparatedTokens.stringify;
var $538971b5b904f078$var$element_1 = $538971b5b904f078$var$element;
/* Constants. */ var $538971b5b904f078$var$emptyString = "";
/* Characters. */ var $538971b5b904f078$var$space$1 = " ";
var $538971b5b904f078$var$quotationMark = '"';
var $538971b5b904f078$var$apostrophe$1 = "'";
var $538971b5b904f078$var$equalsTo = "=";
var $538971b5b904f078$var$lessThan$1 = "<";
var $538971b5b904f078$var$greaterThan = ">";
var $538971b5b904f078$var$slash$1 = "/";
var $538971b5b904f078$var$newLine = "\n";
/* Stringify an element `node`. */ function $538971b5b904f078$var$element(ctx, node, index, parent, printWidthOffset, innerTextLength) {
    var parentSchema = ctx.schema;
    var name = node.tagName;
    var value = "";
    var selfClosing;
    var close;
    var omit;
    var root = node;
    var content;
    var attrs;
    var indentLevel = $538971b5b904f078$var$getNodeData(node, "indentLevel", 0);
    var printContext = {
        offset: printWidthOffset,
        wrapAttributes: false,
        indentLevel: indentLevel
    };
    var isVoid = ctx.voids.indexOf(name) !== -1;
    var ignoreAttrCollapsing = $538971b5b904f078$var$getNodeData(node, "ignore", false) || $538971b5b904f078$var$getNodeData(node, "preserveAttrWrapping", false);
    if (parentSchema.space === "html" && name === "svg") ctx.schema = $538971b5b904f078$var$svg_1;
    if (ctx.schema.space === "svg") {
        omit = false;
        close = true;
        selfClosing = ctx.closeEmpty;
    } else {
        omit = ctx.omit;
        close = ctx.close;
        selfClosing = isVoid;
    }
    // check for 'selfClosing' property set by hast-util-from-webparser package
    // in order to support custom self-closing elements
    if (selfClosing === false) selfClosing = $538971b5b904f078$var$getNodeData(node, "selfClosing", false);
    // <
    printContext.offset += $538971b5b904f078$var$lessThan$1.length;
    // tagName length
    printContext.offset += node.tagName.length;
    // / closing tag
    if (selfClosing && !isVoid) printContext.offset += $538971b5b904f078$var$slash$1.length;
    // >
    printContext.offset += $538971b5b904f078$var$greaterThan.length;
    const propertyCount = Object.keys(node.properties).length;
    // force to wrap attributes on multiple lines when the node contains
    // more than one attribute
    if (propertyCount > 1 && ctx.wrapAttributes) printContext.wrapAttributes = true;
    // one space before each attribute
    if (propertyCount) printContext.offset += propertyCount * $538971b5b904f078$var$space$1.length;
    // represent the length of the inner text of the node
    printContext.offset += innerTextLength;
    attrs = $538971b5b904f078$var$attributes(ctx, node.properties, printContext, ignoreAttrCollapsing);
    const shouldCollapse = ignoreAttrCollapsing === false && printContext.wrapAttributes;
    content = $538971b5b904f078$var$all_1(ctx, root);
    /* If the node is categorised as void, but it has
   * children, remove the categorisation.  This
   * enables for example `menuitem`s, which are
   * void in W3C HTML but not void in WHATWG HTML, to
   * be stringified properly. */ selfClosing = content ? false : selfClosing;
    if (attrs || !omit || !omit.opening(node, index, parent)) {
        value = $538971b5b904f078$var$lessThan$1 + name;
        if (attrs) {
            // add no space after tagName when element is collapsed
            if (shouldCollapse) value += attrs;
            else value += $538971b5b904f078$var$space$1 + attrs;
        }
        let selfClosed = false;
        // check if the should close self-closing elements
        if (selfClosing && close) {
            if ((!ctx.tightClose || attrs.charAt(attrs.length - 1) === $538971b5b904f078$var$slash$1) && !shouldCollapse) value += $538971b5b904f078$var$space$1;
            if (shouldCollapse) value += $538971b5b904f078$var$newLine + $538971b5b904f078$var$repeatString(ctx.tabWidth, printContext.indentLevel);
            selfClosed = true;
            value += $538971b5b904f078$var$slash$1;
        } else if (selfClosing && !isVoid) {
            if (shouldCollapse) value += $538971b5b904f078$var$newLine + $538971b5b904f078$var$repeatString(ctx.tabWidth, printContext.indentLevel);
            selfClosed = true;
            value += $538971b5b904f078$var$slash$1;
        }
        // add newline when element should be wrappend on multiple lines and when
        // it's no self-closing element because in that case the newline was already added before the slash (/)
        if (shouldCollapse && !selfClosed) value += $538971b5b904f078$var$newLine + $538971b5b904f078$var$repeatString(ctx.tabWidth, printContext.indentLevel);
        value += $538971b5b904f078$var$greaterThan;
    }
    value += content;
    if (!selfClosing && (!omit || !omit.closing(node, index, parent))) value += $538971b5b904f078$var$lessThan$1 + $538971b5b904f078$var$slash$1 + name + $538971b5b904f078$var$greaterThan;
    ctx.schema = parentSchema;
    return value;
}
/* Stringify all attributes. */ function $538971b5b904f078$var$attributes(ctx, props, printContext, ignoreIndent) {
    var values = [];
    var key;
    var value;
    var result;
    var length;
    var index;
    var last;
    for(key in props){
        value = props[key];
        if (value == null) continue;
        result = $538971b5b904f078$var$attribute$1(ctx, key, value);
        printContext.offset += result.length;
        if (ignoreIndent === false && printContext.offset > ctx.printWidth) printContext.wrapAttributes = true;
        if (result) values.push(result);
    }
    length = values.length;
    index = -1;
    while(++index < length){
        result = values[index];
        last = null;
        /* In tight mode, don’t add a space after quoted attributes. */ if (last !== $538971b5b904f078$var$quotationMark && last !== $538971b5b904f078$var$apostrophe$1) {
            if (printContext.wrapAttributes) values[index] = $538971b5b904f078$var$newLine + $538971b5b904f078$var$repeatString(ctx.tabWidth, printContext.indentLevel + 1) + result;
            else if (index !== length - 1) values[index] = result + $538971b5b904f078$var$space$1;
            else values[index] = result;
        }
    }
    return values.join($538971b5b904f078$var$emptyString);
}
/* Stringify one attribute. */ function $538971b5b904f078$var$attribute$1(ctx, key, value) {
    var schema = ctx.schema;
    var info = $538971b5b904f078$var$find_1(schema, key);
    var name = info.attribute;
    if (value == null || typeof value === "number" && isNaN(value) || value === false && info.boolean) return $538971b5b904f078$var$emptyString;
    name = $538971b5b904f078$var$attributeName$1(ctx, name);
    if (value === true && info.boolean || value === true && info.overloadedBoolean) return name;
    return name + $538971b5b904f078$var$attributeValue$1(ctx, key, value, info);
}
/* Stringify the attribute name. */ function $538971b5b904f078$var$attributeName$1(ctx, name) {
    // Always encode without parse errors in non-HTML.
    var valid = ctx.schema.space === "html" ? ctx.valid : 1;
    var subset = $538971b5b904f078$var$constants.name[valid][ctx.safe];
    return $538971b5b904f078$var$stringifyEntities(name, $538971b5b904f078$var$immutable(ctx.entities, {
        subset: subset
    }));
}
/* Stringify the attribute value. */ function $538971b5b904f078$var$attributeValue$1(ctx, key, value, info) {
    var quote = ctx.quote;
    if (typeof value === "object" && "length" in value) /* `spaces` doesn’t accept a second argument, but it’s
     * given here just to keep the code cleaner. */ value = (info.commaSeparated ? $538971b5b904f078$var$commas : $538971b5b904f078$var$spaces)(value, {
        padLeft: !ctx.tightLists
    });
    value = String(value);
    // When attr has no value we avoid quoting
    if (value === "") return value;
    else value = $538971b5b904f078$var$equalsTo + quote + value + quote;
    return value;
}
function $538971b5b904f078$var$getNodeData(node, key, defaultValue) {
    let data = node.data || {};
    return data[key] || defaultValue;
}
var $538971b5b904f078$var$doctype_1 = $538971b5b904f078$var$doctype;
/* Stringify a doctype `node`. */ function $538971b5b904f078$var$doctype(ctx, node) {
    var sep = ctx.tightDoctype ? "" : " ";
    var name = node.name;
    var pub = node.public;
    var sys = node.system;
    var val = [
        "<!doctype"
    ];
    if (name) {
        val.push(sep, name);
        if (pub != null) val.push(" public", sep, $538971b5b904f078$var$smart(pub));
        else if (sys != null) val.push(" system");
        if (sys != null) val.push(sep, $538971b5b904f078$var$smart(sys));
    }
    return val.join("") + ">";
}
function $538971b5b904f078$var$smart(value) {
    var quote = value.indexOf('"') === -1 ? '"' : "'";
    return quote + value + quote;
}
var $538971b5b904f078$var$comment_1 = $538971b5b904f078$var$comment;
/* Stringify a comment `node`. */ function $538971b5b904f078$var$comment(ctx, node) {
    return "<!--" + node.value + "-->";
}
var $538971b5b904f078$var$raw_1 = $538971b5b904f078$var$raw;
/* Stringify `raw`. */ function $538971b5b904f078$var$raw(ctx, node) {
    return node.value;
}
var $538971b5b904f078$var$one_1 = $538971b5b904f078$var$one;
var $538971b5b904f078$var$own$2 = {}.hasOwnProperty;
var $538971b5b904f078$var$handlers = {};
$538971b5b904f078$var$handlers.root = $538971b5b904f078$var$all_1;
$538971b5b904f078$var$handlers.text = $538971b5b904f078$var$text_1;
$538971b5b904f078$var$handlers.element = $538971b5b904f078$var$element_1;
$538971b5b904f078$var$handlers.doctype = $538971b5b904f078$var$doctype_1;
$538971b5b904f078$var$handlers.comment = $538971b5b904f078$var$comment_1;
$538971b5b904f078$var$handlers.raw = $538971b5b904f078$var$raw_1;
/* Stringify `node`. */ function $538971b5b904f078$var$one(ctx, node, index, parent, printWidthOffset, innerTextLength) {
    var type = node && node.type;
    if (!type) throw new Error("Expected node, not `" + node + "`");
    if (!$538971b5b904f078$var$own$2.call($538971b5b904f078$var$handlers, type)) throw new Error("Cannot compile unknown node `" + type + "`");
    return $538971b5b904f078$var$handlers[type](ctx, node, index, parent, printWidthOffset, innerTextLength);
}
var $538971b5b904f078$var$voids = $538971b5b904f078$var$getCjsExportFromNamespace($538971b5b904f078$var$htmlVoidElements);
var $538971b5b904f078$var$lib$1 = $538971b5b904f078$var$toHTML;
/* Characters. */ var $538971b5b904f078$var$DQ = '"';
var $538971b5b904f078$var$SQ = "'";
/* Stringify the given HAST node. */ function $538971b5b904f078$var$toHTML(node, options) {
    var settings = options || {};
    var quote = settings.singleQuote ? $538971b5b904f078$var$SQ : $538971b5b904f078$var$DQ;
    var printWidth = settings.printWidth === undefined ? 80 : settings.printWidth;
    var useTabs = settings.useTabs;
    var tabWidth = settings.tabWidth || 2;
    var wrapAttributes = settings.wrapAttributes;
    if (useTabs) tabWidth = "	";
    else if (typeof tabWidth === "number") tabWidth = $538971b5b904f078$var$repeatString(" ", tabWidth);
    return $538971b5b904f078$var$one_1({
        valid: settings.allowParseErrors ? 0 : 1,
        safe: settings.allowDangerousCharacters ? 0 : 1,
        schema: settings.space === "svg" ? $538971b5b904f078$var$svg_1 : $538971b5b904f078$var$html_1,
        omit: settings.omitOptionalTags && $538971b5b904f078$var$omission,
        quote: quote,
        printWidth: printWidth,
        tabWidth: tabWidth,
        wrapAttributes: wrapAttributes,
        tightDoctype: Boolean(settings.tightDoctype),
        tightLists: settings.tightCommaSeparatedLists,
        voids: settings.voids || $538971b5b904f078$var$voids.concat(),
        entities: settings.entities || {},
        close: settings.closeSelfClosing,
        tightClose: settings.tightSelfClosing,
        closeEmpty: settings.closeEmptyElements
    }, node);
}
var $538971b5b904f078$var$prettyhtmlHastToHtml = $538971b5b904f078$var$lib$1;
const $538971b5b904f078$var$void_els = [
    "area",
    "base",
    "br",
    "col",
    "embed",
    "hr",
    "img",
    "input",
    "link",
    "meta",
    "param",
    "source",
    "track",
    "wbr"
];
// these regex don't check if it is a valid svelte tag name
// i want to defer to svelte's compiler errors so i don't end up reimplementing the svelte parser
const $538971b5b904f078$var$RE_SVELTE_TAG = /^<svelte:([a-z]*)[\s\S]*(?:(?:svelte:[a-z]*)|(?:\/))>$/;
const $538971b5b904f078$var$RE_SVELTE_TAG_START = /(^\s*)<([\\/\s])*svelte:/;
function $538971b5b904f078$var$parse_svelte_tag(eat, value, silent) {
    const is_svelte_tag = $538971b5b904f078$var$RE_SVELTE_TAG_START.exec(value);
    if (is_svelte_tag) {
        if (silent) return true;
        const trimmed_value = value.trim();
        let cbPos = 0;
        let pos = 1;
        let current_tag = "";
        let in_tag_name = false;
        while(cbPos > -1){
            if (!trimmed_value[pos]) break;
            if (trimmed_value[pos].match(/</)) {
                cbPos++;
                current_tag = "";
                in_tag_name = true;
            }
            if (in_tag_name && trimmed_value[pos].match(/\s/)) in_tag_name = false;
            if (in_tag_name && !trimmed_value[pos].match(/</)) current_tag += trimmed_value[pos];
            const is_void = $538971b5b904f078$var$void_els.includes(current_tag);
            if (is_void && trimmed_value[pos].match(/>/) || (trimmed_value[pos - 1] + trimmed_value[pos]).match(/\/>/)) cbPos--;
            if ((trimmed_value[pos - 1] + trimmed_value[pos]).match(/<\//)) {
                let inner_indent = 0;
                while(inner_indent > -1)if (trimmed_value[pos].match(/>/)) {
                    pos++;
                    inner_indent -= 1;
                    cbPos -= 2;
                } else pos++;
            }
            pos++;
        }
        const match = $538971b5b904f078$var$RE_SVELTE_TAG.exec(trimmed_value.substring(0, pos).trim());
        if (!match) return;
        return eat(is_svelte_tag[1] + match[0])({
            type: "svelteTag",
            value: match[0],
            name: match[1]
        });
    }
}
// these regex don't check if it is a valid block name
// i want to defer to svelte's compiler errors so i don't end up reimplementing the svelte parser
// 'else if' is a special case due to the annoying whitespace
const $538971b5b904f078$var$RE_SVELTE_BLOCK_START = /(^\s*){[#:/@]/;
const $538971b5b904f078$var$RE_SVELTE_BLOCK = /^{[#:/@](else if|[a-z]+).*}$/;
function $538971b5b904f078$var$parse_svelte_block(eat, value, silent) {
    const is_svelte_block = $538971b5b904f078$var$RE_SVELTE_BLOCK_START.exec(value);
    if (is_svelte_block) {
        if (silent) return true;
        const trimmed_value = value.trim();
        let cbPos = 0;
        let pos = 1;
        while(cbPos > -1){
            if (trimmed_value[pos].match(/{/)) cbPos++;
            if (trimmed_value[pos].match(/}/)) cbPos--;
            pos++;
        }
        const match = $538971b5b904f078$var$RE_SVELTE_BLOCK.exec(trimmed_value.substring(0, pos));
        if (!match) return;
        return eat(is_svelte_block[1] + match[0])({
            type: "svelteBlock",
            value: `${is_svelte_block[1]}${match[0]}`,
            name: match[1]
        });
    }
}
const $538971b5b904f078$var$dotAllPolyfill = "[\0-\uFFFF]";
const $538971b5b904f078$var$attributeName = "[a-zA-Z_:][a-zA-Z0-9:._-]*";
const $538971b5b904f078$var$unquoted = "[^\"'=<>`\\u0000-\\u0020]+";
const $538971b5b904f078$var$singleQuoted = "'[^']*'";
const $538971b5b904f078$var$doubleQuoted = '"[^"]*"';
const $538971b5b904f078$var$jsProps = "{.*}".replace(".", $538971b5b904f078$var$dotAllPolyfill);
const $538971b5b904f078$var$attributeValue = "(?:" + $538971b5b904f078$var$unquoted + "|" + $538971b5b904f078$var$singleQuoted + "|" + $538971b5b904f078$var$doubleQuoted + "|" + $538971b5b904f078$var$jsProps + ")";
const $538971b5b904f078$var$attribute = "(?:\\s+" + $538971b5b904f078$var$attributeName + "(?:\\s*=\\s*" + $538971b5b904f078$var$attributeValue + ")?)";
const $538971b5b904f078$var$openTag = "<[A-Za-z]*[A-Za-z0-9\\.\\-]*" + $538971b5b904f078$var$attribute + "*\\s*\\/?>";
const $538971b5b904f078$var$closeTag = "<\\/[A-Za-z][A-Za-z0-9\\.\\-]*\\s*>";
"<[?].*?[?]>".replace(".", $538971b5b904f078$var$dotAllPolyfill);
const $538971b5b904f078$var$openCloseTag = new RegExp("^(?:" + $538971b5b904f078$var$openTag + "|" + $538971b5b904f078$var$closeTag + ")");
const $538971b5b904f078$var$tab = "	";
const $538971b5b904f078$var$space = " ";
const $538971b5b904f078$var$lineFeed = "\n";
const $538971b5b904f078$var$lessThan = "<";
const $538971b5b904f078$var$rawOpenExpression = /^<(script|pre|style)(?=(\s|>|$))/i;
const $538971b5b904f078$var$rawCloseExpression = /<\/(script|pre|style)>/i;
const $538971b5b904f078$var$commentOpenExpression = /^<!--/;
const $538971b5b904f078$var$commentCloseExpression = /-->/;
const $538971b5b904f078$var$instructionOpenExpression = /^<\?/;
const $538971b5b904f078$var$instructionCloseExpression = /\?>/;
const $538971b5b904f078$var$directiveOpenExpression = /^<![A-Za-z]/;
const $538971b5b904f078$var$directiveCloseExpression = />/;
const $538971b5b904f078$var$cdataOpenExpression = /^<!\[CDATA\[/;
const $538971b5b904f078$var$cdataCloseExpression = /\]\]>/;
const $538971b5b904f078$var$elementCloseExpression = /^$/;
const $538971b5b904f078$var$otherElementOpenExpression = new RegExp($538971b5b904f078$var$openCloseTag.source + "\\s*$");
const $538971b5b904f078$var$fragmentOpenExpression = /^<>/;
//@ts-ignore
function $538971b5b904f078$var$blockHtml(eat, value, silent) {
    const blocks = "[a-z\\.]*(\\.){0,1}[a-z][a-z0-9\\.]*";
    const elementOpenExpression = new RegExp("^</?(" + blocks + ")(?=(\\s|/?>|$))", "i");
    const length = value.length;
    let index = 0;
    let next;
    let line;
    let offset;
    let character;
    let sequence;
    const sequences = [
        [
            $538971b5b904f078$var$rawOpenExpression,
            $538971b5b904f078$var$rawCloseExpression,
            true
        ],
        [
            $538971b5b904f078$var$commentOpenExpression,
            $538971b5b904f078$var$commentCloseExpression,
            true
        ],
        [
            $538971b5b904f078$var$instructionOpenExpression,
            $538971b5b904f078$var$instructionCloseExpression,
            true
        ],
        [
            $538971b5b904f078$var$directiveOpenExpression,
            $538971b5b904f078$var$directiveCloseExpression,
            true
        ],
        [
            $538971b5b904f078$var$cdataOpenExpression,
            $538971b5b904f078$var$cdataCloseExpression,
            true
        ],
        [
            elementOpenExpression,
            $538971b5b904f078$var$elementCloseExpression,
            true
        ],
        [
            $538971b5b904f078$var$fragmentOpenExpression,
            $538971b5b904f078$var$elementCloseExpression,
            true
        ],
        [
            $538971b5b904f078$var$otherElementOpenExpression,
            $538971b5b904f078$var$elementCloseExpression,
            false
        ]
    ];
    // Eat initial spacing.
    while(index < length){
        character = value.charAt(index);
        if (character !== $538971b5b904f078$var$tab && character !== $538971b5b904f078$var$space) break;
        index++;
    }
    if (value.charAt(index) !== $538971b5b904f078$var$lessThan) return;
    next = value.indexOf($538971b5b904f078$var$lineFeed, index + 1);
    next = next === -1 ? length : next;
    line = value.slice(index, next);
    offset = -1;
    const count = sequences.length;
    while(++offset < count)if (sequences[offset][0].test(line)) {
        sequence = sequences[offset];
        break;
    }
    if (!sequence) return;
    if (silent) return sequence[2];
    index = next;
    if (!sequence[1].test(line)) while(index < length){
        next = value.indexOf($538971b5b904f078$var$lineFeed, index + 1);
        next = next === -1 ? length : next;
        line = value.slice(index + 1, next);
        if (sequence[1].test(line)) {
            if (line) index = next;
            break;
        }
        index = next;
    }
    const subvalue = value.slice(0, index);
    return eat(subvalue)({
        type: "html",
        value: subvalue
    });
}
function $538971b5b904f078$var$mdsvex_parser() {
    const Parser = this.Parser;
    const block_tokenizers = Parser.prototype.blockTokenizers;
    const methods = Parser.prototype.blockMethods;
    block_tokenizers.svelteBlock = $538971b5b904f078$var$parse_svelte_block;
    block_tokenizers.svelteTag = $538971b5b904f078$var$parse_svelte_tag;
    block_tokenizers.html = $538971b5b904f078$var$blockHtml;
    block_tokenizers.indentedCode = $538971b5b904f078$var$indentedCode;
    methods.splice(methods.indexOf("html"), 0, "svelteBlock");
    methods.splice(methods.indexOf("html"), 0, "svelteTag");
}
function $538971b5b904f078$var$indentedCode() {
    return true;
}
// Expose a frozen processor.
var $538971b5b904f078$var$unified_1 = $538971b5b904f078$var$unified().freeze();
var $538971b5b904f078$var$slice = [].slice;
var $538971b5b904f078$var$own$1 = {}.hasOwnProperty;
// Process pipeline.
var $538971b5b904f078$var$pipeline = $538971b5b904f078$var$trough_1().use($538971b5b904f078$var$pipelineParse).use($538971b5b904f078$var$pipelineRun).use($538971b5b904f078$var$pipelineStringify);
function $538971b5b904f078$var$pipelineParse(p, ctx) {
    ctx.tree = p.parse(ctx.file);
}
function $538971b5b904f078$var$pipelineRun(p, ctx, next) {
    p.run(ctx.tree, ctx.file, done);
    function done(err, tree, file) {
        if (err) next(err);
        else {
            ctx.tree = tree;
            ctx.file = file;
            next();
        }
    }
}
function $538971b5b904f078$var$pipelineStringify(p, ctx) {
    ctx.file.contents = p.stringify(ctx.tree, ctx.file);
}
// Function to create the first processor.
function $538971b5b904f078$var$unified() {
    var attachers = [];
    var transformers = $538971b5b904f078$var$trough_1();
    var namespace = {};
    var frozen = false;
    var freezeIndex = -1;
    // Data management.
    processor.data = data;
    // Lock.
    processor.freeze = freeze;
    // Plugins.
    processor.attachers = attachers;
    processor.use = use;
    // API.
    processor.parse = parse;
    processor.stringify = stringify;
    processor.run = run;
    processor.runSync = runSync;
    processor.process = process1;
    processor.processSync = processSync;
    // Expose.
    return processor;
    // Create a new processor based on the processor in the current scope.
    function processor() {
        var destination = $538971b5b904f078$var$unified();
        var length = attachers.length;
        var index = -1;
        while(++index < length)destination.use.apply(null, attachers[index]);
        destination.data($538971b5b904f078$var$extend$2(true, {}, namespace));
        return destination;
    }
    // Freeze: used to signal a processor that has finished configuration.
    //
    // For example, take unified itself: it’s frozen.
    // Plugins should not be added to it.
    // Rather, it should be extended, by invoking it, before modifying it.
    //
    // In essence, always invoke this when exporting a processor.
    function freeze() {
        var values;
        var plugin;
        var options;
        var transformer;
        if (frozen) return processor;
        while(++freezeIndex < attachers.length){
            values = attachers[freezeIndex];
            plugin = values[0];
            options = values[1];
            transformer = null;
            if (options === false) continue;
            if (options === true) values[1] = undefined;
            transformer = plugin.apply(processor, values.slice(1));
            if (typeof transformer === "function") transformers.use(transformer);
        }
        frozen = true;
        freezeIndex = Infinity;
        return processor;
    }
    // Data management.
    // Getter / setter for processor-specific informtion.
    function data(key, value) {
        if (typeof key === "string") {
            // Set `key`.
            if (arguments.length === 2) {
                $538971b5b904f078$var$assertUnfrozen("data", frozen);
                namespace[key] = value;
                return processor;
            }
            // Get `key`.
            return $538971b5b904f078$var$own$1.call(namespace, key) && namespace[key] || null;
        }
        // Set space.
        if (key) {
            $538971b5b904f078$var$assertUnfrozen("data", frozen);
            namespace = key;
            return processor;
        }
        // Get space.
        return namespace;
    }
    // Plugin management.
    //
    // Pass it:
    // *   an attacher and options,
    // *   a preset,
    // *   a list of presets, attachers, and arguments (list of attachers and
    //     options).
    function use(value) {
        var settings;
        $538971b5b904f078$var$assertUnfrozen("use", frozen);
        if (value === null || value === undefined) ;
        else if (typeof value === "function") addPlugin.apply(null, arguments);
        else if (typeof value === "object") {
            if ("length" in value) addList(value);
            else addPreset(value);
        } else throw new Error("Expected usable value, not `" + value + "`");
        if (settings) namespace.settings = $538971b5b904f078$var$extend$2(namespace.settings || {}, settings);
        return processor;
        function addPreset(result) {
            addList(result.plugins);
            if (result.settings) settings = $538971b5b904f078$var$extend$2(settings || {}, result.settings);
        }
        function add(value) {
            if (typeof value === "function") addPlugin(value);
            else if (typeof value === "object") {
                if ("length" in value) addPlugin.apply(null, value);
                else addPreset(value);
            } else throw new Error("Expected usable value, not `" + value + "`");
        }
        function addList(plugins) {
            var length;
            var index;
            if (plugins === null || plugins === undefined) ;
            else if (typeof plugins === "object" && "length" in plugins) {
                length = plugins.length;
                index = -1;
                while(++index < length)add(plugins[index]);
            } else throw new Error("Expected a list of plugins, not `" + plugins + "`");
        }
        function addPlugin(plugin, value) {
            var entry = find(plugin);
            if (entry) {
                if ($538971b5b904f078$var$isPlainObj(entry[1]) && $538971b5b904f078$var$isPlainObj(value)) value = $538971b5b904f078$var$extend$2(entry[1], value);
                entry[1] = value;
            } else attachers.push($538971b5b904f078$var$slice.call(arguments));
        }
    }
    function find(plugin) {
        var length = attachers.length;
        var index = -1;
        var entry;
        while(++index < length){
            entry = attachers[index];
            if (entry[0] === plugin) return entry;
        }
    }
    // Parse a file (in string or vfile representation) into a unist node using
    // the `Parser` on the processor.
    function parse(doc) {
        var file = $538971b5b904f078$var$vfile(doc);
        var Parser;
        freeze();
        Parser = processor.Parser;
        $538971b5b904f078$var$assertParser("parse", Parser);
        if ($538971b5b904f078$var$newable(Parser, "parse")) return new Parser(String(file), file).parse();
        return Parser(String(file), file) // eslint-disable-line new-cap
        ;
    }
    // Run transforms on a unist node representation of a file (in string or
    // vfile representation), async.
    function run(node, file, cb) {
        $538971b5b904f078$var$assertNode(node);
        freeze();
        if (!cb && typeof file === "function") {
            cb = file;
            file = null;
        }
        if (!cb) return new Promise(executor);
        executor(null, cb);
        function executor(resolve, reject) {
            transformers.run(node, $538971b5b904f078$var$vfile(file), done);
            function done(err, tree, file) {
                tree = tree || node;
                if (err) reject(err);
                else if (resolve) resolve(tree);
                else cb(null, tree, file);
            }
        }
    }
    // Run transforms on a unist node representation of a file (in string or
    // vfile representation), sync.
    function runSync(node, file) {
        var complete = false;
        var result;
        run(node, file, done);
        $538971b5b904f078$var$assertDone("runSync", "run", complete);
        return result;
        function done(err, tree) {
            complete = true;
            $538971b5b904f078$var$bail_1(err);
            result = tree;
        }
    }
    // Stringify a unist node representation of a file (in string or vfile
    // representation) into a string using the `Compiler` on the processor.
    function stringify(node, doc) {
        var file = $538971b5b904f078$var$vfile(doc);
        var Compiler;
        freeze();
        Compiler = processor.Compiler;
        $538971b5b904f078$var$assertCompiler("stringify", Compiler);
        $538971b5b904f078$var$assertNode(node);
        if ($538971b5b904f078$var$newable(Compiler, "compile")) return new Compiler(node, file).compile();
        return Compiler(node, file) // eslint-disable-line new-cap
        ;
    }
    // Parse a file (in string or vfile representation) into a unist node using
    // the `Parser` on the processor, then run transforms on that node, and
    // compile the resulting node using the `Compiler` on the processor, and
    // store that result on the vfile.
    function process1(doc, cb) {
        freeze();
        $538971b5b904f078$var$assertParser("process", processor.Parser);
        $538971b5b904f078$var$assertCompiler("process", processor.Compiler);
        if (!cb) return new Promise(executor);
        executor(null, cb);
        function executor(resolve, reject) {
            var file = $538971b5b904f078$var$vfile(doc);
            $538971b5b904f078$var$pipeline.run(processor, {
                file: file
            }, done);
            function done(err) {
                if (err) reject(err);
                else if (resolve) resolve(file);
                else cb(null, file);
            }
        }
    }
    // Process the given document (in string or vfile representation), sync.
    function processSync(doc) {
        var complete = false;
        var file;
        freeze();
        $538971b5b904f078$var$assertParser("processSync", processor.Parser);
        $538971b5b904f078$var$assertCompiler("processSync", processor.Compiler);
        file = $538971b5b904f078$var$vfile(doc);
        process1(file, done);
        $538971b5b904f078$var$assertDone("processSync", "process", complete);
        return file;
        function done(err) {
            complete = true;
            $538971b5b904f078$var$bail_1(err);
        }
    }
}
// Check if `value` is a constructor.
function $538971b5b904f078$var$newable(value, name) {
    return typeof value === "function" && value.prototype && // A function with keys in its prototype is probably a constructor.
    // Classes’ prototype methods are not enumerable, so we check if some value
    // exists in the prototype.
    ($538971b5b904f078$var$keys(value.prototype) || name in value.prototype);
}
// Check if `value` is an object with keys.
function $538971b5b904f078$var$keys(value) {
    var key;
    for(key in value)return true;
    return false;
}
// Assert a parser is available.
function $538971b5b904f078$var$assertParser(name, Parser) {
    if (typeof Parser !== "function") throw new Error("Cannot `" + name + "` without `Parser`");
}
// Assert a compiler is available.
function $538971b5b904f078$var$assertCompiler(name, Compiler) {
    if (typeof Compiler !== "function") throw new Error("Cannot `" + name + "` without `Compiler`");
}
// Assert the processor is not frozen.
function $538971b5b904f078$var$assertUnfrozen(name, frozen) {
    if (frozen) throw new Error("Cannot invoke `" + name + "` on a frozen processor.\nCreate a new processor first, by invoking it: use `processor()` instead of `processor`.");
}
// Assert `node` is a unist node.
function $538971b5b904f078$var$assertNode(node) {
    if (!node || typeof node.type !== "string") throw new Error("Expected node, got `" + node + "`");
}
// Assert that `complete` is `true`.
function $538971b5b904f078$var$assertDone(name, asyncName, complete) {
    if (!complete) throw new Error("`" + name + "` finished async. Use `" + asyncName + "` instead");
}
var $538971b5b904f078$var$nlcstToString_1 = $538971b5b904f078$var$nlcstToString;
// Stringify one nlcst node or list of nodes.
function $538971b5b904f078$var$nlcstToString(node, separator) {
    var sep = separator || "";
    var values;
    var length;
    var children;
    if (!node || !("length" in node) && !node.type) throw new Error("Expected node, not `" + node + "`");
    if (typeof node.value === "string") return node.value;
    children = "length" in node ? node : node.children;
    length = children.length;
    // Shortcut: This is pretty common, and a small performance win.
    if (length === 1 && "value" in children[0]) return children[0].value;
    values = [];
    while(length--)values[length] = $538971b5b904f078$var$nlcstToString(children[length], sep);
    return values.join(sep);
}
var $538971b5b904f078$var$tokenizer = $538971b5b904f078$var$tokenizerFactory;
// Factory to create a tokenizer based on a given `expression`.
function $538971b5b904f078$var$tokenizerFactory(childType, expression) {
    return tokenizer;
    // A function that splits.
    function tokenizer(node) {
        var children = [];
        var tokens = node.children;
        var type = node.type;
        var length = tokens.length;
        var index = -1;
        var lastIndex = length - 1;
        var start = 0;
        var first;
        var last;
        var parent;
        while(++index < length)if (index === lastIndex || tokens[index].type === childType && expression.test($538971b5b904f078$var$nlcstToString_1(tokens[index]))) {
            first = tokens[start];
            last = tokens[index];
            parent = {
                type: type,
                children: tokens.slice(start, index + 1)
            };
            if (first.position && last.position) parent.position = {
                start: first.position.start,
                end: last.position.end
            };
            children.push(parent);
            start = index + 1;
        }
        return children;
    }
}
var $538971b5b904f078$var$parser = $538971b5b904f078$var$parserFactory;
// Construct a parser based on `options`.
function $538971b5b904f078$var$parserFactory(options) {
    var type = options.type;
    var tokenizerProperty = options.tokenizer;
    var delimiter = options.delimiter;
    var tokenize = delimiter && $538971b5b904f078$var$tokenizer(options.delimiterType, delimiter);
    return parser;
    function parser(value) {
        var children = this[tokenizerProperty](value);
        return {
            type: type,
            children: tokenize ? tokenize(children) : children
        };
    }
}
// This module is generated by `script/build-expressions.js`.
var $538971b5b904f078$var$expressions = {
    affixSymbol: /^([\)\]\}\u0F3B\u0F3D\u169C\u2046\u207E\u208E\u2309\u230B\u232A\u2769\u276B\u276D\u276F\u2771\u2773\u2775\u27C6\u27E7\u27E9\u27EB\u27ED\u27EF\u2984\u2986\u2988\u298A\u298C\u298E\u2990\u2992\u2994\u2996\u2998\u29D9\u29DB\u29FD\u2E23\u2E25\u2E27\u2E29\u3009\u300B\u300D\u300F\u3011\u3015\u3017\u3019\u301B\u301E\u301F\uFD3E\uFE18\uFE36\uFE38\uFE3A\uFE3C\uFE3E\uFE40\uFE42\uFE44\uFE48\uFE5A\uFE5C\uFE5E\uFF09\uFF3D\uFF5D\uFF60\uFF63]|["'\xBB\u2019\u201D\u203A\u2E03\u2E05\u2E0A\u2E0D\u2E1D\u2E21]|[!\.\?\u2026\u203D])\1*$/,
    newLine: /^[ \t]*((\r?\n|\r)[\t ]*)+$/,
    newLineMulti: /^[ \t]*((\r?\n|\r)[\t ]*){2,}$/,
    terminalMarker: /^((?:[!\.\?\u2026\u203D])+)$/,
    wordSymbolInner: /^((?:[&'\x2D\.:=\?@\xAD\xB7\u2010\u2011\u2019\u2027])|(?:_)+)$/,
    numerical: /^(?:[0-9\xB2\xB3\xB9\xBC-\xBE\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u09F4-\u09F9\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0B72-\u0B77\u0BE6-\u0BF2\u0C66-\u0C6F\u0C78-\u0C7E\u0CE6-\u0CEF\u0D58-\u0D5E\u0D66-\u0D78\u0DE6-\u0DEF\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F33\u1040-\u1049\u1090-\u1099\u1369-\u137C\u16EE-\u16F0\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1946-\u194F\u19D0-\u19DA\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\u2070\u2074-\u2079\u2080-\u2089\u2150-\u2182\u2185-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2CFD\u3007\u3021-\u3029\u3038-\u303A\u3192-\u3195\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\uA620-\uA629\uA6E6-\uA6EF\uA830-\uA835\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uA9F0-\uA9F9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19]|\uD800[\uDD07-\uDD33\uDD40-\uDD78\uDD8A\uDD8B\uDEE1-\uDEFB\uDF20-\uDF23\uDF41\uDF4A\uDFD1-\uDFD5]|\uD801[\uDCA0-\uDCA9]|\uD802[\uDC58-\uDC5F\uDC79-\uDC7F\uDCA7-\uDCAF\uDCFB-\uDCFF\uDD16-\uDD1B\uDDBC\uDDBD\uDDC0-\uDDCF\uDDD2-\uDDFF\uDE40-\uDE48\uDE7D\uDE7E\uDE9D-\uDE9F\uDEEB-\uDEEF\uDF58-\uDF5F\uDF78-\uDF7F\uDFA9-\uDFAF]|\uD803[\uDCFA-\uDCFF\uDD30-\uDD39\uDE60-\uDE7E\uDF1D-\uDF26\uDF51-\uDF54]|\uD804[\uDC52-\uDC6F\uDCF0-\uDCF9\uDD36-\uDD3F\uDDD0-\uDDD9\uDDE1-\uDDF4\uDEF0-\uDEF9]|\uD805[\uDC50-\uDC59\uDCD0-\uDCD9\uDE50-\uDE59\uDEC0-\uDEC9\uDF30-\uDF3B]|\uD806[\uDCE0-\uDCF2]|\uD807[\uDC50-\uDC6C\uDD50-\uDD59\uDDA0-\uDDA9\uDFC0-\uDFD4]|\uD809[\uDC00-\uDC6E]|\uD81A[\uDE60-\uDE69\uDF50-\uDF59\uDF5B-\uDF61]|\uD81B[\uDE80-\uDE96]|\uD834[\uDEE0-\uDEF3\uDF60-\uDF78]|\uD835[\uDFCE-\uDFFF]|\uD838[\uDD40-\uDD49\uDEF0-\uDEF9]|\uD83A[\uDCC7-\uDCCF\uDD50-\uDD59]|\uD83B[\uDC71-\uDCAB\uDCAD-\uDCAF\uDCB1-\uDCB4\uDD01-\uDD2D\uDD2F-\uDD3D]|\uD83C[\uDD00-\uDD0C])+$/,
    digitStart: /^\d/,
    lowerInitial: /^(?:[a-z\xB5\xDF-\xF6\xF8-\xFF\u0101\u0103\u0105\u0107\u0109\u010B\u010D\u010F\u0111\u0113\u0115\u0117\u0119\u011B\u011D\u011F\u0121\u0123\u0125\u0127\u0129\u012B\u012D\u012F\u0131\u0133\u0135\u0137\u0138\u013A\u013C\u013E\u0140\u0142\u0144\u0146\u0148\u0149\u014B\u014D\u014F\u0151\u0153\u0155\u0157\u0159\u015B\u015D\u015F\u0161\u0163\u0165\u0167\u0169\u016B\u016D\u016F\u0171\u0173\u0175\u0177\u017A\u017C\u017E-\u0180\u0183\u0185\u0188\u018C\u018D\u0192\u0195\u0199-\u019B\u019E\u01A1\u01A3\u01A5\u01A8\u01AA\u01AB\u01AD\u01B0\u01B4\u01B6\u01B9\u01BA\u01BD-\u01BF\u01C6\u01C9\u01CC\u01CE\u01D0\u01D2\u01D4\u01D6\u01D8\u01DA\u01DC\u01DD\u01DF\u01E1\u01E3\u01E5\u01E7\u01E9\u01EB\u01ED\u01EF\u01F0\u01F3\u01F5\u01F9\u01FB\u01FD\u01FF\u0201\u0203\u0205\u0207\u0209\u020B\u020D\u020F\u0211\u0213\u0215\u0217\u0219\u021B\u021D\u021F\u0221\u0223\u0225\u0227\u0229\u022B\u022D\u022F\u0231\u0233-\u0239\u023C\u023F\u0240\u0242\u0247\u0249\u024B\u024D\u024F-\u0293\u0295-\u02AF\u0371\u0373\u0377\u037B-\u037D\u0390\u03AC-\u03CE\u03D0\u03D1\u03D5-\u03D7\u03D9\u03DB\u03DD\u03DF\u03E1\u03E3\u03E5\u03E7\u03E9\u03EB\u03ED\u03EF-\u03F3\u03F5\u03F8\u03FB\u03FC\u0430-\u045F\u0461\u0463\u0465\u0467\u0469\u046B\u046D\u046F\u0471\u0473\u0475\u0477\u0479\u047B\u047D\u047F\u0481\u048B\u048D\u048F\u0491\u0493\u0495\u0497\u0499\u049B\u049D\u049F\u04A1\u04A3\u04A5\u04A7\u04A9\u04AB\u04AD\u04AF\u04B1\u04B3\u04B5\u04B7\u04B9\u04BB\u04BD\u04BF\u04C2\u04C4\u04C6\u04C8\u04CA\u04CC\u04CE\u04CF\u04D1\u04D3\u04D5\u04D7\u04D9\u04DB\u04DD\u04DF\u04E1\u04E3\u04E5\u04E7\u04E9\u04EB\u04ED\u04EF\u04F1\u04F3\u04F5\u04F7\u04F9\u04FB\u04FD\u04FF\u0501\u0503\u0505\u0507\u0509\u050B\u050D\u050F\u0511\u0513\u0515\u0517\u0519\u051B\u051D\u051F\u0521\u0523\u0525\u0527\u0529\u052B\u052D\u052F\u0560-\u0588\u10D0-\u10FA\u10FD-\u10FF\u13F8-\u13FD\u1C80-\u1C88\u1D00-\u1D2B\u1D6B-\u1D77\u1D79-\u1D9A\u1E01\u1E03\u1E05\u1E07\u1E09\u1E0B\u1E0D\u1E0F\u1E11\u1E13\u1E15\u1E17\u1E19\u1E1B\u1E1D\u1E1F\u1E21\u1E23\u1E25\u1E27\u1E29\u1E2B\u1E2D\u1E2F\u1E31\u1E33\u1E35\u1E37\u1E39\u1E3B\u1E3D\u1E3F\u1E41\u1E43\u1E45\u1E47\u1E49\u1E4B\u1E4D\u1E4F\u1E51\u1E53\u1E55\u1E57\u1E59\u1E5B\u1E5D\u1E5F\u1E61\u1E63\u1E65\u1E67\u1E69\u1E6B\u1E6D\u1E6F\u1E71\u1E73\u1E75\u1E77\u1E79\u1E7B\u1E7D\u1E7F\u1E81\u1E83\u1E85\u1E87\u1E89\u1E8B\u1E8D\u1E8F\u1E91\u1E93\u1E95-\u1E9D\u1E9F\u1EA1\u1EA3\u1EA5\u1EA7\u1EA9\u1EAB\u1EAD\u1EAF\u1EB1\u1EB3\u1EB5\u1EB7\u1EB9\u1EBB\u1EBD\u1EBF\u1EC1\u1EC3\u1EC5\u1EC7\u1EC9\u1ECB\u1ECD\u1ECF\u1ED1\u1ED3\u1ED5\u1ED7\u1ED9\u1EDB\u1EDD\u1EDF\u1EE1\u1EE3\u1EE5\u1EE7\u1EE9\u1EEB\u1EED\u1EEF\u1EF1\u1EF3\u1EF5\u1EF7\u1EF9\u1EFB\u1EFD\u1EFF-\u1F07\u1F10-\u1F15\u1F20-\u1F27\u1F30-\u1F37\u1F40-\u1F45\u1F50-\u1F57\u1F60-\u1F67\u1F70-\u1F7D\u1F80-\u1F87\u1F90-\u1F97\u1FA0-\u1FA7\u1FB0-\u1FB4\u1FB6\u1FB7\u1FBE\u1FC2-\u1FC4\u1FC6\u1FC7\u1FD0-\u1FD3\u1FD6\u1FD7\u1FE0-\u1FE7\u1FF2-\u1FF4\u1FF6\u1FF7\u210A\u210E\u210F\u2113\u212F\u2134\u2139\u213C\u213D\u2146-\u2149\u214E\u2184\u2C30-\u2C5E\u2C61\u2C65\u2C66\u2C68\u2C6A\u2C6C\u2C71\u2C73\u2C74\u2C76-\u2C7B\u2C81\u2C83\u2C85\u2C87\u2C89\u2C8B\u2C8D\u2C8F\u2C91\u2C93\u2C95\u2C97\u2C99\u2C9B\u2C9D\u2C9F\u2CA1\u2CA3\u2CA5\u2CA7\u2CA9\u2CAB\u2CAD\u2CAF\u2CB1\u2CB3\u2CB5\u2CB7\u2CB9\u2CBB\u2CBD\u2CBF\u2CC1\u2CC3\u2CC5\u2CC7\u2CC9\u2CCB\u2CCD\u2CCF\u2CD1\u2CD3\u2CD5\u2CD7\u2CD9\u2CDB\u2CDD\u2CDF\u2CE1\u2CE3\u2CE4\u2CEC\u2CEE\u2CF3\u2D00-\u2D25\u2D27\u2D2D\uA641\uA643\uA645\uA647\uA649\uA64B\uA64D\uA64F\uA651\uA653\uA655\uA657\uA659\uA65B\uA65D\uA65F\uA661\uA663\uA665\uA667\uA669\uA66B\uA66D\uA681\uA683\uA685\uA687\uA689\uA68B\uA68D\uA68F\uA691\uA693\uA695\uA697\uA699\uA69B\uA723\uA725\uA727\uA729\uA72B\uA72D\uA72F-\uA731\uA733\uA735\uA737\uA739\uA73B\uA73D\uA73F\uA741\uA743\uA745\uA747\uA749\uA74B\uA74D\uA74F\uA751\uA753\uA755\uA757\uA759\uA75B\uA75D\uA75F\uA761\uA763\uA765\uA767\uA769\uA76B\uA76D\uA76F\uA771-\uA778\uA77A\uA77C\uA77F\uA781\uA783\uA785\uA787\uA78C\uA78E\uA791\uA793-\uA795\uA797\uA799\uA79B\uA79D\uA79F\uA7A1\uA7A3\uA7A5\uA7A7\uA7A9\uA7AF\uA7B5\uA7B7\uA7B9\uA7BB\uA7BD\uA7BF\uA7C3\uA7FA\uAB30-\uAB5A\uAB60-\uAB67\uAB70-\uABBF\uFB00-\uFB06\uFB13-\uFB17\uFF41-\uFF5A]|\uD801[\uDC28-\uDC4F\uDCD8-\uDCFB]|\uD803[\uDCC0-\uDCF2]|\uD806[\uDCC0-\uDCDF]|\uD81B[\uDE60-\uDE7F]|\uD835[\uDC1A-\uDC33\uDC4E-\uDC54\uDC56-\uDC67\uDC82-\uDC9B\uDCB6-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDCEA-\uDD03\uDD1E-\uDD37\uDD52-\uDD6B\uDD86-\uDD9F\uDDBA-\uDDD3\uDDEE-\uDE07\uDE22-\uDE3B\uDE56-\uDE6F\uDE8A-\uDEA5\uDEC2-\uDEDA\uDEDC-\uDEE1\uDEFC-\uDF14\uDF16-\uDF1B\uDF36-\uDF4E\uDF50-\uDF55\uDF70-\uDF88\uDF8A-\uDF8F\uDFAA-\uDFC2\uDFC4-\uDFC9\uDFCB]|\uD83A[\uDD22-\uDD43])/,
    surrogates: /[\uD800-\uDFFF]/,
    punctuation: /[!"'-\),-\/:;\?\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u201F\u2022-\u2027\u2032-\u203A\u203C-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDF55-\uDF59]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD806[\uDC3B\uDDE2\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8\uDFFF]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A\uDFE2]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/,
    word: /[0-9A-Za-z\xAA\xB2\xB3\xB5\xB9\xBA\xBC-\xBE\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u052F\u0531-\u0556\u0559\u0560-\u0588\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05EF-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u07FD\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D3-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09F4-\u09F9\u09FC\u09FE\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71-\u0B77\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BF2\u0C00-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C78-\u0C7E\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D63\u0D66-\u0D78\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F33\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u137C\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u17F0-\u17F9\u180B-\u180D\u1810-\u1819\u1820-\u1878\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABE\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CD0-\u1CD2\u1CD4-\u1CFA\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2070\u2071\u2074-\u2079\u207F-\u2089\u2090-\u209C\u20D0-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2150-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2CFD\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u3192-\u3195\u31A0-\u31BA\u31F0-\u31FF\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\u3400-\u4DB5\u4E00-\u9FEF\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA672\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7BF\uA7C2-\uA7C6\uA7F7-\uA827\uA830-\uA835\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB67\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD07-\uDD33\uDD40-\uDD78\uDD8A\uDD8B\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0-\uDEFB\uDF00-\uDF23\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC58-\uDC76\uDC79-\uDC9E\uDCA7-\uDCAF\uDCE0-\uDCF2\uDCF4\uDCF5\uDCFB-\uDD1B\uDD20-\uDD39\uDD80-\uDDB7\uDDBC-\uDDCF\uDDD2-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE38-\uDE3A\uDE3F-\uDE48\uDE60-\uDE7E\uDE80-\uDE9F\uDEC0-\uDEC7\uDEC9-\uDEE6\uDEEB-\uDEEF\uDF00-\uDF35\uDF40-\uDF55\uDF58-\uDF72\uDF78-\uDF91\uDFA9-\uDFAF]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDCFA-\uDD27\uDD30-\uDD39\uDE60-\uDE7E\uDF00-\uDF27\uDF30-\uDF54\uDFE0-\uDFF6]|\uD804[\uDC00-\uDC46\uDC52-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD44-\uDD46\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDC9-\uDDCC\uDDD0-\uDDDA\uDDDC\uDDE1-\uDDF4\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3B-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC5E\uDC5F\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB8\uDEC0-\uDEC9\uDF00-\uDF1A\uDF1D-\uDF2B\uDF30-\uDF3B]|\uD806[\uDC00-\uDC3A\uDCA0-\uDCF2\uDCFF\uDDA0-\uDDA7\uDDAA-\uDDD7\uDDDA-\uDDE1\uDDE3\uDDE4\uDE00-\uDE3E\uDE47\uDE50-\uDE99\uDE9D\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC6C\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD8E\uDD90\uDD91\uDD93-\uDD98\uDDA0-\uDDA9\uDEE0-\uDEF6\uDFC0-\uDFD4]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF5B-\uDF61\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE96\uDF00-\uDF4A\uDF4F-\uDF87\uDF8F-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44\uDEE0-\uDEF3\uDF60-\uDF78]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDD00-\uDD2C\uDD30-\uDD3D\uDD40-\uDD49\uDD4E\uDEC0-\uDEF9]|\uD83A[\uDC00-\uDCC4\uDCC7-\uDCD6\uDD00-\uDD4B\uDD50-\uDD59]|\uD83B[\uDC71-\uDCAB\uDCAD-\uDCAF\uDCB1-\uDCB4\uDD01-\uDD2D\uDD2F-\uDD3D\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD83C[\uDD00-\uDD0C]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/,
    whiteSpace: /[\t-\r \x85\xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/
};
var $538971b5b904f078$var$arrayIterate = $538971b5b904f078$var$iterate;
var $538971b5b904f078$var$own = {}.hasOwnProperty;
function $538971b5b904f078$var$iterate(values, callback, context) {
    var index = -1;
    var result;
    if (!values) throw new Error("Iterate requires that |this| not be " + values);
    if (!$538971b5b904f078$var$own.call(values, "length")) throw new Error("Iterate requires that |this| has a `length`");
    if (typeof callback !== "function") throw new Error("`callback` must be a function");
    // The length might change, so we do not cache it.
    while(++index < values.length){
        // Skip missing values.
        if (!(index in values)) continue;
        result = callback.call(context, values[index], index, values);
        // If `callback` returns a `number`, move `index` over to `number`.
        if (typeof result === "number") {
            // Make sure that negative numbers do not break the loop.
            if (result < 0) index = 0;
            index = result - 1;
        }
    }
}
var $538971b5b904f078$var$unistUtilModifyChildren = $538971b5b904f078$var$modifierFactory;
// Turn `callback` into a child-modifier accepting a parent.  See
// `array-iterate` for more info.
function $538971b5b904f078$var$modifierFactory(callback) {
    return $538971b5b904f078$var$iteratorFactory($538971b5b904f078$var$wrapperFactory(callback));
}
// Turn `callback` into a `iterator' accepting a parent.
function $538971b5b904f078$var$iteratorFactory(callback) {
    return iterator;
    function iterator(parent) {
        var children = parent && parent.children;
        if (!children) throw new Error("Missing children in `parent` for `modifier`");
        return $538971b5b904f078$var$arrayIterate(children, callback, parent);
    }
}
// Pass the context as the third argument to `callback`.
function $538971b5b904f078$var$wrapperFactory(callback) {
    return wrapper;
    function wrapper(value, index) {
        return callback(value, index, this);
    }
}
var $538971b5b904f078$var$mergeInitialWordSymbol_1 = $538971b5b904f078$var$unistUtilModifyChildren($538971b5b904f078$var$mergeInitialWordSymbol);
// Merge certain punctuation marks into their following words.
function $538971b5b904f078$var$mergeInitialWordSymbol(child, index, parent) {
    var children;
    var next;
    if (child.type !== "SymbolNode" && child.type !== "PunctuationNode" || $538971b5b904f078$var$nlcstToString_1(child) !== "&") return;
    children = parent.children;
    next = children[index + 1];
    // If either a previous word, or no following word, exists, exit early.
    if (index !== 0 && children[index - 1].type === "WordNode" || !(next && next.type === "WordNode")) return;
    // Remove `child` from parent.
    children.splice(index, 1);
    // Add the punctuation mark at the start of the next node.
    next.children.unshift(child);
    // Update position.
    if (next.position && child.position) next.position.start = child.position.start;
    // Next, iterate over the node at the previous position, as it's now adjacent
    // to a following word.
    return index - 1;
}
var $538971b5b904f078$var$mergeFinalWordSymbol_1 = $538971b5b904f078$var$unistUtilModifyChildren($538971b5b904f078$var$mergeFinalWordSymbol$1);
// Merge certain punctuation marks into their preceding words.
function $538971b5b904f078$var$mergeFinalWordSymbol$1(child, index, parent) {
    var children;
    var prev;
    var next;
    if (index !== 0 && (child.type === "SymbolNode" || child.type === "PunctuationNode") && $538971b5b904f078$var$nlcstToString_1(child) === "-") {
        children = parent.children;
        prev = children[index - 1];
        next = children[index + 1];
        if ((!next || next.type !== "WordNode") && prev && prev.type === "WordNode") {
            // Remove `child` from parent.
            children.splice(index, 1);
            // Add the punctuation mark at the end of the previous node.
            prev.children.push(child);
            // Update position.
            if (prev.position && child.position) prev.position.end = child.position.end;
            // Next, iterate over the node *now* at the current position (which was
            // the next node).
            return index;
        }
    }
}
var $538971b5b904f078$var$mergeInnerWordSymbol_1 = $538971b5b904f078$var$unistUtilModifyChildren($538971b5b904f078$var$mergeInnerWordSymbol);
// Symbols part of surrounding words.
var $538971b5b904f078$var$wordSymbolInner = $538971b5b904f078$var$expressions.wordSymbolInner;
// Merge words joined by certain punctuation marks.
function $538971b5b904f078$var$mergeInnerWordSymbol(child, index, parent) {
    var siblings;
    var sibling;
    var prev;
    var last;
    var position;
    var tokens;
    var queue;
    if (index !== 0 && (child.type === "SymbolNode" || child.type === "PunctuationNode")) {
        siblings = parent.children;
        prev = siblings[index - 1];
        if (prev && prev.type === "WordNode") {
            position = index - 1;
            tokens = [];
            queue = [];
            // -   If a token which is neither word nor inner word symbol is found,
            //     the loop is broken
            // -   If an inner word symbol is found,  it’s queued
            // -   If a word is found, it’s queued (and the queue stored and emptied)
            while(siblings[++position]){
                sibling = siblings[position];
                if (sibling.type === "WordNode") {
                    tokens = tokens.concat(queue, sibling.children);
                    queue = [];
                } else if ((sibling.type === "SymbolNode" || sibling.type === "PunctuationNode") && $538971b5b904f078$var$wordSymbolInner.test($538971b5b904f078$var$nlcstToString_1(sibling))) queue.push(sibling);
                else break;
            }
            if (tokens.length !== 0) {
                // If there is a queue, remove its length from `position`.
                if (queue.length !== 0) position -= queue.length;
                // Remove every (one or more) inner-word punctuation marks and children
                // of words.
                siblings.splice(index, position - index);
                // Add all found tokens to `prev`s children.
                prev.children = prev.children.concat(tokens);
                last = tokens[tokens.length - 1];
                // Update position.
                if (prev.position && last.position) prev.position.end = last.position.end;
                // Next, iterate over the node *now* at the current position.
                return index;
            }
        }
    }
}
var $538971b5b904f078$var$mergeInnerWordSlash_1 = $538971b5b904f078$var$unistUtilModifyChildren($538971b5b904f078$var$mergeInnerWordSlash);
var $538971b5b904f078$var$slash = "/";
// Merge words joined by certain punctuation marks.
function $538971b5b904f078$var$mergeInnerWordSlash(child, index, parent) {
    var siblings = parent.children;
    var prev;
    var next;
    var prevValue;
    var nextValue;
    var queue;
    var tail;
    var count;
    prev = siblings[index - 1];
    next = siblings[index + 1];
    if (prev && prev.type === "WordNode" && (child.type === "SymbolNode" || child.type === "PunctuationNode") && $538971b5b904f078$var$nlcstToString_1(child) === $538971b5b904f078$var$slash) {
        prevValue = $538971b5b904f078$var$nlcstToString_1(prev);
        tail = child;
        queue = [
            child
        ];
        count = 1;
        if (next && next.type === "WordNode") {
            nextValue = $538971b5b904f078$var$nlcstToString_1(next);
            tail = next;
            queue = queue.concat(next.children);
            count++;
        }
        if (prevValue.length < 3 && (!nextValue || nextValue.length < 3)) {
            // Add all found tokens to `prev`s children.
            prev.children = prev.children.concat(queue);
            siblings.splice(index, count);
            // Update position.
            if (prev.position && tail.position) prev.position.end = tail.position.end;
            // Next, iterate over the node *now* at the current position.
            return index;
        }
    }
}
var $538971b5b904f078$var$mergeInitialisms_1 = $538971b5b904f078$var$unistUtilModifyChildren($538971b5b904f078$var$mergeInitialisms);
var $538971b5b904f078$var$numerical = $538971b5b904f078$var$expressions.numerical;
// Merge initialisms.
function $538971b5b904f078$var$mergeInitialisms(child, index, parent) {
    var siblings;
    var prev;
    var children;
    var length;
    var position;
    var otherChild;
    var isAllDigits;
    var value;
    if (index !== 0 && $538971b5b904f078$var$nlcstToString_1(child) === ".") {
        siblings = parent.children;
        prev = siblings[index - 1];
        children = prev.children;
        length = children && children.length;
        if (prev.type === "WordNode" && length !== 1 && length % 2 !== 0) {
            position = length;
            isAllDigits = true;
            while(children[--position]){
                otherChild = children[position];
                value = $538971b5b904f078$var$nlcstToString_1(otherChild);
                if (position % 2 === 0) {
                    // Initialisms consist of one character values.
                    if (value.length > 1) return;
                    if (!$538971b5b904f078$var$numerical.test(value)) isAllDigits = false;
                } else if (value !== ".") {
                    if (position < length - 2) break;
                    else return;
                }
            }
            if (!isAllDigits) {
                // Remove `child` from parent.
                siblings.splice(index, 1);
                // Add child to the previous children.
                children.push(child);
                // Update position.
                if (prev.position && child.position) prev.position.end = child.position.end;
                // Next, iterate over the node *now* at the current position.
                return index;
            }
        }
    }
}
var $538971b5b904f078$var$mergeWords = $538971b5b904f078$var$unistUtilModifyChildren($538971b5b904f078$var$mergeFinalWordSymbol);
// Merge multiple words. This merges the children of adjacent words, something
// which should not occur naturally by parse-latin, but might happen when custom
// tokens were passed in.
function $538971b5b904f078$var$mergeFinalWordSymbol(child, index, parent) {
    var siblings = parent.children;
    var next;
    if (child.type === "WordNode") {
        next = siblings[index + 1];
        if (next && next.type === "WordNode") {
            // Remove `next` from parent.
            siblings.splice(index + 1, 1);
            // Add the punctuation mark at the end of the previous node.
            child.children = child.children.concat(next.children);
            // Update position.
            if (next.position && child.position) child.position.end = next.position.end;
            // Next, re-iterate the current node.
            return index;
        }
    }
}
var $538971b5b904f078$var$unistUtilVisitChildren = $538971b5b904f078$var$visitChildren;
function $538971b5b904f078$var$visitChildren(callback) {
    return visitor;
    // Visit `parent`, invoking `callback` for each child.
    function visitor(parent) {
        var index = -1;
        var children = parent && parent.children;
        if (!children) throw new Error("Missing children in `parent` for `visitor`");
        while(++index in children)callback(children[index], index, parent);
    }
}
var $538971b5b904f078$var$patchPosition_1 = $538971b5b904f078$var$unistUtilVisitChildren($538971b5b904f078$var$patchPosition);
// Patch the position on a parent node based on its first and last child.
function $538971b5b904f078$var$patchPosition(child, index, node) {
    var siblings = node.children;
    if (!child.position) return;
    if (index === 0 && (!node.position || /* istanbul ignore next */ !node.position.start)) {
        $538971b5b904f078$var$patch(node);
        node.position.start = child.position.start;
    }
    if (index === siblings.length - 1 && (!node.position || !node.position.end)) {
        $538971b5b904f078$var$patch(node);
        node.position.end = child.position.end;
    }
}
// Add a `position` object when it does not yet exist on `node`.
function $538971b5b904f078$var$patch(node) {
    if (!node.position) node.position = {};
}
var $538971b5b904f078$var$mergeNonWordSentences_1 = $538971b5b904f078$var$unistUtilModifyChildren($538971b5b904f078$var$mergeNonWordSentences);
// Merge a sentence into the following sentence, when the sentence does not
// contain word tokens.
function $538971b5b904f078$var$mergeNonWordSentences(child, index, parent) {
    var children = child.children;
    var position = -1;
    var prev;
    var next;
    while(children[++position]){
        if (children[position].type === "WordNode") return;
    }
    prev = parent.children[index - 1];
    if (prev) {
        prev.children = prev.children.concat(children);
        // Remove the child.
        parent.children.splice(index, 1);
        // Patch position.
        if (prev.position && child.position) prev.position.end = child.position.end;
        // Next, iterate over the node *now* at the current position (which was the
        // next node).
        return index;
    }
    next = parent.children[index + 1];
    if (next) {
        next.children = children.concat(next.children);
        // Patch position.
        if (next.position && child.position) next.position.start = child.position.start;
        // Remove the child.
        parent.children.splice(index, 1);
    }
}
var $538971b5b904f078$var$mergeAffixSymbol_1 = $538971b5b904f078$var$unistUtilModifyChildren($538971b5b904f078$var$mergeAffixSymbol);
// Closing or final punctuation, or terminal markers that should still be
// included in the previous sentence, even though they follow the sentence’s
// terminal marker.
var $538971b5b904f078$var$affixSymbol = $538971b5b904f078$var$expressions.affixSymbol;
// Move certain punctuation following a terminal marker (thus in the next
// sentence) to the previous sentence.
function $538971b5b904f078$var$mergeAffixSymbol(child, index, parent) {
    var children = child.children;
    var first;
    var second;
    var prev;
    if (children && children.length !== 0 && index !== 0) {
        first = children[0];
        second = children[1];
        prev = parent.children[index - 1];
        if ((first.type === "SymbolNode" || first.type === "PunctuationNode") && $538971b5b904f078$var$affixSymbol.test($538971b5b904f078$var$nlcstToString_1(first))) {
            prev.children.push(children.shift());
            // Update position.
            if (first.position && prev.position) prev.position.end = first.position.end;
            if (second && second.position && child.position) child.position.start = second.position.start;
            // Next, iterate over the previous node again.
            return index - 1;
        }
    }
}
var $538971b5b904f078$var$mergeInitialLowerCaseLetterSentences_1 = $538971b5b904f078$var$unistUtilModifyChildren($538971b5b904f078$var$mergeInitialLowerCaseLetterSentences);
// Initial lowercase letter.
var $538971b5b904f078$var$lowerInitial = $538971b5b904f078$var$expressions.lowerInitial;
// Merge a sentence into its previous sentence, when the sentence starts with a
// lower case letter.
function $538971b5b904f078$var$mergeInitialLowerCaseLetterSentences(child, index, parent) {
    var children = child.children;
    var position;
    var node;
    var siblings;
    var prev;
    if (children && children.length !== 0 && index !== 0) {
        position = -1;
        while(children[++position]){
            node = children[position];
            if (node.type === "WordNode") {
                if (!$538971b5b904f078$var$lowerInitial.test($538971b5b904f078$var$nlcstToString_1(node))) return;
                siblings = parent.children;
                prev = siblings[index - 1];
                prev.children = prev.children.concat(children);
                siblings.splice(index, 1);
                // Update position.
                if (prev.position && child.position) prev.position.end = child.position.end;
                // Next, iterate over the node *now* at the current position.
                return index;
            }
            if (node.type === "SymbolNode" || node.type === "PunctuationNode") return;
        }
    }
}
var $538971b5b904f078$var$mergeInitialDigitSentences_1 = $538971b5b904f078$var$unistUtilModifyChildren($538971b5b904f078$var$mergeInitialDigitSentences);
// Initial lowercase letter.
var $538971b5b904f078$var$digit = $538971b5b904f078$var$expressions.digitStart;
// Merge a sentence into its previous sentence, when the sentence starts with a
// lower case letter.
function $538971b5b904f078$var$mergeInitialDigitSentences(child, index, parent) {
    var children = child.children;
    var siblings = parent.children;
    var prev = siblings[index - 1];
    var head = children[0];
    if (prev && head && head.type === "WordNode" && $538971b5b904f078$var$digit.test($538971b5b904f078$var$nlcstToString_1(head))) {
        prev.children = prev.children.concat(children);
        siblings.splice(index, 1);
        // Update position.
        if (prev.position && child.position) prev.position.end = child.position.end;
        // Next, iterate over the node *now* at the current position.
        return index;
    }
}
var $538971b5b904f078$var$mergePrefixExceptions_1 = $538971b5b904f078$var$unistUtilModifyChildren($538971b5b904f078$var$mergePrefixExceptions);
// Blacklist of full stop characters that should not be treated as terminal
// sentence markers: A case-insensitive abbreviation.
var $538971b5b904f078$var$abbreviationPrefix = new RegExp("^([0-9]{1,3}|[a-z]|al|ca|cap|cca|cent|cf|cit|con|cp|cwt|ead|etc|ff|fl|ibid|id|nem|op|pro|seq|sic|stat|tem|viz)$");
// Merge a sentence into its next sentence, when the sentence ends with a
// certain word.
function $538971b5b904f078$var$mergePrefixExceptions(child, index, parent) {
    var children = child.children;
    var period;
    var node;
    var next;
    if (children && children.length > 1) {
        period = children[children.length - 1];
        if (period && $538971b5b904f078$var$nlcstToString_1(period) === ".") {
            node = children[children.length - 2];
            if (node && node.type === "WordNode" && $538971b5b904f078$var$abbreviationPrefix.test($538971b5b904f078$var$nlcstToString_1(node).toLowerCase())) {
                // Merge period into abbreviation.
                node.children.push(period);
                children.pop();
                // Update position.
                if (period.position && node.position) node.position.end = period.position.end;
                // Merge sentences.
                next = parent.children[index + 1];
                if (next) {
                    child.children = children.concat(next.children);
                    parent.children.splice(index + 1, 1);
                    // Update position.
                    if (next.position && child.position) child.position.end = next.position.end;
                    // Next, iterate over the current node again.
                    return index - 1;
                }
            }
        }
    }
}
var $538971b5b904f078$var$mergeAffixExceptions_1 = $538971b5b904f078$var$unistUtilModifyChildren($538971b5b904f078$var$mergeAffixExceptions);
// Merge a sentence into its previous sentence, when the sentence starts with a
// comma.
function $538971b5b904f078$var$mergeAffixExceptions(child, index, parent) {
    var children = child.children;
    var node;
    var position;
    var value;
    var previousChild;
    if (!children || children.length === 0 || index === 0) return;
    position = -1;
    while(children[++position]){
        node = children[position];
        if (node.type === "WordNode") return;
        if (node.type === "SymbolNode" || node.type === "PunctuationNode") {
            value = $538971b5b904f078$var$nlcstToString_1(node);
            if (value !== "," && value !== ";") return;
            previousChild = parent.children[index - 1];
            previousChild.children = previousChild.children.concat(children);
            // Update position.
            if (previousChild.position && child.position) previousChild.position.end = child.position.end;
            parent.children.splice(index, 1);
            // Next, iterate over the node *now* at the current position.
            return index;
        }
    }
}
var $538971b5b904f078$var$mergeRemainingFullStops_1 = $538971b5b904f078$var$unistUtilVisitChildren($538971b5b904f078$var$mergeRemainingFullStops);
// Blacklist of full stop characters that should not be treated as terminal
// sentence markers: A case-insensitive abbreviation.
var $538971b5b904f078$var$terminalMarker = $538971b5b904f078$var$expressions.terminalMarker;
// Merge non-terminal-marker full stops into the previous word (if available),
// or the next word (if available).
function $538971b5b904f078$var$mergeRemainingFullStops(child) {
    var children = child.children;
    var position = children.length;
    var hasFoundDelimiter = false;
    var grandchild;
    var prev;
    var next;
    var nextNext;
    while(children[--position]){
        grandchild = children[position];
        if (grandchild.type !== "SymbolNode" && grandchild.type !== "PunctuationNode") {
            // This is a sentence without terminal marker, so we 'fool' the code to
            // make it think we have found one.
            if (grandchild.type === "WordNode") hasFoundDelimiter = true;
            continue;
        }
        // Exit when this token is not a terminal marker.
        if (!$538971b5b904f078$var$terminalMarker.test($538971b5b904f078$var$nlcstToString_1(grandchild))) continue;
        // Ignore the first terminal marker found (starting at the end), as it
        // should not be merged.
        if (!hasFoundDelimiter) {
            hasFoundDelimiter = true;
            continue;
        }
        // Only merge a single full stop.
        if ($538971b5b904f078$var$nlcstToString_1(grandchild) !== ".") continue;
        prev = children[position - 1];
        next = children[position + 1];
        if (prev && prev.type === "WordNode") {
            nextNext = children[position + 2];
            // Continue when the full stop is followed by a space and another full
            // stop, such as: `{.} .`
            if (next && nextNext && next.type === "WhiteSpaceNode" && $538971b5b904f078$var$nlcstToString_1(nextNext) === ".") continue;
            // Remove `child` from parent.
            children.splice(position, 1);
            // Add the punctuation mark at the end of the previous node.
            prev.children.push(grandchild);
            // Update position.
            if (grandchild.position && prev.position) prev.position.end = grandchild.position.end;
            position--;
        } else if (next && next.type === "WordNode") {
            // Remove `child` from parent.
            children.splice(position, 1);
            // Add the punctuation mark at the start of the next node.
            next.children.unshift(grandchild);
            if (grandchild.position && next.position) next.position.start = grandchild.position.start;
        }
    }
}
var $538971b5b904f078$var$makeInitialWhiteSpaceSiblings_1 = $538971b5b904f078$var$unistUtilVisitChildren($538971b5b904f078$var$makeInitialWhiteSpaceSiblings);
// Move white space starting a sentence up, so they are the siblings of
// sentences.
function $538971b5b904f078$var$makeInitialWhiteSpaceSiblings(child, index, parent) {
    var children = child.children;
    var next;
    if (children && children.length !== 0 && children[0].type === "WhiteSpaceNode") {
        parent.children.splice(index, 0, children.shift());
        next = children[0];
        if (next && next.position && child.position) child.position.start = next.position.start;
    }
}
var $538971b5b904f078$var$makeFinalWhiteSpaceSiblings_1 = $538971b5b904f078$var$unistUtilModifyChildren($538971b5b904f078$var$makeFinalWhiteSpaceSiblings);
// Move white space ending a paragraph up, so they are the siblings of
// paragraphs.
function $538971b5b904f078$var$makeFinalWhiteSpaceSiblings(child, index, parent) {
    var children = child.children;
    var prev;
    if (children && children.length !== 0 && children[children.length - 1].type === "WhiteSpaceNode") {
        parent.children.splice(index + 1, 0, child.children.pop());
        prev = children[children.length - 1];
        if (prev && prev.position && child.position) child.position.end = prev.position.end;
        // Next, iterate over the current node again.
        return index;
    }
}
var $538971b5b904f078$var$breakImplicitSentences_1 = $538971b5b904f078$var$unistUtilModifyChildren($538971b5b904f078$var$breakImplicitSentences);
// Two or more new line characters.
var $538971b5b904f078$var$multiNewLine = $538971b5b904f078$var$expressions.newLineMulti;
// Break a sentence if a white space with more than one new-line is found.
function $538971b5b904f078$var$breakImplicitSentences(child, index, parent) {
    var children;
    var position;
    var length;
    var tail;
    var head;
    var end;
    var insertion;
    var node;
    if (child.type !== "SentenceNode") return;
    children = child.children;
    // Ignore first and last child.
    length = children.length - 1;
    position = 0;
    while(++position < length){
        node = children[position];
        if (node.type !== "WhiteSpaceNode" || !$538971b5b904f078$var$multiNewLine.test($538971b5b904f078$var$nlcstToString_1(node))) continue;
        child.children = children.slice(0, position);
        insertion = {
            type: "SentenceNode",
            children: children.slice(position + 1)
        };
        tail = children[position - 1];
        head = children[position + 1];
        parent.children.splice(index + 1, 0, node, insertion);
        if (child.position && tail.position && head.position) {
            end = child.position.end;
            child.position.end = tail.position.end;
            insertion.position = {
                start: head.position.start,
                end: end
            };
        }
        return index + 1;
    }
}
var $538971b5b904f078$var$removeEmptyNodes_1 = $538971b5b904f078$var$unistUtilModifyChildren($538971b5b904f078$var$removeEmptyNodes);
// Remove empty children.
function $538971b5b904f078$var$removeEmptyNodes(child, index, parent) {
    if ("children" in child && child.children.length === 0) {
        parent.children.splice(index, 1);
        // Next, iterate over the node *now* at the current position (which was the
        // next node).
        return index;
    }
}
var $538971b5b904f078$var$lib = $538971b5b904f078$var$ParseLatin;
// PARSE LATIN
// Transform Latin-script natural language into an NLCST-tree.
function $538971b5b904f078$var$ParseLatin(doc, file) {
    var value = file || doc;
    if (!(this instanceof $538971b5b904f078$var$ParseLatin)) return new $538971b5b904f078$var$ParseLatin(doc, file);
    this.doc = value ? String(value) : null;
}
// Quick access to the prototype.
var $538971b5b904f078$var$proto = $538971b5b904f078$var$ParseLatin.prototype;
// Default position.
$538971b5b904f078$var$proto.position = true;
// Create text nodes.
$538971b5b904f078$var$proto.tokenizeSymbol = $538971b5b904f078$var$createTextFactory("Symbol");
$538971b5b904f078$var$proto.tokenizeWhiteSpace = $538971b5b904f078$var$createTextFactory("WhiteSpace");
$538971b5b904f078$var$proto.tokenizePunctuation = $538971b5b904f078$var$createTextFactory("Punctuation");
$538971b5b904f078$var$proto.tokenizeSource = $538971b5b904f078$var$createTextFactory("Source");
$538971b5b904f078$var$proto.tokenizeText = $538971b5b904f078$var$createTextFactory("Text");
// Expose `run`.
$538971b5b904f078$var$proto.run = $538971b5b904f078$var$run;
// Inject `plugins` to modifiy the result of the method at `key` on the operated
// on context.
$538971b5b904f078$var$proto.use = $538971b5b904f078$var$useFactory(function(context, key, plugins) {
    context[key] = context[key].concat(plugins);
});
// Inject `plugins` to modifiy the result of the method at `key` on the operated
// on context, before any other.
$538971b5b904f078$var$proto.useFirst = $538971b5b904f078$var$useFactory(function(context, key, plugins) {
    context[key] = plugins.concat(context[key]);
});
// Easy access to the document parser. This additionally supports retext-style
// invocation: where an instance is created for each file, and the file is given
// on construction.
$538971b5b904f078$var$proto.parse = function(value) {
    return this.tokenizeRoot(value || this.doc);
};
// Transform a `value` into a list of `NLCSTNode`s.
$538971b5b904f078$var$proto.tokenize = function(value) {
    return $538971b5b904f078$var$tokenize(this, value);
};
// PARENT NODES
//
// All these nodes are `pluggable`: they come with a `use` method which accepts
// a plugin (`function(NLCSTNode)`).
// Every time one of these methods are called, the plugin is invoked with the
// node, allowing for easy modification.
//
// In fact, the internal transformation from `tokenize` (a list of words, white
// space, punctuation, and symbols) to `tokenizeRoot` (an NLCST tree), is also
// implemented through this mechanism.
// Create a `WordNode` with its children set to a single `TextNode`, its value
// set to the given `value`.
$538971b5b904f078$var$pluggable($538971b5b904f078$var$ParseLatin, "tokenizeWord", function(value, eat) {
    var add = (eat || $538971b5b904f078$var$noopEat)("");
    var parent = {
        type: "WordNode",
        children: []
    };
    this.tokenizeText(value, eat, parent);
    return add(parent);
});
// Create a `SentenceNode` with its children set to `Node`s, their values set
// to the tokenized given `value`.
//
// Unless plugins add new nodes, the sentence is populated by `WordNode`s,
// `SymbolNode`s, `PunctuationNode`s, and `WhiteSpaceNode`s.
$538971b5b904f078$var$pluggable($538971b5b904f078$var$ParseLatin, "tokenizeSentence", $538971b5b904f078$var$parser({
    type: "SentenceNode",
    tokenizer: "tokenize"
}));
// Create a `ParagraphNode` with its children set to `Node`s, their values set
// to the tokenized given `value`.
//
// Unless plugins add new nodes, the paragraph is populated by `SentenceNode`s
// and `WhiteSpaceNode`s.
$538971b5b904f078$var$pluggable($538971b5b904f078$var$ParseLatin, "tokenizeParagraph", $538971b5b904f078$var$parser({
    type: "ParagraphNode",
    delimiter: $538971b5b904f078$var$expressions.terminalMarker,
    delimiterType: "PunctuationNode",
    tokenizer: "tokenizeSentence"
}));
// Create a `RootNode` with its children set to `Node`s, their values set to the
// tokenized given `value`.
$538971b5b904f078$var$pluggable($538971b5b904f078$var$ParseLatin, "tokenizeRoot", $538971b5b904f078$var$parser({
    type: "RootNode",
    delimiter: $538971b5b904f078$var$expressions.newLine,
    delimiterType: "WhiteSpaceNode",
    tokenizer: "tokenizeParagraph"
}));
// PLUGINS
$538971b5b904f078$var$proto.use("tokenizeSentence", [
    $538971b5b904f078$var$mergeInitialWordSymbol_1,
    $538971b5b904f078$var$mergeFinalWordSymbol_1,
    $538971b5b904f078$var$mergeInnerWordSymbol_1,
    $538971b5b904f078$var$mergeInnerWordSlash_1,
    $538971b5b904f078$var$mergeInitialisms_1,
    $538971b5b904f078$var$mergeWords,
    $538971b5b904f078$var$patchPosition_1
]);
$538971b5b904f078$var$proto.use("tokenizeParagraph", [
    $538971b5b904f078$var$mergeNonWordSentences_1,
    $538971b5b904f078$var$mergeAffixSymbol_1,
    $538971b5b904f078$var$mergeInitialLowerCaseLetterSentences_1,
    $538971b5b904f078$var$mergeInitialDigitSentences_1,
    $538971b5b904f078$var$mergePrefixExceptions_1,
    $538971b5b904f078$var$mergeAffixExceptions_1,
    $538971b5b904f078$var$mergeRemainingFullStops_1,
    $538971b5b904f078$var$makeInitialWhiteSpaceSiblings_1,
    $538971b5b904f078$var$makeFinalWhiteSpaceSiblings_1,
    $538971b5b904f078$var$breakImplicitSentences_1,
    $538971b5b904f078$var$removeEmptyNodes_1,
    $538971b5b904f078$var$patchPosition_1
]);
$538971b5b904f078$var$proto.use("tokenizeRoot", [
    $538971b5b904f078$var$makeInitialWhiteSpaceSiblings_1,
    $538971b5b904f078$var$makeFinalWhiteSpaceSiblings_1,
    $538971b5b904f078$var$removeEmptyNodes_1,
    $538971b5b904f078$var$patchPosition_1
]);
// TEXT NODES
// Factory to create a `Text`.
function $538971b5b904f078$var$createTextFactory(type) {
    type += "Node";
    return createText;
    // Construct a `Text` from a bound `type`
    function createText(value, eat, parent) {
        if (value === null || value === undefined) value = "";
        return (eat || $538971b5b904f078$var$noopEat)(value)({
            type: type,
            value: String(value)
        }, parent);
    }
}
// Run transform plug-ins for `key` on `nodes`.
function $538971b5b904f078$var$run(key, nodes) {
    var wareKey = key + "Plugins";
    var plugins = this[wareKey];
    var index = -1;
    if (plugins) while(plugins[++index])plugins[index](nodes);
    return nodes;
}
// Make a method “pluggable”.
function $538971b5b904f078$var$pluggable(Constructor, key, callback) {
    // Set a pluggable version of `callback` on `Constructor`.
    Constructor.prototype[key] = function() {
        return this.run(key, callback.apply(this, arguments));
    };
}
// Factory to inject `plugins`. Takes `callback` for the actual inserting.
function $538971b5b904f078$var$useFactory(callback) {
    return use;
    // Validate if `plugins` can be inserted.
    // Invokes the bound `callback` to do the actual inserting.
    function use(key, plugins) {
        var self = this;
        var wareKey;
        // Throw if the method is not pluggable.
        if (!(key in self)) throw new Error("Illegal Invocation: Unsupported `key` for `use(key, plugins)`. Make sure `key` is a supported function");
        // Fail silently when no plugins are given.
        if (!plugins) return;
        wareKey = key + "Plugins";
        // Make sure `plugins` is a list.
        if (typeof plugins === "function") plugins = [
            plugins
        ];
        else plugins = plugins.concat();
        // Make sure `wareKey` exists.
        if (!self[wareKey]) self[wareKey] = [];
        // Invoke callback with the ware key and plugins.
        callback(self, wareKey, plugins);
    }
}
// CLASSIFY
// Match a word character.
var $538971b5b904f078$var$wordRe = $538971b5b904f078$var$expressions.word;
// Match a surrogate character.
var $538971b5b904f078$var$surrogatesRe = $538971b5b904f078$var$expressions.surrogates;
// Match a punctuation character.
var $538971b5b904f078$var$punctuationRe = $538971b5b904f078$var$expressions.punctuation;
// Match a white space character.
var $538971b5b904f078$var$whiteSpaceRe = $538971b5b904f078$var$expressions.whiteSpace;
// Transform a `value` into a list of `NLCSTNode`s.
function $538971b5b904f078$var$tokenize(parser, value) {
    var tokens;
    var offset;
    var line;
    var column;
    var index;
    var length;
    var character;
    var queue;
    var prev;
    var left;
    var right;
    var eater;
    if (value === null || value === undefined) value = "";
    else if (value instanceof String) value = value.toString();
    if (typeof value !== "string") {
        // Return the given nodes if this is either an empty array, or an array with
        // a node as a first child.
        if ("length" in value && (!value[0] || value[0].type)) return value;
        throw new Error("Illegal invocation: '" + value + "' is not a valid argument for 'ParseLatin'");
    }
    tokens = [];
    if (!value) return tokens;
    index = 0;
    offset = 0;
    line = 1;
    column = 1;
    // Eat mechanism to use.
    eater = parser.position ? eat : noPositionEat;
    length = value.length;
    prev = "";
    queue = "";
    while(index < length){
        character = value.charAt(index);
        if ($538971b5b904f078$var$whiteSpaceRe.test(character)) right = "WhiteSpace";
        else if ($538971b5b904f078$var$punctuationRe.test(character)) right = "Punctuation";
        else if ($538971b5b904f078$var$wordRe.test(character)) right = "Word";
        else right = "Symbol";
        tick();
        prev = character;
        character = "";
        left = right;
        right = null;
        index++;
    }
    tick();
    return tokens;
    // Check one character.
    function tick() {
        if (left === right && (left === "Word" || left === "WhiteSpace" || character === prev || $538971b5b904f078$var$surrogatesRe.test(character))) queue += character;
        else {
            // Flush the previous queue.
            if (queue) parser["tokenize" + left](queue, eater);
            queue = character;
        }
    }
    // Remove `subvalue` from `value`.
    // Expects `subvalue` to be at the start from `value`, and applies no
    // validation.
    function eat(subvalue) {
        var pos = position();
        update(subvalue);
        return apply;
        // Add the given arguments, add `position` to the returned node, and return
        // the node.
        function apply() {
            return pos(add.apply(null, arguments));
        }
    }
    // Remove `subvalue` from `value`.
    // Does not patch positional information.
    function noPositionEat() {
        return apply;
        // Add the given arguments and return the node.
        function apply() {
            return add.apply(null, arguments);
        }
    }
    // Add mechanism.
    function add(node, parent) {
        if (parent) parent.children.push(node);
        else tokens.push(node);
        return node;
    }
    // Mark position and patch `node.position`.
    function position() {
        var before = now();
        // Add the position to a node.
        function patch(node) {
            node.position = new Position(before);
            return node;
        }
        return patch;
    }
    // Update line and column based on `value`.
    function update(subvalue) {
        var subvalueLength = subvalue.length;
        var character = -1;
        var lastIndex = -1;
        offset += subvalueLength;
        while(++character < subvalueLength)if (subvalue.charAt(character) === "\n") {
            lastIndex = character;
            line++;
        }
        if (lastIndex === -1) column += subvalueLength;
        else column = subvalueLength - lastIndex;
    }
    // Store position information for a node.
    function Position(start) {
        this.start = start;
        this.end = now();
    }
    // Get the current position.
    function now() {
        return {
            line: line,
            column: column,
            offset: offset
        };
    }
}
// Add mechanism used when text-tokenisers are called directly outside of the
// `tokenize` function.
function $538971b5b904f078$var$noopAdd(node, parent) {
    if (parent) parent.children.push(node);
    return node;
}
// Eat and add mechanism without adding positional information, used when
// text-tokenisers are called directly outside of the `tokenize` function.
function $538971b5b904f078$var$noopEat() {
    return $538971b5b904f078$var$noopAdd;
}
var $538971b5b904f078$var$parseLatin = $538971b5b904f078$var$lib;
var $538971b5b904f078$var$retextLatin = $538971b5b904f078$var$parse$1;
$538971b5b904f078$var$parse$1.Parser = $538971b5b904f078$var$parseLatin;
function $538971b5b904f078$var$parse$1() {
    this.Parser = $538971b5b904f078$var$unherit_1($538971b5b904f078$var$parseLatin);
}
var $538971b5b904f078$var$retextStringify = $538971b5b904f078$var$stringify$1;
function $538971b5b904f078$var$stringify$1() {
    this.Compiler = $538971b5b904f078$var$compiler;
}
function $538971b5b904f078$var$compiler(tree) {
    return $538971b5b904f078$var$nlcstToString_1(tree);
}
var $538971b5b904f078$var$retext = $538971b5b904f078$var$unified_1().use($538971b5b904f078$var$retextLatin).use($538971b5b904f078$var$retextStringify).freeze();
var $538971b5b904f078$var$retextSmartypants = $538971b5b904f078$var$smartypants;
var $538971b5b904f078$var$punctuation = "PunctuationNode";
var $538971b5b904f078$var$symbol = "SymbolNode";
var $538971b5b904f078$var$word = "WordNode";
var $538971b5b904f078$var$whiteSpace = "WhiteSpaceNode";
var $538971b5b904f078$var$decadeExpression = /^\d\ds$/;
var $538971b5b904f078$var$threeFullStopsExpression = /^\.{3,}$/;
var $538971b5b904f078$var$fullStopsExpression = /^\.+$/;
var $538971b5b904f078$var$threeDashes = "---";
var $538971b5b904f078$var$twoDashes = "--";
var $538971b5b904f078$var$emDash = "\u2014";
var $538971b5b904f078$var$enDash = "\u2013";
var $538971b5b904f078$var$ellipsis = "\u2026";
var $538971b5b904f078$var$twoBackticks = "``";
var $538971b5b904f078$var$backtick = "`";
var $538971b5b904f078$var$twoSingleQuotes = "''";
var $538971b5b904f078$var$singleQuote = "'";
var $538971b5b904f078$var$apostrophe = "\u2019";
var $538971b5b904f078$var$doubleQuote = '"';
var $538971b5b904f078$var$openingDoubleQuote = "\u201C";
var $538971b5b904f078$var$closingDoubleQuote = "\u201D";
var $538971b5b904f078$var$openingSingleQuote = "\u2018";
var $538971b5b904f078$var$closingSingleQuote = "\u2019";
var $538971b5b904f078$var$closingQuotes = {};
var $538971b5b904f078$var$openingQuotes = {};
$538971b5b904f078$var$openingQuotes[$538971b5b904f078$var$doubleQuote] = $538971b5b904f078$var$openingDoubleQuote;
$538971b5b904f078$var$closingQuotes[$538971b5b904f078$var$doubleQuote] = $538971b5b904f078$var$closingDoubleQuote;
$538971b5b904f078$var$openingQuotes[$538971b5b904f078$var$singleQuote] = $538971b5b904f078$var$openingSingleQuote;
$538971b5b904f078$var$closingQuotes[$538971b5b904f078$var$singleQuote] = $538971b5b904f078$var$closingSingleQuote;
var $538971b5b904f078$var$educators = {};
// Expose educators.
$538971b5b904f078$var$educators.dashes = {
    true: $538971b5b904f078$var$dashes,
    oldschool: $538971b5b904f078$var$oldschool,
    inverted: $538971b5b904f078$var$inverted
};
$538971b5b904f078$var$educators.backticks = {
    true: $538971b5b904f078$var$backticks,
    all: $538971b5b904f078$var$all
};
$538971b5b904f078$var$educators.ellipses = {
    true: $538971b5b904f078$var$ellipses
};
$538971b5b904f078$var$educators.quotes = {
    true: $538971b5b904f078$var$quotes
};
// Attacher.
function $538971b5b904f078$var$smartypants(options) {
    var methods = [];
    var quotes;
    var ellipses;
    var backticks;
    var dashes;
    if (!options) options = {};
    if ("quotes" in options) {
        quotes = options.quotes;
        if (quotes !== Boolean(quotes)) throw new TypeError("Illegal invocation: `" + quotes + "` " + "is not a valid value for `quotes` in " + "`smartypants`");
    } else quotes = true;
    if ("ellipses" in options) {
        ellipses = options.ellipses;
        if (ellipses !== Boolean(ellipses)) throw new TypeError("Illegal invocation: `" + ellipses + "` " + "is not a valid value for `ellipses` in " + "`smartypants`");
    } else ellipses = true;
    if ("backticks" in options) {
        backticks = options.backticks;
        if (backticks !== Boolean(backticks) && backticks !== "all") throw new TypeError("Illegal invocation: `" + backticks + "` " + "is not a valid value for `backticks` in " + "`smartypants`");
        if (backticks === "all" && quotes === true) throw new TypeError("Illegal invocation: `backticks: " + backticks + "` is not a valid value " + "when `quotes: " + quotes + "` in " + "`smartypants`");
    } else backticks = true;
    if ("dashes" in options) {
        dashes = options.dashes;
        if (dashes !== Boolean(dashes) && dashes !== "oldschool" && dashes !== "inverted") throw new TypeError("Illegal invocation: `" + dashes + "` " + "is not a valid value for `dahes` in " + "`smartypants`");
    } else dashes = true;
    if (quotes !== false) methods.push($538971b5b904f078$var$educators.quotes[quotes]);
    if (ellipses !== false) methods.push($538971b5b904f078$var$educators.ellipses[ellipses]);
    if (backticks !== false) methods.push($538971b5b904f078$var$educators.backticks[backticks]);
    if (dashes !== false) methods.push($538971b5b904f078$var$educators.dashes[dashes]);
    return $538971b5b904f078$var$transformFactory(methods);
}
// Create a transformer for the bound methods.
function $538971b5b904f078$var$transformFactory(methods) {
    var length = methods.length;
    return transformer;
    // Transformer.
    function transformer(tree) {
        $538971b5b904f078$var$unistUtilVisit(tree, visitor);
    }
    function visitor(node, position, parent) {
        var index = -1;
        if (node.type === $538971b5b904f078$var$punctuation || node.type === $538971b5b904f078$var$symbol) while(++index < length)methods[index](node, position, parent);
    }
}
// Transform three dahes into an em-dash, and two into an en-dash.
function $538971b5b904f078$var$oldschool(node) {
    if (node.value === $538971b5b904f078$var$threeDashes) node.value = $538971b5b904f078$var$emDash;
    else if (node.value === $538971b5b904f078$var$twoDashes) node.value = $538971b5b904f078$var$enDash;
}
// Transform two dahes into an em-dash.
function $538971b5b904f078$var$dashes(node) {
    if (node.value === $538971b5b904f078$var$twoDashes) node.value = $538971b5b904f078$var$emDash;
}
// Transform three dahes into an en-dash, and two into an em-dash.
function $538971b5b904f078$var$inverted(node) {
    if (node.value === $538971b5b904f078$var$threeDashes) node.value = $538971b5b904f078$var$enDash;
    else if (node.value === $538971b5b904f078$var$twoDashes) node.value = $538971b5b904f078$var$emDash;
}
// Transform double backticks and single quotes into smart quotes.
function $538971b5b904f078$var$backticks(node) {
    if (node.value === $538971b5b904f078$var$twoBackticks) node.value = $538971b5b904f078$var$openingDoubleQuote;
    else if (node.value === $538971b5b904f078$var$twoSingleQuotes) node.value = $538971b5b904f078$var$closingDoubleQuote;
}
// Transform single and double backticks and single quotes into smart quotes.
function $538971b5b904f078$var$all(node) {
    $538971b5b904f078$var$backticks(node);
    if (node.value === $538971b5b904f078$var$backtick) node.value = $538971b5b904f078$var$openingSingleQuote;
    else if (node.value === $538971b5b904f078$var$singleQuote) node.value = $538971b5b904f078$var$closingSingleQuote;
}
// Transform multiple dots into unicode ellipses.
function $538971b5b904f078$var$ellipses(node, index, parent) {
    var value = node.value;
    var siblings = parent.children;
    var position;
    var nodes;
    var sibling;
    var type;
    var count;
    var queue;
    // Simple node with three dots and without white-space.
    if ($538971b5b904f078$var$threeFullStopsExpression.test(node.value)) {
        node.value = $538971b5b904f078$var$ellipsis;
        return;
    }
    if (!$538971b5b904f078$var$fullStopsExpression.test(value)) return;
    // Search for dot-nodes with white-space between.
    nodes = [];
    position = index;
    count = 1;
    // It’s possible that the node is merged with an adjacent word-node.  In that
    // code, we cannot transform it because there’s no reference to the
    // grandparent.
    while(--position > 0){
        sibling = siblings[position];
        if (sibling.type !== $538971b5b904f078$var$whiteSpace) break;
        queue = sibling;
        sibling = siblings[--position];
        type = sibling && sibling.type;
        if (sibling && (type === $538971b5b904f078$var$punctuation || type === $538971b5b904f078$var$symbol) && $538971b5b904f078$var$fullStopsExpression.test(sibling.value)) {
            nodes.push(queue, sibling);
            count++;
            continue;
        }
        break;
    }
    if (count < 3) return;
    siblings.splice(index - nodes.length, nodes.length);
    node.value = $538971b5b904f078$var$ellipsis;
}
// Transform straight single- and double quotes into smart quotes.
// eslint-disable-next-line complexity
function $538971b5b904f078$var$quotes(node, index, parent) {
    var siblings = parent.children;
    var value = node.value;
    var next;
    var nextNext;
    var prev;
    var nextValue;
    if (value !== $538971b5b904f078$var$doubleQuote && value !== $538971b5b904f078$var$singleQuote) return;
    prev = siblings[index - 1];
    next = siblings[index + 1];
    nextNext = siblings[index + 2];
    nextValue = next && $538971b5b904f078$var$nlcstToString_1(next);
    if (next && nextNext && (next.type === $538971b5b904f078$var$punctuation || next.type === $538971b5b904f078$var$symbol) && nextNext.type !== $538971b5b904f078$var$word) // Special case if the very first character is a quote followed by
    // punctuation at a non-word-break. Close the quotes by brute force.
    node.value = $538971b5b904f078$var$closingQuotes[value];
    else if (nextNext && (nextValue === $538971b5b904f078$var$doubleQuote || nextValue === $538971b5b904f078$var$singleQuote) && nextNext.type === $538971b5b904f078$var$word) {
        // Special case for double sets of quotes:
        // `He said, "'Quoted' words in a larger quote."`
        node.value = $538971b5b904f078$var$openingQuotes[value];
        next.value = $538971b5b904f078$var$openingQuotes[nextValue];
    } else if (next && $538971b5b904f078$var$decadeExpression.test(nextValue)) // Special case for decade abbreviations: `the '80s`
    node.value = $538971b5b904f078$var$closingQuotes[value];
    else if (prev && next && (prev.type === $538971b5b904f078$var$whiteSpace || prev.type === $538971b5b904f078$var$punctuation || prev.type === $538971b5b904f078$var$symbol) && next.type === $538971b5b904f078$var$word) // Get most opening single quotes.
    node.value = $538971b5b904f078$var$openingQuotes[value];
    else if (prev && prev.type !== $538971b5b904f078$var$whiteSpace && prev.type !== $538971b5b904f078$var$symbol && prev.type !== $538971b5b904f078$var$punctuation) // Closing quotes.
    node.value = $538971b5b904f078$var$closingQuotes[value];
    else if (!next || next.type === $538971b5b904f078$var$whiteSpace || (value === $538971b5b904f078$var$singleQuote || value === $538971b5b904f078$var$apostrophe) && nextValue === "s") node.value = $538971b5b904f078$var$closingQuotes[value];
    else node.value = $538971b5b904f078$var$openingQuotes[value];
}
function $538971b5b904f078$var$isNothing(subject) {
    return typeof subject === "undefined" || subject === null;
}
function $538971b5b904f078$var$isObject(subject) {
    return typeof subject === "object" && subject !== null;
}
function $538971b5b904f078$var$toArray(sequence) {
    if (Array.isArray(sequence)) return sequence;
    else if ($538971b5b904f078$var$isNothing(sequence)) return [];
    return [
        sequence
    ];
}
function $538971b5b904f078$var$extend(target, source) {
    var index, length, key, sourceKeys;
    if (source) {
        sourceKeys = Object.keys(source);
        for(index = 0, length = sourceKeys.length; index < length; index += 1){
            key = sourceKeys[index];
            target[key] = source[key];
        }
    }
    return target;
}
function $538971b5b904f078$var$repeat(string, count) {
    var result = "", cycle;
    for(cycle = 0; cycle < count; cycle += 1)result += string;
    return result;
}
function $538971b5b904f078$var$isNegativeZero(number) {
    return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
}
var $538971b5b904f078$var$isNothing_1 = $538971b5b904f078$var$isNothing;
var $538971b5b904f078$var$isObject_1 = $538971b5b904f078$var$isObject;
var $538971b5b904f078$var$toArray_1 = $538971b5b904f078$var$toArray;
var $538971b5b904f078$var$repeat_1 = $538971b5b904f078$var$repeat;
var $538971b5b904f078$var$isNegativeZero_1 = $538971b5b904f078$var$isNegativeZero;
var $538971b5b904f078$var$extend_1 = $538971b5b904f078$var$extend;
var $538971b5b904f078$var$common = {
    isNothing: $538971b5b904f078$var$isNothing_1,
    isObject: $538971b5b904f078$var$isObject_1,
    toArray: $538971b5b904f078$var$toArray_1,
    repeat: $538971b5b904f078$var$repeat_1,
    isNegativeZero: $538971b5b904f078$var$isNegativeZero_1,
    extend: $538971b5b904f078$var$extend_1
};
// YAML error class. http://stackoverflow.com/questions/8458984
function $538971b5b904f078$var$YAMLException$1(reason, mark) {
    // Super constructor
    Error.call(this);
    this.name = "YAMLException";
    this.reason = reason;
    this.mark = mark;
    this.message = (this.reason || "(unknown reason)") + (this.mark ? " " + this.mark.toString() : "");
    // Include stack trace in error object
    if (Error.captureStackTrace) // Chrome and NodeJS
    Error.captureStackTrace(this, this.constructor);
    else // FF, IE 10+ and Safari 6+. Fallback for others
    this.stack = new Error().stack || "";
}
// Inherit from Error
$538971b5b904f078$var$YAMLException$1.prototype = Object.create(Error.prototype);
$538971b5b904f078$var$YAMLException$1.prototype.constructor = $538971b5b904f078$var$YAMLException$1;
$538971b5b904f078$var$YAMLException$1.prototype.toString = function toString(compact) {
    var result = this.name + ": ";
    result += this.reason || "(unknown reason)";
    if (!compact && this.mark) result += " " + this.mark.toString();
    return result;
};
var $538971b5b904f078$var$exception = $538971b5b904f078$var$YAMLException$1;
function $538971b5b904f078$var$Mark(name, buffer, position, line, column) {
    this.name = name;
    this.buffer = buffer;
    this.position = position;
    this.line = line;
    this.column = column;
}
$538971b5b904f078$var$Mark.prototype.getSnippet = function getSnippet(indent, maxLength) {
    var head, start, tail, end, snippet;
    if (!this.buffer) return null;
    indent = indent || 4;
    maxLength = maxLength || 75;
    head = "";
    start = this.position;
    while(start > 0 && "\0\r\n\x85\u2028\u2029".indexOf(this.buffer.charAt(start - 1)) === -1){
        start -= 1;
        if (this.position - start > maxLength / 2 - 1) {
            head = " ... ";
            start += 5;
            break;
        }
    }
    tail = "";
    end = this.position;
    while(end < this.buffer.length && "\0\r\n\x85\u2028\u2029".indexOf(this.buffer.charAt(end)) === -1){
        end += 1;
        if (end - this.position > maxLength / 2 - 1) {
            tail = " ... ";
            end -= 5;
            break;
        }
    }
    snippet = this.buffer.slice(start, end);
    return $538971b5b904f078$var$common.repeat(" ", indent) + head + snippet + tail + "\n" + $538971b5b904f078$var$common.repeat(" ", indent + this.position - start + head.length) + "^";
};
$538971b5b904f078$var$Mark.prototype.toString = function toString(compact) {
    var snippet, where = "";
    if (this.name) where += 'in "' + this.name + '" ';
    where += "at line " + (this.line + 1) + ", column " + (this.column + 1);
    if (!compact) {
        snippet = this.getSnippet();
        if (snippet) where += ":\n" + snippet;
    }
    return where;
};
var $538971b5b904f078$var$mark = $538971b5b904f078$var$Mark;
var $538971b5b904f078$var$TYPE_CONSTRUCTOR_OPTIONS = [
    "kind",
    "resolve",
    "construct",
    "instanceOf",
    "predicate",
    "represent",
    "defaultStyle",
    "styleAliases"
];
var $538971b5b904f078$var$YAML_NODE_KINDS = [
    "scalar",
    "sequence",
    "mapping"
];
function $538971b5b904f078$var$compileStyleAliases(map) {
    var result = {};
    if (map !== null) Object.keys(map).forEach(function(style) {
        map[style].forEach(function(alias) {
            result[String(alias)] = style;
        });
    });
    return result;
}
function $538971b5b904f078$var$Type$1(tag, options) {
    options = options || {};
    Object.keys(options).forEach(function(name) {
        if ($538971b5b904f078$var$TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) throw new $538971b5b904f078$var$exception('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    });
    // TODO: Add tag format check.
    this.tag = tag;
    this.kind = options["kind"] || null;
    this.resolve = options["resolve"] || function() {
        return true;
    };
    this.construct = options["construct"] || function(data) {
        return data;
    };
    this.instanceOf = options["instanceOf"] || null;
    this.predicate = options["predicate"] || null;
    this.represent = options["represent"] || null;
    this.defaultStyle = options["defaultStyle"] || null;
    this.styleAliases = $538971b5b904f078$var$compileStyleAliases(options["styleAliases"] || null);
    if ($538971b5b904f078$var$YAML_NODE_KINDS.indexOf(this.kind) === -1) throw new $538971b5b904f078$var$exception('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
}
var $538971b5b904f078$var$type = $538971b5b904f078$var$Type$1;
/*eslint-disable max-len*/ function $538971b5b904f078$var$compileList(schema, name, result) {
    var exclude = [];
    schema.include.forEach(function(includedSchema) {
        result = $538971b5b904f078$var$compileList(includedSchema, name, result);
    });
    schema[name].forEach(function(currentType) {
        result.forEach(function(previousType, previousIndex) {
            if (previousType.tag === currentType.tag && previousType.kind === currentType.kind) exclude.push(previousIndex);
        });
        result.push(currentType);
    });
    return result.filter(function(type, index) {
        return exclude.indexOf(index) === -1;
    });
}
function $538971b5b904f078$var$compileMap() {
    var result = {
        scalar: {},
        sequence: {},
        mapping: {},
        fallback: {}
    }, index, length;
    function collectType(type) {
        result[type.kind][type.tag] = result["fallback"][type.tag] = type;
    }
    for(index = 0, length = arguments.length; index < length; index += 1)arguments[index].forEach(collectType);
    return result;
}
function $538971b5b904f078$var$Schema$1(definition) {
    this.include = definition.include || [];
    this.implicit = definition.implicit || [];
    this.explicit = definition.explicit || [];
    this.implicit.forEach(function(type) {
        if (type.loadKind && type.loadKind !== "scalar") throw new $538971b5b904f078$var$exception("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
    });
    this.compiledImplicit = $538971b5b904f078$var$compileList(this, "implicit", []);
    this.compiledExplicit = $538971b5b904f078$var$compileList(this, "explicit", []);
    this.compiledTypeMap = $538971b5b904f078$var$compileMap(this.compiledImplicit, this.compiledExplicit);
}
$538971b5b904f078$var$Schema$1.DEFAULT = null;
$538971b5b904f078$var$Schema$1.create = function createSchema() {
    var schemas, types;
    switch(arguments.length){
        case 1:
            schemas = $538971b5b904f078$var$Schema$1.DEFAULT;
            types = arguments[0];
            break;
        case 2:
            schemas = arguments[0];
            types = arguments[1];
            break;
        default:
            throw new $538971b5b904f078$var$exception("Wrong number of arguments for Schema.create function");
    }
    schemas = $538971b5b904f078$var$common.toArray(schemas);
    types = $538971b5b904f078$var$common.toArray(types);
    if (!schemas.every(function(schema) {
        return schema instanceof $538971b5b904f078$var$Schema$1;
    })) throw new $538971b5b904f078$var$exception("Specified list of super schemas (or a single Schema object) contains a non-Schema object.");
    if (!types.every(function(type$1) {
        return type$1 instanceof $538971b5b904f078$var$type;
    })) throw new $538971b5b904f078$var$exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    return new $538971b5b904f078$var$Schema$1({
        include: schemas,
        explicit: types
    });
};
var $538971b5b904f078$var$schema = $538971b5b904f078$var$Schema$1;
var $538971b5b904f078$var$str = new $538971b5b904f078$var$type("tag:yaml.org,2002:str", {
    kind: "scalar",
    construct: function(data) {
        return data !== null ? data : "";
    }
});
var $538971b5b904f078$var$seq = new $538971b5b904f078$var$type("tag:yaml.org,2002:seq", {
    kind: "sequence",
    construct: function(data) {
        return data !== null ? data : [];
    }
});
var $538971b5b904f078$var$map = new $538971b5b904f078$var$type("tag:yaml.org,2002:map", {
    kind: "mapping",
    construct: function(data) {
        return data !== null ? data : {};
    }
});
var $538971b5b904f078$var$failsafe = new $538971b5b904f078$var$schema({
    explicit: [
        $538971b5b904f078$var$str,
        $538971b5b904f078$var$seq,
        $538971b5b904f078$var$map
    ]
});
function $538971b5b904f078$var$resolveYamlNull(data) {
    if (data === null) return true;
    var max = data.length;
    return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");
}
function $538971b5b904f078$var$constructYamlNull() {
    return null;
}
function $538971b5b904f078$var$isNull(object) {
    return object === null;
}
var $538971b5b904f078$var$_null = new $538971b5b904f078$var$type("tag:yaml.org,2002:null", {
    kind: "scalar",
    resolve: $538971b5b904f078$var$resolveYamlNull,
    construct: $538971b5b904f078$var$constructYamlNull,
    predicate: $538971b5b904f078$var$isNull,
    represent: {
        canonical: function() {
            return "~";
        },
        lowercase: function() {
            return "null";
        },
        uppercase: function() {
            return "NULL";
        },
        camelcase: function() {
            return "Null";
        }
    },
    defaultStyle: "lowercase"
});
function $538971b5b904f078$var$resolveYamlBoolean(data) {
    if (data === null) return false;
    var max = data.length;
    return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");
}
function $538971b5b904f078$var$constructYamlBoolean(data) {
    return data === "true" || data === "True" || data === "TRUE";
}
function $538971b5b904f078$var$isBoolean(object) {
    return Object.prototype.toString.call(object) === "[object Boolean]";
}
var $538971b5b904f078$var$bool = new $538971b5b904f078$var$type("tag:yaml.org,2002:bool", {
    kind: "scalar",
    resolve: $538971b5b904f078$var$resolveYamlBoolean,
    construct: $538971b5b904f078$var$constructYamlBoolean,
    predicate: $538971b5b904f078$var$isBoolean,
    represent: {
        lowercase: function(object) {
            return object ? "true" : "false";
        },
        uppercase: function(object) {
            return object ? "TRUE" : "FALSE";
        },
        camelcase: function(object) {
            return object ? "True" : "False";
        }
    },
    defaultStyle: "lowercase"
});
function $538971b5b904f078$var$isHexCode(c) {
    return 0x30 /* 0 */  <= c && c <= 0x39 /* 9 */  || 0x41 /* A */  <= c && c <= 0x46 /* F */  || 0x61 /* a */  <= c && c <= 0x66 /* f */ ;
}
function $538971b5b904f078$var$isOctCode(c) {
    return 0x30 /* 0 */  <= c && c <= 0x37 /* 7 */ ;
}
function $538971b5b904f078$var$isDecCode(c) {
    return 0x30 /* 0 */  <= c && c <= 0x39 /* 9 */ ;
}
function $538971b5b904f078$var$resolveYamlInteger(data) {
    if (data === null) return false;
    var max = data.length, index = 0, hasDigits = false, ch;
    if (!max) return false;
    ch = data[index];
    // sign
    if (ch === "-" || ch === "+") ch = data[++index];
    if (ch === "0") {
        // 0
        if (index + 1 === max) return true;
        ch = data[++index];
        // base 2, base 8, base 16
        if (ch === "b") {
            // base 2
            index++;
            for(; index < max; index++){
                ch = data[index];
                if (ch === "_") continue;
                if (ch !== "0" && ch !== "1") return false;
                hasDigits = true;
            }
            return hasDigits && ch !== "_";
        }
        if (ch === "x") {
            // base 16
            index++;
            for(; index < max; index++){
                ch = data[index];
                if (ch === "_") continue;
                if (!$538971b5b904f078$var$isHexCode(data.charCodeAt(index))) return false;
                hasDigits = true;
            }
            return hasDigits && ch !== "_";
        }
        // base 8
        for(; index < max; index++){
            ch = data[index];
            if (ch === "_") continue;
            if (!$538971b5b904f078$var$isOctCode(data.charCodeAt(index))) return false;
            hasDigits = true;
        }
        return hasDigits && ch !== "_";
    }
    // base 10 (except 0) or base 60
    // value should not start with `_`;
    if (ch === "_") return false;
    for(; index < max; index++){
        ch = data[index];
        if (ch === "_") continue;
        if (ch === ":") break;
        if (!$538971b5b904f078$var$isDecCode(data.charCodeAt(index))) return false;
        hasDigits = true;
    }
    // Should have digits and should not end with `_`
    if (!hasDigits || ch === "_") return false;
    // if !base60 - done;
    if (ch !== ":") return true;
    // base60 almost not used, no needs to optimize
    return /^(:[0-5]?[0-9])+$/.test(data.slice(index));
}
function $538971b5b904f078$var$constructYamlInteger(data) {
    var value = data, sign = 1, ch, base, digits = [];
    if (value.indexOf("_") !== -1) value = value.replace(/_/g, "");
    ch = value[0];
    if (ch === "-" || ch === "+") {
        if (ch === "-") sign = -1;
        value = value.slice(1);
        ch = value[0];
    }
    if (value === "0") return 0;
    if (ch === "0") {
        if (value[1] === "b") return sign * parseInt(value.slice(2), 2);
        if (value[1] === "x") return sign * parseInt(value, 16);
        return sign * parseInt(value, 8);
    }
    if (value.indexOf(":") !== -1) {
        value.split(":").forEach(function(v) {
            digits.unshift(parseInt(v, 10));
        });
        value = 0;
        base = 1;
        digits.forEach(function(d) {
            value += d * base;
            base *= 60;
        });
        return sign * value;
    }
    return sign * parseInt(value, 10);
}
function $538971b5b904f078$var$isInteger(object) {
    return Object.prototype.toString.call(object) === "[object Number]" && object % 1 === 0 && !$538971b5b904f078$var$common.isNegativeZero(object);
}
var $538971b5b904f078$var$int_1 = new $538971b5b904f078$var$type("tag:yaml.org,2002:int", {
    kind: "scalar",
    resolve: $538971b5b904f078$var$resolveYamlInteger,
    construct: $538971b5b904f078$var$constructYamlInteger,
    predicate: $538971b5b904f078$var$isInteger,
    represent: {
        binary: function(obj) {
            return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
        },
        octal: function(obj) {
            return obj >= 0 ? "0" + obj.toString(8) : "-0" + obj.toString(8).slice(1);
        },
        decimal: function(obj) {
            return obj.toString(10);
        },
        /* eslint-disable max-len */ hexadecimal: function(obj) {
            return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
        }
    },
    defaultStyle: "decimal",
    styleAliases: {
        binary: [
            2,
            "bin"
        ],
        octal: [
            8,
            "oct"
        ],
        decimal: [
            10,
            "dec"
        ],
        hexadecimal: [
            16,
            "hex"
        ]
    }
});
var $538971b5b904f078$var$YAML_FLOAT_PATTERN = new RegExp(// 2.5e4, 2.5 and integers
"^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$");
function $538971b5b904f078$var$resolveYamlFloat(data) {
    if (data === null) return false;
    if (!$538971b5b904f078$var$YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`
    // Probably should update regexp & check speed
    data[data.length - 1] === "_") return false;
    return true;
}
function $538971b5b904f078$var$constructYamlFloat(data) {
    var value, sign, base, digits;
    value = data.replace(/_/g, "").toLowerCase();
    sign = value[0] === "-" ? -1 : 1;
    digits = [];
    if ("+-".indexOf(value[0]) >= 0) value = value.slice(1);
    if (value === ".inf") return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
    else if (value === ".nan") return NaN;
    else if (value.indexOf(":") >= 0) {
        value.split(":").forEach(function(v) {
            digits.unshift(parseFloat(v, 10));
        });
        value = 0.0;
        base = 1;
        digits.forEach(function(d) {
            value += d * base;
            base *= 60;
        });
        return sign * value;
    }
    return sign * parseFloat(value, 10);
}
var $538971b5b904f078$var$SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
function $538971b5b904f078$var$representYamlFloat(object, style) {
    var res;
    if (isNaN(object)) switch(style){
        case "lowercase":
            return ".nan";
        case "uppercase":
            return ".NAN";
        case "camelcase":
            return ".NaN";
    }
    else if (Number.POSITIVE_INFINITY === object) switch(style){
        case "lowercase":
            return ".inf";
        case "uppercase":
            return ".INF";
        case "camelcase":
            return ".Inf";
    }
    else if (Number.NEGATIVE_INFINITY === object) switch(style){
        case "lowercase":
            return "-.inf";
        case "uppercase":
            return "-.INF";
        case "camelcase":
            return "-.Inf";
    }
    else if ($538971b5b904f078$var$common.isNegativeZero(object)) return "-0.0";
    res = object.toString(10);
    // JS stringifier can build scientific format without dots: 5e-100,
    // while YAML requres dot: 5.e-100. Fix it with simple hack
    return $538971b5b904f078$var$SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
}
function $538971b5b904f078$var$isFloat(object) {
    return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || $538971b5b904f078$var$common.isNegativeZero(object));
}
var $538971b5b904f078$var$float_1 = new $538971b5b904f078$var$type("tag:yaml.org,2002:float", {
    kind: "scalar",
    resolve: $538971b5b904f078$var$resolveYamlFloat,
    construct: $538971b5b904f078$var$constructYamlFloat,
    predicate: $538971b5b904f078$var$isFloat,
    represent: $538971b5b904f078$var$representYamlFloat,
    defaultStyle: "lowercase"
});
var $538971b5b904f078$var$json = new $538971b5b904f078$var$schema({
    include: [
        $538971b5b904f078$var$failsafe
    ],
    implicit: [
        $538971b5b904f078$var$_null,
        $538971b5b904f078$var$bool,
        $538971b5b904f078$var$int_1,
        $538971b5b904f078$var$float_1
    ]
});
var $538971b5b904f078$var$core = new $538971b5b904f078$var$schema({
    include: [
        $538971b5b904f078$var$json
    ]
});
var $538971b5b904f078$var$YAML_DATE_REGEXP = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"); // [3] day
var $538971b5b904f078$var$YAML_TIMESTAMP_REGEXP = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"); // [11] tz_minute
function $538971b5b904f078$var$resolveYamlTimestamp(data) {
    if (data === null) return false;
    if ($538971b5b904f078$var$YAML_DATE_REGEXP.exec(data) !== null) return true;
    if ($538971b5b904f078$var$YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
    return false;
}
function $538971b5b904f078$var$constructYamlTimestamp(data) {
    var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
    match = $538971b5b904f078$var$YAML_DATE_REGEXP.exec(data);
    if (match === null) match = $538971b5b904f078$var$YAML_TIMESTAMP_REGEXP.exec(data);
    if (match === null) throw new Error("Date resolve error");
    // match: [1] year [2] month [3] day
    year = +match[1];
    month = +match[2] - 1; // JS month starts with 0
    day = +match[3];
    if (!match[4]) return new Date(Date.UTC(year, month, day));
    // match: [4] hour [5] minute [6] second [7] fraction
    hour = +match[4];
    minute = +match[5];
    second = +match[6];
    if (match[7]) {
        fraction = match[7].slice(0, 3);
        while(fraction.length < 3)fraction += "0";
        fraction = +fraction;
    }
    // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute
    if (match[9]) {
        tz_hour = +match[10];
        tz_minute = +(match[11] || 0);
        delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds
        if (match[9] === "-") delta = -delta;
    }
    date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
    if (delta) date.setTime(date.getTime() - delta);
    return date;
}
function $538971b5b904f078$var$representYamlTimestamp(object /*, style*/ ) {
    return object.toISOString();
}
var $538971b5b904f078$var$timestamp = new $538971b5b904f078$var$type("tag:yaml.org,2002:timestamp", {
    kind: "scalar",
    resolve: $538971b5b904f078$var$resolveYamlTimestamp,
    construct: $538971b5b904f078$var$constructYamlTimestamp,
    instanceOf: Date,
    represent: $538971b5b904f078$var$representYamlTimestamp
});
function $538971b5b904f078$var$resolveYamlMerge(data) {
    return data === "<<" || data === null;
}
var $538971b5b904f078$var$merge = new $538971b5b904f078$var$type("tag:yaml.org,2002:merge", {
    kind: "scalar",
    resolve: $538971b5b904f078$var$resolveYamlMerge
});
/*eslint-disable no-bitwise*/ var $538971b5b904f078$var$NodeBuffer;
try {
    // A trick for browserified version, to not include `Buffer` shim
    var $538971b5b904f078$var$_require$1 = $538971b5b904f078$var$commonjsRequire;
    $538971b5b904f078$var$NodeBuffer = $538971b5b904f078$var$_require$1("buffer").Buffer;
} catch (__) {}
// [ 64, 65, 66 ] -> [ padding, CR, LF ]
var $538971b5b904f078$var$BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
function $538971b5b904f078$var$resolveYamlBinary(data) {
    if (data === null) return false;
    var code, idx, bitlen = 0, max = data.length, map = $538971b5b904f078$var$BASE64_MAP;
    // Convert one by one.
    for(idx = 0; idx < max; idx++){
        code = map.indexOf(data.charAt(idx));
        // Skip CR/LF
        if (code > 64) continue;
        // Fail on illegal characters
        if (code < 0) return false;
        bitlen += 6;
    }
    // If there are any bits left, source was corrupted
    return bitlen % 8 === 0;
}
function $538971b5b904f078$var$constructYamlBinary(data) {
    var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max = input.length, map = $538971b5b904f078$var$BASE64_MAP, bits = 0, result = [];
    // Collect by 6*4 bits (3 bytes)
    for(idx = 0; idx < max; idx++){
        if (idx % 4 === 0 && idx) {
            result.push(bits >> 16 & 0xFF);
            result.push(bits >> 8 & 0xFF);
            result.push(bits & 0xFF);
        }
        bits = bits << 6 | map.indexOf(input.charAt(idx));
    }
    // Dump tail
    tailbits = max % 4 * 6;
    if (tailbits === 0) {
        result.push(bits >> 16 & 0xFF);
        result.push(bits >> 8 & 0xFF);
        result.push(bits & 0xFF);
    } else if (tailbits === 18) {
        result.push(bits >> 10 & 0xFF);
        result.push(bits >> 2 & 0xFF);
    } else if (tailbits === 12) result.push(bits >> 4 & 0xFF);
    // Wrap into Buffer for NodeJS and leave Array for browser
    if ($538971b5b904f078$var$NodeBuffer) // Support node 6.+ Buffer API when available
    return $538971b5b904f078$var$NodeBuffer.from ? $538971b5b904f078$var$NodeBuffer.from(result) : new $538971b5b904f078$var$NodeBuffer(result);
    return result;
}
function $538971b5b904f078$var$representYamlBinary(object /*, style*/ ) {
    var result = "", bits = 0, idx, tail, max = object.length, map = $538971b5b904f078$var$BASE64_MAP;
    // Convert every three bytes to 4 ASCII characters.
    for(idx = 0; idx < max; idx++){
        if (idx % 3 === 0 && idx) {
            result += map[bits >> 18 & 0x3F];
            result += map[bits >> 12 & 0x3F];
            result += map[bits >> 6 & 0x3F];
            result += map[bits & 0x3F];
        }
        bits = (bits << 8) + object[idx];
    }
    // Dump tail
    tail = max % 3;
    if (tail === 0) {
        result += map[bits >> 18 & 0x3F];
        result += map[bits >> 12 & 0x3F];
        result += map[bits >> 6 & 0x3F];
        result += map[bits & 0x3F];
    } else if (tail === 2) {
        result += map[bits >> 10 & 0x3F];
        result += map[bits >> 4 & 0x3F];
        result += map[bits << 2 & 0x3F];
        result += map[64];
    } else if (tail === 1) {
        result += map[bits >> 2 & 0x3F];
        result += map[bits << 4 & 0x3F];
        result += map[64];
        result += map[64];
    }
    return result;
}
function $538971b5b904f078$var$isBinary(object) {
    return $538971b5b904f078$var$NodeBuffer && $538971b5b904f078$var$NodeBuffer.isBuffer(object);
}
var $538971b5b904f078$var$binary = new $538971b5b904f078$var$type("tag:yaml.org,2002:binary", {
    kind: "scalar",
    resolve: $538971b5b904f078$var$resolveYamlBinary,
    construct: $538971b5b904f078$var$constructYamlBinary,
    predicate: $538971b5b904f078$var$isBinary,
    represent: $538971b5b904f078$var$representYamlBinary
});
var $538971b5b904f078$var$_hasOwnProperty$3 = Object.prototype.hasOwnProperty;
var $538971b5b904f078$var$_toString$2 = Object.prototype.toString;
function $538971b5b904f078$var$resolveYamlOmap(data) {
    if (data === null) return true;
    var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
    for(index = 0, length = object.length; index < length; index += 1){
        pair = object[index];
        pairHasKey = false;
        if ($538971b5b904f078$var$_toString$2.call(pair) !== "[object Object]") return false;
        for(pairKey in pair)if ($538971b5b904f078$var$_hasOwnProperty$3.call(pair, pairKey)) {
            if (!pairHasKey) pairHasKey = true;
            else return false;
        }
        if (!pairHasKey) return false;
        if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
        else return false;
    }
    return true;
}
function $538971b5b904f078$var$constructYamlOmap(data) {
    return data !== null ? data : [];
}
var $538971b5b904f078$var$omap = new $538971b5b904f078$var$type("tag:yaml.org,2002:omap", {
    kind: "sequence",
    resolve: $538971b5b904f078$var$resolveYamlOmap,
    construct: $538971b5b904f078$var$constructYamlOmap
});
var $538971b5b904f078$var$_toString$1 = Object.prototype.toString;
function $538971b5b904f078$var$resolveYamlPairs(data) {
    if (data === null) return true;
    var index, length, pair, keys, result, object = data;
    result = new Array(object.length);
    for(index = 0, length = object.length; index < length; index += 1){
        pair = object[index];
        if ($538971b5b904f078$var$_toString$1.call(pair) !== "[object Object]") return false;
        keys = Object.keys(pair);
        if (keys.length !== 1) return false;
        result[index] = [
            keys[0],
            pair[keys[0]]
        ];
    }
    return true;
}
function $538971b5b904f078$var$constructYamlPairs(data) {
    if (data === null) return [];
    var index, length, pair, keys, result, object = data;
    result = new Array(object.length);
    for(index = 0, length = object.length; index < length; index += 1){
        pair = object[index];
        keys = Object.keys(pair);
        result[index] = [
            keys[0],
            pair[keys[0]]
        ];
    }
    return result;
}
var $538971b5b904f078$var$pairs = new $538971b5b904f078$var$type("tag:yaml.org,2002:pairs", {
    kind: "sequence",
    resolve: $538971b5b904f078$var$resolveYamlPairs,
    construct: $538971b5b904f078$var$constructYamlPairs
});
var $538971b5b904f078$var$_hasOwnProperty$2 = Object.prototype.hasOwnProperty;
function $538971b5b904f078$var$resolveYamlSet(data) {
    if (data === null) return true;
    var key, object = data;
    for(key in object)if ($538971b5b904f078$var$_hasOwnProperty$2.call(object, key)) {
        if (object[key] !== null) return false;
    }
    return true;
}
function $538971b5b904f078$var$constructYamlSet(data) {
    return data !== null ? data : {};
}
var $538971b5b904f078$var$set = new $538971b5b904f078$var$type("tag:yaml.org,2002:set", {
    kind: "mapping",
    resolve: $538971b5b904f078$var$resolveYamlSet,
    construct: $538971b5b904f078$var$constructYamlSet
});
var $538971b5b904f078$var$default_safe = new $538971b5b904f078$var$schema({
    include: [
        $538971b5b904f078$var$core
    ],
    implicit: [
        $538971b5b904f078$var$timestamp,
        $538971b5b904f078$var$merge
    ],
    explicit: [
        $538971b5b904f078$var$binary,
        $538971b5b904f078$var$omap,
        $538971b5b904f078$var$pairs,
        $538971b5b904f078$var$set
    ]
});
function $538971b5b904f078$var$resolveJavascriptUndefined() {
    return true;
}
function $538971b5b904f078$var$constructJavascriptUndefined() {
    /*eslint-disable no-undefined*/ return undefined;
}
function $538971b5b904f078$var$representJavascriptUndefined() {
    return "";
}
function $538971b5b904f078$var$isUndefined(object) {
    return typeof object === "undefined";
}
var $538971b5b904f078$var$_undefined = new $538971b5b904f078$var$type("tag:yaml.org,2002:js/undefined", {
    kind: "scalar",
    resolve: $538971b5b904f078$var$resolveJavascriptUndefined,
    construct: $538971b5b904f078$var$constructJavascriptUndefined,
    predicate: $538971b5b904f078$var$isUndefined,
    represent: $538971b5b904f078$var$representJavascriptUndefined
});
function $538971b5b904f078$var$resolveJavascriptRegExp(data) {
    if (data === null) return false;
    if (data.length === 0) return false;
    var regexp = data, tail = /\/([gim]*)$/.exec(data), modifiers = "";
    // if regexp starts with '/' it can have modifiers and must be properly closed
    // `/foo/gim` - modifiers tail can be maximum 3 chars
    if (regexp[0] === "/") {
        if (tail) modifiers = tail[1];
        if (modifiers.length > 3) return false;
        // if expression starts with /, is should be properly terminated
        if (regexp[regexp.length - modifiers.length - 1] !== "/") return false;
    }
    return true;
}
function $538971b5b904f078$var$constructJavascriptRegExp(data) {
    var regexp = data, tail = /\/([gim]*)$/.exec(data), modifiers = "";
    // `/foo/gim` - tail can be maximum 4 chars
    if (regexp[0] === "/") {
        if (tail) modifiers = tail[1];
        regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
    }
    return new RegExp(regexp, modifiers);
}
function $538971b5b904f078$var$representJavascriptRegExp(object /*, style*/ ) {
    var result = "/" + object.source + "/";
    if (object.global) result += "g";
    if (object.multiline) result += "m";
    if (object.ignoreCase) result += "i";
    return result;
}
function $538971b5b904f078$var$isRegExp(object) {
    return Object.prototype.toString.call(object) === "[object RegExp]";
}
var $538971b5b904f078$var$regexp = new $538971b5b904f078$var$type("tag:yaml.org,2002:js/regexp", {
    kind: "scalar",
    resolve: $538971b5b904f078$var$resolveJavascriptRegExp,
    construct: $538971b5b904f078$var$constructJavascriptRegExp,
    predicate: $538971b5b904f078$var$isRegExp,
    represent: $538971b5b904f078$var$representJavascriptRegExp
});
var $538971b5b904f078$var$esprima;
// Browserified version does not have esprima
//
// 1. For node.js just require module as deps
// 2. For browser try to require mudule via external AMD system.
//    If not found - try to fallback to window.esprima. If not
//    found too - then fail to parse.
//
try {
    // workaround to exclude package from browserify list.
    var $538971b5b904f078$var$_require = $538971b5b904f078$var$commonjsRequire;
    $538971b5b904f078$var$esprima = $538971b5b904f078$var$_require("esprima");
} catch (_) {
    /* eslint-disable no-redeclare */ /* global window */ if (typeof window !== "undefined") $538971b5b904f078$var$esprima = window.esprima;
}
function $538971b5b904f078$var$resolveJavascriptFunction(data) {
    if (data === null) return false;
    try {
        var source = "(" + data + ")", ast = $538971b5b904f078$var$esprima.parse(source, {
            range: true
        });
        if (ast.type !== "Program" || ast.body.length !== 1 || ast.body[0].type !== "ExpressionStatement" || ast.body[0].expression.type !== "ArrowFunctionExpression" && ast.body[0].expression.type !== "FunctionExpression") return false;
        return true;
    } catch (err) {
        return false;
    }
}
function $538971b5b904f078$var$constructJavascriptFunction(data) {
    /*jslint evil:true*/ var source = "(" + data + ")", ast = $538971b5b904f078$var$esprima.parse(source, {
        range: true
    }), params = [], body;
    if (ast.type !== "Program" || ast.body.length !== 1 || ast.body[0].type !== "ExpressionStatement" || ast.body[0].expression.type !== "ArrowFunctionExpression" && ast.body[0].expression.type !== "FunctionExpression") throw new Error("Failed to resolve function");
    ast.body[0].expression.params.forEach(function(param) {
        params.push(param.name);
    });
    body = ast.body[0].expression.body.range;
    // Esprima's ranges include the first '{' and the last '}' characters on
    // function expressions. So cut them out.
    if (ast.body[0].expression.body.type === "BlockStatement") /*eslint-disable no-new-func*/ return new Function(params, source.slice(body[0] + 1, body[1] - 1));
    // ES6 arrow functions can omit the BlockStatement. In that case, just return
    // the body.
    /*eslint-disable no-new-func*/ return new Function(params, "return " + source.slice(body[0], body[1]));
}
function $538971b5b904f078$var$representJavascriptFunction(object /*, style*/ ) {
    return object.toString();
}
function $538971b5b904f078$var$isFunction(object) {
    return Object.prototype.toString.call(object) === "[object Function]";
}
var $538971b5b904f078$var$_function = new $538971b5b904f078$var$type("tag:yaml.org,2002:js/function", {
    kind: "scalar",
    resolve: $538971b5b904f078$var$resolveJavascriptFunction,
    construct: $538971b5b904f078$var$constructJavascriptFunction,
    predicate: $538971b5b904f078$var$isFunction,
    represent: $538971b5b904f078$var$representJavascriptFunction
});
var $538971b5b904f078$var$default_full = $538971b5b904f078$var$schema.DEFAULT = new $538971b5b904f078$var$schema({
    include: [
        $538971b5b904f078$var$default_safe
    ],
    explicit: [
        $538971b5b904f078$var$_undefined,
        $538971b5b904f078$var$regexp,
        $538971b5b904f078$var$_function
    ]
});
/*eslint-disable max-len,no-use-before-define*/ var $538971b5b904f078$var$_hasOwnProperty$1 = Object.prototype.hasOwnProperty;
var $538971b5b904f078$var$CONTEXT_FLOW_IN = 1;
var $538971b5b904f078$var$CONTEXT_FLOW_OUT = 2;
var $538971b5b904f078$var$CONTEXT_BLOCK_IN = 3;
var $538971b5b904f078$var$CONTEXT_BLOCK_OUT = 4;
var $538971b5b904f078$var$CHOMPING_CLIP = 1;
var $538971b5b904f078$var$CHOMPING_STRIP = 2;
var $538971b5b904f078$var$CHOMPING_KEEP = 3;
var $538971b5b904f078$var$PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var $538971b5b904f078$var$PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var $538971b5b904f078$var$PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
var $538971b5b904f078$var$PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
var $538971b5b904f078$var$PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function $538971b5b904f078$var$_class(obj) {
    return Object.prototype.toString.call(obj);
}
function $538971b5b904f078$var$is_EOL(c) {
    return c === 0x0A /* LF */  || c === 0x0D /* CR */ ;
}
function $538971b5b904f078$var$is_WHITE_SPACE(c) {
    return c === 0x09 /* Tab */  || c === 0x20 /* Space */ ;
}
function $538971b5b904f078$var$is_WS_OR_EOL(c) {
    return c === 0x09 /* Tab */  || c === 0x20 /* Space */  || c === 0x0A /* LF */  || c === 0x0D /* CR */ ;
}
function $538971b5b904f078$var$is_FLOW_INDICATOR(c) {
    return c === 0x2C /* , */  || c === 0x5B /* [ */  || c === 0x5D /* ] */  || c === 0x7B /* { */  || c === 0x7D /* } */ ;
}
function $538971b5b904f078$var$fromHexCode(c) {
    var lc;
    if (0x30 /* 0 */  <= c && c <= 0x39 /* 9 */ ) return c - 0x30;
    /*eslint-disable no-bitwise*/ lc = c | 0x20;
    if (0x61 /* a */  <= lc && lc <= 0x66 /* f */ ) return lc - 0x61 + 10;
    return -1;
}
function $538971b5b904f078$var$escapedHexLen(c) {
    if (c === 0x78 /* x */ ) return 2;
    if (c === 0x75 /* u */ ) return 4;
    if (c === 0x55 /* U */ ) return 8;
    return 0;
}
function $538971b5b904f078$var$fromDecimalCode(c) {
    if (0x30 /* 0 */  <= c && c <= 0x39 /* 9 */ ) return c - 0x30;
    return -1;
}
function $538971b5b904f078$var$simpleEscapeSequence(c) {
    /* eslint-disable indent */ return c === 0x30 /* 0 */  ? "\0" : c === 0x61 /* a */  ? "\x07" : c === 0x62 /* b */  ? "\b" : c === 0x74 /* t */  ? "	" : c === 0x09 /* Tab */  ? "	" : c === 0x6E /* n */  ? "\n" : c === 0x76 /* v */  ? "\v" : c === 0x66 /* f */  ? "\f" : c === 0x72 /* r */  ? "\r" : c === 0x65 /* e */  ? "\x1b" : c === 0x20 /* Space */  ? " " : c === 0x22 /* " */  ? '"' : c === 0x2F /* / */  ? "/" : c === 0x5C /* \ */  ? "\\" : c === 0x4E /* N */  ? "\x85" : c === 0x5F /* _ */  ? "\xa0" : c === 0x4C /* L */  ? "\u2028" : c === 0x50 /* P */  ? "\u2029" : "";
}
function $538971b5b904f078$var$charFromCodepoint(c) {
    if (c <= 0xFFFF) return String.fromCharCode(c);
    // Encode UTF-16 surrogate pair
    // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF
    return String.fromCharCode((c - 0x010000 >> 10) + 0xD800, (c - 0x010000 & 0x03FF) + 0xDC00);
}
var $538971b5b904f078$var$simpleEscapeCheck = new Array(256); // integer, for fast access
var $538971b5b904f078$var$simpleEscapeMap = new Array(256);
for(var $538971b5b904f078$var$i = 0; $538971b5b904f078$var$i < 256; $538971b5b904f078$var$i++){
    $538971b5b904f078$var$simpleEscapeCheck[$538971b5b904f078$var$i] = $538971b5b904f078$var$simpleEscapeSequence($538971b5b904f078$var$i) ? 1 : 0;
    $538971b5b904f078$var$simpleEscapeMap[$538971b5b904f078$var$i] = $538971b5b904f078$var$simpleEscapeSequence($538971b5b904f078$var$i);
}
function $538971b5b904f078$var$State$1(input, options) {
    this.input = input;
    this.filename = options["filename"] || null;
    this.schema = options["schema"] || $538971b5b904f078$var$default_full;
    this.onWarning = options["onWarning"] || null;
    this.legacy = options["legacy"] || false;
    this.json = options["json"] || false;
    this.listener = options["listener"] || null;
    this.implicitTypes = this.schema.compiledImplicit;
    this.typeMap = this.schema.compiledTypeMap;
    this.length = input.length;
    this.position = 0;
    this.line = 0;
    this.lineStart = 0;
    this.lineIndent = 0;
    this.documents = [];
/*
  this.version;
  this.checkLineBreaks;
  this.tagMap;
  this.anchorMap;
  this.tag;
  this.anchor;
  this.kind;
  this.result;*/ }
function $538971b5b904f078$var$generateError(state, message) {
    return new $538971b5b904f078$var$exception(message, new $538971b5b904f078$var$mark(state.filename, state.input, state.position, state.line, state.position - state.lineStart));
}
function $538971b5b904f078$var$throwError(state, message) {
    throw $538971b5b904f078$var$generateError(state, message);
}
function $538971b5b904f078$var$throwWarning(state, message) {
    if (state.onWarning) state.onWarning.call(null, $538971b5b904f078$var$generateError(state, message));
}
var $538971b5b904f078$var$directiveHandlers = {
    YAML: function handleYamlDirective(state, name, args) {
        var match, major, minor;
        if (state.version !== null) $538971b5b904f078$var$throwError(state, "duplication of %YAML directive");
        if (args.length !== 1) $538971b5b904f078$var$throwError(state, "YAML directive accepts exactly one argument");
        match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
        if (match === null) $538971b5b904f078$var$throwError(state, "ill-formed argument of the YAML directive");
        major = parseInt(match[1], 10);
        minor = parseInt(match[2], 10);
        if (major !== 1) $538971b5b904f078$var$throwError(state, "unacceptable YAML version of the document");
        state.version = args[0];
        state.checkLineBreaks = minor < 2;
        if (minor !== 1 && minor !== 2) $538971b5b904f078$var$throwWarning(state, "unsupported YAML version of the document");
    },
    TAG: function handleTagDirective(state, name, args) {
        var handle, prefix;
        if (args.length !== 2) $538971b5b904f078$var$throwError(state, "TAG directive accepts exactly two arguments");
        handle = args[0];
        prefix = args[1];
        if (!$538971b5b904f078$var$PATTERN_TAG_HANDLE.test(handle)) $538971b5b904f078$var$throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
        if ($538971b5b904f078$var$_hasOwnProperty$1.call(state.tagMap, handle)) $538971b5b904f078$var$throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
        if (!$538971b5b904f078$var$PATTERN_TAG_URI.test(prefix)) $538971b5b904f078$var$throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
        state.tagMap[handle] = prefix;
    }
};
function $538971b5b904f078$var$captureSegment(state, start, end, checkJson) {
    var _position, _length, _character, _result;
    if (start < end) {
        _result = state.input.slice(start, end);
        if (checkJson) for(_position = 0, _length = _result.length; _position < _length; _position += 1){
            _character = _result.charCodeAt(_position);
            if (!(_character === 0x09 || 0x20 <= _character && _character <= 0x10FFFF)) $538971b5b904f078$var$throwError(state, "expected valid JSON character");
        }
        else if ($538971b5b904f078$var$PATTERN_NON_PRINTABLE.test(_result)) $538971b5b904f078$var$throwError(state, "the stream contains non-printable characters");
        state.result += _result;
    }
}
function $538971b5b904f078$var$mergeMappings(state, destination, source, overridableKeys) {
    var sourceKeys, key, index, quantity;
    if (!$538971b5b904f078$var$common.isObject(source)) $538971b5b904f078$var$throwError(state, "cannot merge mappings; the provided source object is unacceptable");
    sourceKeys = Object.keys(source);
    for(index = 0, quantity = sourceKeys.length; index < quantity; index += 1){
        key = sourceKeys[index];
        if (!$538971b5b904f078$var$_hasOwnProperty$1.call(destination, key)) {
            destination[key] = source[key];
            overridableKeys[key] = true;
        }
    }
}
function $538971b5b904f078$var$storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {
    var index, quantity;
    // The output is a plain object here, so keys can only be strings.
    // We need to convert keyNode to a string, but doing so can hang the process
    // (deeply nested arrays that explode exponentially using aliases).
    if (Array.isArray(keyNode)) {
        keyNode = Array.prototype.slice.call(keyNode);
        for(index = 0, quantity = keyNode.length; index < quantity; index += 1){
            if (Array.isArray(keyNode[index])) $538971b5b904f078$var$throwError(state, "nested arrays are not supported inside keys");
            if (typeof keyNode === "object" && $538971b5b904f078$var$_class(keyNode[index]) === "[object Object]") keyNode[index] = "[object Object]";
        }
    }
    // Avoid code execution in load() via toString property
    // (still use its own toString for arrays, timestamps,
    // and whatever user schema extensions happen to have @@toStringTag)
    if (typeof keyNode === "object" && $538971b5b904f078$var$_class(keyNode) === "[object Object]") keyNode = "[object Object]";
    keyNode = String(keyNode);
    if (_result === null) _result = {};
    if (keyTag === "tag:yaml.org,2002:merge") {
        if (Array.isArray(valueNode)) for(index = 0, quantity = valueNode.length; index < quantity; index += 1)$538971b5b904f078$var$mergeMappings(state, _result, valueNode[index], overridableKeys);
        else $538971b5b904f078$var$mergeMappings(state, _result, valueNode, overridableKeys);
    } else {
        if (!state.json && !$538971b5b904f078$var$_hasOwnProperty$1.call(overridableKeys, keyNode) && $538971b5b904f078$var$_hasOwnProperty$1.call(_result, keyNode)) {
            state.line = startLine || state.line;
            state.position = startPos || state.position;
            $538971b5b904f078$var$throwError(state, "duplicated mapping key");
        }
        _result[keyNode] = valueNode;
        delete overridableKeys[keyNode];
    }
    return _result;
}
function $538971b5b904f078$var$readLineBreak(state) {
    var ch;
    ch = state.input.charCodeAt(state.position);
    if (ch === 0x0A /* LF */ ) state.position++;
    else if (ch === 0x0D /* CR */ ) {
        state.position++;
        if (state.input.charCodeAt(state.position) === 0x0A /* LF */ ) state.position++;
    } else $538971b5b904f078$var$throwError(state, "a line break is expected");
    state.line += 1;
    state.lineStart = state.position;
}
function $538971b5b904f078$var$skipSeparationSpace(state, allowComments, checkIndent) {
    var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
    while(ch !== 0){
        while($538971b5b904f078$var$is_WHITE_SPACE(ch))ch = state.input.charCodeAt(++state.position);
        if (allowComments && ch === 0x23 /* # */ ) do ch = state.input.charCodeAt(++state.position);
        while (ch !== 0x0A /* LF */  && ch !== 0x0D /* CR */  && ch !== 0);
        if ($538971b5b904f078$var$is_EOL(ch)) {
            $538971b5b904f078$var$readLineBreak(state);
            ch = state.input.charCodeAt(state.position);
            lineBreaks++;
            state.lineIndent = 0;
            while(ch === 0x20 /* Space */ ){
                state.lineIndent++;
                ch = state.input.charCodeAt(++state.position);
            }
        } else break;
    }
    if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) $538971b5b904f078$var$throwWarning(state, "deficient indentation");
    return lineBreaks;
}
function $538971b5b904f078$var$testDocumentSeparator(state) {
    var _position = state.position, ch;
    ch = state.input.charCodeAt(_position);
    // Condition state.position === state.lineStart is tested
    // in parent on each call, for efficiency. No needs to test here again.
    if ((ch === 0x2D /* - */  || ch === 0x2E /* . */ ) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
        _position += 3;
        ch = state.input.charCodeAt(_position);
        if (ch === 0 || $538971b5b904f078$var$is_WS_OR_EOL(ch)) return true;
    }
    return false;
}
function $538971b5b904f078$var$writeFoldedLines(state, count) {
    if (count === 1) state.result += " ";
    else if (count > 1) state.result += $538971b5b904f078$var$common.repeat("\n", count - 1);
}
function $538971b5b904f078$var$readPlainScalar(state, nodeIndent, withinFlowCollection) {
    var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
    ch = state.input.charCodeAt(state.position);
    if ($538971b5b904f078$var$is_WS_OR_EOL(ch) || $538971b5b904f078$var$is_FLOW_INDICATOR(ch) || ch === 0x23 /* # */  || ch === 0x26 /* & */  || ch === 0x2A /* * */  || ch === 0x21 /* ! */  || ch === 0x7C /* | */  || ch === 0x3E /* > */  || ch === 0x27 /* ' */  || ch === 0x22 /* " */  || ch === 0x25 /* % */  || ch === 0x40 /* @ */  || ch === 0x60 /* ` */ ) return false;
    if (ch === 0x3F /* ? */  || ch === 0x2D /* - */ ) {
        following = state.input.charCodeAt(state.position + 1);
        if ($538971b5b904f078$var$is_WS_OR_EOL(following) || withinFlowCollection && $538971b5b904f078$var$is_FLOW_INDICATOR(following)) return false;
    }
    state.kind = "scalar";
    state.result = "";
    captureStart = captureEnd = state.position;
    hasPendingContent = false;
    while(ch !== 0){
        if (ch === 0x3A /* : */ ) {
            following = state.input.charCodeAt(state.position + 1);
            if ($538971b5b904f078$var$is_WS_OR_EOL(following) || withinFlowCollection && $538971b5b904f078$var$is_FLOW_INDICATOR(following)) break;
        } else if (ch === 0x23 /* # */ ) {
            preceding = state.input.charCodeAt(state.position - 1);
            if ($538971b5b904f078$var$is_WS_OR_EOL(preceding)) break;
        } else if (state.position === state.lineStart && $538971b5b904f078$var$testDocumentSeparator(state) || withinFlowCollection && $538971b5b904f078$var$is_FLOW_INDICATOR(ch)) break;
        else if ($538971b5b904f078$var$is_EOL(ch)) {
            _line = state.line;
            _lineStart = state.lineStart;
            _lineIndent = state.lineIndent;
            $538971b5b904f078$var$skipSeparationSpace(state, false, -1);
            if (state.lineIndent >= nodeIndent) {
                hasPendingContent = true;
                ch = state.input.charCodeAt(state.position);
                continue;
            } else {
                state.position = captureEnd;
                state.line = _line;
                state.lineStart = _lineStart;
                state.lineIndent = _lineIndent;
                break;
            }
        }
        if (hasPendingContent) {
            $538971b5b904f078$var$captureSegment(state, captureStart, captureEnd, false);
            $538971b5b904f078$var$writeFoldedLines(state, state.line - _line);
            captureStart = captureEnd = state.position;
            hasPendingContent = false;
        }
        if (!$538971b5b904f078$var$is_WHITE_SPACE(ch)) captureEnd = state.position + 1;
        ch = state.input.charCodeAt(++state.position);
    }
    $538971b5b904f078$var$captureSegment(state, captureStart, captureEnd, false);
    if (state.result) return true;
    state.kind = _kind;
    state.result = _result;
    return false;
}
function $538971b5b904f078$var$readSingleQuotedScalar(state, nodeIndent) {
    var ch, captureStart, captureEnd;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 0x27 /* ' */ ) return false;
    state.kind = "scalar";
    state.result = "";
    state.position++;
    captureStart = captureEnd = state.position;
    while((ch = state.input.charCodeAt(state.position)) !== 0){
        if (ch === 0x27 /* ' */ ) {
            $538971b5b904f078$var$captureSegment(state, captureStart, state.position, true);
            ch = state.input.charCodeAt(++state.position);
            if (ch === 0x27 /* ' */ ) {
                captureStart = state.position;
                state.position++;
                captureEnd = state.position;
            } else return true;
        } else if ($538971b5b904f078$var$is_EOL(ch)) {
            $538971b5b904f078$var$captureSegment(state, captureStart, captureEnd, true);
            $538971b5b904f078$var$writeFoldedLines(state, $538971b5b904f078$var$skipSeparationSpace(state, false, nodeIndent));
            captureStart = captureEnd = state.position;
        } else if (state.position === state.lineStart && $538971b5b904f078$var$testDocumentSeparator(state)) $538971b5b904f078$var$throwError(state, "unexpected end of the document within a single quoted scalar");
        else {
            state.position++;
            captureEnd = state.position;
        }
    }
    $538971b5b904f078$var$throwError(state, "unexpected end of the stream within a single quoted scalar");
}
function $538971b5b904f078$var$readDoubleQuotedScalar(state, nodeIndent) {
    var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 0x22 /* " */ ) return false;
    state.kind = "scalar";
    state.result = "";
    state.position++;
    captureStart = captureEnd = state.position;
    while((ch = state.input.charCodeAt(state.position)) !== 0){
        if (ch === 0x22 /* " */ ) {
            $538971b5b904f078$var$captureSegment(state, captureStart, state.position, true);
            state.position++;
            return true;
        } else if (ch === 0x5C /* \ */ ) {
            $538971b5b904f078$var$captureSegment(state, captureStart, state.position, true);
            ch = state.input.charCodeAt(++state.position);
            if ($538971b5b904f078$var$is_EOL(ch)) $538971b5b904f078$var$skipSeparationSpace(state, false, nodeIndent);
            else if (ch < 256 && $538971b5b904f078$var$simpleEscapeCheck[ch]) {
                state.result += $538971b5b904f078$var$simpleEscapeMap[ch];
                state.position++;
            } else if ((tmp = $538971b5b904f078$var$escapedHexLen(ch)) > 0) {
                hexLength = tmp;
                hexResult = 0;
                for(; hexLength > 0; hexLength--){
                    ch = state.input.charCodeAt(++state.position);
                    if ((tmp = $538971b5b904f078$var$fromHexCode(ch)) >= 0) hexResult = (hexResult << 4) + tmp;
                    else $538971b5b904f078$var$throwError(state, "expected hexadecimal character");
                }
                state.result += $538971b5b904f078$var$charFromCodepoint(hexResult);
                state.position++;
            } else $538971b5b904f078$var$throwError(state, "unknown escape sequence");
            captureStart = captureEnd = state.position;
        } else if ($538971b5b904f078$var$is_EOL(ch)) {
            $538971b5b904f078$var$captureSegment(state, captureStart, captureEnd, true);
            $538971b5b904f078$var$writeFoldedLines(state, $538971b5b904f078$var$skipSeparationSpace(state, false, nodeIndent));
            captureStart = captureEnd = state.position;
        } else if (state.position === state.lineStart && $538971b5b904f078$var$testDocumentSeparator(state)) $538971b5b904f078$var$throwError(state, "unexpected end of the document within a double quoted scalar");
        else {
            state.position++;
            captureEnd = state.position;
        }
    }
    $538971b5b904f078$var$throwError(state, "unexpected end of the stream within a double quoted scalar");
}
function $538971b5b904f078$var$readFlowCollection(state, nodeIndent) {
    var readNext = true, _line, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = {}, keyNode, keyTag, valueNode, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch === 0x5B /* [ */ ) {
        terminator = 0x5D; /* ] */ 
        isMapping = false;
        _result = [];
    } else if (ch === 0x7B /* { */ ) {
        terminator = 0x7D; /* } */ 
        isMapping = true;
        _result = {};
    } else return false;
    if (state.anchor !== null) state.anchorMap[state.anchor] = _result;
    ch = state.input.charCodeAt(++state.position);
    while(ch !== 0){
        $538971b5b904f078$var$skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if (ch === terminator) {
            state.position++;
            state.tag = _tag;
            state.anchor = _anchor;
            state.kind = isMapping ? "mapping" : "sequence";
            state.result = _result;
            return true;
        } else if (!readNext) $538971b5b904f078$var$throwError(state, "missed comma between flow collection entries");
        keyTag = keyNode = valueNode = null;
        isPair = isExplicitPair = false;
        if (ch === 0x3F /* ? */ ) {
            following = state.input.charCodeAt(state.position + 1);
            if ($538971b5b904f078$var$is_WS_OR_EOL(following)) {
                isPair = isExplicitPair = true;
                state.position++;
                $538971b5b904f078$var$skipSeparationSpace(state, true, nodeIndent);
            }
        }
        _line = state.line;
        $538971b5b904f078$var$composeNode(state, nodeIndent, $538971b5b904f078$var$CONTEXT_FLOW_IN, false, true);
        keyTag = state.tag;
        keyNode = state.result;
        $538971b5b904f078$var$skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if ((isExplicitPair || state.line === _line) && ch === 0x3A /* : */ ) {
            isPair = true;
            ch = state.input.charCodeAt(++state.position);
            $538971b5b904f078$var$skipSeparationSpace(state, true, nodeIndent);
            $538971b5b904f078$var$composeNode(state, nodeIndent, $538971b5b904f078$var$CONTEXT_FLOW_IN, false, true);
            valueNode = state.result;
        }
        if (isMapping) $538971b5b904f078$var$storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);
        else if (isPair) _result.push($538971b5b904f078$var$storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode));
        else _result.push(keyNode);
        $538971b5b904f078$var$skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if (ch === 0x2C /* , */ ) {
            readNext = true;
            ch = state.input.charCodeAt(++state.position);
        } else readNext = false;
    }
    $538971b5b904f078$var$throwError(state, "unexpected end of the stream within a flow collection");
}
function $538971b5b904f078$var$readBlockScalar(state, nodeIndent) {
    var captureStart, folding, chomping = $538971b5b904f078$var$CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch === 0x7C /* | */ ) folding = false;
    else if (ch === 0x3E /* > */ ) folding = true;
    else return false;
    state.kind = "scalar";
    state.result = "";
    while(ch !== 0){
        ch = state.input.charCodeAt(++state.position);
        if (ch === 0x2B /* + */  || ch === 0x2D /* - */ ) {
            if ($538971b5b904f078$var$CHOMPING_CLIP === chomping) chomping = ch === 0x2B /* + */  ? $538971b5b904f078$var$CHOMPING_KEEP : $538971b5b904f078$var$CHOMPING_STRIP;
            else $538971b5b904f078$var$throwError(state, "repeat of a chomping mode identifier");
        } else if ((tmp = $538971b5b904f078$var$fromDecimalCode(ch)) >= 0) {
            if (tmp === 0) $538971b5b904f078$var$throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
            else if (!detectedIndent) {
                textIndent = nodeIndent + tmp - 1;
                detectedIndent = true;
            } else $538971b5b904f078$var$throwError(state, "repeat of an indentation width identifier");
        } else break;
    }
    if ($538971b5b904f078$var$is_WHITE_SPACE(ch)) {
        do ch = state.input.charCodeAt(++state.position);
        while ($538971b5b904f078$var$is_WHITE_SPACE(ch));
        if (ch === 0x23 /* # */ ) do ch = state.input.charCodeAt(++state.position);
        while (!$538971b5b904f078$var$is_EOL(ch) && ch !== 0);
    }
    while(ch !== 0){
        $538971b5b904f078$var$readLineBreak(state);
        state.lineIndent = 0;
        ch = state.input.charCodeAt(state.position);
        while((!detectedIndent || state.lineIndent < textIndent) && ch === 0x20 /* Space */ ){
            state.lineIndent++;
            ch = state.input.charCodeAt(++state.position);
        }
        if (!detectedIndent && state.lineIndent > textIndent) textIndent = state.lineIndent;
        if ($538971b5b904f078$var$is_EOL(ch)) {
            emptyLines++;
            continue;
        }
        // End of the scalar.
        if (state.lineIndent < textIndent) {
            // Perform the chomping.
            if (chomping === $538971b5b904f078$var$CHOMPING_KEEP) state.result += $538971b5b904f078$var$common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
            else if (chomping === $538971b5b904f078$var$CHOMPING_CLIP) {
                if (didReadContent) state.result += "\n";
            }
            break;
        }
        // Folded style: use fancy rules to handle line breaks.
        if (folding) {
            // Lines starting with white space characters (more-indented lines) are not folded.
            if ($538971b5b904f078$var$is_WHITE_SPACE(ch)) {
                atMoreIndented = true;
                // except for the first content line (cf. Example 8.1)
                state.result += $538971b5b904f078$var$common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
            // End of more-indented block.
            } else if (atMoreIndented) {
                atMoreIndented = false;
                state.result += $538971b5b904f078$var$common.repeat("\n", emptyLines + 1);
            // Just one line break - perceive as the same line.
            } else if (emptyLines === 0) {
                if (didReadContent) state.result += " ";
            } else state.result += $538971b5b904f078$var$common.repeat("\n", emptyLines);
        // Literal style: just add exact number of line breaks between content lines.
        } else // Keep all line breaks except the header line break.
        state.result += $538971b5b904f078$var$common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
        didReadContent = true;
        detectedIndent = true;
        emptyLines = 0;
        captureStart = state.position;
        while(!$538971b5b904f078$var$is_EOL(ch) && ch !== 0)ch = state.input.charCodeAt(++state.position);
        $538971b5b904f078$var$captureSegment(state, captureStart, state.position, false);
    }
    return true;
}
function $538971b5b904f078$var$readBlockSequence(state, nodeIndent) {
    var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
    if (state.anchor !== null) state.anchorMap[state.anchor] = _result;
    ch = state.input.charCodeAt(state.position);
    while(ch !== 0){
        if (ch !== 0x2D /* - */ ) break;
        following = state.input.charCodeAt(state.position + 1);
        if (!$538971b5b904f078$var$is_WS_OR_EOL(following)) break;
        detected = true;
        state.position++;
        if ($538971b5b904f078$var$skipSeparationSpace(state, true, -1)) {
            if (state.lineIndent <= nodeIndent) {
                _result.push(null);
                ch = state.input.charCodeAt(state.position);
                continue;
            }
        }
        _line = state.line;
        $538971b5b904f078$var$composeNode(state, nodeIndent, $538971b5b904f078$var$CONTEXT_BLOCK_IN, false, true);
        _result.push(state.result);
        $538971b5b904f078$var$skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
        if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) $538971b5b904f078$var$throwError(state, "bad indentation of a sequence entry");
        else if (state.lineIndent < nodeIndent) break;
    }
    if (detected) {
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = "sequence";
        state.result = _result;
        return true;
    }
    return false;
}
function $538971b5b904f078$var$readBlockMapping(state, nodeIndent, flowIndent) {
    var following, allowCompact, _line, _pos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = {}, keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
    if (state.anchor !== null) state.anchorMap[state.anchor] = _result;
    ch = state.input.charCodeAt(state.position);
    while(ch !== 0){
        following = state.input.charCodeAt(state.position + 1);
        _line = state.line; // Save the current line.
        _pos = state.position;
        //
        // Explicit notation case. There are two separate blocks:
        // first for the key (denoted by "?") and second for the value (denoted by ":")
        //
        if ((ch === 0x3F /* ? */  || ch === 0x3A /* : */ ) && $538971b5b904f078$var$is_WS_OR_EOL(following)) {
            if (ch === 0x3F /* ? */ ) {
                if (atExplicitKey) {
                    $538971b5b904f078$var$storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
                    keyTag = keyNode = valueNode = null;
                }
                detected = true;
                atExplicitKey = true;
                allowCompact = true;
            } else if (atExplicitKey) {
                // i.e. 0x3A/* : */ === character after the explicit key.
                atExplicitKey = false;
                allowCompact = true;
            } else $538971b5b904f078$var$throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
            state.position += 1;
            ch = following;
        //
        // Implicit notation case. Flow-style node as the key first, then ":", and the value.
        //
        } else if ($538971b5b904f078$var$composeNode(state, flowIndent, $538971b5b904f078$var$CONTEXT_FLOW_OUT, false, true)) {
            if (state.line === _line) {
                ch = state.input.charCodeAt(state.position);
                while($538971b5b904f078$var$is_WHITE_SPACE(ch))ch = state.input.charCodeAt(++state.position);
                if (ch === 0x3A /* : */ ) {
                    ch = state.input.charCodeAt(++state.position);
                    if (!$538971b5b904f078$var$is_WS_OR_EOL(ch)) $538971b5b904f078$var$throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
                    if (atExplicitKey) {
                        $538971b5b904f078$var$storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
                        keyTag = keyNode = valueNode = null;
                    }
                    detected = true;
                    atExplicitKey = false;
                    allowCompact = false;
                    keyTag = state.tag;
                    keyNode = state.result;
                } else if (detected) $538971b5b904f078$var$throwError(state, "can not read an implicit mapping pair; a colon is missed");
                else {
                    state.tag = _tag;
                    state.anchor = _anchor;
                    return true; // Keep the result of `composeNode`.
                }
            } else if (detected) $538971b5b904f078$var$throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
            else {
                state.tag = _tag;
                state.anchor = _anchor;
                return true; // Keep the result of `composeNode`.
            }
        } else break; // Reading is done. Go to the epilogue.
        //
        // Common reading code for both explicit and implicit notations.
        //
        if (state.line === _line || state.lineIndent > nodeIndent) {
            if ($538971b5b904f078$var$composeNode(state, nodeIndent, $538971b5b904f078$var$CONTEXT_BLOCK_OUT, true, allowCompact)) {
                if (atExplicitKey) keyNode = state.result;
                else valueNode = state.result;
            }
            if (!atExplicitKey) {
                $538971b5b904f078$var$storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos);
                keyTag = keyNode = valueNode = null;
            }
            $538971b5b904f078$var$skipSeparationSpace(state, true, -1);
            ch = state.input.charCodeAt(state.position);
        }
        if (state.lineIndent > nodeIndent && ch !== 0) $538971b5b904f078$var$throwError(state, "bad indentation of a mapping entry");
        else if (state.lineIndent < nodeIndent) break;
    }
    //
    // Epilogue.
    //
    // Special case: last mapping's node contains only the key in explicit notation.
    if (atExplicitKey) $538971b5b904f078$var$storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
    // Expose the resulting mapping.
    if (detected) {
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = "mapping";
        state.result = _result;
    }
    return detected;
}
function $538971b5b904f078$var$readTagProperty(state) {
    var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 0x21 /* ! */ ) return false;
    if (state.tag !== null) $538971b5b904f078$var$throwError(state, "duplication of a tag property");
    ch = state.input.charCodeAt(++state.position);
    if (ch === 0x3C /* < */ ) {
        isVerbatim = true;
        ch = state.input.charCodeAt(++state.position);
    } else if (ch === 0x21 /* ! */ ) {
        isNamed = true;
        tagHandle = "!!";
        ch = state.input.charCodeAt(++state.position);
    } else tagHandle = "!";
    _position = state.position;
    if (isVerbatim) {
        do ch = state.input.charCodeAt(++state.position);
        while (ch !== 0 && ch !== 0x3E /* > */ );
        if (state.position < state.length) {
            tagName = state.input.slice(_position, state.position);
            ch = state.input.charCodeAt(++state.position);
        } else $538971b5b904f078$var$throwError(state, "unexpected end of the stream within a verbatim tag");
    } else {
        while(ch !== 0 && !$538971b5b904f078$var$is_WS_OR_EOL(ch)){
            if (ch === 0x21 /* ! */ ) {
                if (!isNamed) {
                    tagHandle = state.input.slice(_position - 1, state.position + 1);
                    if (!$538971b5b904f078$var$PATTERN_TAG_HANDLE.test(tagHandle)) $538971b5b904f078$var$throwError(state, "named tag handle cannot contain such characters");
                    isNamed = true;
                    _position = state.position + 1;
                } else $538971b5b904f078$var$throwError(state, "tag suffix cannot contain exclamation marks");
            }
            ch = state.input.charCodeAt(++state.position);
        }
        tagName = state.input.slice(_position, state.position);
        if ($538971b5b904f078$var$PATTERN_FLOW_INDICATORS.test(tagName)) $538971b5b904f078$var$throwError(state, "tag suffix cannot contain flow indicator characters");
    }
    if (tagName && !$538971b5b904f078$var$PATTERN_TAG_URI.test(tagName)) $538971b5b904f078$var$throwError(state, "tag name cannot contain such characters: " + tagName);
    if (isVerbatim) state.tag = tagName;
    else if ($538971b5b904f078$var$_hasOwnProperty$1.call(state.tagMap, tagHandle)) state.tag = state.tagMap[tagHandle] + tagName;
    else if (tagHandle === "!") state.tag = "!" + tagName;
    else if (tagHandle === "!!") state.tag = "tag:yaml.org,2002:" + tagName;
    else $538971b5b904f078$var$throwError(state, 'undeclared tag handle "' + tagHandle + '"');
    return true;
}
function $538971b5b904f078$var$readAnchorProperty(state) {
    var _position, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 0x26 /* & */ ) return false;
    if (state.anchor !== null) $538971b5b904f078$var$throwError(state, "duplication of an anchor property");
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;
    while(ch !== 0 && !$538971b5b904f078$var$is_WS_OR_EOL(ch) && !$538971b5b904f078$var$is_FLOW_INDICATOR(ch))ch = state.input.charCodeAt(++state.position);
    if (state.position === _position) $538971b5b904f078$var$throwError(state, "name of an anchor node must contain at least one character");
    state.anchor = state.input.slice(_position, state.position);
    return true;
}
function $538971b5b904f078$var$readAlias(state) {
    var _position, alias, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 0x2A /* * */ ) return false;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;
    while(ch !== 0 && !$538971b5b904f078$var$is_WS_OR_EOL(ch) && !$538971b5b904f078$var$is_FLOW_INDICATOR(ch))ch = state.input.charCodeAt(++state.position);
    if (state.position === _position) $538971b5b904f078$var$throwError(state, "name of an alias node must contain at least one character");
    alias = state.input.slice(_position, state.position);
    if (!state.anchorMap.hasOwnProperty(alias)) $538971b5b904f078$var$throwError(state, 'unidentified alias "' + alias + '"');
    state.result = state.anchorMap[alias];
    $538971b5b904f078$var$skipSeparationSpace(state, true, -1);
    return true;
}
function $538971b5b904f078$var$composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
    var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, type, flowIndent, blockIndent;
    if (state.listener !== null) state.listener("open", state);
    state.tag = null;
    state.anchor = null;
    state.kind = null;
    state.result = null;
    allowBlockStyles = allowBlockScalars = allowBlockCollections = $538971b5b904f078$var$CONTEXT_BLOCK_OUT === nodeContext || $538971b5b904f078$var$CONTEXT_BLOCK_IN === nodeContext;
    if (allowToSeek) {
        if ($538971b5b904f078$var$skipSeparationSpace(state, true, -1)) {
            atNewLine = true;
            if (state.lineIndent > parentIndent) indentStatus = 1;
            else if (state.lineIndent === parentIndent) indentStatus = 0;
            else if (state.lineIndent < parentIndent) indentStatus = -1;
        }
    }
    if (indentStatus === 1) {
        while($538971b5b904f078$var$readTagProperty(state) || $538971b5b904f078$var$readAnchorProperty(state))if ($538971b5b904f078$var$skipSeparationSpace(state, true, -1)) {
            atNewLine = true;
            allowBlockCollections = allowBlockStyles;
            if (state.lineIndent > parentIndent) indentStatus = 1;
            else if (state.lineIndent === parentIndent) indentStatus = 0;
            else if (state.lineIndent < parentIndent) indentStatus = -1;
        } else allowBlockCollections = false;
    }
    if (allowBlockCollections) allowBlockCollections = atNewLine || allowCompact;
    if (indentStatus === 1 || $538971b5b904f078$var$CONTEXT_BLOCK_OUT === nodeContext) {
        if ($538971b5b904f078$var$CONTEXT_FLOW_IN === nodeContext || $538971b5b904f078$var$CONTEXT_FLOW_OUT === nodeContext) flowIndent = parentIndent;
        else flowIndent = parentIndent + 1;
        blockIndent = state.position - state.lineStart;
        if (indentStatus === 1) {
            if (allowBlockCollections && ($538971b5b904f078$var$readBlockSequence(state, blockIndent) || $538971b5b904f078$var$readBlockMapping(state, blockIndent, flowIndent)) || $538971b5b904f078$var$readFlowCollection(state, flowIndent)) hasContent = true;
            else {
                if (allowBlockScalars && $538971b5b904f078$var$readBlockScalar(state, flowIndent) || $538971b5b904f078$var$readSingleQuotedScalar(state, flowIndent) || $538971b5b904f078$var$readDoubleQuotedScalar(state, flowIndent)) hasContent = true;
                else if ($538971b5b904f078$var$readAlias(state)) {
                    hasContent = true;
                    if (state.tag !== null || state.anchor !== null) $538971b5b904f078$var$throwError(state, "alias node should not have any properties");
                } else if ($538971b5b904f078$var$readPlainScalar(state, flowIndent, $538971b5b904f078$var$CONTEXT_FLOW_IN === nodeContext)) {
                    hasContent = true;
                    if (state.tag === null) state.tag = "?";
                }
                if (state.anchor !== null) state.anchorMap[state.anchor] = state.result;
            }
        } else if (indentStatus === 0) // Special case: block sequences are allowed to have same indentation level as the parent.
        // http://www.yaml.org/spec/1.2/spec.html#id2799784
        hasContent = allowBlockCollections && $538971b5b904f078$var$readBlockSequence(state, blockIndent);
    }
    if (state.tag !== null && state.tag !== "!") {
        if (state.tag === "?") {
            // Implicit resolving is not allowed for non-scalar types, and '?'
            // non-specific tag is only automatically assigned to plain scalars.
            //
            // We only need to check kind conformity in case user explicitly assigns '?'
            // tag, for example like this: "!<?> [0]"
            //
            if (state.result !== null && state.kind !== "scalar") $538971b5b904f078$var$throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
            for(typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1){
                type = state.implicitTypes[typeIndex];
                if (type.resolve(state.result)) {
                    state.result = type.construct(state.result);
                    state.tag = type.tag;
                    if (state.anchor !== null) state.anchorMap[state.anchor] = state.result;
                    break;
                }
            }
        } else if ($538971b5b904f078$var$_hasOwnProperty$1.call(state.typeMap[state.kind || "fallback"], state.tag)) {
            type = state.typeMap[state.kind || "fallback"][state.tag];
            if (state.result !== null && type.kind !== state.kind) $538971b5b904f078$var$throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
            if (!type.resolve(state.result)) $538971b5b904f078$var$throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
            else {
                state.result = type.construct(state.result);
                if (state.anchor !== null) state.anchorMap[state.anchor] = state.result;
            }
        } else $538971b5b904f078$var$throwError(state, "unknown tag !<" + state.tag + ">");
    }
    if (state.listener !== null) state.listener("close", state);
    return state.tag !== null || state.anchor !== null || hasContent;
}
function $538971b5b904f078$var$readDocument(state) {
    var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
    state.version = null;
    state.checkLineBreaks = state.legacy;
    state.tagMap = {};
    state.anchorMap = {};
    while((ch = state.input.charCodeAt(state.position)) !== 0){
        $538971b5b904f078$var$skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
        if (state.lineIndent > 0 || ch !== 0x25 /* % */ ) break;
        hasDirectives = true;
        ch = state.input.charCodeAt(++state.position);
        _position = state.position;
        while(ch !== 0 && !$538971b5b904f078$var$is_WS_OR_EOL(ch))ch = state.input.charCodeAt(++state.position);
        directiveName = state.input.slice(_position, state.position);
        directiveArgs = [];
        if (directiveName.length < 1) $538971b5b904f078$var$throwError(state, "directive name must not be less than one character in length");
        while(ch !== 0){
            while($538971b5b904f078$var$is_WHITE_SPACE(ch))ch = state.input.charCodeAt(++state.position);
            if (ch === 0x23 /* # */ ) {
                do ch = state.input.charCodeAt(++state.position);
                while (ch !== 0 && !$538971b5b904f078$var$is_EOL(ch));
                break;
            }
            if ($538971b5b904f078$var$is_EOL(ch)) break;
            _position = state.position;
            while(ch !== 0 && !$538971b5b904f078$var$is_WS_OR_EOL(ch))ch = state.input.charCodeAt(++state.position);
            directiveArgs.push(state.input.slice(_position, state.position));
        }
        if (ch !== 0) $538971b5b904f078$var$readLineBreak(state);
        if ($538971b5b904f078$var$_hasOwnProperty$1.call($538971b5b904f078$var$directiveHandlers, directiveName)) $538971b5b904f078$var$directiveHandlers[directiveName](state, directiveName, directiveArgs);
        else $538971b5b904f078$var$throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
    $538971b5b904f078$var$skipSeparationSpace(state, true, -1);
    if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 0x2D /* - */  && state.input.charCodeAt(state.position + 1) === 0x2D /* - */  && state.input.charCodeAt(state.position + 2) === 0x2D /* - */ ) {
        state.position += 3;
        $538971b5b904f078$var$skipSeparationSpace(state, true, -1);
    } else if (hasDirectives) $538971b5b904f078$var$throwError(state, "directives end mark is expected");
    $538971b5b904f078$var$composeNode(state, state.lineIndent - 1, $538971b5b904f078$var$CONTEXT_BLOCK_OUT, false, true);
    $538971b5b904f078$var$skipSeparationSpace(state, true, -1);
    if (state.checkLineBreaks && $538971b5b904f078$var$PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) $538971b5b904f078$var$throwWarning(state, "non-ASCII line breaks are interpreted as content");
    state.documents.push(state.result);
    if (state.position === state.lineStart && $538971b5b904f078$var$testDocumentSeparator(state)) {
        if (state.input.charCodeAt(state.position) === 0x2E /* . */ ) {
            state.position += 3;
            $538971b5b904f078$var$skipSeparationSpace(state, true, -1);
        }
        return;
    }
    if (state.position < state.length - 1) $538971b5b904f078$var$throwError(state, "end of the stream or a document separator is expected");
    else return;
}
function $538971b5b904f078$var$loadDocuments(input, options) {
    input = String(input);
    options = options || {};
    if (input.length !== 0) {
        // Add tailing `\n` if not exists
        if (input.charCodeAt(input.length - 1) !== 0x0A /* LF */  && input.charCodeAt(input.length - 1) !== 0x0D /* CR */ ) input += "\n";
        // Strip BOM
        if (input.charCodeAt(0) === 0xFEFF) input = input.slice(1);
    }
    var state = new $538971b5b904f078$var$State$1(input, options);
    var nullpos = input.indexOf("\0");
    if (nullpos !== -1) {
        state.position = nullpos;
        $538971b5b904f078$var$throwError(state, "null byte is not allowed in input");
    }
    // Use 0 as string terminator. That significantly simplifies bounds check.
    state.input += "\0";
    while(state.input.charCodeAt(state.position) === 0x20 /* Space */ ){
        state.lineIndent += 1;
        state.position += 1;
    }
    while(state.position < state.length - 1)$538971b5b904f078$var$readDocument(state);
    return state.documents;
}
function $538971b5b904f078$var$loadAll$1(input, iterator, options) {
    if (iterator !== null && typeof iterator === "object" && typeof options === "undefined") {
        options = iterator;
        iterator = null;
    }
    var documents = $538971b5b904f078$var$loadDocuments(input, options);
    if (typeof iterator !== "function") return documents;
    for(var index = 0, length = documents.length; index < length; index += 1)iterator(documents[index]);
}
function $538971b5b904f078$var$load$1(input, options) {
    var documents = $538971b5b904f078$var$loadDocuments(input, options);
    if (documents.length === 0) /*eslint-disable no-undefined*/ return undefined;
    else if (documents.length === 1) return documents[0];
    throw new $538971b5b904f078$var$exception("expected a single document in the stream, but found more");
}
function $538971b5b904f078$var$safeLoadAll$1(input, iterator, options) {
    if (typeof iterator === "object" && iterator !== null && typeof options === "undefined") {
        options = iterator;
        iterator = null;
    }
    return $538971b5b904f078$var$loadAll$1(input, iterator, $538971b5b904f078$var$common.extend({
        schema: $538971b5b904f078$var$default_safe
    }, options));
}
function $538971b5b904f078$var$safeLoad$1(input, options) {
    return $538971b5b904f078$var$load$1(input, $538971b5b904f078$var$common.extend({
        schema: $538971b5b904f078$var$default_safe
    }, options));
}
var $538971b5b904f078$var$loadAll_1 = $538971b5b904f078$var$loadAll$1;
var $538971b5b904f078$var$load_1 = $538971b5b904f078$var$load$1;
var $538971b5b904f078$var$safeLoadAll_1 = $538971b5b904f078$var$safeLoadAll$1;
var $538971b5b904f078$var$safeLoad_1 = $538971b5b904f078$var$safeLoad$1;
var $538971b5b904f078$var$loader = {
    loadAll: $538971b5b904f078$var$loadAll_1,
    load: $538971b5b904f078$var$load_1,
    safeLoadAll: $538971b5b904f078$var$safeLoadAll_1,
    safeLoad: $538971b5b904f078$var$safeLoad_1
};
/*eslint-disable no-use-before-define*/ var $538971b5b904f078$var$_toString = Object.prototype.toString;
var $538971b5b904f078$var$_hasOwnProperty = Object.prototype.hasOwnProperty;
var $538971b5b904f078$var$CHAR_TAB = 0x09; /* Tab */ 
var $538971b5b904f078$var$CHAR_LINE_FEED = 0x0A; /* LF */ 
var $538971b5b904f078$var$CHAR_CARRIAGE_RETURN = 0x0D; /* CR */ 
var $538971b5b904f078$var$CHAR_SPACE = 0x20; /* Space */ 
var $538971b5b904f078$var$CHAR_EXCLAMATION = 0x21; /* ! */ 
var $538971b5b904f078$var$CHAR_DOUBLE_QUOTE = 0x22; /* " */ 
var $538971b5b904f078$var$CHAR_SHARP = 0x23; /* # */ 
var $538971b5b904f078$var$CHAR_PERCENT = 0x25; /* % */ 
var $538971b5b904f078$var$CHAR_AMPERSAND = 0x26; /* & */ 
var $538971b5b904f078$var$CHAR_SINGLE_QUOTE = 0x27; /* ' */ 
var $538971b5b904f078$var$CHAR_ASTERISK = 0x2A; /* * */ 
var $538971b5b904f078$var$CHAR_COMMA = 0x2C; /* , */ 
var $538971b5b904f078$var$CHAR_MINUS = 0x2D; /* - */ 
var $538971b5b904f078$var$CHAR_COLON = 0x3A; /* : */ 
var $538971b5b904f078$var$CHAR_EQUALS = 0x3D; /* = */ 
var $538971b5b904f078$var$CHAR_GREATER_THAN = 0x3E; /* > */ 
var $538971b5b904f078$var$CHAR_QUESTION = 0x3F; /* ? */ 
var $538971b5b904f078$var$CHAR_COMMERCIAL_AT = 0x40; /* @ */ 
var $538971b5b904f078$var$CHAR_LEFT_SQUARE_BRACKET = 0x5B; /* [ */ 
var $538971b5b904f078$var$CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */ 
var $538971b5b904f078$var$CHAR_GRAVE_ACCENT = 0x60; /* ` */ 
var $538971b5b904f078$var$CHAR_LEFT_CURLY_BRACKET = 0x7B; /* { */ 
var $538971b5b904f078$var$CHAR_VERTICAL_LINE = 0x7C; /* | */ 
var $538971b5b904f078$var$CHAR_RIGHT_CURLY_BRACKET = 0x7D; /* } */ 
var $538971b5b904f078$var$ESCAPE_SEQUENCES = {};
$538971b5b904f078$var$ESCAPE_SEQUENCES[0x00] = "\\0";
$538971b5b904f078$var$ESCAPE_SEQUENCES[0x07] = "\\a";
$538971b5b904f078$var$ESCAPE_SEQUENCES[0x08] = "\\b";
$538971b5b904f078$var$ESCAPE_SEQUENCES[0x09] = "\\t";
$538971b5b904f078$var$ESCAPE_SEQUENCES[0x0A] = "\\n";
$538971b5b904f078$var$ESCAPE_SEQUENCES[0x0B] = "\\v";
$538971b5b904f078$var$ESCAPE_SEQUENCES[0x0C] = "\\f";
$538971b5b904f078$var$ESCAPE_SEQUENCES[0x0D] = "\\r";
$538971b5b904f078$var$ESCAPE_SEQUENCES[0x1B] = "\\e";
$538971b5b904f078$var$ESCAPE_SEQUENCES[0x22] = '\\"';
$538971b5b904f078$var$ESCAPE_SEQUENCES[0x5C] = "\\\\";
$538971b5b904f078$var$ESCAPE_SEQUENCES[0x85] = "\\N";
$538971b5b904f078$var$ESCAPE_SEQUENCES[0xA0] = "\\_";
$538971b5b904f078$var$ESCAPE_SEQUENCES[0x2028] = "\\L";
$538971b5b904f078$var$ESCAPE_SEQUENCES[0x2029] = "\\P";
var $538971b5b904f078$var$DEPRECATED_BOOLEANS_SYNTAX = [
    "y",
    "Y",
    "yes",
    "Yes",
    "YES",
    "on",
    "On",
    "ON",
    "n",
    "N",
    "no",
    "No",
    "NO",
    "off",
    "Off",
    "OFF"
];
function $538971b5b904f078$var$compileStyleMap(schema, map) {
    var result, keys, index, length, tag, style, type;
    if (map === null) return {};
    result = {};
    keys = Object.keys(map);
    for(index = 0, length = keys.length; index < length; index += 1){
        tag = keys[index];
        style = String(map[tag]);
        if (tag.slice(0, 2) === "!!") tag = "tag:yaml.org,2002:" + tag.slice(2);
        type = schema.compiledTypeMap["fallback"][tag];
        if (type && $538971b5b904f078$var$_hasOwnProperty.call(type.styleAliases, style)) style = type.styleAliases[style];
        result[tag] = style;
    }
    return result;
}
function $538971b5b904f078$var$encodeHex(character) {
    var string, handle, length;
    string = character.toString(16).toUpperCase();
    if (character <= 0xFF) {
        handle = "x";
        length = 2;
    } else if (character <= 0xFFFF) {
        handle = "u";
        length = 4;
    } else if (character <= 0xFFFFFFFF) {
        handle = "U";
        length = 8;
    } else throw new $538971b5b904f078$var$exception("code point within a string may not be greater than 0xFFFFFFFF");
    return "\\" + handle + $538971b5b904f078$var$common.repeat("0", length - string.length) + string;
}
function $538971b5b904f078$var$State(options) {
    this.schema = options["schema"] || $538971b5b904f078$var$default_full;
    this.indent = Math.max(1, options["indent"] || 2);
    this.noArrayIndent = options["noArrayIndent"] || false;
    this.skipInvalid = options["skipInvalid"] || false;
    this.flowLevel = $538971b5b904f078$var$common.isNothing(options["flowLevel"]) ? -1 : options["flowLevel"];
    this.styleMap = $538971b5b904f078$var$compileStyleMap(this.schema, options["styles"] || null);
    this.sortKeys = options["sortKeys"] || false;
    this.lineWidth = options["lineWidth"] || 80;
    this.noRefs = options["noRefs"] || false;
    this.noCompatMode = options["noCompatMode"] || false;
    this.condenseFlow = options["condenseFlow"] || false;
    this.implicitTypes = this.schema.compiledImplicit;
    this.explicitTypes = this.schema.compiledExplicit;
    this.tag = null;
    this.result = "";
    this.duplicates = [];
    this.usedDuplicates = null;
}
// Indents every line in a string. Empty lines (\n only) are not indented.
function $538971b5b904f078$var$indentString(string, spaces) {
    var ind = $538971b5b904f078$var$common.repeat(" ", spaces), position = 0, next = -1, result = "", line, length = string.length;
    while(position < length){
        next = string.indexOf("\n", position);
        if (next === -1) {
            line = string.slice(position);
            position = length;
        } else {
            line = string.slice(position, next + 1);
            position = next + 1;
        }
        if (line.length && line !== "\n") result += ind;
        result += line;
    }
    return result;
}
function $538971b5b904f078$var$generateNextLine(state, level) {
    return "\n" + $538971b5b904f078$var$common.repeat(" ", state.indent * level);
}
function $538971b5b904f078$var$testImplicitResolving(state, str) {
    var index, length, type;
    for(index = 0, length = state.implicitTypes.length; index < length; index += 1){
        type = state.implicitTypes[index];
        if (type.resolve(str)) return true;
    }
    return false;
}
// [33] s-white ::= s-space | s-tab
function $538971b5b904f078$var$isWhitespace(c) {
    return c === $538971b5b904f078$var$CHAR_SPACE || c === $538971b5b904f078$var$CHAR_TAB;
}
// Returns true if the character can be printed without escaping.
// From YAML 1.2: "any allowed characters known to be non-printable
// should also be escaped. [However,] This isn’t mandatory"
// Derived from nb-char - \t - #x85 - #xA0 - #x2028 - #x2029.
function $538971b5b904f078$var$isPrintable(c) {
    return 0x00020 <= c && c <= 0x00007E || 0x000A1 <= c && c <= 0x00D7FF && c !== 0x2028 && c !== 0x2029 || 0x0E000 <= c && c <= 0x00FFFD && c !== 0xFEFF /* BOM */  || 0x10000 <= c && c <= 0x10FFFF;
}
// [34] ns-char ::= nb-char - s-white
// [27] nb-char ::= c-printable - b-char - c-byte-order-mark
// [26] b-char  ::= b-line-feed | b-carriage-return
// [24] b-line-feed       ::=     #xA    /* LF */
// [25] b-carriage-return ::=     #xD    /* CR */
// [3]  c-byte-order-mark ::=     #xFEFF
function $538971b5b904f078$var$isNsChar(c) {
    return $538971b5b904f078$var$isPrintable(c) && !$538971b5b904f078$var$isWhitespace(c) && c !== 0xFEFF && c !== $538971b5b904f078$var$CHAR_CARRIAGE_RETURN && c !== $538971b5b904f078$var$CHAR_LINE_FEED;
}
// Simplified test for values allowed after the first character in plain style.
function $538971b5b904f078$var$isPlainSafe(c, prev) {
    // Uses a subset of nb-char - c-flow-indicator - ":" - "#"
    // where nb-char ::= c-printable - b-char - c-byte-order-mark.
    return $538971b5b904f078$var$isPrintable(c) && c !== 0xFEFF && c !== $538971b5b904f078$var$CHAR_COMMA && c !== $538971b5b904f078$var$CHAR_LEFT_SQUARE_BRACKET && c !== $538971b5b904f078$var$CHAR_RIGHT_SQUARE_BRACKET && c !== $538971b5b904f078$var$CHAR_LEFT_CURLY_BRACKET && c !== $538971b5b904f078$var$CHAR_RIGHT_CURLY_BRACKET && c !== $538971b5b904f078$var$CHAR_COLON && (c !== $538971b5b904f078$var$CHAR_SHARP || prev && $538971b5b904f078$var$isNsChar(prev));
}
// Simplified test for values allowed as the first character in plain style.
function $538971b5b904f078$var$isPlainSafeFirst(c) {
    // Uses a subset of ns-char - c-indicator
    // where ns-char = nb-char - s-white.
    return $538971b5b904f078$var$isPrintable(c) && c !== 0xFEFF && !$538971b5b904f078$var$isWhitespace(c) // - s-white
     && c !== $538971b5b904f078$var$CHAR_MINUS && c !== $538971b5b904f078$var$CHAR_QUESTION && c !== $538971b5b904f078$var$CHAR_COLON && c !== $538971b5b904f078$var$CHAR_COMMA && c !== $538971b5b904f078$var$CHAR_LEFT_SQUARE_BRACKET && c !== $538971b5b904f078$var$CHAR_RIGHT_SQUARE_BRACKET && c !== $538971b5b904f078$var$CHAR_LEFT_CURLY_BRACKET && c !== $538971b5b904f078$var$CHAR_RIGHT_CURLY_BRACKET && c !== $538971b5b904f078$var$CHAR_SHARP && c !== $538971b5b904f078$var$CHAR_AMPERSAND && c !== $538971b5b904f078$var$CHAR_ASTERISK && c !== $538971b5b904f078$var$CHAR_EXCLAMATION && c !== $538971b5b904f078$var$CHAR_VERTICAL_LINE && c !== $538971b5b904f078$var$CHAR_EQUALS && c !== $538971b5b904f078$var$CHAR_GREATER_THAN && c !== $538971b5b904f078$var$CHAR_SINGLE_QUOTE && c !== $538971b5b904f078$var$CHAR_DOUBLE_QUOTE && c !== $538971b5b904f078$var$CHAR_PERCENT && c !== $538971b5b904f078$var$CHAR_COMMERCIAL_AT && c !== $538971b5b904f078$var$CHAR_GRAVE_ACCENT;
}
// Determines whether block indentation indicator is required.
function $538971b5b904f078$var$needIndentIndicator(string) {
    var leadingSpaceRe = /^\n* /;
    return leadingSpaceRe.test(string);
}
var $538971b5b904f078$var$STYLE_PLAIN = 1, $538971b5b904f078$var$STYLE_SINGLE = 2, $538971b5b904f078$var$STYLE_LITERAL = 3, $538971b5b904f078$var$STYLE_FOLDED = 4, $538971b5b904f078$var$STYLE_DOUBLE = 5;
// Determines which scalar styles are possible and returns the preferred style.
// lineWidth = -1 => no limit.
// Pre-conditions: str.length > 0.
// Post-conditions:
//    STYLE_PLAIN or STYLE_SINGLE => no \n are in the string.
//    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).
//    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).
function $538971b5b904f078$var$chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {
    var i;
    var char, prev_char;
    var hasLineBreak = false;
    var hasFoldableLine = false; // only checked if shouldTrackWidth
    var shouldTrackWidth = lineWidth !== -1;
    var previousLineBreak = -1; // count the first line correctly
    var plain = $538971b5b904f078$var$isPlainSafeFirst(string.charCodeAt(0)) && !$538971b5b904f078$var$isWhitespace(string.charCodeAt(string.length - 1));
    if (singleLineOnly) // Case: no block styles.
    // Check for disallowed characters to rule out plain and single.
    for(i = 0; i < string.length; i++){
        char = string.charCodeAt(i);
        if (!$538971b5b904f078$var$isPrintable(char)) return $538971b5b904f078$var$STYLE_DOUBLE;
        prev_char = i > 0 ? string.charCodeAt(i - 1) : null;
        plain = plain && $538971b5b904f078$var$isPlainSafe(char, prev_char);
    }
    else {
        // Case: block styles permitted.
        for(i = 0; i < string.length; i++){
            char = string.charCodeAt(i);
            if (char === $538971b5b904f078$var$CHAR_LINE_FEED) {
                hasLineBreak = true;
                // Check if any line can be folded.
                if (shouldTrackWidth) {
                    hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
                    i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
                    previousLineBreak = i;
                }
            } else if (!$538971b5b904f078$var$isPrintable(char)) return $538971b5b904f078$var$STYLE_DOUBLE;
            prev_char = i > 0 ? string.charCodeAt(i - 1) : null;
            plain = plain && $538971b5b904f078$var$isPlainSafe(char, prev_char);
        }
        // in case the end is missing a \n
        hasFoldableLine = hasFoldableLine || shouldTrackWidth && i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
    }
    // Although every style can represent \n without escaping, prefer block styles
    // for multiline, since they're more readable and they don't add empty lines.
    // Also prefer folding a super-long line.
    if (!hasLineBreak && !hasFoldableLine) // Strings interpretable as another type have to be quoted;
    // e.g. the string 'true' vs. the boolean true.
    return plain && !testAmbiguousType(string) ? $538971b5b904f078$var$STYLE_PLAIN : $538971b5b904f078$var$STYLE_SINGLE;
    // Edge case: block indentation indicator can only have one digit.
    if (indentPerLevel > 9 && $538971b5b904f078$var$needIndentIndicator(string)) return $538971b5b904f078$var$STYLE_DOUBLE;
    // At this point we know block styles are valid.
    // Prefer literal style unless we want to fold.
    return hasFoldableLine ? $538971b5b904f078$var$STYLE_FOLDED : $538971b5b904f078$var$STYLE_LITERAL;
}
// Note: line breaking/folding is implemented for only the folded style.
// NB. We drop the last trailing newline (if any) of a returned block scalar
//  since the dumper adds its own newline. This always works:
//    • No ending newline => unaffected; already using strip "-" chomping.
//    • Ending newline    => removed then restored.
//  Importantly, this keeps the "+" chomp indicator from gaining an extra line.
function $538971b5b904f078$var$writeScalar(state, string, level, iskey) {
    state.dump = function() {
        if (string.length === 0) return "''";
        if (!state.noCompatMode && $538971b5b904f078$var$DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1) return "'" + string + "'";
        var indent = state.indent * Math.max(1, level); // no 0-indent scalars
        // As indentation gets deeper, let the width decrease monotonically
        // to the lower bound min(state.lineWidth, 40).
        // Note that this implies
        //  state.lineWidth ≤ 40 + state.indent: width is fixed at the lower bound.
        //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.
        // This behaves better than a constant minimum width which disallows narrower options,
        // or an indent threshold which causes the width to suddenly increase.
        var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
        // Without knowing if keys are implicit/explicit, assume implicit for safety.
        var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
        function testAmbiguity(string) {
            return $538971b5b904f078$var$testImplicitResolving(state, string);
        }
        switch($538971b5b904f078$var$chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)){
            case $538971b5b904f078$var$STYLE_PLAIN:
                return string;
            case $538971b5b904f078$var$STYLE_SINGLE:
                return "'" + string.replace(/'/g, "''") + "'";
            case $538971b5b904f078$var$STYLE_LITERAL:
                return "|" + $538971b5b904f078$var$blockHeader(string, state.indent) + $538971b5b904f078$var$dropEndingNewline($538971b5b904f078$var$indentString(string, indent));
            case $538971b5b904f078$var$STYLE_FOLDED:
                return ">" + $538971b5b904f078$var$blockHeader(string, state.indent) + $538971b5b904f078$var$dropEndingNewline($538971b5b904f078$var$indentString($538971b5b904f078$var$foldString(string, lineWidth), indent));
            case $538971b5b904f078$var$STYLE_DOUBLE:
                return '"' + $538971b5b904f078$var$escapeString(string) + '"';
            default:
                throw new $538971b5b904f078$var$exception("impossible error: invalid scalar style");
        }
    }();
}
// Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.
function $538971b5b904f078$var$blockHeader(string, indentPerLevel) {
    var indentIndicator = $538971b5b904f078$var$needIndentIndicator(string) ? String(indentPerLevel) : "";
    // note the special case: the string '\n' counts as a "trailing" empty line.
    var clip = string[string.length - 1] === "\n";
    var keep = clip && (string[string.length - 2] === "\n" || string === "\n");
    var chomp = keep ? "+" : clip ? "" : "-";
    return indentIndicator + chomp + "\n";
}
// (See the note for writeScalar.)
function $538971b5b904f078$var$dropEndingNewline(string) {
    return string[string.length - 1] === "\n" ? string.slice(0, -1) : string;
}
// Note: a long line without a suitable break point will exceed the width limit.
// Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.
function $538971b5b904f078$var$foldString(string, width) {
    // In folded style, $k$ consecutive newlines output as $k+1$ newlines—
    // unless they're before or after a more-indented line, or at the very
    // beginning or end, in which case $k$ maps to $k$.
    // Therefore, parse each chunk as newline(s) followed by a content line.
    var lineRe = /(\n+)([^\n]*)/g;
    // first line (possibly an empty line)
    var result = function() {
        var nextLF = string.indexOf("\n");
        nextLF = nextLF !== -1 ? nextLF : string.length;
        lineRe.lastIndex = nextLF;
        return $538971b5b904f078$var$foldLine(string.slice(0, nextLF), width);
    }();
    // If we haven't reached the first content line yet, don't add an extra \n.
    var prevMoreIndented = string[0] === "\n" || string[0] === " ";
    var moreIndented;
    // rest of the lines
    var match;
    while(match = lineRe.exec(string)){
        var prefix = match[1], line = match[2];
        moreIndented = line[0] === " ";
        result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + $538971b5b904f078$var$foldLine(line, width);
        prevMoreIndented = moreIndented;
    }
    return result;
}
// Greedy line breaking.
// Picks the longest line under the limit each time,
// otherwise settles for the shortest line over the limit.
// NB. More-indented lines *cannot* be folded, as that would add an extra \n.
function $538971b5b904f078$var$foldLine(line, width) {
    if (line === "" || line[0] === " ") return line;
    // Since a more-indented line adds a \n, breaks can't be followed by a space.
    var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.
    var match;
    // start is an inclusive index. end, curr, and next are exclusive.
    var start = 0, end, curr = 0, next = 0;
    var result = "";
    // Invariants: 0 <= start <= length-1.
    //   0 <= curr <= next <= max(0, length-2). curr - start <= width.
    // Inside the loop:
    //   A match implies length >= 2, so curr and next are <= length-2.
    while(match = breakRe.exec(line)){
        next = match.index;
        // maintain invariant: curr - start <= width
        if (next - start > width) {
            end = curr > start ? curr : next; // derive end <= length-2
            result += "\n" + line.slice(start, end);
            // skip the space that was output as \n
            start = end + 1; // derive start <= length-1
        }
        curr = next;
    }
    // By the invariants, start <= length-1, so there is something left over.
    // It is either the whole string or a part starting from non-whitespace.
    result += "\n";
    // Insert a break if the remainder is too long and there is a break available.
    if (line.length - start > width && curr > start) result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
    else result += line.slice(start);
    return result.slice(1); // drop extra \n joiner
}
// Escapes a double-quoted string.
function $538971b5b904f078$var$escapeString(string) {
    var result = "";
    var char, nextChar;
    var escapeSeq;
    for(var i = 0; i < string.length; i++){
        char = string.charCodeAt(i);
        // Check for surrogate pairs (reference Unicode 3.0 section "3.7 Surrogates").
        if (char >= 0xD800 && char <= 0xDBFF /* high surrogate */ ) {
            nextChar = string.charCodeAt(i + 1);
            if (nextChar >= 0xDC00 && nextChar <= 0xDFFF /* low surrogate */ ) {
                // Combine the surrogate pair and store it escaped.
                result += $538971b5b904f078$var$encodeHex((char - 0xD800) * 0x400 + nextChar - 0xDC00 + 0x10000);
                // Advance index one extra since we already used that char here.
                i++;
                continue;
            }
        }
        escapeSeq = $538971b5b904f078$var$ESCAPE_SEQUENCES[char];
        result += !escapeSeq && $538971b5b904f078$var$isPrintable(char) ? string[i] : escapeSeq || $538971b5b904f078$var$encodeHex(char);
    }
    return result;
}
function $538971b5b904f078$var$writeFlowSequence(state, level, object) {
    var _result = "", _tag = state.tag, index, length;
    for(index = 0, length = object.length; index < length; index += 1)// Write only valid elements.
    if ($538971b5b904f078$var$writeNode(state, level, object[index], false, false)) {
        if (index !== 0) _result += "," + (!state.condenseFlow ? " " : "");
        _result += state.dump;
    }
    state.tag = _tag;
    state.dump = "[" + _result + "]";
}
function $538971b5b904f078$var$writeBlockSequence(state, level, object, compact) {
    var _result = "", _tag = state.tag, index, length;
    for(index = 0, length = object.length; index < length; index += 1)// Write only valid elements.
    if ($538971b5b904f078$var$writeNode(state, level + 1, object[index], true, true)) {
        if (!compact || index !== 0) _result += $538971b5b904f078$var$generateNextLine(state, level);
        if (state.dump && $538971b5b904f078$var$CHAR_LINE_FEED === state.dump.charCodeAt(0)) _result += "-";
        else _result += "- ";
        _result += state.dump;
    }
    state.tag = _tag;
    state.dump = _result || "[]"; // Empty sequence if no valid values.
}
function $538971b5b904f078$var$writeFlowMapping(state, level, object) {
    var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
    for(index = 0, length = objectKeyList.length; index < length; index += 1){
        pairBuffer = "";
        if (index !== 0) pairBuffer += ", ";
        if (state.condenseFlow) pairBuffer += '"';
        objectKey = objectKeyList[index];
        objectValue = object[objectKey];
        if (!$538971b5b904f078$var$writeNode(state, level, objectKey, false, false)) continue; // Skip this pair because of invalid key;
        if (state.dump.length > 1024) pairBuffer += "? ";
        pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
        if (!$538971b5b904f078$var$writeNode(state, level, objectValue, false, false)) continue; // Skip this pair because of invalid value.
        pairBuffer += state.dump;
        // Both key and value are valid.
        _result += pairBuffer;
    }
    state.tag = _tag;
    state.dump = "{" + _result + "}";
}
function $538971b5b904f078$var$writeBlockMapping(state, level, object, compact) {
    var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
    // Allow sorting keys so that the output file is deterministic
    if (state.sortKeys === true) // Default sorting
    objectKeyList.sort();
    else if (typeof state.sortKeys === "function") // Custom sort function
    objectKeyList.sort(state.sortKeys);
    else if (state.sortKeys) // Something is wrong
    throw new $538971b5b904f078$var$exception("sortKeys must be a boolean or a function");
    for(index = 0, length = objectKeyList.length; index < length; index += 1){
        pairBuffer = "";
        if (!compact || index !== 0) pairBuffer += $538971b5b904f078$var$generateNextLine(state, level);
        objectKey = objectKeyList[index];
        objectValue = object[objectKey];
        if (!$538971b5b904f078$var$writeNode(state, level + 1, objectKey, true, true, true)) continue; // Skip this pair because of invalid key.
        explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
        if (explicitPair) {
            if (state.dump && $538971b5b904f078$var$CHAR_LINE_FEED === state.dump.charCodeAt(0)) pairBuffer += "?";
            else pairBuffer += "? ";
        }
        pairBuffer += state.dump;
        if (explicitPair) pairBuffer += $538971b5b904f078$var$generateNextLine(state, level);
        if (!$538971b5b904f078$var$writeNode(state, level + 1, objectValue, true, explicitPair)) continue; // Skip this pair because of invalid value.
        if (state.dump && $538971b5b904f078$var$CHAR_LINE_FEED === state.dump.charCodeAt(0)) pairBuffer += ":";
        else pairBuffer += ": ";
        pairBuffer += state.dump;
        // Both key and value are valid.
        _result += pairBuffer;
    }
    state.tag = _tag;
    state.dump = _result || "{}"; // Empty mapping if no valid pairs.
}
function $538971b5b904f078$var$detectType(state, object, explicit) {
    var _result, typeList, index, length, type, style;
    typeList = explicit ? state.explicitTypes : state.implicitTypes;
    for(index = 0, length = typeList.length; index < length; index += 1){
        type = typeList[index];
        if ((type.instanceOf || type.predicate) && (!type.instanceOf || typeof object === "object" && object instanceof type.instanceOf) && (!type.predicate || type.predicate(object))) {
            state.tag = explicit ? type.tag : "?";
            if (type.represent) {
                style = state.styleMap[type.tag] || type.defaultStyle;
                if ($538971b5b904f078$var$_toString.call(type.represent) === "[object Function]") _result = type.represent(object, style);
                else if ($538971b5b904f078$var$_hasOwnProperty.call(type.represent, style)) _result = type.represent[style](object, style);
                else throw new $538971b5b904f078$var$exception("!<" + type.tag + '> tag resolver accepts not "' + style + '" style');
                state.dump = _result;
            }
            return true;
        }
    }
    return false;
}
// Serializes `object` and writes it to global `result`.
// Returns true on success, or false on invalid object.
//
function $538971b5b904f078$var$writeNode(state, level, object, block, compact, iskey) {
    state.tag = null;
    state.dump = object;
    if (!$538971b5b904f078$var$detectType(state, object, false)) $538971b5b904f078$var$detectType(state, object, true);
    var type = $538971b5b904f078$var$_toString.call(state.dump);
    if (block) block = state.flowLevel < 0 || state.flowLevel > level;
    var objectOrArray = type === "[object Object]" || type === "[object Array]", duplicateIndex, duplicate;
    if (objectOrArray) {
        duplicateIndex = state.duplicates.indexOf(object);
        duplicate = duplicateIndex !== -1;
    }
    if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) compact = false;
    if (duplicate && state.usedDuplicates[duplicateIndex]) state.dump = "*ref_" + duplicateIndex;
    else {
        if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) state.usedDuplicates[duplicateIndex] = true;
        if (type === "[object Object]") {
            if (block && Object.keys(state.dump).length !== 0) {
                $538971b5b904f078$var$writeBlockMapping(state, level, state.dump, compact);
                if (duplicate) state.dump = "&ref_" + duplicateIndex + state.dump;
            } else {
                $538971b5b904f078$var$writeFlowMapping(state, level, state.dump);
                if (duplicate) state.dump = "&ref_" + duplicateIndex + " " + state.dump;
            }
        } else if (type === "[object Array]") {
            var arrayLevel = state.noArrayIndent && level > 0 ? level - 1 : level;
            if (block && state.dump.length !== 0) {
                $538971b5b904f078$var$writeBlockSequence(state, arrayLevel, state.dump, compact);
                if (duplicate) state.dump = "&ref_" + duplicateIndex + state.dump;
            } else {
                $538971b5b904f078$var$writeFlowSequence(state, arrayLevel, state.dump);
                if (duplicate) state.dump = "&ref_" + duplicateIndex + " " + state.dump;
            }
        } else if (type === "[object String]") {
            if (state.tag !== "?") $538971b5b904f078$var$writeScalar(state, state.dump, level, iskey);
        } else {
            if (state.skipInvalid) return false;
            throw new $538971b5b904f078$var$exception("unacceptable kind of an object to dump " + type);
        }
        if (state.tag !== null && state.tag !== "?") state.dump = "!<" + state.tag + "> " + state.dump;
    }
    return true;
}
function $538971b5b904f078$var$getDuplicateReferences(object, state) {
    var objects = [], duplicatesIndexes = [], index, length;
    $538971b5b904f078$var$inspectNode(object, objects, duplicatesIndexes);
    for(index = 0, length = duplicatesIndexes.length; index < length; index += 1)state.duplicates.push(objects[duplicatesIndexes[index]]);
    state.usedDuplicates = new Array(length);
}
function $538971b5b904f078$var$inspectNode(object, objects, duplicatesIndexes) {
    var objectKeyList, index, length;
    if (object !== null && typeof object === "object") {
        index = objects.indexOf(object);
        if (index !== -1) {
            if (duplicatesIndexes.indexOf(index) === -1) duplicatesIndexes.push(index);
        } else {
            objects.push(object);
            if (Array.isArray(object)) for(index = 0, length = object.length; index < length; index += 1)$538971b5b904f078$var$inspectNode(object[index], objects, duplicatesIndexes);
            else {
                objectKeyList = Object.keys(object);
                for(index = 0, length = objectKeyList.length; index < length; index += 1)$538971b5b904f078$var$inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
            }
        }
    }
}
function $538971b5b904f078$var$dump$1(input, options) {
    options = options || {};
    var state = new $538971b5b904f078$var$State(options);
    if (!state.noRefs) $538971b5b904f078$var$getDuplicateReferences(input, state);
    if ($538971b5b904f078$var$writeNode(state, 0, input, true, true)) return state.dump + "\n";
    return "";
}
function $538971b5b904f078$var$safeDump$1(input, options) {
    return $538971b5b904f078$var$dump$1(input, $538971b5b904f078$var$common.extend({
        schema: $538971b5b904f078$var$default_safe
    }, options));
}
var $538971b5b904f078$var$dump_1 = $538971b5b904f078$var$dump$1;
var $538971b5b904f078$var$safeDump_1 = $538971b5b904f078$var$safeDump$1;
var $538971b5b904f078$var$dumper = {
    dump: $538971b5b904f078$var$dump_1,
    safeDump: $538971b5b904f078$var$safeDump_1
};
function $538971b5b904f078$var$deprecated(name) {
    return function() {
        throw new Error("Function " + name + " is deprecated and cannot be used.");
    };
}
var $538971b5b904f078$var$Type = $538971b5b904f078$var$type;
var $538971b5b904f078$var$Schema = $538971b5b904f078$var$schema;
var $538971b5b904f078$var$FAILSAFE_SCHEMA = $538971b5b904f078$var$failsafe;
var $538971b5b904f078$var$JSON_SCHEMA = $538971b5b904f078$var$json;
var $538971b5b904f078$var$CORE_SCHEMA = $538971b5b904f078$var$core;
var $538971b5b904f078$var$DEFAULT_SAFE_SCHEMA = $538971b5b904f078$var$default_safe;
var $538971b5b904f078$var$DEFAULT_FULL_SCHEMA = $538971b5b904f078$var$default_full;
var $538971b5b904f078$var$load = $538971b5b904f078$var$loader.load;
var $538971b5b904f078$var$loadAll = $538971b5b904f078$var$loader.loadAll;
var $538971b5b904f078$var$safeLoad = $538971b5b904f078$var$loader.safeLoad;
var $538971b5b904f078$var$safeLoadAll = $538971b5b904f078$var$loader.safeLoadAll;
var $538971b5b904f078$var$dump = $538971b5b904f078$var$dumper.dump;
var $538971b5b904f078$var$safeDump = $538971b5b904f078$var$dumper.safeDump;
var $538971b5b904f078$var$YAMLException = $538971b5b904f078$var$exception;
// Deprecated schema names from JS-YAML 2.0.x
var $538971b5b904f078$var$MINIMAL_SCHEMA = $538971b5b904f078$var$failsafe;
var $538971b5b904f078$var$SAFE_SCHEMA = $538971b5b904f078$var$default_safe;
var $538971b5b904f078$var$DEFAULT_SCHEMA = $538971b5b904f078$var$default_full;
// Deprecated functions from JS-YAML 1.x.x
var $538971b5b904f078$var$scan = $538971b5b904f078$var$deprecated("scan");
var $538971b5b904f078$var$parse = $538971b5b904f078$var$deprecated("parse");
var $538971b5b904f078$var$compose = $538971b5b904f078$var$deprecated("compose");
var $538971b5b904f078$var$addConstructor = $538971b5b904f078$var$deprecated("addConstructor");
var $538971b5b904f078$var$jsYaml$1 = {
    Type: $538971b5b904f078$var$Type,
    Schema: $538971b5b904f078$var$Schema,
    FAILSAFE_SCHEMA: $538971b5b904f078$var$FAILSAFE_SCHEMA,
    JSON_SCHEMA: $538971b5b904f078$var$JSON_SCHEMA,
    CORE_SCHEMA: $538971b5b904f078$var$CORE_SCHEMA,
    DEFAULT_SAFE_SCHEMA: $538971b5b904f078$var$DEFAULT_SAFE_SCHEMA,
    DEFAULT_FULL_SCHEMA: $538971b5b904f078$var$DEFAULT_FULL_SCHEMA,
    load: $538971b5b904f078$var$load,
    loadAll: $538971b5b904f078$var$loadAll,
    safeLoad: $538971b5b904f078$var$safeLoad,
    safeLoadAll: $538971b5b904f078$var$safeLoadAll,
    dump: $538971b5b904f078$var$dump,
    safeDump: $538971b5b904f078$var$safeDump,
    YAMLException: $538971b5b904f078$var$YAMLException,
    MINIMAL_SCHEMA: $538971b5b904f078$var$MINIMAL_SCHEMA,
    SAFE_SCHEMA: $538971b5b904f078$var$SAFE_SCHEMA,
    DEFAULT_SCHEMA: $538971b5b904f078$var$DEFAULT_SCHEMA,
    scan: $538971b5b904f078$var$scan,
    parse: $538971b5b904f078$var$parse,
    compose: $538971b5b904f078$var$compose,
    addConstructor: $538971b5b904f078$var$addConstructor
};
var $538971b5b904f078$var$jsYaml = $538971b5b904f078$var$jsYaml$1;
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */ /**
 * Module variables.
 * @private
 */ var $538971b5b904f078$var$matchHtmlRegExp = /["'&<>]/;
/**
 * Module exports.
 * @public
 */ var $538971b5b904f078$var$escapeHtml_1 = $538971b5b904f078$var$escapeHtml;
/**
 * Escape special characters in the given string of html.
 *
 * @param  {string} string The string to escape for inserting into HTML
 * @return {string}
 * @public
 */ function $538971b5b904f078$var$escapeHtml(string) {
    var str = "" + string;
    var match = $538971b5b904f078$var$matchHtmlRegExp.exec(str);
    if (!match) return str;
    var escape;
    var html = "";
    var index = 0;
    var lastIndex = 0;
    for(index = match.index; index < str.length; index++){
        switch(str.charCodeAt(index)){
            case 34:
                escape = "&quot;";
                break;
            case 38:
                escape = "&amp;";
                break;
            case 39:
                escape = "&#39;";
                break;
            case 60:
                escape = "&lt;";
                break;
            case 62:
                escape = "&gt;";
                break;
            default:
                continue;
        }
        if (lastIndex !== index) html += str.substring(lastIndex, index);
        lastIndex = index + 1;
        html += escape;
    }
    return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
}
function $538971b5b904f078$var$_optionalChain(ops) {
    let lastAccessLHS = undefined;
    let value = ops[0];
    let i = 1;
    while(i < ops.length){
        const op = ops[i];
        const fn = ops[i + 1];
        i += 2;
        if ((op === "optionalAccess" || op === "optionalCall") && value == null) return undefined;
        if (op === "access" || op === "optionalAccess") {
            lastAccessLHS = value;
            value = fn(value);
        } else if (op === "call" || op === "optionalCall") {
            value = fn((...args)=>value.call(lastAccessLHS, ...args));
            lastAccessLHS = undefined;
        }
    }
    return value;
}
// this needs a big old cleanup
const $538971b5b904f078$var$newline = "\n";
// extract the yaml from 'yaml' nodes and put them in the vfil for later use
function $538971b5b904f078$var$default_frontmatter(value, messages) {
    try {
        return $538971b5b904f078$var$jsYaml.safeLoad(value);
    } catch (e) {
        messages.push(new $538971b5b904f078$var$vfileMessage("YAML failed to parse"));
    }
}
function $538971b5b904f078$var$parse_frontmatter({ parse: parse, type: type }) {
    const transformer = (tree, vFile)=>{
        $538971b5b904f078$var$unistUtilVisit(tree, type, (node)=>{
            const data = parse(node.value, vFile.messages);
            if (data) // @ts-ignore
            vFile.data.fm = data;
        });
    };
    return transformer;
}
// in code nodes replace the character witrh the html entities
// maybe I'll need more of these
const $538971b5b904f078$var$entites = [
    [
        /</g,
        "&lt;"
    ],
    [
        />/g,
        "&gt;"
    ],
    [
        /{/g,
        "&#123;"
    ],
    [
        /}/g,
        "&#125;"
    ]
];
function $538971b5b904f078$var$escape_code({ blocks: blocks }) {
    return function(tree) {
        if (!blocks) $538971b5b904f078$var$unistUtilVisit(tree, "code", escape);
        $538971b5b904f078$var$unistUtilVisit(tree, "inlineCode", escape);
        function escape(node) {
            for(let i = 0; i < $538971b5b904f078$var$entites.length; i += 1)node.value = node.value.replace($538971b5b904f078$var$entites[i][0], $538971b5b904f078$var$entites[i][1]);
        }
    };
}
// special case - process nodes with retext and smartypants
// retext plugins can't work generally due to the difficulties in converting between the two trees
function $538971b5b904f078$var$smartypants_transformer(options = {}) {
    const processor = $538971b5b904f078$var$retext().use($538971b5b904f078$var$retextSmartypants, options);
    return function(tree) {
        $538971b5b904f078$var$unistUtilVisit(tree, "text", (node)=>{
            node.value = String(processor.processSync(node.value));
        });
    };
}
// regex for scripts and attributes
const $538971b5b904f078$var$attrs = `(?:\\s{0,1}[a-zA-z]+=(?:"){0,1}[a-zA-Z0-9]+(?:"){0,1})*`;
const $538971b5b904f078$var$context = `(?:\\s{0,1}context)=(?:"){0,1}module(?:"){0,1}`;
const $538971b5b904f078$var$RE_BLANK = /^\n+$|^\s+$/;
const $538971b5b904f078$var$RE_SCRIPT = new RegExp(`^(<script` + $538971b5b904f078$var$attrs + `>)`);
const $538971b5b904f078$var$RE_MODULE_SCRIPT = new RegExp(`^(<script` + $538971b5b904f078$var$attrs + $538971b5b904f078$var$context + $538971b5b904f078$var$attrs + `>)`);
function $538971b5b904f078$var$extract_parts(nodes) {
    // since we are wrapping and replacing we need to keep track of the different component 'parts'
    // many special tags cannot be wrapped nor can style or script tags
    const parts = {
        special: [],
        html: [],
        instance: [],
        module: [],
        css: []
    };
    // iterate through all top level child nodes and assign them to the correct 'part'
    // anything that is a normal HAST node gets stored as HTML untouched
    // everything else gets parsed by the svelte parser
    children: for(let i = 0; i < nodes.length; i += 1){
        const empty_node = nodes[i].type === "text" && $538971b5b904f078$var$RE_BLANK.exec(nodes[i].value);
        // i no longer knwo why i did this
        if (empty_node || !nodes[i].value) {
            if (!parts.html.length || !($538971b5b904f078$var$RE_BLANK.exec(nodes[i].value) && $538971b5b904f078$var$RE_BLANK.exec(parts.html[parts.html.length - 1].value))) parts.html.push(nodes[i]);
            continue children;
        }
        let result;
        try {
            result = (0, $371cbf9bf2e321d1$exports.parse)(nodes[i].value);
        } catch (e) {
            parts.html.push(nodes[i]);
            continue children;
        }
        // svelte special tags that have to be top level
        if (!result.html || !result.html.children) return parts;
        const _parts = result.html.children.map((v)=>{
            if (v.type === "Options" || v.type === "Head" || v.type === "Window" || v.type === "Body") return [
                "special",
                v.start,
                v.end
            ];
            else return [
                "html",
                v.start,
                v.end
            ];
        });
        results: for(const key in result){
            if (key === "html" || !result[key]) continue results;
            _parts.push([
                key,
                result[key].start,
                result[key].end
            ]);
        }
        // sort them to ensure the array is in the order they appear in the source, no gaps
        // this might not be necessary any more, i forget
        const sorted = _parts.sort((a, b)=>a[1] - b[1]);
        // push the nodes into the correct 'part' since they are sorted everything should be in the correct order
        sorted.forEach((next)=>{
            parts[next[0]].push({
                type: "raw",
                value: nodes[i].value.substring(next[1], next[2])
            });
        });
    }
    return parts;
}
function $538971b5b904f078$var$map_layout_to_path(filename, layout_map) {
    const match = Object.keys(layout_map).find((l)=>new RegExp(`\\` + `${$773sa$sep}${l}` + `\\` + `${$773sa$sep}`).test($773sa$normalize(filename).replace(process.cwd(), "")));
    if (match) return layout_map[match];
    else return layout_map["_"] ? layout_map["_"] : undefined;
}
function $538971b5b904f078$var$generate_layout_import(layout) {
    if (!layout) return false;
    return `import Layout_MDSVEX_DEFAULT${layout.components.length ? `, * as Components` : ""} from '${layout.path}';`;
}
function $538971b5b904f078$var$generate_layout({ frontmatter_layout: frontmatter_layout, layout_options: layout_options, layout_mode: layout_mode, filename: filename }) {
    let selected_layout;
    const error = {
        reason: ""
    };
    if (!layout_options || frontmatter_layout === false) return [
        false,
        false,
        false
    ];
    else if (layout_mode === "single") {
        selected_layout = layout_options.__mdsvex_default;
        if (frontmatter_layout) error.reason = `You attempted to apply a named layout in the front-matter of "${filename}", but did not provide any named layouts as options to the preprocessor. `;
    } else if (frontmatter_layout) {
        selected_layout = layout_options[frontmatter_layout];
        if (!selected_layout) error.reason = `Could not find a layout with the name "${frontmatter_layout}" and no fall back layout ("_") was provided.`;
    } else selected_layout = $538971b5b904f078$var$map_layout_to_path(filename, layout_options);
    return [
        $538971b5b904f078$var$generate_layout_import(selected_layout),
        selected_layout !== undefined && selected_layout.components.length > 0 && selected_layout.components,
        error.reason ? error : false
    ];
}
function $538971b5b904f078$var$transform_hast({ layout: layout, layout_mode: layout_mode }) {
    return function transformer(tree, vFile) {
        // we need to keep { and } intact for svelte, so reverse the escaping in links and images
        // if anyone actually uses these characters for any other reason i'll probably just cry
        $538971b5b904f078$var$unistUtilVisit(tree, "element", (node)=>{
            if (node.tagName === "a" && node.properties && typeof node.properties.href === "string") node.properties.href = node.properties.href.replace(/%7B/g, "{").replace(/%7D/g, "}");
            if (node.tagName === "img" && node.properties && typeof node.properties.src === "string") node.properties.src = node.properties.src.replace(/%7B/g, "{").replace(/%7D/g, "}");
        });
        // the rest only applies to layouts and front matter
        // this  breaks position data
        // svelte preprocessors don't currently support sourcemaps
        // i'll fix this when they do
        //@ts-ignore
        if (!layout && !vFile.data.fm) return tree;
        $538971b5b904f078$var$unistUtilVisit(tree, "root", (node)=>{
            const { special: special, html: html, instance: instance, module: _module, css: css } = $538971b5b904f078$var$extract_parts(node.children);
            const { fm: metadata } = vFile.data;
            // Workaround for script and style tags in strings
            // https://github.com/sveltejs/svelte/issues/5292
            const stringified = metadata && JSON.stringify(metadata).replace(/<(\/?script|\/?style)/g, '<"+"$1');
            const fm = metadata && `export const metadata = ${stringified};${$538971b5b904f078$var$newline}` + `\tconst { ${Object.keys(metadata).join(", ")} } = metadata;`;
            const frontmatter_layout = metadata && metadata.layout;
            const [import_script, components, error] = $538971b5b904f078$var$generate_layout({
                frontmatter_layout: frontmatter_layout,
                layout_options: layout,
                layout_mode: layout_mode,
                //@ts-ignore
                filename: vFile.filename
            });
            if (error) vFile.messages.push(new $538971b5b904f078$var$vfileMessage(error.reason));
            if (components) for(let i = 0; i < components.length; i++)$538971b5b904f078$var$unistUtilVisit(tree, "element", (node)=>{
                if (node.tagName === components[i]) node.tagName = `Components.${components[i]}`;
            });
            // add the layout if we are using one, reusing the existing script if one exists
            if (import_script && !instance[0]) instance.push({
                type: "raw",
                value: `${$538971b5b904f078$var$newline}<script>${$538971b5b904f078$var$newline}\t${import_script}${$538971b5b904f078$var$newline}</script>${$538971b5b904f078$var$newline}`
            });
            else if (import_script) instance[0].value = instance[0].value.replace($538971b5b904f078$var$RE_SCRIPT, `$1${$538971b5b904f078$var$newline}\t${import_script}`);
            // inject the frontmatter into the module script if there is any, reusing the existing module script if one exists
            if (!_module[0] && fm) _module.push({
                type: "raw",
                value: `<script context="module">${$538971b5b904f078$var$newline}\t${fm}${$538971b5b904f078$var$newline}</script>`
            });
            else if (fm) // @ts-ignore
            _module[0].value = _module[0].value.replace($538971b5b904f078$var$RE_MODULE_SCRIPT, `$1${$538971b5b904f078$var$newline}\t${fm}`);
            // smoosh it all together in an order that makes sense,
            // if using a layout we only wrap the html and nothing else
            //@ts-ignore
            node.children = [
                //@ts-ignore
                ..._module,
                //@ts-ignore
                {
                    type: "raw",
                    value: _module[0] ? $538971b5b904f078$var$newline : ""
                },
                //@ts-ignore
                ...instance,
                //@ts-ignore
                {
                    type: "raw",
                    value: instance[0] ? $538971b5b904f078$var$newline : ""
                },
                //@ts-ignore
                ...css,
                //@ts-ignore
                {
                    type: "raw",
                    value: css[0] ? $538971b5b904f078$var$newline : ""
                },
                //@ts-ignore
                ...special,
                //@ts-ignore
                {
                    type: "raw",
                    value: special[0] ? $538971b5b904f078$var$newline : ""
                },
                {
                    //@ts-ignore
                    type: "raw",
                    value: import_script ? `<Layout_MDSVEX_DEFAULT {...$$props}${fm ? " {...metadata}" : ""}>` : ""
                },
                //@ts-ignore
                {
                    type: "raw",
                    value: $538971b5b904f078$var$newline
                },
                //@ts-ignore
                ...html,
                //@ts-ignore
                {
                    type: "raw",
                    value: $538971b5b904f078$var$newline
                },
                //@ts-ignore
                {
                    type: "raw",
                    value: import_script ? "</Layout_MDSVEX_DEFAULT>" : ""
                }
            ];
        });
    };
}
// highlighting stuff
// { [lang]: { path, deps: pointer to key } }
const $538971b5b904f078$var$langs = {};
let $538971b5b904f078$var$Prism;
const $538971b5b904f078$var$make_path = (base_path, id)=>base_path.replace("{id}", id);
// we need to get all language metadata
// also track if they depend on other languages so we can autoload without breaking
// i don't actually know what the require key means but it sounds important
function $538971b5b904f078$var$get_lang_info(name, lang_meta, base_path) {
    const _lang_meta = {
        name: name,
        path: `prismjs/${$538971b5b904f078$var$make_path(base_path, name)}`,
        deps: new Set()
    };
    const aliases = new Set();
    // TODO: DRY this up, it is literally identical
    if (lang_meta.require) {
        if (Array.isArray(lang_meta.require)) lang_meta.require.forEach((id)=>_lang_meta.deps.add(id));
        else _lang_meta.deps.add(lang_meta.require);
    }
    if (lang_meta.peerDependencies) {
        if (Array.isArray(lang_meta.peerDependencies)) lang_meta.peerDependencies.forEach((id)=>_lang_meta.deps.add(id));
        else _lang_meta.deps.add(lang_meta.peerDependencies);
    }
    if (lang_meta.alias) {
        if (Array.isArray(lang_meta.alias)) lang_meta.alias.forEach((id)=>aliases.add(id));
        else aliases.add(lang_meta.alias);
    }
    return [
        {
            ..._lang_meta,
            aliases: aliases
        },
        aliases
    ];
}

// workaround for ts weirdness - intersection types work better with interfaces vs object literals
function $538971b5b904f078$var$load_language_metadata() {
    if (!process.browser) {
        const { meta: meta, ...languages } = (parcelRequire("k5gQN")).languages;
        for(const lang in languages){
            const [lang_info, aliases] = $538971b5b904f078$var$get_lang_info(lang, languages[lang], meta.path);
            $538971b5b904f078$var$langs[lang] = lang_info;
            aliases.forEach((_n)=>{
                $538971b5b904f078$var$langs[_n] = $538971b5b904f078$var$langs[lang];
            });
        }
        const svelte_meta = {
            name: "svelte",
            aliases: new Set([
                "sv"
            ]),
            path: "prism-svelte",
            deps: new Set([
                "javscript",
                "css"
            ])
        };
        $538971b5b904f078$var$langs.svelte = svelte_meta;
        $538971b5b904f078$var$langs.sv = svelte_meta;
    }
}
function $538971b5b904f078$var$load_language(lang) {
    if (!process.browser) {
        if (!$538971b5b904f078$var$langs[lang]) return;
        $538971b5b904f078$var$langs[lang].deps.forEach((name)=>$538971b5b904f078$var$load_language(name));
        require($538971b5b904f078$var$langs[lang].path);
    }
}
function $538971b5b904f078$var$highlight_blocks({ highlighter: highlight_fn, alias: alias } = {}) {
    if (highlight_fn && !process.browser) {
        $538971b5b904f078$var$load_language_metadata();
        if (alias) for(const lang in alias)$538971b5b904f078$var$langs[lang] = $538971b5b904f078$var$langs[alias[lang]];
    }
    return async function(tree) {
        if (highlight_fn) {
            const nodes = [];
            $538971b5b904f078$var$unistUtilVisit(tree, "code", (node)=>{
                nodes.push(node);
            });
            await Promise.all(nodes.map(async (node)=>{
                node.type = "html";
                node.value = await highlight_fn(node.value, node.lang, node.meta);
            }));
        }
    };
}
// escape curlies, backtick, \t, \r, \n to avoid breaking output of {@html `here`} in .svelte
const $538971b5b904f078$export$92ff52ce4f9996ed = (str)=>str.replace(/[{}`]/g, //@ts-ignore
    (c)=>({
            "{": "&#123;",
            "}": "&#125;",
            "`": "&#96;"
        })[c]).replace(/\\([trn])/g, "&#92;$1");

const $538971b5b904f078$export$cad6dd1b95c8039a = (code, lang)=>{
    const normalised_lang = $538971b5b904f078$var$_optionalChain([
        lang,
        "optionalAccess",
        (_)=>_.toLowerCase,
        "call",
        (_2)=>_2()
    ]);
    if (!process.browser) {
        let _lang = !!normalised_lang && $538971b5b904f078$var$langs[normalised_lang];
        if (!$538971b5b904f078$var$Prism) $538971b5b904f078$var$Prism = (parcelRequire("c6ROf"));
        if (_lang && !$538971b5b904f078$var$Prism.languages[_lang.name]) $538971b5b904f078$var$load_language(_lang.name);
        if (!_lang && normalised_lang && $538971b5b904f078$var$Prism.languages[normalised_lang]) {
            $538971b5b904f078$var$langs[normalised_lang] = {
                name: lang
            };
            _lang = $538971b5b904f078$var$langs[normalised_lang];
        }
        const highlighted = $538971b5b904f078$export$92ff52ce4f9996ed(_lang ? $538971b5b904f078$var$Prism.highlight(code, $538971b5b904f078$var$Prism.languages[_lang.name], _lang.name) : $538971b5b904f078$var$escapeHtml_1(code));
        return `<pre class="language-${normalised_lang}">{@html \`<code class="language-${normalised_lang}">${highlighted}</code>\`}</pre>`;
    } else {
        const highlighted = $538971b5b904f078$export$92ff52ce4f9996ed($538971b5b904f078$var$escapeHtml_1(code));
        return `<pre class="language-${normalised_lang}">{@html \`<code class="language-${normalised_lang}">${highlighted}</code>\`}</pre>`;
    }
};
function $538971b5b904f078$var$stringify(options = {}) {
    this.Compiler = compiler;
    function compiler(tree) {
        return $538971b5b904f078$var$prettyhtmlHastToHtml(tree, options);
    }
}
const $538971b5b904f078$var$apply_plugins = (plugins, parser)=>{
    plugins.forEach((plugin)=>{
        if (Array.isArray(plugin)) {
            if (plugin[1] && plugin[1]) parser.use(plugin[0], plugin[1]);
            else parser.use(plugin[0]);
        } else parser.use(plugin);
    });
    return parser;
};
function $538971b5b904f078$var$transform({ remarkPlugins: remarkPlugins = [], rehypePlugins: rehypePlugins = [], frontmatter: frontmatter, smartypants: smartypants, layout: layout, layout_mode: layout_mode, highlight: highlight } = {
    layout_mode: "single"
}) {
    const fm_opts = frontmatter ? frontmatter : {
        parse: $538971b5b904f078$var$default_frontmatter,
        type: "yaml",
        marker: "-"
    };
    const toMDAST = $538971b5b904f078$var$unified_1$1().use($538971b5b904f078$var$remarkParse).use($538971b5b904f078$var$mdsvex_parser).use($538971b5b904f078$var$remarkExternalLinks, {
        target: false,
        rel: [
            "nofollow"
        ]
    }).use($538971b5b904f078$var$escape_code, {
        blocks: !!highlight
    }).use($538971b5b904f078$var$remarkFrontmatter, [
        {
            type: fm_opts.type,
            marker: fm_opts.marker
        }
    ]).use($538971b5b904f078$var$parse_frontmatter, {
        parse: fm_opts.parse,
        type: fm_opts.type
    });
    if (smartypants) toMDAST.use($538971b5b904f078$var$smartypants_transformer, typeof smartypants === "boolean" ? {} : smartypants);
    $538971b5b904f078$var$apply_plugins(remarkPlugins, toMDAST).use($538971b5b904f078$var$highlight_blocks, highlight || {});
    const toHAST = toMDAST.use($538971b5b904f078$var$remarkRehype, {
        // @ts-ignore
        allowDangerousHtml: true,
        allowDangerousCharacters: true
    }).use($538971b5b904f078$var$transform_hast, {
        layout: layout,
        layout_mode: layout_mode
    });
    $538971b5b904f078$var$apply_plugins(rehypePlugins, toHAST);
    const processor = toHAST.use($538971b5b904f078$var$stringify, {
        allowDangerousHtml: true,
        allowDangerousCharacters: true
    });
    return processor;
}
const $538971b5b904f078$var$defaults = {
    remarkPlugins: [],
    rehypePlugins: [],
    smartypants: true,
    extension: ".svx",
    highlight: {
        highlighter: $538971b5b904f078$export$cad6dd1b95c8039a
    }
};
function $538971b5b904f078$var$to_posix(_path) {
    const isExtendedLengthPath = /^\\\\\?\\/.test(_path);
    const hasNonAscii = /[^\u0000-\u0080]+/.test(_path);
    if (isExtendedLengthPath || hasNonAscii) return _path;
    return _path.replace(/\\/g, "/");
}
function $538971b5b904f078$var$resolve_layout(layout_path) {
    try {
        return $538971b5b904f078$var$to_posix(undefined(layout_path));
    } catch (e) {
        try {
            const _path = (0, $773sa$join)(process.cwd(), layout_path);
            return $538971b5b904f078$var$to_posix(undefined(_path));
        } catch (e) {
            throw new Error(`The layout path you provided couldn't be found at either ${layout_path} or ${(0, $773sa$join)(process.cwd(), layout_path)}. Please double-check it and try again.`);
        }
    }
}
// handle custom components
function $538971b5b904f078$var$process_layouts(layouts) {
    const _layouts = layouts;
    for(const key in _layouts){
        const layout = (0, $773sa$fs).readFileSync(_layouts[key].path, {
            encoding: "utf8"
        });
        let ast;
        try {
            ast = (0, $371cbf9bf2e321d1$exports.parse)(layout);
        } catch (e) {
            throw new Error(e.toString() + `\n	at ${_layouts[key].path}`);
        }
        if (ast.module) {
            const component_exports = ast.module.content.body.filter((node)=>node.type === "ExportNamedDeclaration");
            if (component_exports.length) {
                _layouts[key].components = [];
                for(let i = 0; i < component_exports.length; i++){
                    if (component_exports[i].specifiers && component_exports[i].specifiers.length) for(let j = 0; j < component_exports[i].specifiers.length; j++)_layouts[key].components.push(component_exports[i].specifiers[j].exported.name);
                    else if (component_exports[i].declaration.declarations) {
                        //@ts-ignore
                        const declarations = component_exports[i].declaration.declarations;
                        for(let j = 0; j < declarations.length; j++)_layouts[key].components.push(declarations[j].id.name);
                    } else if (component_exports[i].declaration) _layouts[key].components.push(//@ts-ignore
                    component_exports[i].declaration.id.name);
                }
            }
        }
    }
    return _layouts;
}
/**
 * The svelte preprocessor for use with svelte.preprocess
 *
 * **options** - An options object with the following properties, all are optional.
 *
 * - `extension` - The extension to use for mdsvex files
 * - `extensions` - The extensions to use for mdsvex files
 * - `layout` - Layouts to apply to mdsvex documents
 * - `frontmatter` - frontmatter options for documents
 * - `highlight` - syntax highlighting options
 * - `smartypants` - smart typography options
 * - `remarkPlugins` - remark plugins to apply to the markdown
 * - `rehypePlugins` - rehype plugins to apply to the rendered html
 *
 */ const $538971b5b904f078$export$d61cf7a1924293cc = (options = $538971b5b904f078$var$defaults)=>{
    const { remarkPlugins: remarkPlugins = [], rehypePlugins: rehypePlugins = [], smartypants: smartypants = true, extension: extension = ".svx", extensions: extensions, layout: layout = false, highlight: highlight = {
        highlighter: $538971b5b904f078$export$cad6dd1b95c8039a
    }, frontmatter: frontmatter } = options;
    //@ts-ignore
    if (options.layouts) throw new Error(`mdsvex: "layouts" is not a valid option. Did you mean "layout"?`);
    const unknown_opts = [];
    const known_opts = [
        "filename",
        "remarkPlugins",
        "rehypePlugins",
        "smartypants",
        "extension",
        "extensions",
        "layout",
        "highlight",
        "frontmatter"
    ];
    for(const opt in options)if (!known_opts.includes(opt)) unknown_opts.push(opt);
    if (unknown_opts.length) console.warn(`mdsvex: Received unknown options: ${unknown_opts.join(", ")}. Valid options are: ${known_opts.join(", ")}.`);
    let _layout = {};
    let layout_mode = "single";
    if (typeof layout === "string") _layout.__mdsvex_default = {
        path: $538971b5b904f078$var$resolve_layout(layout),
        components: []
    };
    else if (typeof layout === "object") {
        layout_mode = "named";
        for(const name in layout)_layout[name] = {
            path: $538971b5b904f078$var$resolve_layout(layout[name]),
            components: []
        };
    }
    if (highlight && highlight.highlighter === undefined) highlight.highlighter = $538971b5b904f078$export$cad6dd1b95c8039a;
    _layout = $538971b5b904f078$var$process_layouts(_layout);
    const parser = $538971b5b904f078$var$transform({
        remarkPlugins: remarkPlugins,
        rehypePlugins: rehypePlugins,
        smartypants: smartypants,
        layout: _layout,
        layout_mode: layout_mode,
        highlight: highlight,
        frontmatter: frontmatter
    });
    return {
        name: "mdsvex",
        markup: async ({ content: content, filename: filename })=>{
            const extensionsParts = (extensions || [
                extension
            ]).map((ext)=>ext.split(".").pop());
            if (!extensionsParts.includes(filename.split(".").pop())) return;
            const parsed = await parser.process({
                contents: content,
                filename: filename
            });
            return {
                code: parsed.contents,
                data: parsed.data,
                map: ""
            };
        }
    };
};
/**
 * The standalone compile function.
 *
 * - **source** - the source code to convert.
 * - **options** - An options object with the following properties, all are optional.
 *
 * - `filename` - The filename of the generated file
 * - `extension` - The extension to use for mdsvex files
 * - `extensions` - The extensions to use for mdsvex files
 * - `layout` - Layouts to apply to mdsvex documents
 * - `frontmatter` - frontmatter options for documents
 * - `highlight` - syntax highlighting options
 * - `smartypants` - smart typography options
 * - `remarkPlugins` - remark plugins to apply to the markdown
 * - `rehypePlugins` - rehype plugins to apply to the rendered html
 */ const $538971b5b904f078$export$ef7acd7185315e22 = (source, opts)=>$538971b5b904f078$export$d61cf7a1924293cc(opts).markup({
        content: source,
        filename: opts && opts.filename || `file${opts && (opts.extensions && opts.extensions[0] || opts.extension) || ".svx"}`
    });


var $2521e4a700446aca$exports = {};
var $0567f1b5861cebf9$exports = {};
var $2804e7345fc544e2$exports = {};
var $2804e7345fc544e2$var$components = {
    "core": {
        "meta": {
            "path": "components/prism-core.js",
            "option": "mandatory"
        },
        "core": "Core"
    },
    "themes": {
        "meta": {
            "path": "themes/{id}.css",
            "link": "index.html?theme={id}",
            "exclusive": true
        },
        "prism": {
            "title": "Default",
            "option": "default"
        },
        "prism-dark": "Dark",
        "prism-funky": "Funky",
        "prism-okaidia": {
            "title": "Okaidia",
            "owner": "ocodia"
        },
        "prism-twilight": {
            "title": "Twilight",
            "owner": "remybach"
        },
        "prism-coy": {
            "title": "Coy",
            "owner": "tshedor"
        },
        "prism-solarizedlight": {
            "title": "Solarized Light",
            "owner": "hectormatos2011 "
        },
        "prism-tomorrow": {
            "title": "Tomorrow Night",
            "owner": "Rosey"
        }
    },
    "languages": {
        "meta": {
            "path": "components/prism-{id}",
            "noCSS": true,
            "examplesPath": "examples/prism-{id}",
            "addCheckAll": true
        },
        "markup": {
            "title": "Markup",
            "alias": [
                "html",
                "xml",
                "svg",
                "mathml",
                "ssml",
                "atom",
                "rss"
            ],
            "aliasTitles": {
                "html": "HTML",
                "xml": "XML",
                "svg": "SVG",
                "mathml": "MathML",
                "ssml": "SSML",
                "atom": "Atom",
                "rss": "RSS"
            },
            "option": "default"
        },
        "css": {
            "title": "CSS",
            "option": "default",
            "modify": "markup"
        },
        "clike": {
            "title": "C-like",
            "option": "default"
        },
        "javascript": {
            "title": "JavaScript",
            "require": "clike",
            "modify": "markup",
            "optional": "regex",
            "alias": "js",
            "option": "default"
        },
        "abap": {
            "title": "ABAP",
            "owner": "dellagustin"
        },
        "abnf": {
            "title": "ABNF",
            "owner": "RunDevelopment"
        },
        "actionscript": {
            "title": "ActionScript",
            "require": "javascript",
            "modify": "markup",
            "owner": "Golmote"
        },
        "ada": {
            "title": "Ada",
            "owner": "Lucretia"
        },
        "agda": {
            "title": "Agda",
            "owner": "xy-ren"
        },
        "al": {
            "title": "AL",
            "owner": "RunDevelopment"
        },
        "antlr4": {
            "title": "ANTLR4",
            "alias": "g4",
            "owner": "RunDevelopment"
        },
        "apacheconf": {
            "title": "Apache Configuration",
            "owner": "GuiTeK"
        },
        "apex": {
            "title": "Apex",
            "require": [
                "clike",
                "sql"
            ],
            "owner": "RunDevelopment"
        },
        "apl": {
            "title": "APL",
            "owner": "ngn"
        },
        "applescript": {
            "title": "AppleScript",
            "owner": "Golmote"
        },
        "aql": {
            "title": "AQL",
            "owner": "RunDevelopment"
        },
        "arduino": {
            "title": "Arduino",
            "require": "cpp",
            "alias": "ino",
            "owner": "dkern"
        },
        "arff": {
            "title": "ARFF",
            "owner": "Golmote"
        },
        "armasm": {
            "title": "ARM Assembly",
            "alias": "arm-asm",
            "owner": "RunDevelopment"
        },
        "arturo": {
            "title": "Arturo",
            "alias": "art",
            "optional": [
                "bash",
                "css",
                "javascript",
                "markup",
                "markdown",
                "sql"
            ],
            "owner": "drkameleon"
        },
        "asciidoc": {
            "alias": "adoc",
            "title": "AsciiDoc",
            "owner": "Golmote"
        },
        "aspnet": {
            "title": "ASP.NET (C#)",
            "require": [
                "markup",
                "csharp"
            ],
            "owner": "nauzilus"
        },
        "asm6502": {
            "title": "6502 Assembly",
            "owner": "kzurawel"
        },
        "asmatmel": {
            "title": "Atmel AVR Assembly",
            "owner": "cerkit"
        },
        "autohotkey": {
            "title": "AutoHotkey",
            "owner": "aviaryan"
        },
        "autoit": {
            "title": "AutoIt",
            "owner": "Golmote"
        },
        "avisynth": {
            "title": "AviSynth",
            "alias": "avs",
            "owner": "Zinfidel"
        },
        "avro-idl": {
            "title": "Avro IDL",
            "alias": "avdl",
            "owner": "RunDevelopment"
        },
        "awk": {
            "title": "AWK",
            "alias": "gawk",
            "aliasTitles": {
                "gawk": "GAWK"
            },
            "owner": "RunDevelopment"
        },
        "bash": {
            "title": "Bash",
            "alias": [
                "sh",
                "shell"
            ],
            "aliasTitles": {
                "sh": "Shell",
                "shell": "Shell"
            },
            "owner": "zeitgeist87"
        },
        "basic": {
            "title": "BASIC",
            "owner": "Golmote"
        },
        "batch": {
            "title": "Batch",
            "owner": "Golmote"
        },
        "bbcode": {
            "title": "BBcode",
            "alias": "shortcode",
            "aliasTitles": {
                "shortcode": "Shortcode"
            },
            "owner": "RunDevelopment"
        },
        "bbj": {
            "title": "BBj",
            "owner": "hyyan"
        },
        "bicep": {
            "title": "Bicep",
            "owner": "johnnyreilly"
        },
        "birb": {
            "title": "Birb",
            "require": "clike",
            "owner": "Calamity210"
        },
        "bison": {
            "title": "Bison",
            "require": "c",
            "owner": "Golmote"
        },
        "bnf": {
            "title": "BNF",
            "alias": "rbnf",
            "aliasTitles": {
                "rbnf": "RBNF"
            },
            "owner": "RunDevelopment"
        },
        "bqn": {
            "title": "BQN",
            "owner": "yewscion"
        },
        "brainfuck": {
            "title": "Brainfuck",
            "owner": "Golmote"
        },
        "brightscript": {
            "title": "BrightScript",
            "owner": "RunDevelopment"
        },
        "bro": {
            "title": "Bro",
            "owner": "wayward710"
        },
        "bsl": {
            "title": "BSL (1C:Enterprise)",
            "alias": "oscript",
            "aliasTitles": {
                "oscript": "OneScript"
            },
            "owner": "Diversus23"
        },
        "c": {
            "title": "C",
            "require": "clike",
            "owner": "zeitgeist87"
        },
        "csharp": {
            "title": "C#",
            "require": "clike",
            "alias": [
                "cs",
                "dotnet"
            ],
            "owner": "mvalipour"
        },
        "cpp": {
            "title": "C++",
            "require": "c",
            "owner": "zeitgeist87"
        },
        "cfscript": {
            "title": "CFScript",
            "require": "clike",
            "alias": "cfc",
            "owner": "mjclemente"
        },
        "chaiscript": {
            "title": "ChaiScript",
            "require": [
                "clike",
                "cpp"
            ],
            "owner": "RunDevelopment"
        },
        "cil": {
            "title": "CIL",
            "owner": "sbrl"
        },
        "cilkc": {
            "title": "Cilk/C",
            "require": "c",
            "alias": "cilk-c",
            "owner": "OpenCilk"
        },
        "cilkcpp": {
            "title": "Cilk/C++",
            "require": "cpp",
            "alias": [
                "cilk-cpp",
                "cilk"
            ],
            "owner": "OpenCilk"
        },
        "clojure": {
            "title": "Clojure",
            "owner": "troglotit"
        },
        "cmake": {
            "title": "CMake",
            "owner": "mjrogozinski"
        },
        "cobol": {
            "title": "COBOL",
            "owner": "RunDevelopment"
        },
        "coffeescript": {
            "title": "CoffeeScript",
            "require": "javascript",
            "alias": "coffee",
            "owner": "R-osey"
        },
        "concurnas": {
            "title": "Concurnas",
            "alias": "conc",
            "owner": "jasontatton"
        },
        "csp": {
            "title": "Content-Security-Policy",
            "owner": "ScottHelme"
        },
        "cooklang": {
            "title": "Cooklang",
            "owner": "ahue"
        },
        "coq": {
            "title": "Coq",
            "owner": "RunDevelopment"
        },
        "crystal": {
            "title": "Crystal",
            "require": "ruby",
            "owner": "MakeNowJust"
        },
        "css-extras": {
            "title": "CSS Extras",
            "require": "css",
            "modify": "css",
            "owner": "milesj"
        },
        "csv": {
            "title": "CSV",
            "owner": "RunDevelopment"
        },
        "cue": {
            "title": "CUE",
            "owner": "RunDevelopment"
        },
        "cypher": {
            "title": "Cypher",
            "owner": "RunDevelopment"
        },
        "d": {
            "title": "D",
            "require": "clike",
            "owner": "Golmote"
        },
        "dart": {
            "title": "Dart",
            "require": "clike",
            "owner": "Golmote"
        },
        "dataweave": {
            "title": "DataWeave",
            "owner": "machaval"
        },
        "dax": {
            "title": "DAX",
            "owner": "peterbud"
        },
        "dhall": {
            "title": "Dhall",
            "owner": "RunDevelopment"
        },
        "diff": {
            "title": "Diff",
            "owner": "uranusjr"
        },
        "django": {
            "title": "Django/Jinja2",
            "require": "markup-templating",
            "alias": "jinja2",
            "owner": "romanvm"
        },
        "dns-zone-file": {
            "title": "DNS zone file",
            "owner": "RunDevelopment",
            "alias": "dns-zone"
        },
        "docker": {
            "title": "Docker",
            "alias": "dockerfile",
            "owner": "JustinBeckwith"
        },
        "dot": {
            "title": "DOT (Graphviz)",
            "alias": "gv",
            "optional": "markup",
            "owner": "RunDevelopment"
        },
        "ebnf": {
            "title": "EBNF",
            "owner": "RunDevelopment"
        },
        "editorconfig": {
            "title": "EditorConfig",
            "owner": "osipxd"
        },
        "eiffel": {
            "title": "Eiffel",
            "owner": "Conaclos"
        },
        "ejs": {
            "title": "EJS",
            "require": [
                "javascript",
                "markup-templating"
            ],
            "owner": "RunDevelopment",
            "alias": "eta",
            "aliasTitles": {
                "eta": "Eta"
            }
        },
        "elixir": {
            "title": "Elixir",
            "owner": "Golmote"
        },
        "elm": {
            "title": "Elm",
            "owner": "zwilias"
        },
        "etlua": {
            "title": "Embedded Lua templating",
            "require": [
                "lua",
                "markup-templating"
            ],
            "owner": "RunDevelopment"
        },
        "erb": {
            "title": "ERB",
            "require": [
                "ruby",
                "markup-templating"
            ],
            "owner": "Golmote"
        },
        "erlang": {
            "title": "Erlang",
            "owner": "Golmote"
        },
        "excel-formula": {
            "title": "Excel Formula",
            "alias": [
                "xlsx",
                "xls"
            ],
            "owner": "RunDevelopment"
        },
        "fsharp": {
            "title": "F#",
            "require": "clike",
            "owner": "simonreynolds7"
        },
        "factor": {
            "title": "Factor",
            "owner": "catb0t"
        },
        "false": {
            "title": "False",
            "owner": "edukisto"
        },
        "firestore-security-rules": {
            "title": "Firestore security rules",
            "require": "clike",
            "owner": "RunDevelopment"
        },
        "flow": {
            "title": "Flow",
            "require": "javascript",
            "owner": "Golmote"
        },
        "fortran": {
            "title": "Fortran",
            "owner": "Golmote"
        },
        "ftl": {
            "title": "FreeMarker Template Language",
            "require": "markup-templating",
            "owner": "RunDevelopment"
        },
        "gml": {
            "title": "GameMaker Language",
            "alias": "gamemakerlanguage",
            "require": "clike",
            "owner": "LiarOnce"
        },
        "gap": {
            "title": "GAP (CAS)",
            "owner": "RunDevelopment"
        },
        "gcode": {
            "title": "G-code",
            "owner": "RunDevelopment"
        },
        "gdscript": {
            "title": "GDScript",
            "owner": "RunDevelopment"
        },
        "gedcom": {
            "title": "GEDCOM",
            "owner": "Golmote"
        },
        "gettext": {
            "title": "gettext",
            "alias": "po",
            "owner": "RunDevelopment"
        },
        "gherkin": {
            "title": "Gherkin",
            "owner": "hason"
        },
        "git": {
            "title": "Git",
            "owner": "lgiraudel"
        },
        "glsl": {
            "title": "GLSL",
            "require": "c",
            "owner": "Golmote"
        },
        "gn": {
            "title": "GN",
            "alias": "gni",
            "owner": "RunDevelopment"
        },
        "linker-script": {
            "title": "GNU Linker Script",
            "alias": "ld",
            "owner": "RunDevelopment"
        },
        "go": {
            "title": "Go",
            "require": "clike",
            "owner": "arnehormann"
        },
        "go-module": {
            "title": "Go module",
            "alias": "go-mod",
            "owner": "RunDevelopment"
        },
        "gradle": {
            "title": "Gradle",
            "require": "clike",
            "owner": "zeabdelkhalek-badido18"
        },
        "graphql": {
            "title": "GraphQL",
            "optional": "markdown",
            "owner": "Golmote"
        },
        "groovy": {
            "title": "Groovy",
            "require": "clike",
            "owner": "robfletcher"
        },
        "haml": {
            "title": "Haml",
            "require": "ruby",
            "optional": [
                "css",
                "css-extras",
                "coffeescript",
                "erb",
                "javascript",
                "less",
                "markdown",
                "scss",
                "textile"
            ],
            "owner": "Golmote"
        },
        "handlebars": {
            "title": "Handlebars",
            "require": "markup-templating",
            "alias": [
                "hbs",
                "mustache"
            ],
            "aliasTitles": {
                "mustache": "Mustache"
            },
            "owner": "Golmote"
        },
        "haskell": {
            "title": "Haskell",
            "alias": "hs",
            "owner": "bholst"
        },
        "haxe": {
            "title": "Haxe",
            "require": "clike",
            "optional": "regex",
            "owner": "Golmote"
        },
        "hcl": {
            "title": "HCL",
            "owner": "outsideris"
        },
        "hlsl": {
            "title": "HLSL",
            "require": "c",
            "owner": "RunDevelopment"
        },
        "hoon": {
            "title": "Hoon",
            "owner": "matildepark"
        },
        "http": {
            "title": "HTTP",
            "optional": [
                "csp",
                "css",
                "hpkp",
                "hsts",
                "javascript",
                "json",
                "markup",
                "uri"
            ],
            "owner": "danielgtaylor"
        },
        "hpkp": {
            "title": "HTTP Public-Key-Pins",
            "owner": "ScottHelme"
        },
        "hsts": {
            "title": "HTTP Strict-Transport-Security",
            "owner": "ScottHelme"
        },
        "ichigojam": {
            "title": "IchigoJam",
            "owner": "BlueCocoa"
        },
        "icon": {
            "title": "Icon",
            "owner": "Golmote"
        },
        "icu-message-format": {
            "title": "ICU Message Format",
            "owner": "RunDevelopment"
        },
        "idris": {
            "title": "Idris",
            "alias": "idr",
            "owner": "KeenS",
            "require": "haskell"
        },
        "ignore": {
            "title": ".ignore",
            "owner": "osipxd",
            "alias": [
                "gitignore",
                "hgignore",
                "npmignore"
            ],
            "aliasTitles": {
                "gitignore": ".gitignore",
                "hgignore": ".hgignore",
                "npmignore": ".npmignore"
            }
        },
        "inform7": {
            "title": "Inform 7",
            "owner": "Golmote"
        },
        "ini": {
            "title": "Ini",
            "owner": "aviaryan"
        },
        "io": {
            "title": "Io",
            "owner": "AlesTsurko"
        },
        "j": {
            "title": "J",
            "owner": "Golmote"
        },
        "java": {
            "title": "Java",
            "require": "clike",
            "owner": "sherblot"
        },
        "javadoc": {
            "title": "JavaDoc",
            "require": [
                "markup",
                "java",
                "javadoclike"
            ],
            "modify": "java",
            "optional": "scala",
            "owner": "RunDevelopment"
        },
        "javadoclike": {
            "title": "JavaDoc-like",
            "modify": [
                "java",
                "javascript",
                "php"
            ],
            "owner": "RunDevelopment"
        },
        "javastacktrace": {
            "title": "Java stack trace",
            "owner": "RunDevelopment"
        },
        "jexl": {
            "title": "Jexl",
            "owner": "czosel"
        },
        "jolie": {
            "title": "Jolie",
            "require": "clike",
            "owner": "thesave"
        },
        "jq": {
            "title": "JQ",
            "owner": "RunDevelopment"
        },
        "jsdoc": {
            "title": "JSDoc",
            "require": [
                "javascript",
                "javadoclike",
                "typescript"
            ],
            "modify": "javascript",
            "optional": [
                "actionscript",
                "coffeescript"
            ],
            "owner": "RunDevelopment"
        },
        "js-extras": {
            "title": "JS Extras",
            "require": "javascript",
            "modify": "javascript",
            "optional": [
                "actionscript",
                "coffeescript",
                "flow",
                "n4js",
                "typescript"
            ],
            "owner": "RunDevelopment"
        },
        "json": {
            "title": "JSON",
            "alias": "webmanifest",
            "aliasTitles": {
                "webmanifest": "Web App Manifest"
            },
            "owner": "CupOfTea696"
        },
        "json5": {
            "title": "JSON5",
            "require": "json",
            "owner": "RunDevelopment"
        },
        "jsonp": {
            "title": "JSONP",
            "require": "json",
            "owner": "RunDevelopment"
        },
        "jsstacktrace": {
            "title": "JS stack trace",
            "owner": "sbrl"
        },
        "js-templates": {
            "title": "JS Templates",
            "require": "javascript",
            "modify": "javascript",
            "optional": [
                "css",
                "css-extras",
                "graphql",
                "markdown",
                "markup",
                "sql"
            ],
            "owner": "RunDevelopment"
        },
        "julia": {
            "title": "Julia",
            "owner": "cdagnino"
        },
        "keepalived": {
            "title": "Keepalived Configure",
            "owner": "dev-itsheng"
        },
        "keyman": {
            "title": "Keyman",
            "owner": "mcdurdin"
        },
        "kotlin": {
            "title": "Kotlin",
            "alias": [
                "kt",
                "kts"
            ],
            "aliasTitles": {
                "kts": "Kotlin Script"
            },
            "require": "clike",
            "owner": "Golmote"
        },
        "kumir": {
            "title": "KuMir (\u041A\u0443\u041C\u0438\u0440)",
            "alias": "kum",
            "owner": "edukisto"
        },
        "kusto": {
            "title": "Kusto",
            "owner": "RunDevelopment"
        },
        "latex": {
            "title": "LaTeX",
            "alias": [
                "tex",
                "context"
            ],
            "aliasTitles": {
                "tex": "TeX",
                "context": "ConTeXt"
            },
            "owner": "japborst"
        },
        "latte": {
            "title": "Latte",
            "require": [
                "clike",
                "markup-templating",
                "php"
            ],
            "owner": "nette"
        },
        "less": {
            "title": "Less",
            "require": "css",
            "optional": "css-extras",
            "owner": "Golmote"
        },
        "lilypond": {
            "title": "LilyPond",
            "require": "scheme",
            "alias": "ly",
            "owner": "RunDevelopment"
        },
        "liquid": {
            "title": "Liquid",
            "require": "markup-templating",
            "owner": "cinhtau"
        },
        "lisp": {
            "title": "Lisp",
            "alias": [
                "emacs",
                "elisp",
                "emacs-lisp"
            ],
            "owner": "JuanCaicedo"
        },
        "livescript": {
            "title": "LiveScript",
            "owner": "Golmote"
        },
        "llvm": {
            "title": "LLVM IR",
            "owner": "porglezomp"
        },
        "log": {
            "title": "Log file",
            "optional": "javastacktrace",
            "owner": "RunDevelopment"
        },
        "lolcode": {
            "title": "LOLCODE",
            "owner": "Golmote"
        },
        "lua": {
            "title": "Lua",
            "owner": "Golmote"
        },
        "magma": {
            "title": "Magma (CAS)",
            "owner": "RunDevelopment"
        },
        "makefile": {
            "title": "Makefile",
            "owner": "Golmote"
        },
        "markdown": {
            "title": "Markdown",
            "require": "markup",
            "optional": "yaml",
            "alias": "md",
            "owner": "Golmote"
        },
        "markup-templating": {
            "title": "Markup templating",
            "require": "markup",
            "owner": "Golmote"
        },
        "mata": {
            "title": "Mata",
            "owner": "RunDevelopment"
        },
        "matlab": {
            "title": "MATLAB",
            "owner": "Golmote"
        },
        "maxscript": {
            "title": "MAXScript",
            "owner": "RunDevelopment"
        },
        "mel": {
            "title": "MEL",
            "owner": "Golmote"
        },
        "mermaid": {
            "title": "Mermaid",
            "owner": "RunDevelopment"
        },
        "metafont": {
            "title": "METAFONT",
            "owner": "LaeriExNihilo"
        },
        "mizar": {
            "title": "Mizar",
            "owner": "Golmote"
        },
        "mongodb": {
            "title": "MongoDB",
            "owner": "airs0urce",
            "require": "javascript"
        },
        "monkey": {
            "title": "Monkey",
            "owner": "Golmote"
        },
        "moonscript": {
            "title": "MoonScript",
            "alias": "moon",
            "owner": "RunDevelopment"
        },
        "n1ql": {
            "title": "N1QL",
            "owner": "TMWilds"
        },
        "n4js": {
            "title": "N4JS",
            "require": "javascript",
            "optional": "jsdoc",
            "alias": "n4jsd",
            "owner": "bsmith-n4"
        },
        "nand2tetris-hdl": {
            "title": "Nand To Tetris HDL",
            "owner": "stephanmax"
        },
        "naniscript": {
            "title": "Naninovel Script",
            "owner": "Elringus",
            "alias": "nani"
        },
        "nasm": {
            "title": "NASM",
            "owner": "rbmj"
        },
        "neon": {
            "title": "NEON",
            "owner": "nette"
        },
        "nevod": {
            "title": "Nevod",
            "owner": "nezaboodka"
        },
        "nginx": {
            "title": "nginx",
            "owner": "volado"
        },
        "nim": {
            "title": "Nim",
            "owner": "Golmote"
        },
        "nix": {
            "title": "Nix",
            "owner": "Golmote"
        },
        "nsis": {
            "title": "NSIS",
            "owner": "idleberg"
        },
        "objectivec": {
            "title": "Objective-C",
            "require": "c",
            "alias": "objc",
            "owner": "uranusjr"
        },
        "ocaml": {
            "title": "OCaml",
            "owner": "Golmote"
        },
        "odin": {
            "title": "Odin",
            "owner": "edukisto"
        },
        "opencl": {
            "title": "OpenCL",
            "require": "c",
            "modify": [
                "c",
                "cpp"
            ],
            "owner": "Milania1"
        },
        "openqasm": {
            "title": "OpenQasm",
            "alias": "qasm",
            "owner": "RunDevelopment"
        },
        "oz": {
            "title": "Oz",
            "owner": "Golmote"
        },
        "parigp": {
            "title": "PARI/GP",
            "owner": "Golmote"
        },
        "parser": {
            "title": "Parser",
            "require": "markup",
            "owner": "Golmote"
        },
        "pascal": {
            "title": "Pascal",
            "alias": "objectpascal",
            "aliasTitles": {
                "objectpascal": "Object Pascal"
            },
            "owner": "Golmote"
        },
        "pascaligo": {
            "title": "Pascaligo",
            "owner": "DefinitelyNotAGoat"
        },
        "psl": {
            "title": "PATROL Scripting Language",
            "owner": "bertysentry"
        },
        "pcaxis": {
            "title": "PC-Axis",
            "alias": "px",
            "owner": "RunDevelopment"
        },
        "peoplecode": {
            "title": "PeopleCode",
            "alias": "pcode",
            "owner": "RunDevelopment"
        },
        "perl": {
            "title": "Perl",
            "owner": "Golmote"
        },
        "php": {
            "title": "PHP",
            "require": "markup-templating",
            "owner": "milesj"
        },
        "phpdoc": {
            "title": "PHPDoc",
            "require": [
                "php",
                "javadoclike"
            ],
            "modify": "php",
            "owner": "RunDevelopment"
        },
        "php-extras": {
            "title": "PHP Extras",
            "require": "php",
            "modify": "php",
            "owner": "milesj"
        },
        "plant-uml": {
            "title": "PlantUML",
            "alias": "plantuml",
            "owner": "RunDevelopment"
        },
        "plsql": {
            "title": "PL/SQL",
            "require": "sql",
            "owner": "Golmote"
        },
        "powerquery": {
            "title": "PowerQuery",
            "alias": [
                "pq",
                "mscript"
            ],
            "owner": "peterbud"
        },
        "powershell": {
            "title": "PowerShell",
            "owner": "nauzilus"
        },
        "processing": {
            "title": "Processing",
            "require": "clike",
            "owner": "Golmote"
        },
        "prolog": {
            "title": "Prolog",
            "owner": "Golmote"
        },
        "promql": {
            "title": "PromQL",
            "owner": "arendjr"
        },
        "properties": {
            "title": ".properties",
            "owner": "Golmote"
        },
        "protobuf": {
            "title": "Protocol Buffers",
            "require": "clike",
            "owner": "just-boris"
        },
        "pug": {
            "title": "Pug",
            "require": [
                "markup",
                "javascript"
            ],
            "optional": [
                "coffeescript",
                "ejs",
                "handlebars",
                "less",
                "livescript",
                "markdown",
                "scss",
                "stylus",
                "twig"
            ],
            "owner": "Golmote"
        },
        "puppet": {
            "title": "Puppet",
            "owner": "Golmote"
        },
        "pure": {
            "title": "Pure",
            "optional": [
                "c",
                "cpp",
                "fortran"
            ],
            "owner": "Golmote"
        },
        "purebasic": {
            "title": "PureBasic",
            "require": "clike",
            "alias": "pbfasm",
            "owner": "HeX0R101"
        },
        "purescript": {
            "title": "PureScript",
            "require": "haskell",
            "alias": "purs",
            "owner": "sriharshachilakapati"
        },
        "python": {
            "title": "Python",
            "alias": "py",
            "owner": "multipetros"
        },
        "qsharp": {
            "title": "Q#",
            "require": "clike",
            "alias": "qs",
            "owner": "fedonman"
        },
        "q": {
            "title": "Q (kdb+ database)",
            "owner": "Golmote"
        },
        "qml": {
            "title": "QML",
            "require": "javascript",
            "owner": "RunDevelopment"
        },
        "qore": {
            "title": "Qore",
            "require": "clike",
            "owner": "temnroegg"
        },
        "r": {
            "title": "R",
            "owner": "Golmote"
        },
        "racket": {
            "title": "Racket",
            "require": "scheme",
            "alias": "rkt",
            "owner": "RunDevelopment"
        },
        "cshtml": {
            "title": "Razor C#",
            "alias": "razor",
            "require": [
                "markup",
                "csharp"
            ],
            "optional": [
                "css",
                "css-extras",
                "javascript",
                "js-extras"
            ],
            "owner": "RunDevelopment"
        },
        "jsx": {
            "title": "React JSX",
            "require": [
                "markup",
                "javascript"
            ],
            "optional": [
                "jsdoc",
                "js-extras",
                "js-templates"
            ],
            "owner": "vkbansal"
        },
        "tsx": {
            "title": "React TSX",
            "require": [
                "jsx",
                "typescript"
            ]
        },
        "reason": {
            "title": "Reason",
            "require": "clike",
            "owner": "Golmote"
        },
        "regex": {
            "title": "Regex",
            "owner": "RunDevelopment"
        },
        "rego": {
            "title": "Rego",
            "owner": "JordanSh"
        },
        "renpy": {
            "title": "Ren'py",
            "alias": "rpy",
            "owner": "HyuchiaDiego"
        },
        "rescript": {
            "title": "ReScript",
            "alias": "res",
            "owner": "vmarcosp"
        },
        "rest": {
            "title": "reST (reStructuredText)",
            "owner": "Golmote"
        },
        "rip": {
            "title": "Rip",
            "owner": "ravinggenius"
        },
        "roboconf": {
            "title": "Roboconf",
            "owner": "Golmote"
        },
        "robotframework": {
            "title": "Robot Framework",
            "alias": "robot",
            "owner": "RunDevelopment"
        },
        "ruby": {
            "title": "Ruby",
            "require": "clike",
            "alias": "rb",
            "owner": "samflores"
        },
        "rust": {
            "title": "Rust",
            "owner": "Golmote"
        },
        "sas": {
            "title": "SAS",
            "optional": [
                "groovy",
                "lua",
                "sql"
            ],
            "owner": "Golmote"
        },
        "sass": {
            "title": "Sass (Sass)",
            "require": "css",
            "optional": "css-extras",
            "owner": "Golmote"
        },
        "scss": {
            "title": "Sass (SCSS)",
            "require": "css",
            "optional": "css-extras",
            "owner": "MoOx"
        },
        "scala": {
            "title": "Scala",
            "require": "java",
            "owner": "jozic"
        },
        "scheme": {
            "title": "Scheme",
            "owner": "bacchus123"
        },
        "shell-session": {
            "title": "Shell session",
            "require": "bash",
            "alias": [
                "sh-session",
                "shellsession"
            ],
            "owner": "RunDevelopment"
        },
        "smali": {
            "title": "Smali",
            "owner": "RunDevelopment"
        },
        "smalltalk": {
            "title": "Smalltalk",
            "owner": "Golmote"
        },
        "smarty": {
            "title": "Smarty",
            "require": "markup-templating",
            "optional": "php",
            "owner": "Golmote"
        },
        "sml": {
            "title": "SML",
            "alias": "smlnj",
            "aliasTitles": {
                "smlnj": "SML/NJ"
            },
            "owner": "RunDevelopment"
        },
        "solidity": {
            "title": "Solidity (Ethereum)",
            "alias": "sol",
            "require": "clike",
            "owner": "glachaud"
        },
        "solution-file": {
            "title": "Solution file",
            "alias": "sln",
            "owner": "RunDevelopment"
        },
        "soy": {
            "title": "Soy (Closure Template)",
            "require": "markup-templating",
            "owner": "Golmote"
        },
        "sparql": {
            "title": "SPARQL",
            "require": "turtle",
            "owner": "Triply-Dev",
            "alias": "rq"
        },
        "splunk-spl": {
            "title": "Splunk SPL",
            "owner": "RunDevelopment"
        },
        "sqf": {
            "title": "SQF: Status Quo Function (Arma 3)",
            "require": "clike",
            "owner": "RunDevelopment"
        },
        "sql": {
            "title": "SQL",
            "owner": "multipetros"
        },
        "squirrel": {
            "title": "Squirrel",
            "require": "clike",
            "owner": "RunDevelopment"
        },
        "stan": {
            "title": "Stan",
            "owner": "RunDevelopment"
        },
        "stata": {
            "title": "Stata Ado",
            "require": [
                "mata",
                "java",
                "python"
            ],
            "owner": "RunDevelopment"
        },
        "iecst": {
            "title": "Structured Text (IEC 61131-3)",
            "owner": "serhioromano"
        },
        "stylus": {
            "title": "Stylus",
            "owner": "vkbansal"
        },
        "supercollider": {
            "title": "SuperCollider",
            "alias": "sclang",
            "owner": "RunDevelopment"
        },
        "swift": {
            "title": "Swift",
            "owner": "chrischares"
        },
        "systemd": {
            "title": "Systemd configuration file",
            "owner": "RunDevelopment"
        },
        "t4-templating": {
            "title": "T4 templating",
            "owner": "RunDevelopment"
        },
        "t4-cs": {
            "title": "T4 Text Templates (C#)",
            "require": [
                "t4-templating",
                "csharp"
            ],
            "alias": "t4",
            "owner": "RunDevelopment"
        },
        "t4-vb": {
            "title": "T4 Text Templates (VB)",
            "require": [
                "t4-templating",
                "vbnet"
            ],
            "owner": "RunDevelopment"
        },
        "tap": {
            "title": "TAP",
            "owner": "isaacs",
            "require": "yaml"
        },
        "tcl": {
            "title": "Tcl",
            "owner": "PeterChaplin"
        },
        "tt2": {
            "title": "Template Toolkit 2",
            "require": [
                "clike",
                "markup-templating"
            ],
            "owner": "gflohr"
        },
        "textile": {
            "title": "Textile",
            "require": "markup",
            "optional": "css",
            "owner": "Golmote"
        },
        "toml": {
            "title": "TOML",
            "owner": "RunDevelopment"
        },
        "tremor": {
            "title": "Tremor",
            "alias": [
                "trickle",
                "troy"
            ],
            "owner": "darach",
            "aliasTitles": {
                "trickle": "trickle",
                "troy": "troy"
            }
        },
        "turtle": {
            "title": "Turtle",
            "alias": "trig",
            "aliasTitles": {
                "trig": "TriG"
            },
            "owner": "jakubklimek"
        },
        "twig": {
            "title": "Twig",
            "require": "markup-templating",
            "owner": "brandonkelly"
        },
        "typescript": {
            "title": "TypeScript",
            "require": "javascript",
            "optional": "js-templates",
            "alias": "ts",
            "owner": "vkbansal"
        },
        "typoscript": {
            "title": "TypoScript",
            "alias": "tsconfig",
            "aliasTitles": {
                "tsconfig": "TSConfig"
            },
            "owner": "dkern"
        },
        "unrealscript": {
            "title": "UnrealScript",
            "alias": [
                "uscript",
                "uc"
            ],
            "owner": "RunDevelopment"
        },
        "uorazor": {
            "title": "UO Razor Script",
            "owner": "jaseowns"
        },
        "uri": {
            "title": "URI",
            "alias": "url",
            "aliasTitles": {
                "url": "URL"
            },
            "owner": "RunDevelopment"
        },
        "v": {
            "title": "V",
            "require": "clike",
            "owner": "taggon"
        },
        "vala": {
            "title": "Vala",
            "require": "clike",
            "optional": "regex",
            "owner": "TemplarVolk"
        },
        "vbnet": {
            "title": "VB.Net",
            "require": "basic",
            "owner": "Bigsby"
        },
        "velocity": {
            "title": "Velocity",
            "require": "markup",
            "owner": "Golmote"
        },
        "verilog": {
            "title": "Verilog",
            "owner": "a-rey"
        },
        "vhdl": {
            "title": "VHDL",
            "owner": "a-rey"
        },
        "vim": {
            "title": "vim",
            "owner": "westonganger"
        },
        "visual-basic": {
            "title": "Visual Basic",
            "alias": [
                "vb",
                "vba"
            ],
            "aliasTitles": {
                "vba": "VBA"
            },
            "owner": "Golmote"
        },
        "warpscript": {
            "title": "WarpScript",
            "owner": "RunDevelopment"
        },
        "wasm": {
            "title": "WebAssembly",
            "owner": "Golmote"
        },
        "web-idl": {
            "title": "Web IDL",
            "alias": "webidl",
            "owner": "RunDevelopment"
        },
        "wgsl": {
            "title": "WGSL",
            "owner": "Dr4gonthree"
        },
        "wiki": {
            "title": "Wiki markup",
            "require": "markup",
            "owner": "Golmote"
        },
        "wolfram": {
            "title": "Wolfram language",
            "alias": [
                "mathematica",
                "nb",
                "wl"
            ],
            "aliasTitles": {
                "mathematica": "Mathematica",
                "nb": "Mathematica Notebook"
            },
            "owner": "msollami"
        },
        "wren": {
            "title": "Wren",
            "owner": "clsource"
        },
        "xeora": {
            "title": "Xeora",
            "require": "markup",
            "alias": "xeoracube",
            "aliasTitles": {
                "xeoracube": "XeoraCube"
            },
            "owner": "freakmaxi"
        },
        "xml-doc": {
            "title": "XML doc (.net)",
            "require": "markup",
            "modify": [
                "csharp",
                "fsharp",
                "vbnet"
            ],
            "owner": "RunDevelopment"
        },
        "xojo": {
            "title": "Xojo (REALbasic)",
            "owner": "Golmote"
        },
        "xquery": {
            "title": "XQuery",
            "require": "markup",
            "owner": "Golmote"
        },
        "yaml": {
            "title": "YAML",
            "alias": "yml",
            "owner": "hason"
        },
        "yang": {
            "title": "YANG",
            "owner": "RunDevelopment"
        },
        "zig": {
            "title": "Zig",
            "owner": "RunDevelopment"
        }
    },
    "plugins": {
        "meta": {
            "path": "plugins/{id}/prism-{id}",
            "link": "plugins/{id}/"
        },
        "line-highlight": {
            "title": "Line Highlight",
            "description": "Highlights specific lines and/or line ranges."
        },
        "line-numbers": {
            "title": "Line Numbers",
            "description": "Line number at the beginning of code lines.",
            "owner": "kuba-kubula"
        },
        "show-invisibles": {
            "title": "Show Invisibles",
            "description": "Show hidden characters such as tabs and line breaks.",
            "optional": [
                "autolinker",
                "data-uri-highlight"
            ]
        },
        "autolinker": {
            "title": "Autolinker",
            "description": "Converts URLs and emails in code to clickable links. Parses Markdown links in comments."
        },
        "wpd": {
            "title": "WebPlatform Docs",
            "description": 'Makes tokens link to <a href="https://webplatform.github.io/docs/">WebPlatform.org documentation</a>. The links open in a new tab.'
        },
        "custom-class": {
            "title": "Custom Class",
            "description": "This plugin allows you to prefix Prism's default classes (<code>.comment</code> can become <code>.namespace--comment</code>) or replace them with your defined ones (like <code>.editor__comment</code>). You can even add new classes.",
            "owner": "dvkndn",
            "noCSS": true
        },
        "file-highlight": {
            "title": "File Highlight",
            "description": "Fetch external files and highlight them with Prism. Used on the Prism website itself.",
            "noCSS": true
        },
        "show-language": {
            "title": "Show Language",
            "description": "Display the highlighted language in code blocks (inline code does not show the label).",
            "owner": "nauzilus",
            "noCSS": true,
            "require": "toolbar"
        },
        "jsonp-highlight": {
            "title": "JSONP Highlight",
            "description": "Fetch content with JSONP and highlight some interesting content (e.g. GitHub/Gists or Bitbucket API).",
            "noCSS": true,
            "owner": "nauzilus"
        },
        "highlight-keywords": {
            "title": "Highlight Keywords",
            "description": "Adds special CSS classes for each keyword for fine-grained highlighting.",
            "owner": "vkbansal",
            "noCSS": true
        },
        "remove-initial-line-feed": {
            "title": "Remove initial line feed",
            "description": "Removes the initial line feed in code blocks.",
            "owner": "Golmote",
            "noCSS": true
        },
        "inline-color": {
            "title": "Inline color",
            "description": "Adds a small inline preview for colors in style sheets.",
            "require": "css-extras",
            "owner": "RunDevelopment"
        },
        "previewers": {
            "title": "Previewers",
            "description": "Previewers for angles, colors, gradients, easing and time.",
            "require": "css-extras",
            "owner": "Golmote"
        },
        "autoloader": {
            "title": "Autoloader",
            "description": "Automatically loads the needed languages to highlight the code blocks.",
            "owner": "Golmote",
            "noCSS": true
        },
        "keep-markup": {
            "title": "Keep Markup",
            "description": "Prevents custom markup from being dropped out during highlighting.",
            "owner": "Golmote",
            "optional": "normalize-whitespace",
            "noCSS": true
        },
        "command-line": {
            "title": "Command Line",
            "description": "Display a command line with a prompt and, optionally, the output/response from the commands.",
            "owner": "chriswells0"
        },
        "unescaped-markup": {
            "title": "Unescaped Markup",
            "description": "Write markup without having to escape anything."
        },
        "normalize-whitespace": {
            "title": "Normalize Whitespace",
            "description": "Supports multiple operations to normalize whitespace in code blocks.",
            "owner": "zeitgeist87",
            "optional": "unescaped-markup",
            "noCSS": true
        },
        "data-uri-highlight": {
            "title": "Data-URI Highlight",
            "description": "Highlights data-URI contents.",
            "owner": "Golmote",
            "noCSS": true
        },
        "toolbar": {
            "title": "Toolbar",
            "description": "Attach a toolbar for plugins to easily register buttons on the top of a code block.",
            "owner": "mAAdhaTTah"
        },
        "copy-to-clipboard": {
            "title": "Copy to Clipboard Button",
            "description": "Add a button that copies the code block to the clipboard when clicked.",
            "owner": "mAAdhaTTah",
            "require": "toolbar",
            "noCSS": true
        },
        "download-button": {
            "title": "Download Button",
            "description": "A button in the toolbar of a code block adding a convenient way to download a code file.",
            "owner": "Golmote",
            "require": "toolbar",
            "noCSS": true
        },
        "match-braces": {
            "title": "Match braces",
            "description": "Highlights matching braces.",
            "owner": "RunDevelopment"
        },
        "diff-highlight": {
            "title": "Diff Highlight",
            "description": "Highlights the code inside diff blocks.",
            "owner": "RunDevelopment",
            "require": "diff"
        },
        "filter-highlight-all": {
            "title": "Filter highlightAll",
            "description": "Filters the elements the <code>highlightAll</code> and <code>highlightAllUnder</code> methods actually highlight.",
            "owner": "RunDevelopment",
            "noCSS": true
        },
        "treeview": {
            "title": "Treeview",
            "description": "A language with special styles to highlight file system tree structures.",
            "owner": "Golmote"
        }
    }
};
if (0, $2804e7345fc544e2$exports) $2804e7345fc544e2$exports = $2804e7345fc544e2$var$components;


var $e70de23fe9555f8a$exports = {};
$e70de23fe9555f8a$exports = {
    // Case insensitive
    supportedLangs: [
        "JavaScript",
        "HTML",
        "CSS",
        "SQL",
        "Python",
        "TypeScript",
        "Java",
        "Bash",
        "CSharp",
        "C++",
        "PHP",
        "C",
        "PowerShell",
        "Go",
        "Rust",
        "Kotlin",
        "Dart",
        "Ruby",
        "R",
        "MATLAB",
        "DAX",
        "JSON",
        "YAML",
        "Markdown",
        "Code",
        "Svelte",
        "Shell"
    ].map((r)=>r.toLowerCase())
};


var $0567f1b5861cebf9$require$supportedLangs = $e70de23fe9555f8a$exports.supportedLangs;
/**
 * @returns {Set<string>}
 */ const $0567f1b5861cebf9$var$getPrismLangs = function() {
    let prismLangs = new Set();
    $0567f1b5861cebf9$require$supportedLangs.forEach((supportedLanguage)=>{
        prismLangs.add(supportedLanguage);
        if (supportedLanguage in $2804e7345fc544e2$exports.languages) {
            const languageComponent = $2804e7345fc544e2$exports.languages[supportedLanguage];
            if (languageComponent.alias) {
                if (Array.isArray(languageComponent.alias)) /** @type {string[]} */ languageComponent.alias.forEach((a)=>prismLangs.add(a));
                else prismLangs.add(languageComponent.alias);
            }
        }
    });
    return prismLangs;
};
$0567f1b5861cebf9$exports = $0567f1b5861cebf9$var$getPrismLangs;


/**
 *
 * @param {string} code
 * @param {string} lang
 * @param {string} [meta]
 * @returns
 */ function $2521e4a700446aca$var$highlighter(code, lang, meta) {
    code = code.replace(/'/g, "&apos;");
    code = code.replace(/"/g, "&quot;");
    // Replace curly braces or Svelte will try to evaluate as a JS expression
    code = code.replace(/{/g, "&lbrace;").replace(/}/g, "&rbrace;");
    if (lang?.toLowerCase() === "sql" && meta || !$0567f1b5861cebf9$exports().has(lang?.toLowerCase() ?? "")) {
        const queryId = lang?.toLowerCase() === "sql" && meta ? meta : lang;
        return `
        {#if ${queryId} }
            <QueryViewer
                queryID = "${queryId ?? "untitled"}"
                queryResult = {${queryId ?? "untitled"}}
            /> 
        {/if}
        `;
    }
    // Ensure that "real" code blocks are rendered not run as queries
    return `<CodeBlock source="${code}" copyToClipboard=true language="${lang}"/>`;
}
$2521e4a700446aca$exports = {
    highlighter: $2521e4a700446aca$var$highlighter
};


var $57a4462a49c99b67$require$highlighter = $2521e4a700446aca$exports.highlighter;
var $8ce7c84cad4722b7$exports = {};
/**
 * @type {import("svelte-preprocess/dist/types").PreprocessorGroup}
 */ const $8ce7c84cad4722b7$var$addScriptTags = {
    markup ({ content: content, filename: filename }) {
        if (filename?.endsWith(".md")) {
            if (!content.match(/\<script(.*)\>/)) {
                const result = content + '\n\n<script context="module"> </script>\n\n<script> </script>\n\n';
                return {
                    code: result
                };
            }
            if (!content.match(/\<script(.*)context\=\"module\"(.*)\>/)) {
                const result = content + '\n\n<script context="module"> </script>\n\n';
                return {
                    code: result
                };
            }
            if (!content.match(/\<script\>/)) {
                const result = content + "\n\n<script> </script>\n\n";
                return {
                    code: result
                };
            }
        }
    }
};
$8ce7c84cad4722b7$exports = $8ce7c84cad4722b7$var$addScriptTags;


var $812958982b4444cc$exports = {};
var $43cacfa68fbc5590$exports = {};
var $aa20b4fbeecfd8b4$exports = {};
/*
 * JavaScript MD5
 * https://github.com/blueimp/JavaScript-MD5
 *
 * Copyright 2011, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * https://opensource.org/licenses/MIT
 *
 * Based on
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */ /* global define */ (function($) {
    "use strict";
    /**
   * Add integers, wrapping at 2^32.
   * This uses 16-bit operations internally to work around bugs in interpreters.
   *
   * @param {number} x First integer
   * @param {number} y Second integer
   * @returns {number} Sum
   */ function safeAdd(x, y) {
        var lsw = (x & 0xffff) + (y & 0xffff);
        var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
        return msw << 16 | lsw & 0xffff;
    }
    /**
   * Bitwise rotate a 32-bit number to the left.
   *
   * @param {number} num 32-bit number
   * @param {number} cnt Rotation count
   * @returns {number} Rotated number
   */ function bitRotateLeft(num, cnt) {
        return num << cnt | num >>> 32 - cnt;
    }
    /**
   * Basic operation the algorithm uses.
   *
   * @param {number} q q
   * @param {number} a a
   * @param {number} b b
   * @param {number} x x
   * @param {number} s s
   * @param {number} t t
   * @returns {number} Result
   */ function md5cmn(q, a, b, x, s, t) {
        return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
    }
    /**
   * Basic operation the algorithm uses.
   *
   * @param {number} a a
   * @param {number} b b
   * @param {number} c c
   * @param {number} d d
   * @param {number} x x
   * @param {number} s s
   * @param {number} t t
   * @returns {number} Result
   */ function md5ff(a, b, c, d, x, s, t) {
        return md5cmn(b & c | ~b & d, a, b, x, s, t);
    }
    /**
   * Basic operation the algorithm uses.
   *
   * @param {number} a a
   * @param {number} b b
   * @param {number} c c
   * @param {number} d d
   * @param {number} x x
   * @param {number} s s
   * @param {number} t t
   * @returns {number} Result
   */ function md5gg(a, b, c, d, x, s, t) {
        return md5cmn(b & d | c & ~d, a, b, x, s, t);
    }
    /**
   * Basic operation the algorithm uses.
   *
   * @param {number} a a
   * @param {number} b b
   * @param {number} c c
   * @param {number} d d
   * @param {number} x x
   * @param {number} s s
   * @param {number} t t
   * @returns {number} Result
   */ function md5hh(a, b, c, d, x, s, t) {
        return md5cmn(b ^ c ^ d, a, b, x, s, t);
    }
    /**
   * Basic operation the algorithm uses.
   *
   * @param {number} a a
   * @param {number} b b
   * @param {number} c c
   * @param {number} d d
   * @param {number} x x
   * @param {number} s s
   * @param {number} t t
   * @returns {number} Result
   */ function md5ii(a, b, c, d, x, s, t) {
        return md5cmn(c ^ (b | ~d), a, b, x, s, t);
    }
    /**
   * Calculate the MD5 of an array of little-endian words, and a bit length.
   *
   * @param {Array} x Array of little-endian words
   * @param {number} len Bit length
   * @returns {Array<number>} MD5 Array
   */ function binlMD5(x, len) {
        /* append padding */ x[len >> 5] |= 0x80 << len % 32;
        x[(len + 64 >>> 9 << 4) + 14] = len;
        var i;
        var olda;
        var oldb;
        var oldc;
        var oldd;
        var a = 1732584193;
        var b = -271733879;
        var c = -1732584194;
        var d = 271733878;
        for(i = 0; i < x.length; i += 16){
            olda = a;
            oldb = b;
            oldc = c;
            oldd = d;
            a = md5ff(a, b, c, d, x[i], 7, -680876936);
            d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
            c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
            b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
            a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
            d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
            c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
            b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
            a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
            d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
            c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
            b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
            a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
            d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
            c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
            b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
            a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
            d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
            c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
            b = md5gg(b, c, d, a, x[i], 20, -373897302);
            a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
            d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
            c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
            b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
            a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
            d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
            c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
            b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
            a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
            d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
            c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
            b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
            a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
            d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
            c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
            b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
            a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
            d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
            c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
            b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
            a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
            d = md5hh(d, a, b, c, x[i], 11, -358537222);
            c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
            b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
            a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
            d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
            c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
            b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
            a = md5ii(a, b, c, d, x[i], 6, -198630844);
            d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
            c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
            b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
            a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
            d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
            c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
            b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
            a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
            d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
            c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
            b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
            a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
            d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
            c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
            b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
            a = safeAdd(a, olda);
            b = safeAdd(b, oldb);
            c = safeAdd(c, oldc);
            d = safeAdd(d, oldd);
        }
        return [
            a,
            b,
            c,
            d
        ];
    }
    /**
   * Convert an array of little-endian words to a string
   *
   * @param {Array<number>} input MD5 Array
   * @returns {string} MD5 string
   */ function binl2rstr(input) {
        var i;
        var output = "";
        var length32 = input.length * 32;
        for(i = 0; i < length32; i += 8)output += String.fromCharCode(input[i >> 5] >>> i % 32 & 0xff);
        return output;
    }
    /**
   * Convert a raw string to an array of little-endian words
   * Characters >255 have their high-byte silently ignored.
   *
   * @param {string} input Raw input string
   * @returns {Array<number>} Array of little-endian words
   */ function rstr2binl(input) {
        var i;
        var output = [];
        output[(input.length >> 2) - 1] = undefined;
        for(i = 0; i < output.length; i += 1)output[i] = 0;
        var length8 = input.length * 8;
        for(i = 0; i < length8; i += 8)output[i >> 5] |= (input.charCodeAt(i / 8) & 0xff) << i % 32;
        return output;
    }
    /**
   * Calculate the MD5 of a raw string
   *
   * @param {string} s Input string
   * @returns {string} Raw MD5 string
   */ function rstrMD5(s) {
        return binl2rstr(binlMD5(rstr2binl(s), s.length * 8));
    }
    /**
   * Calculates the HMAC-MD5 of a key and some data (raw strings)
   *
   * @param {string} key HMAC key
   * @param {string} data Raw input string
   * @returns {string} Raw MD5 string
   */ function rstrHMACMD5(key, data) {
        var i;
        var bkey = rstr2binl(key);
        var ipad = [];
        var opad = [];
        var hash;
        ipad[15] = opad[15] = undefined;
        if (bkey.length > 16) bkey = binlMD5(bkey, key.length * 8);
        for(i = 0; i < 16; i += 1){
            ipad[i] = bkey[i] ^ 0x36363636;
            opad[i] = bkey[i] ^ 0x5c5c5c5c;
        }
        hash = binlMD5(ipad.concat(rstr2binl(data)), 512 + data.length * 8);
        return binl2rstr(binlMD5(opad.concat(hash), 640));
    }
    /**
   * Convert a raw string to a hex string
   *
   * @param {string} input Raw input string
   * @returns {string} Hex encoded string
   */ function rstr2hex(input) {
        var hexTab = "0123456789abcdef";
        var output = "";
        var x;
        var i;
        for(i = 0; i < input.length; i += 1){
            x = input.charCodeAt(i);
            output += hexTab.charAt(x >>> 4 & 0x0f) + hexTab.charAt(x & 0x0f);
        }
        return output;
    }
    /**
   * Encode a string as UTF-8
   *
   * @param {string} input Input string
   * @returns {string} UTF8 string
   */ function str2rstrUTF8(input) {
        return unescape(encodeURIComponent(input));
    }
    /**
   * Encodes input string as raw MD5 string
   *
   * @param {string} s Input string
   * @returns {string} Raw MD5 string
   */ function rawMD5(s) {
        return rstrMD5(str2rstrUTF8(s));
    }
    /**
   * Encodes input string as Hex encoded string
   *
   * @param {string} s Input string
   * @returns {string} Hex encoded string
   */ function hexMD5(s) {
        return rstr2hex(rawMD5(s));
    }
    /**
   * Calculates the raw HMAC-MD5 for the given key and data
   *
   * @param {string} k HMAC key
   * @param {string} d Input string
   * @returns {string} Raw MD5 string
   */ function rawHMACMD5(k, d) {
        return rstrHMACMD5(str2rstrUTF8(k), str2rstrUTF8(d));
    }
    /**
   * Calculates the Hex encoded HMAC-MD5 for the given key and data
   *
   * @param {string} k HMAC key
   * @param {string} d Input string
   * @returns {string} Raw MD5 string
   */ function hexHMACMD5(k, d) {
        return rstr2hex(rawHMACMD5(k, d));
    }
    /**
   * Calculates MD5 value for a given string.
   * If a key is provided, calculates the HMAC-MD5 value.
   * Returns a Hex encoded string unless the raw argument is given.
   *
   * @param {string} string Input string
   * @param {string} [key] HMAC key
   * @param {boolean} [raw] Raw output switch
   * @returns {string} MD5 output
   */ function md5(string, key, raw) {
        if (!key) {
            if (!raw) return hexMD5(string);
            return rawMD5(string);
        }
        if (!raw) return hexHMACMD5(key, string);
        return rawHMACMD5(key, string);
    }
    if (typeof define === "function" && define.amd) define(function() {
        return md5;
    });
    else if (0, $aa20b4fbeecfd8b4$exports) $aa20b4fbeecfd8b4$exports = md5;
    else $.md5 = md5;
})($aa20b4fbeecfd8b4$exports);


$43cacfa68fbc5590$exports = {
    /**
	 * Generates a unique (but consistent) hash for a route
	 * @param {string} filename
	 * @example /src/pages/+page.md /src/pages/my-route/+page.md
	 * @returns string
	 */ getRouteHash: (filename)=>{
        const isIndex = filename.split("/src/pages")[1] === "/+page.md";
        if (isIndex) return $aa20b4fbeecfd8b4$exports("/");
        let route = filename.split("/src/pages")?.[1].replace(".md", "").replace(/\/\+page/g, "");
        if (!route) throw new Error(`Failed to generate route hash for ${filename} (${JSON.stringify({
            isIndex: isIndex
        })})`);
        return $aa20b4fbeecfd8b4$exports(route);
    }
};


var $812958982b4444cc$require$getRouteHash = $43cacfa68fbc5590$exports.getRouteHash;
var $1594040042302d21$exports = {};
var $27552814fada39bf$exports = {};
"use strict";
var $325ad8ae6f9a8b25$exports = {};
"use strict";
$325ad8ae6f9a8b25$exports = $325ad8ae6f9a8b25$var$bail;
function $325ad8ae6f9a8b25$var$bail(err) {
    if (err) throw err;
}



var $9pg6E = parcelRequire("9pg6E");
var $9189b693d4c784a9$exports = {};
"use strict";
var $9189b693d4c784a9$var$hasOwn = Object.prototype.hasOwnProperty;
var $9189b693d4c784a9$var$toStr = Object.prototype.toString;
var $9189b693d4c784a9$var$defineProperty = Object.defineProperty;
var $9189b693d4c784a9$var$gOPD = Object.getOwnPropertyDescriptor;
var $9189b693d4c784a9$var$isArray = function isArray(arr) {
    if (typeof Array.isArray === "function") return Array.isArray(arr);
    return $9189b693d4c784a9$var$toStr.call(arr) === "[object Array]";
};
var $9189b693d4c784a9$var$isPlainObject = function isPlainObject(obj) {
    if (!obj || $9189b693d4c784a9$var$toStr.call(obj) !== "[object Object]") return false;
    var hasOwnConstructor = $9189b693d4c784a9$var$hasOwn.call(obj, "constructor");
    var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && $9189b693d4c784a9$var$hasOwn.call(obj.constructor.prototype, "isPrototypeOf");
    // Not own constructor property must be Object
    if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) return false;
    // Own properties are enumerated firstly, so to speed up,
    // if last one is own, then all properties are own.
    var key;
    for(key in obj);
    return typeof key === "undefined" || $9189b693d4c784a9$var$hasOwn.call(obj, key);
};
// If name is '__proto__', and Object.defineProperty is available, define __proto__ as an own property on target
var $9189b693d4c784a9$var$setProperty = function setProperty(target, options) {
    if ($9189b693d4c784a9$var$defineProperty && options.name === "__proto__") $9189b693d4c784a9$var$defineProperty(target, options.name, {
        enumerable: true,
        configurable: true,
        value: options.newValue,
        writable: true
    });
    else target[options.name] = options.newValue;
};
// Return undefined instead of __proto__ if '__proto__' is not an own property
var $9189b693d4c784a9$var$getProperty = function getProperty(obj, name) {
    if (name === "__proto__") {
        if (!$9189b693d4c784a9$var$hasOwn.call(obj, name)) return void 0;
        else if ($9189b693d4c784a9$var$gOPD) // In early versions of node, obj['__proto__'] is buggy when obj has
        // __proto__ as an own property. Object.getOwnPropertyDescriptor() works.
        return $9189b693d4c784a9$var$gOPD(obj, name).value;
    }
    return obj[name];
};
$9189b693d4c784a9$exports = function extend() {
    var options, name, src, copy, copyIsArray, clone;
    var target = arguments[0];
    var i = 1;
    var length = arguments.length;
    var deep = false;
    // Handle a deep copy situation
    if (typeof target === "boolean") {
        deep = target;
        target = arguments[1] || {};
        // skip the boolean and the target
        i = 2;
    }
    if (target == null || typeof target !== "object" && typeof target !== "function") target = {};
    for(; i < length; ++i){
        options = arguments[i];
        // Only deal with non-null/undefined values
        if (options != null) // Extend the base object
        for(name in options){
            src = $9189b693d4c784a9$var$getProperty(target, name);
            copy = $9189b693d4c784a9$var$getProperty(options, name);
            // Prevent never-ending loop
            if (target !== copy) {
                // Recurse if we're merging plain objects or arrays
                if (deep && copy && ($9189b693d4c784a9$var$isPlainObject(copy) || (copyIsArray = $9189b693d4c784a9$var$isArray(copy)))) {
                    if (copyIsArray) {
                        copyIsArray = false;
                        clone = src && $9189b693d4c784a9$var$isArray(src) ? src : [];
                    } else clone = src && $9189b693d4c784a9$var$isPlainObject(src) ? src : {};
                    // Never move original objects, clone them
                    $9189b693d4c784a9$var$setProperty(target, {
                        name: name,
                        newValue: extend(deep, clone, copy)
                    });
                // Don't bring in undefined values
                } else if (typeof copy !== "undefined") $9189b693d4c784a9$var$setProperty(target, {
                    name: name,
                    newValue: copy
                });
            }
        }
    }
    // Return the modified object
    return target;
};


var $53c78200ddedfc2d$exports = {};
"use strict";
$53c78200ddedfc2d$exports = (value)=>{
    if (Object.prototype.toString.call(value) !== "[object Object]") return false;
    const prototype = Object.getPrototypeOf(value);
    return prototype === null || prototype === Object.prototype;
};


var $1c96d5fae079a8f1$exports = {};
"use strict";
var $3d0a6448d21d3777$exports = {};
"use strict";
var $3d0a6448d21d3777$var$slice = [].slice;
$3d0a6448d21d3777$exports = $3d0a6448d21d3777$var$wrap;
// Wrap `fn`.
// Can be sync or async; return a promise, receive a completion handler, return
// new values and errors.
function $3d0a6448d21d3777$var$wrap(fn, callback) {
    var invoked;
    return wrapped;
    function wrapped() {
        var params = $3d0a6448d21d3777$var$slice.call(arguments, 0);
        var callback = fn.length > params.length;
        var result;
        if (callback) params.push(done);
        try {
            result = fn.apply(null, params);
        } catch (error) {
            // Well, this is quite the pickle.
            // `fn` received a callback and invoked it (thus continuing the pipeline),
            // but later also threw an error.
            // We’re not about to restart the pipeline again, so the only thing left
            // to do is to throw the thing instead.
            if (callback && invoked) throw error;
            return done(error);
        }
        if (!callback) {
            if (result && typeof result.then === "function") result.then(then, done);
            else if (result instanceof Error) done(result);
            else then(result);
        }
    }
    // Invoke `next`, only once.
    function done() {
        if (!invoked) {
            invoked = true;
            callback.apply(null, arguments);
        }
    }
    // Invoke `done` with one value.
    // Tracks if an error is passed, too.
    function then(value) {
        done(null, value);
    }
}


$1c96d5fae079a8f1$exports = $1c96d5fae079a8f1$var$trough;
$1c96d5fae079a8f1$var$trough.wrap = $3d0a6448d21d3777$exports;
var $1c96d5fae079a8f1$var$slice = [].slice;
// Create new middleware.
function $1c96d5fae079a8f1$var$trough() {
    var fns = [];
    var middleware = {};
    middleware.run = run;
    middleware.use = use;
    return middleware;
    // Run `fns`.  Last argument must be a completion handler.
    function run() {
        var index = -1;
        var input = $1c96d5fae079a8f1$var$slice.call(arguments, 0, -1);
        var done = arguments[arguments.length - 1];
        if (typeof done !== "function") throw new Error("Expected function as last argument, not " + done);
        next.apply(null, [
            null
        ].concat(input));
        // Run the next `fn`, if any.
        function next(err) {
            var fn = fns[++index];
            var params = $1c96d5fae079a8f1$var$slice.call(arguments, 0);
            var values = params.slice(1);
            var length = input.length;
            var pos = -1;
            if (err) {
                done(err);
                return;
            }
            // Copy non-nully input into values.
            while(++pos < length)if (values[pos] === null || values[pos] === undefined) values[pos] = input[pos];
            input = values;
            // Next or done.
            if (fn) $3d0a6448d21d3777$exports(fn, next).apply(null, input);
            else done.apply(null, [
                null
            ].concat(input));
        }
    }
    // Add `fn` to the list.
    function use(fn) {
        if (typeof fn !== "function") throw new Error("Expected `fn` to be a function, not " + fn);
        fns.push(fn);
        return middleware;
    }
}


var $2e83faa16f175bcb$exports = {};
"use strict";

$2e83faa16f175bcb$exports = (parcelRequire("iDD18"));


// Expose a frozen processor.
$27552814fada39bf$exports = $27552814fada39bf$var$unified().freeze();
var $27552814fada39bf$var$slice = [].slice;
var $27552814fada39bf$var$own = {}.hasOwnProperty;
// Process pipeline.
var $27552814fada39bf$var$pipeline = $1c96d5fae079a8f1$exports().use($27552814fada39bf$var$pipelineParse).use($27552814fada39bf$var$pipelineRun).use($27552814fada39bf$var$pipelineStringify);
function $27552814fada39bf$var$pipelineParse(p, ctx) {
    ctx.tree = p.parse(ctx.file);
}
function $27552814fada39bf$var$pipelineRun(p, ctx, next) {
    p.run(ctx.tree, ctx.file, done);
    function done(err, tree, file) {
        if (err) next(err);
        else {
            ctx.tree = tree;
            ctx.file = file;
            next();
        }
    }
}
function $27552814fada39bf$var$pipelineStringify(p, ctx) {
    var result = p.stringify(ctx.tree, ctx.file);
    var file = ctx.file;
    if (result === undefined || result === null) ;
    else if (typeof result === "string" || $9pg6E(result)) file.contents = result;
    else file.result = result;
}
// Function to create the first processor.
function $27552814fada39bf$var$unified() {
    var attachers = [];
    var transformers = $1c96d5fae079a8f1$exports();
    var namespace = {};
    var frozen = false;
    var freezeIndex = -1;
    // Data management.
    processor.data = data;
    // Lock.
    processor.freeze = freeze;
    // Plugins.
    processor.attachers = attachers;
    processor.use = use;
    // API.
    processor.parse = parse;
    processor.stringify = stringify;
    processor.run = run;
    processor.runSync = runSync;
    processor.process = process;
    processor.processSync = processSync;
    // Expose.
    return processor;
    // Create a new processor based on the processor in the current scope.
    function processor() {
        var destination = $27552814fada39bf$var$unified();
        var length = attachers.length;
        var index = -1;
        while(++index < length)destination.use.apply(null, attachers[index]);
        destination.data($9189b693d4c784a9$exports(true, {}, namespace));
        return destination;
    }
    // Freeze: used to signal a processor that has finished configuration.
    //
    // For example, take unified itself: it’s frozen.
    // Plugins should not be added to it.
    // Rather, it should be extended, by invoking it, before modifying it.
    //
    // In essence, always invoke this when exporting a processor.
    function freeze() {
        var values;
        var plugin;
        var options;
        var transformer;
        if (frozen) return processor;
        while(++freezeIndex < attachers.length){
            values = attachers[freezeIndex];
            plugin = values[0];
            options = values[1];
            transformer = null;
            if (options === false) continue;
            if (options === true) values[1] = undefined;
            transformer = plugin.apply(processor, values.slice(1));
            if (typeof transformer === "function") transformers.use(transformer);
        }
        frozen = true;
        freezeIndex = Infinity;
        return processor;
    }
    // Data management.
    // Getter / setter for processor-specific informtion.
    function data(key, value) {
        if (typeof key === "string") {
            // Set `key`.
            if (arguments.length === 2) {
                $27552814fada39bf$var$assertUnfrozen("data", frozen);
                namespace[key] = value;
                return processor;
            }
            // Get `key`.
            return $27552814fada39bf$var$own.call(namespace, key) && namespace[key] || null;
        }
        // Set space.
        if (key) {
            $27552814fada39bf$var$assertUnfrozen("data", frozen);
            namespace = key;
            return processor;
        }
        // Get space.
        return namespace;
    }
    // Plugin management.
    //
    // Pass it:
    // *   an attacher and options,
    // *   a preset,
    // *   a list of presets, attachers, and arguments (list of attachers and
    //     options).
    function use(value) {
        var settings;
        $27552814fada39bf$var$assertUnfrozen("use", frozen);
        if (value === null || value === undefined) ;
        else if (typeof value === "function") addPlugin.apply(null, arguments);
        else if (typeof value === "object") {
            if ("length" in value) addList(value);
            else addPreset(value);
        } else throw new Error("Expected usable value, not `" + value + "`");
        if (settings) namespace.settings = $9189b693d4c784a9$exports(namespace.settings || {}, settings);
        return processor;
        function addPreset(result) {
            addList(result.plugins);
            if (result.settings) settings = $9189b693d4c784a9$exports(settings || {}, result.settings);
        }
        function add(value) {
            if (typeof value === "function") addPlugin(value);
            else if (typeof value === "object") {
                if ("length" in value) addPlugin.apply(null, value);
                else addPreset(value);
            } else throw new Error("Expected usable value, not `" + value + "`");
        }
        function addList(plugins) {
            var length;
            var index;
            if (plugins === null || plugins === undefined) ;
            else if (typeof plugins === "object" && "length" in plugins) {
                length = plugins.length;
                index = -1;
                while(++index < length)add(plugins[index]);
            } else throw new Error("Expected a list of plugins, not `" + plugins + "`");
        }
        function addPlugin(plugin, value) {
            var entry = find(plugin);
            if (entry) {
                if ($53c78200ddedfc2d$exports(entry[1]) && $53c78200ddedfc2d$exports(value)) value = $9189b693d4c784a9$exports(entry[1], value);
                entry[1] = value;
            } else attachers.push($27552814fada39bf$var$slice.call(arguments));
        }
    }
    function find(plugin) {
        var length = attachers.length;
        var index = -1;
        var entry;
        while(++index < length){
            entry = attachers[index];
            if (entry[0] === plugin) return entry;
        }
    }
    // Parse a file (in string or vfile representation) into a unist node using
    // the `Parser` on the processor.
    function parse(doc) {
        var file = $2e83faa16f175bcb$exports(doc);
        var Parser;
        freeze();
        Parser = processor.Parser;
        $27552814fada39bf$var$assertParser("parse", Parser);
        if ($27552814fada39bf$var$newable(Parser, "parse")) return new Parser(String(file), file).parse();
        return Parser(String(file), file) // eslint-disable-line new-cap
        ;
    }
    // Run transforms on a unist node representation of a file (in string or
    // vfile representation), async.
    function run(node, file, cb) {
        $27552814fada39bf$var$assertNode(node);
        freeze();
        if (!cb && typeof file === "function") {
            cb = file;
            file = null;
        }
        if (!cb) return new Promise(executor);
        executor(null, cb);
        function executor(resolve, reject) {
            transformers.run(node, $2e83faa16f175bcb$exports(file), done);
            function done(err, tree, file) {
                tree = tree || node;
                if (err) reject(err);
                else if (resolve) resolve(tree);
                else cb(null, tree, file);
            }
        }
    }
    // Run transforms on a unist node representation of a file (in string or
    // vfile representation), sync.
    function runSync(node, file) {
        var complete = false;
        var result;
        run(node, file, done);
        $27552814fada39bf$var$assertDone("runSync", "run", complete);
        return result;
        function done(err, tree) {
            complete = true;
            $325ad8ae6f9a8b25$exports(err);
            result = tree;
        }
    }
    // Stringify a unist node representation of a file (in string or vfile
    // representation) into a string using the `Compiler` on the processor.
    function stringify(node, doc) {
        var file = $2e83faa16f175bcb$exports(doc);
        var Compiler;
        freeze();
        Compiler = processor.Compiler;
        $27552814fada39bf$var$assertCompiler("stringify", Compiler);
        $27552814fada39bf$var$assertNode(node);
        if ($27552814fada39bf$var$newable(Compiler, "compile")) return new Compiler(node, file).compile();
        return Compiler(node, file) // eslint-disable-line new-cap
        ;
    }
    // Parse a file (in string or vfile representation) into a unist node using
    // the `Parser` on the processor, then run transforms on that node, and
    // compile the resulting node using the `Compiler` on the processor, and
    // store that result on the vfile.
    function process(doc, cb) {
        freeze();
        $27552814fada39bf$var$assertParser("process", processor.Parser);
        $27552814fada39bf$var$assertCompiler("process", processor.Compiler);
        if (!cb) return new Promise(executor);
        executor(null, cb);
        function executor(resolve, reject) {
            var file = $2e83faa16f175bcb$exports(doc);
            $27552814fada39bf$var$pipeline.run(processor, {
                file: file
            }, done);
            function done(err) {
                if (err) reject(err);
                else if (resolve) resolve(file);
                else cb(null, file);
            }
        }
    }
    // Process the given document (in string or vfile representation), sync.
    function processSync(doc) {
        var complete = false;
        var file;
        freeze();
        $27552814fada39bf$var$assertParser("processSync", processor.Parser);
        $27552814fada39bf$var$assertCompiler("processSync", processor.Compiler);
        file = $2e83faa16f175bcb$exports(doc);
        process(file, done);
        $27552814fada39bf$var$assertDone("processSync", "process", complete);
        return file;
        function done(err) {
            complete = true;
            $325ad8ae6f9a8b25$exports(err);
        }
    }
}
// Check if `value` is a constructor.
function $27552814fada39bf$var$newable(value, name) {
    return typeof value === "function" && value.prototype && // A function with keys in its prototype is probably a constructor.
    // Classes’ prototype methods are not enumerable, so we check if some value
    // exists in the prototype.
    ($27552814fada39bf$var$keys(value.prototype) || name in value.prototype);
}
// Check if `value` is an object with keys.
function $27552814fada39bf$var$keys(value) {
    var key;
    for(key in value)return true;
    return false;
}
// Assert a parser is available.
function $27552814fada39bf$var$assertParser(name, Parser) {
    if (typeof Parser !== "function") throw new Error("Cannot `" + name + "` without `Parser`");
}
// Assert a compiler is available.
function $27552814fada39bf$var$assertCompiler(name, Compiler) {
    if (typeof Compiler !== "function") throw new Error("Cannot `" + name + "` without `Compiler`");
}
// Assert the processor is not frozen.
function $27552814fada39bf$var$assertUnfrozen(name, frozen) {
    if (frozen) throw new Error("Cannot invoke `" + name + "` on a frozen processor.\nCreate a new processor first, by invoking it: use `processor()` instead of `processor`.");
}
// Assert `node` is a unist node.
function $27552814fada39bf$var$assertNode(node) {
    if (!node || typeof node.type !== "string") throw new Error("Expected node, got `" + node + "`");
}
// Assert that `complete` is `true`.
function $27552814fada39bf$var$assertDone(name, asyncName, complete) {
    if (!complete) throw new Error("`" + name + "` finished async. Use `" + asyncName + "` instead");
}


var $ae7509fecc2740de$exports = {};
"use strict";
var $16da83320bc1a191$exports = {};
"use strict";

var $l7d6x = parcelRequire("l7d6x");
var $6dad5de6baded148$exports = {};


try {
    var $6dad5de6baded148$var$util = $6dad5de6baded148$import$1706da53f7e85fa1;
    /* istanbul ignore next */ if (typeof $6dad5de6baded148$var$util.inherits !== "function") throw "";
    $6dad5de6baded148$exports = $6dad5de6baded148$var$util.inherits;
} catch (e) {
    /* istanbul ignore next */ $6dad5de6baded148$exports = (parcelRequire("28zcN"));
}


$16da83320bc1a191$exports = $16da83320bc1a191$var$unherit;
// Create a custom constructor which can be modified without affecting the
// original class.
function $16da83320bc1a191$var$unherit(Super) {
    var result;
    var key;
    var value;
    $6dad5de6baded148$exports(Of, Super);
    $6dad5de6baded148$exports(From, Of);
    // Clone values.
    result = Of.prototype;
    for(key in result){
        value = result[key];
        if (value && typeof value === "object") result[key] = "concat" in value ? value.concat() : $l7d6x(value);
    }
    return Of;
    // Constructor accepting a single argument, which itself is an `arguments`
    // object.
    function From(parameters) {
        return Super.apply(this, parameters);
    }
    // Constructor accepting variadic arguments.
    function Of() {
        if (!(this instanceof Of)) return new From(arguments);
        return Super.apply(this, arguments);
    }
}



var $l7d6x = parcelRequire("l7d6x");
var $c71162ffa2a4dbe3$exports = {};
"use strict";

var $l7d6x = parcelRequire("l7d6x");
var $a14f5cd402fabd82$exports = {};
"use strict";
$a14f5cd402fabd82$exports = $a14f5cd402fabd82$var$factory;
// Construct a state `toggler`: a function which inverses `property` in context
// based on its current value.
// The by `toggler` returned function restores that value.
function $a14f5cd402fabd82$var$factory(key, state, ctx) {
    return enter;
    function enter() {
        var context = ctx || this;
        var current = context[key];
        context[key] = !state;
        return exit;
        function exit() {
            context[key] = current;
        }
    }
}


var $1ee545530e3c2b4d$exports = {};
"use strict";
$1ee545530e3c2b4d$exports = $1ee545530e3c2b4d$var$factory;
function $1ee545530e3c2b4d$var$factory(file) {
    var value = String(file);
    var indices = [];
    var search = /\r?\n|\r/g;
    while(search.exec(value))indices.push(search.lastIndex);
    indices.push(value.length + 1);
    return {
        toPoint: offsetToPoint,
        toPosition: offsetToPoint,
        toOffset: pointToOffset
    };
    // Get the line and column-based `point` for `offset` in the bound indices.
    function offsetToPoint(offset) {
        var index = -1;
        if (offset > -1 && offset < indices[indices.length - 1]) while(++index < indices.length){
            if (indices[index] > offset) return {
                line: index + 1,
                column: offset - (indices[index - 1] || 0) + 1,
                offset: offset
            };
        }
        return {};
    }
    // Get the `offset` for a line and column-based `point` in the bound
    // indices.
    function pointToOffset(point) {
        var line = point && point.line;
        var column = point && point.column;
        var offset;
        if (!isNaN(line) && !isNaN(column) && line - 1 in indices) offset = (indices[line - 2] || 0) + column - 1 || 0;
        return offset > -1 && offset < indices[indices.length - 1] ? offset : -1;
    }
}


var $2173c7325b0626fb$exports = {};
"use strict";
$2173c7325b0626fb$exports = $2173c7325b0626fb$var$factory;
var $2173c7325b0626fb$var$backslash = "\\";
// Factory to de-escape a value, based on a list at `key` in `ctx`.
function $2173c7325b0626fb$var$factory(ctx, key) {
    return unescape;
    // De-escape a string using the expression at `key` in `ctx`.
    function unescape(value) {
        var previous = 0;
        var index = value.indexOf($2173c7325b0626fb$var$backslash);
        var escape = ctx[key];
        var queue = [];
        var character;
        while(index !== -1){
            queue.push(value.slice(previous, index));
            previous = index + 1;
            character = value.charAt(previous);
            // If the following character is not a valid escape, add the slash.
            if (!character || escape.indexOf(character) === -1) queue.push($2173c7325b0626fb$var$backslash);
            index = value.indexOf($2173c7325b0626fb$var$backslash, previous + 1);
        }
        queue.push(value.slice(previous));
        return queue.join("");
    }
}


var $2a2858cd7c1876ad$exports = {};
"use strict";

var $l7d6x = parcelRequire("l7d6x");

var $gYcXs = parcelRequire("gYcXs");
$2a2858cd7c1876ad$exports = $2a2858cd7c1876ad$var$factory;
// Factory to create an entity decoder.
function $2a2858cd7c1876ad$var$factory(ctx) {
    decoder.raw = decodeRaw;
    return decoder;
    // Normalize `position` to add an `indent`.
    function normalize(position) {
        var offsets = ctx.offset;
        var line = position.line;
        var result = [];
        while(++line){
            if (!(line in offsets)) break;
            result.push((offsets[line] || 0) + 1);
        }
        return {
            start: position,
            indent: result
        };
    }
    // Decode `value` (at `position`) into text-nodes.
    function decoder(value, position, handler) {
        $gYcXs(value, {
            position: normalize(position),
            warning: handleWarning,
            text: handler,
            reference: handler,
            textContext: ctx,
            referenceContext: ctx
        });
    }
    // Decode `value` (at `position`) into a string.
    function decodeRaw(value, position, options) {
        return $gYcXs(value, $l7d6x(options, {
            position: normalize(position),
            warning: handleWarning
        }));
    }
    // Handle a warning.
    // See <https://github.com/wooorm/parse-entities> for the warnings.
    function handleWarning(reason, position, code) {
        if (code !== 3) ctx.file.message(reason, position);
    }
}


var $70333de19f349c8c$exports = {};
"use strict";
$70333de19f349c8c$exports = $70333de19f349c8c$var$factory;
// Construct a tokenizer.  This creates both `tokenizeInline` and `tokenizeBlock`.
function $70333de19f349c8c$var$factory(type) {
    return tokenize;
    // Tokenizer for a bound `type`.
    function tokenize(value, location) {
        var self = this;
        var offset = self.offset;
        var tokens = [];
        var methods = self[type + "Methods"];
        var tokenizers = self[type + "Tokenizers"];
        var line = location.line;
        var column = location.column;
        var index;
        var length;
        var method;
        var name;
        var matched;
        var valueLength;
        // Trim white space only lines.
        if (!value) return tokens;
        // Expose on `eat`.
        eat.now = now;
        eat.file = self.file;
        // Sync initial offset.
        updatePosition("");
        // Iterate over `value`, and iterate over all tokenizers.  When one eats
        // something, re-iterate with the remaining value.  If no tokenizer eats,
        // something failed (should not happen) and an exception is thrown.
        while(value){
            index = -1;
            length = methods.length;
            matched = false;
            while(++index < length){
                name = methods[index];
                method = tokenizers[name];
                // Previously, we had constructs such as footnotes and YAML that used
                // these properties.
                // Those are now external (plus there are userland extensions), that may
                // still use them.
                if (method && /* istanbul ignore next */ (!method.onlyAtStart || self.atStart) && /* istanbul ignore next */ (!method.notInList || !self.inList) && /* istanbul ignore next */ (!method.notInBlock || !self.inBlock) && (!method.notInLink || !self.inLink)) {
                    valueLength = value.length;
                    method.apply(self, [
                        eat,
                        value
                    ]);
                    matched = valueLength !== value.length;
                    if (matched) break;
                }
            }
            /* istanbul ignore if */ if (!matched) self.file.fail(new Error("Infinite loop"), eat.now());
        }
        self.eof = now();
        return tokens;
        // Update line, column, and offset based on `value`.
        function updatePosition(subvalue) {
            var lastIndex = -1;
            var index = subvalue.indexOf("\n");
            while(index !== -1){
                line++;
                lastIndex = index;
                index = subvalue.indexOf("\n", index + 1);
            }
            if (lastIndex === -1) column += subvalue.length;
            else column = subvalue.length - lastIndex;
            if (line in offset) {
                if (lastIndex !== -1) column += offset[line];
                else if (column <= offset[line]) column = offset[line] + 1;
            }
        }
        // Get offset.  Called before the first character is eaten to retrieve the
        // range’s offsets.
        function getOffset() {
            var indentation = [];
            var pos = line + 1;
            // Done.  Called when the last character is eaten to retrieve the range’s
            // offsets.
            return function() {
                var last = line + 1;
                while(pos < last){
                    indentation.push((offset[pos] || 0) + 1);
                    pos++;
                }
                return indentation;
            };
        }
        // Get the current position.
        function now() {
            var pos = {
                line: line,
                column: column
            };
            pos.offset = self.toOffset(pos);
            return pos;
        }
        // Store position information for a node.
        function Position(start) {
            this.start = start;
            this.end = now();
        }
        // Throw when a value is incorrectly eaten.  This shouldn’t happen but will
        // throw on new, incorrect rules.
        function validateEat(subvalue) {
            /* istanbul ignore if */ if (value.slice(0, subvalue.length) !== subvalue) // Capture stack-trace.
            self.file.fail(new Error("Incorrectly eaten value: please report this warning on https://git.io/vg5Ft"), now());
        }
        // Mark position and patch `node.position`.
        function position() {
            var before = now();
            return update;
            // Add the position to a node.
            function update(node, indent) {
                var previous = node.position;
                var start = previous ? previous.start : before;
                var combined = [];
                var n = previous && previous.end.line;
                var l = before.line;
                node.position = new Position(start);
                // If there was already a `position`, this node was merged.  Fixing
                // `start` wasn’t hard, but the indent is different.  Especially
                // because some information, the indent between `n` and `l` wasn’t
                // tracked.  Luckily, that space is (should be?) empty, so we can
                // safely check for it now.
                if (previous && indent && previous.indent) {
                    combined = previous.indent;
                    if (n < l) {
                        while(++n < l)combined.push((offset[n] || 0) + 1);
                        combined.push(before.column);
                    }
                    indent = combined.concat(indent);
                }
                node.position.indent = indent || [];
                return node;
            }
        }
        // Add `node` to `parent`s children or to `tokens`.  Performs merges where
        // possible.
        function add(node, parent) {
            var children = parent ? parent.children : tokens;
            var previous = children[children.length - 1];
            var fn;
            if (previous && node.type === previous.type && (node.type === "text" || node.type === "blockquote") && $70333de19f349c8c$var$mergeable(previous) && $70333de19f349c8c$var$mergeable(node)) {
                fn = node.type === "text" ? $70333de19f349c8c$var$mergeText : $70333de19f349c8c$var$mergeBlockquote;
                node = fn.call(self, previous, node);
            }
            if (node !== previous) children.push(node);
            if (self.atStart && tokens.length !== 0) self.exitStart();
            return node;
        }
        // Remove `subvalue` from `value`.  `subvalue` must be at the start of
        // `value`.
        function eat(subvalue) {
            var indent = getOffset();
            var pos = position();
            var current = now();
            validateEat(subvalue);
            apply.reset = reset;
            reset.test = test;
            apply.test = test;
            value = value.slice(subvalue.length);
            updatePosition(subvalue);
            indent = indent();
            return apply;
            // Add the given arguments, add `position` to the returned node, and
            // return the node.
            function apply(node, parent) {
                return pos(add(pos(node), parent), indent);
            }
            // Functions just like apply, but resets the content: the line and
            // column are reversed, and the eaten value is re-added.   This is
            // useful for nodes with a single type of content, such as lists and
            // tables.  See `apply` above for what parameters are expected.
            function reset() {
                var node = apply.apply(null, arguments);
                line = current.line;
                column = current.column;
                value = subvalue + value;
                return node;
            }
            // Test the position, after eating, and reverse to a not-eaten state.
            function test() {
                var result = pos({});
                line = current.line;
                column = current.column;
                value = subvalue + value;
                return result.position;
            }
        }
    }
}
// Check whether a node is mergeable with adjacent nodes.
function $70333de19f349c8c$var$mergeable(node) {
    var start;
    var end;
    if (node.type !== "text" || !node.position) return true;
    start = node.position.start;
    end = node.position.end;
    // Only merge nodes which occupy the same size as their `value`.
    return start.line !== end.line || end.column - start.column === node.value.length;
}
// Merge two text nodes: `node` into `prev`.
function $70333de19f349c8c$var$mergeText(previous, node) {
    previous.value += node.value;
    return previous;
}
// Merge two blockquotes: `node` into `prev`, unless in CommonMark or gfm modes.
function $70333de19f349c8c$var$mergeBlockquote(previous, node) {
    if (this.options.commonmark || this.options.gfm) return node;
    previous.children = previous.children.concat(node.children);
    return previous;
}


$c71162ffa2a4dbe3$exports = $c71162ffa2a4dbe3$var$Parser;
function $c71162ffa2a4dbe3$var$Parser(doc, file) {
    this.file = file;
    this.offset = {};
    this.options = $l7d6x(this.options);
    this.setOptions({});
    this.inList = false;
    this.inBlock = false;
    this.inLink = false;
    this.atStart = true;
    this.toOffset = $1ee545530e3c2b4d$exports(file).toOffset;
    this.unescape = $2173c7325b0626fb$exports(this, "escape");
    this.decode = $2a2858cd7c1876ad$exports(this);
}
var $c71162ffa2a4dbe3$var$proto = $c71162ffa2a4dbe3$var$Parser.prototype;

// Expose core.
$c71162ffa2a4dbe3$var$proto.setOptions = (parcelRequire("lziKw"));

$c71162ffa2a4dbe3$var$proto.parse = (parcelRequire("iJz74"));

// Expose `defaults`.
$c71162ffa2a4dbe3$var$proto.options = (parcelRequire("hljKK"));
// Enter and exit helpers.
$c71162ffa2a4dbe3$var$proto.exitStart = $a14f5cd402fabd82$exports("atStart", true);
$c71162ffa2a4dbe3$var$proto.enterList = $a14f5cd402fabd82$exports("inList", false);
$c71162ffa2a4dbe3$var$proto.enterLink = $a14f5cd402fabd82$exports("inLink", false);
$c71162ffa2a4dbe3$var$proto.enterBlock = $a14f5cd402fabd82$exports("inBlock", false);
// Nodes that can interupt a paragraph:
//
// ```markdown
// A paragraph, followed by a thematic break.
// ___
// ```
//
// In the above example, the thematic break “interupts” the paragraph.
$c71162ffa2a4dbe3$var$proto.interruptParagraph = [
    [
        "thematicBreak"
    ],
    [
        "list"
    ],
    [
        "atxHeading"
    ],
    [
        "fencedCode"
    ],
    [
        "blockquote"
    ],
    [
        "html"
    ],
    [
        "setextHeading",
        {
            commonmark: false
        }
    ],
    [
        "definition",
        {
            commonmark: false
        }
    ]
];
// Nodes that can interupt a list:
//
// ```markdown
// - One
// ___
// ```
//
// In the above example, the thematic break “interupts” the list.
$c71162ffa2a4dbe3$var$proto.interruptList = [
    [
        "atxHeading",
        {
            pedantic: false
        }
    ],
    [
        "fencedCode",
        {
            pedantic: false
        }
    ],
    [
        "thematicBreak",
        {
            pedantic: false
        }
    ],
    [
        "definition",
        {
            commonmark: false
        }
    ]
];
// Nodes that can interupt a blockquote:
//
// ```markdown
// > A paragraph.
// ___
// ```
//
// In the above example, the thematic break “interupts” the blockquote.
$c71162ffa2a4dbe3$var$proto.interruptBlockquote = [
    [
        "indentedCode",
        {
            commonmark: true
        }
    ],
    [
        "fencedCode",
        {
            commonmark: true
        }
    ],
    [
        "atxHeading",
        {
            commonmark: true
        }
    ],
    [
        "setextHeading",
        {
            commonmark: true
        }
    ],
    [
        "thematicBreak",
        {
            commonmark: true
        }
    ],
    [
        "html",
        {
            commonmark: true
        }
    ],
    [
        "list",
        {
            commonmark: true
        }
    ],
    [
        "definition",
        {
            commonmark: false
        }
    ]
];












// Handlers.
$c71162ffa2a4dbe3$var$proto.blockTokenizers = {
    blankLine: (parcelRequire("2ywBB")),
    indentedCode: (parcelRequire("ht18v")),
    fencedCode: (parcelRequire("dehwG")),
    blockquote: (parcelRequire("8pQ2R")),
    atxHeading: (parcelRequire("8lsyk")),
    thematicBreak: (parcelRequire("jsWmx")),
    list: (parcelRequire("bddsb")),
    setextHeading: (parcelRequire("01T1z")),
    html: (parcelRequire("hJSi4")),
    definition: (parcelRequire("h5OtA")),
    table: (parcelRequire("23Qvg")),
    paragraph: (parcelRequire("dwiBC"))
};













$c71162ffa2a4dbe3$var$proto.inlineTokenizers = {
    escape: (parcelRequire("4Ueka")),
    autoLink: (parcelRequire("bOmlb")),
    url: (parcelRequire("7qwWb")),
    email: (parcelRequire("4DPeL")),
    html: (parcelRequire("8MZNG")),
    link: (parcelRequire("qmr7W")),
    reference: (parcelRequire("4JOvC")),
    strong: (parcelRequire("adw3U")),
    emphasis: (parcelRequire("9Y0N7")),
    deletion: (parcelRequire("9OC3l")),
    code: (parcelRequire("4vCYF")),
    break: (parcelRequire("1ZgN2")),
    text: (parcelRequire("2VPr6"))
};
// Expose precedence.
$c71162ffa2a4dbe3$var$proto.blockMethods = $c71162ffa2a4dbe3$var$keys($c71162ffa2a4dbe3$var$proto.blockTokenizers);
$c71162ffa2a4dbe3$var$proto.inlineMethods = $c71162ffa2a4dbe3$var$keys($c71162ffa2a4dbe3$var$proto.inlineTokenizers);
// Tokenizers.
$c71162ffa2a4dbe3$var$proto.tokenizeBlock = $70333de19f349c8c$exports("block");
$c71162ffa2a4dbe3$var$proto.tokenizeInline = $70333de19f349c8c$exports("inline");
$c71162ffa2a4dbe3$var$proto.tokenizeFactory = $70333de19f349c8c$exports;
// Get all keys in `value`.
function $c71162ffa2a4dbe3$var$keys(value) {
    var result = [];
    var key;
    for(key in value)result.push(key);
    return result;
}


$ae7509fecc2740de$exports = $ae7509fecc2740de$var$parse;
$ae7509fecc2740de$var$parse.Parser = $c71162ffa2a4dbe3$exports;
function $ae7509fecc2740de$var$parse(options) {
    var settings = this.data("settings");
    var Local = $16da83320bc1a191$exports($c71162ffa2a4dbe3$exports);
    Local.prototype.options = $l7d6x(Local.prototype.options, settings, options);
    this.Parser = Local;
}



var $cGAg2 = parcelRequire("cGAg2");



var $i09cj = parcelRequire("i09cj");
var $1594040042302d21$require$parseFrontmatter = $i09cj.parseFrontmatter;
var $178603cf4f85cdeb$exports = {};
"use strict";

var $21oST = parcelRequire("21oST");
var $0567d90f1fca1a69$exports = {};
"use strict";


var $970f87b72e936edf$exports = {};
"use strict";
$970f87b72e936edf$exports = (flag, argv = process.argv)=>{
    const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
    const position = argv.indexOf(prefix + flag);
    const terminatorPosition = argv.indexOf("--");
    return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
};


const { env: $0567d90f1fca1a69$var$env } = process;
let $0567d90f1fca1a69$var$forceColor;
if ($970f87b72e936edf$exports("no-color") || $970f87b72e936edf$exports("no-colors") || $970f87b72e936edf$exports("color=false") || $970f87b72e936edf$exports("color=never")) $0567d90f1fca1a69$var$forceColor = 0;
else if ($970f87b72e936edf$exports("color") || $970f87b72e936edf$exports("colors") || $970f87b72e936edf$exports("color=true") || $970f87b72e936edf$exports("color=always")) $0567d90f1fca1a69$var$forceColor = 1;
if ("FORCE_COLOR" in $0567d90f1fca1a69$var$env) {
    if ($0567d90f1fca1a69$var$env.FORCE_COLOR === "true") $0567d90f1fca1a69$var$forceColor = 1;
    else if ($0567d90f1fca1a69$var$env.FORCE_COLOR === "false") $0567d90f1fca1a69$var$forceColor = 0;
    else $0567d90f1fca1a69$var$forceColor = $0567d90f1fca1a69$var$env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt($0567d90f1fca1a69$var$env.FORCE_COLOR, 10), 3);
}
function $0567d90f1fca1a69$var$translateLevel(level) {
    if (level === 0) return false;
    return {
        level: level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
    };
}
function $0567d90f1fca1a69$var$supportsColor(haveStream, streamIsTTY) {
    if ($0567d90f1fca1a69$var$forceColor === 0) return 0;
    if ($970f87b72e936edf$exports("color=16m") || $970f87b72e936edf$exports("color=full") || $970f87b72e936edf$exports("color=truecolor")) return 3;
    if ($970f87b72e936edf$exports("color=256")) return 2;
    if (haveStream && !streamIsTTY && $0567d90f1fca1a69$var$forceColor === undefined) return 0;
    const min = $0567d90f1fca1a69$var$forceColor || 0;
    if ($0567d90f1fca1a69$var$env.TERM === "dumb") return min;
    if (process.platform === "win32") {
        // Windows 10 build 10586 is the first Windows release that supports 256 colors.
        // Windows 10 build 14931 is the first release that supports 16m/TrueColor.
        const osRelease = $773sa$release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) return Number(osRelease[2]) >= 14931 ? 3 : 2;
        return 1;
    }
    if ("CI" in $0567d90f1fca1a69$var$env) {
        if ([
            "TRAVIS",
            "CIRCLECI",
            "APPVEYOR",
            "GITLAB_CI",
            "GITHUB_ACTIONS",
            "BUILDKITE"
        ].some((sign)=>sign in $0567d90f1fca1a69$var$env) || $0567d90f1fca1a69$var$env.CI_NAME === "codeship") return 1;
        return min;
    }
    if ("TEAMCITY_VERSION" in $0567d90f1fca1a69$var$env) return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test($0567d90f1fca1a69$var$env.TEAMCITY_VERSION) ? 1 : 0;
    if ($0567d90f1fca1a69$var$env.COLORTERM === "truecolor") return 3;
    if ("TERM_PROGRAM" in $0567d90f1fca1a69$var$env) {
        const version = parseInt(($0567d90f1fca1a69$var$env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch($0567d90f1fca1a69$var$env.TERM_PROGRAM){
            case "iTerm.app":
                return version >= 3 ? 3 : 2;
            case "Apple_Terminal":
                return 2;
        }
    }
    if (/-256(color)?$/i.test($0567d90f1fca1a69$var$env.TERM)) return 2;
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test($0567d90f1fca1a69$var$env.TERM)) return 1;
    if ("COLORTERM" in $0567d90f1fca1a69$var$env) return 1;
    return min;
}
function $0567d90f1fca1a69$var$getSupportLevel(stream) {
    const level = $0567d90f1fca1a69$var$supportsColor(stream, stream && stream.isTTY);
    return $0567d90f1fca1a69$var$translateLevel(level);
}
$0567d90f1fca1a69$exports = {
    supportsColor: $0567d90f1fca1a69$var$getSupportLevel,
    stdout: $0567d90f1fca1a69$var$translateLevel($0567d90f1fca1a69$var$supportsColor(true, $773sa$isatty(1))),
    stderr: $0567d90f1fca1a69$var$translateLevel($0567d90f1fca1a69$var$supportsColor(true, $773sa$isatty(2)))
};


var $178603cf4f85cdeb$require$stdoutColor = $0567d90f1fca1a69$exports.stdout;
var $178603cf4f85cdeb$require$stderrColor = $0567d90f1fca1a69$exports.stderr;
var $8b38d370b44d71d9$exports = {};
"use strict";
const $8b38d370b44d71d9$var$stringReplaceAll = (string, substring, replacer)=>{
    let index = string.indexOf(substring);
    if (index === -1) return string;
    const substringLength = substring.length;
    let endIndex = 0;
    let returnValue = "";
    do {
        returnValue += string.substr(endIndex, index - endIndex) + substring + replacer;
        endIndex = index + substringLength;
        index = string.indexOf(substring, endIndex);
    }while (index !== -1);
    returnValue += string.substr(endIndex);
    return returnValue;
};
const $8b38d370b44d71d9$var$stringEncaseCRLFWithFirstIndex = (string, prefix, postfix, index)=>{
    let endIndex = 0;
    let returnValue = "";
    do {
        const gotCR = string[index - 1] === "\r";
        returnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
        endIndex = index + 1;
        index = string.indexOf("\n", endIndex);
    }while (index !== -1);
    returnValue += string.substr(endIndex);
    return returnValue;
};
$8b38d370b44d71d9$exports = {
    stringReplaceAll: $8b38d370b44d71d9$var$stringReplaceAll,
    stringEncaseCRLFWithFirstIndex: $8b38d370b44d71d9$var$stringEncaseCRLFWithFirstIndex
};


var $178603cf4f85cdeb$require$stringReplaceAll = $8b38d370b44d71d9$exports.stringReplaceAll;
var $178603cf4f85cdeb$require$stringEncaseCRLFWithFirstIndex = $8b38d370b44d71d9$exports.stringEncaseCRLFWithFirstIndex;
const { isArray: $178603cf4f85cdeb$var$isArray } = Array;
// `supportsColor.level` → `ansiStyles.color[name]` mapping
const $178603cf4f85cdeb$var$levelMapping = [
    "ansi",
    "ansi",
    "ansi256",
    "ansi16m"
];
const $178603cf4f85cdeb$var$styles = Object.create(null);
const $178603cf4f85cdeb$var$applyOptions = (object, options = {})=>{
    if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) throw new Error("The `level` option should be an integer from 0 to 3");
    // Detect level if not set manually
    const colorLevel = $178603cf4f85cdeb$require$stdoutColor ? $178603cf4f85cdeb$require$stdoutColor.level : 0;
    object.level = options.level === undefined ? colorLevel : options.level;
};
class $178603cf4f85cdeb$var$ChalkClass {
    constructor(options){
        // eslint-disable-next-line no-constructor-return
        return $178603cf4f85cdeb$var$chalkFactory(options);
    }
}
const $178603cf4f85cdeb$var$chalkFactory = (options)=>{
    const chalk = {};
    $178603cf4f85cdeb$var$applyOptions(chalk, options);
    chalk.template = (...arguments_)=>$178603cf4f85cdeb$var$chalkTag(chalk.template, ...arguments_);
    Object.setPrototypeOf(chalk, $178603cf4f85cdeb$var$Chalk.prototype);
    Object.setPrototypeOf(chalk.template, chalk);
    chalk.template.constructor = ()=>{
        throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
    };
    chalk.template.Instance = $178603cf4f85cdeb$var$ChalkClass;
    return chalk.template;
};
function $178603cf4f85cdeb$var$Chalk(options) {
    return $178603cf4f85cdeb$var$chalkFactory(options);
}
for (const [styleName, style] of Object.entries($21oST))$178603cf4f85cdeb$var$styles[styleName] = {
    get () {
        const builder = $178603cf4f85cdeb$var$createBuilder(this, $178603cf4f85cdeb$var$createStyler(style.open, style.close, this._styler), this._isEmpty);
        Object.defineProperty(this, styleName, {
            value: builder
        });
        return builder;
    }
};
$178603cf4f85cdeb$var$styles.visible = {
    get () {
        const builder = $178603cf4f85cdeb$var$createBuilder(this, this._styler, true);
        Object.defineProperty(this, "visible", {
            value: builder
        });
        return builder;
    }
};
const $178603cf4f85cdeb$var$usedModels = [
    "rgb",
    "hex",
    "keyword",
    "hsl",
    "hsv",
    "hwb",
    "ansi",
    "ansi256"
];
for (const model of $178603cf4f85cdeb$var$usedModels)$178603cf4f85cdeb$var$styles[model] = {
    get () {
        const { level: level } = this;
        return function(...arguments_) {
            const styler = $178603cf4f85cdeb$var$createStyler($21oST.color[$178603cf4f85cdeb$var$levelMapping[level]][model](...arguments_), $21oST.color.close, this._styler);
            return $178603cf4f85cdeb$var$createBuilder(this, styler, this._isEmpty);
        };
    }
};
for (const model of $178603cf4f85cdeb$var$usedModels){
    const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
    $178603cf4f85cdeb$var$styles[bgModel] = {
        get () {
            const { level: level } = this;
            return function(...arguments_) {
                const styler = $178603cf4f85cdeb$var$createStyler($21oST.bgColor[$178603cf4f85cdeb$var$levelMapping[level]][model](...arguments_), $21oST.bgColor.close, this._styler);
                return $178603cf4f85cdeb$var$createBuilder(this, styler, this._isEmpty);
            };
        }
    };
}
const $178603cf4f85cdeb$var$proto = Object.defineProperties(()=>{}, {
    ...$178603cf4f85cdeb$var$styles,
    level: {
        enumerable: true,
        get () {
            return this._generator.level;
        },
        set (level) {
            this._generator.level = level;
        }
    }
});
const $178603cf4f85cdeb$var$createStyler = (open, close, parent)=>{
    let openAll;
    let closeAll;
    if (parent === undefined) {
        openAll = open;
        closeAll = close;
    } else {
        openAll = parent.openAll + open;
        closeAll = close + parent.closeAll;
    }
    return {
        open: open,
        close: close,
        openAll: openAll,
        closeAll: closeAll,
        parent: parent
    };
};
const $178603cf4f85cdeb$var$createBuilder = (self, _styler, _isEmpty)=>{
    const builder = (...arguments_)=>{
        if ($178603cf4f85cdeb$var$isArray(arguments_[0]) && $178603cf4f85cdeb$var$isArray(arguments_[0].raw)) // Called as a template literal, for example: chalk.red`2 + 3 = {bold ${2+3}}`
        return $178603cf4f85cdeb$var$applyStyle(builder, $178603cf4f85cdeb$var$chalkTag(builder, ...arguments_));
        // Single argument is hot path, implicit coercion is faster than anything
        // eslint-disable-next-line no-implicit-coercion
        return $178603cf4f85cdeb$var$applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
    };
    // We alter the prototype because we must return a function, but there is
    // no way to create a function with a different prototype
    Object.setPrototypeOf(builder, $178603cf4f85cdeb$var$proto);
    builder._generator = self;
    builder._styler = _styler;
    builder._isEmpty = _isEmpty;
    return builder;
};
const $178603cf4f85cdeb$var$applyStyle = (self, string)=>{
    if (self.level <= 0 || !string) return self._isEmpty ? "" : string;
    let styler = self._styler;
    if (styler === undefined) return string;
    const { openAll: openAll, closeAll: closeAll } = styler;
    if (string.indexOf("\x1b") !== -1) while(styler !== undefined){
        // Replace any instances already present with a re-opening code
        // otherwise only the part of the string until said closing code
        // will be colored, and the rest will simply be 'plain'.
        string = $178603cf4f85cdeb$require$stringReplaceAll(string, styler.close, styler.open);
        styler = styler.parent;
    }
    // We can move both next actions out of loop, because remaining actions in loop won't have
    // any/visible effect on parts we add here. Close the styling before a linebreak and reopen
    // after next line to fix a bleed issue on macOS: https://github.com/chalk/chalk/pull/92
    const lfIndex = string.indexOf("\n");
    if (lfIndex !== -1) string = $178603cf4f85cdeb$require$stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
    return openAll + string + closeAll;
};
let $178603cf4f85cdeb$var$template;

const $178603cf4f85cdeb$var$chalkTag = (chalk, ...strings)=>{
    const [firstString] = strings;
    if (!$178603cf4f85cdeb$var$isArray(firstString) || !$178603cf4f85cdeb$var$isArray(firstString.raw)) // If chalk() was called by itself or with a string,
    // return the string itself as a string.
    return strings.join(" ");
    const arguments_ = strings.slice(1);
    const parts = [
        firstString.raw[0]
    ];
    for(let i = 1; i < firstString.length; i++)parts.push(String(arguments_[i - 1]).replace(/[{}\\]/g, "\\$&"), String(firstString.raw[i]));
    if ($178603cf4f85cdeb$var$template === undefined) $178603cf4f85cdeb$var$template = (parcelRequire("kuMYa"));
    return $178603cf4f85cdeb$var$template(chalk, parts.join(""));
};
Object.defineProperties($178603cf4f85cdeb$var$Chalk.prototype, $178603cf4f85cdeb$var$styles);
const $178603cf4f85cdeb$var$chalk = $178603cf4f85cdeb$var$Chalk(); // eslint-disable-line new-cap
$178603cf4f85cdeb$var$chalk.supportsColor = $178603cf4f85cdeb$require$stdoutColor;
$178603cf4f85cdeb$var$chalk.stderr = $178603cf4f85cdeb$var$Chalk({
    level: $178603cf4f85cdeb$require$stderrColor ? $178603cf4f85cdeb$require$stderrColor.level : 0
}); // eslint-disable-line new-cap
$178603cf4f85cdeb$var$chalk.stderr.supportsColor = $178603cf4f85cdeb$require$stderrColor;
$178603cf4f85cdeb$exports = $178603cf4f85cdeb$var$chalk;


/** @typedef {{ id: string, compileError?: string, compiledQueryString: string, inputQueryString: string, compiled: boolean, inline: boolean }} Query */ /** @type {Record<string, boolean>} */ const $1594040042302d21$var$warnedExternalQueries = {};
/**
 *
 * @param {string} externalQuery
 * @param {string} id
 * @returns {Query | undefined}
 */ const $1594040042302d21$var$readFileToQuery = (externalQuery, id)=>{
    try {
        const content = $773sa$readFileSync(`./queries/${externalQuery}`).toString().trim();
        return {
            id: id.toLowerCase(),
            compiledQueryString: content,
            inputQueryString: content,
            compiled: false,
            inline: false
        };
    } catch  {
        console.warn(`Failed to load sql file ${externalQuery}`);
        return undefined;
    }
};
// Unified parser step to ignore indented code blocks.
// Adapted from the mdsvex source, here: https://github.com/pngwn/MDsveX/blob/master/packages/mdsvex/src/parsers/index.ts
// Discussion & background here:  https://github.com/evidence-dev/evidence/issues/286
/**
 * @this {import('unified').Processor}
 */ const $1594040042302d21$var$ignoreIndentedCode = function() {
    const Parser = this.Parser;
    const block_tokenizers = Parser.prototype.blockTokenizers;
    block_tokenizers.indentedCode = ()=>true;
};
/**
 * @param {string} content File content
 * @param {string} [filename] File name
 * @returns {Query[]}
 */ const $1594040042302d21$var$extractExternalQueries = (content, filename)=>{
    const frontmatter = $1594040042302d21$require$parseFrontmatter(content);
    if (!frontmatter) return [];
    if (!frontmatter.queries) return [];
    if (!Array.isArray(frontmatter.queries)) {
        if (filename) console.warn(`Malformed frontmatter found in ${filename}. Unable to extract external queries.`);
        else console.warn("Malformed frontmatter found. Unable to extract external queries.");
        return [];
    }
    /** @type {unknown[]} */ const queries = frontmatter.queries;
    /**
	 *
	 * @param {string} externalQuery
	 * @returns {boolean}
	 */ const validateExternalQuery = (externalQuery)=>{
        if (!externalQuery.endsWith(".sql")) {
            if (!$1594040042302d21$var$warnedExternalQueries[externalQuery]) {
                $1594040042302d21$var$warnedExternalQueries[externalQuery] = true;
                console.warn($178603cf4f85cdeb$exports.bold.red(`! ${externalQuery}`) + $178603cf4f85cdeb$exports.gray(" does not appear to be a .sql file, and will not be loaded"));
            }
            return false;
        }
        return true;
    };
    return queries.map((externalQuery)=>{
        if (typeof externalQuery === "string") {
            if (!validateExternalQuery(externalQuery)) return false;
            const id = externalQuery.split(".sql")[0].replace("/", "_").replace("\\", "_");
            return $1594040042302d21$var$readFileToQuery(externalQuery, id);
        } else if (externalQuery && typeof externalQuery === "object") {
            const [usedKey, value] = Object.entries(externalQuery)[0] ?? [
                "",
                undefined
            ];
            // Note; this is to be obseleted, as the import syntax evolves, but for now only one key should be used.
            if (Object.keys(externalQuery).length > 1) console.warn(`ExternalQuery object has more than one key, this may lead to unintended behavior. Only ${usedKey}: ${value} will be imported.`);
            if (!validateExternalQuery(value)) return false;
            return $1594040042302d21$var$readFileToQuery(value, usedKey);
        }
    }).filter((x)=>!!x); // filter out queries that returned false;
};
/**
 * @param {string} content Raw File Content
 * @returns {Query[]}
 */ const $1594040042302d21$var$extractInlineQueries = (content)=>{
    /** @type {Query[]} */ let queries = [];
    let tree = $27552814fada39bf$exports().use($ae7509fecc2740de$exports).use($1594040042302d21$var$ignoreIndentedCode).parse(content);
    const prismLangs = $0567f1b5861cebf9$exports();
    $cGAg2(tree, "code", function(/** @type {import("mdast").Code} */ node) {
        let id = node.lang ?? "untitled";
        if (id.toLowerCase() === "sql" && node.meta) id = node.meta;
        if (!prismLangs.has(id.toLowerCase()) && id.toLowerCase() !== "plaintext") {
            // Prevent prism code blocks from being interpreted as queries
            let compiledQueryString = node.value.trim(); // refs get compiled and sent to db orchestrator
            let inputQueryString = compiledQueryString; // original, as written
            let compiled = false; // default flag, switched to true if query is compiled
            queries.push({
                id: id,
                compiledQueryString: compiledQueryString,
                inputQueryString: inputQueryString,
                compiled: compiled,
                inline: true
            });
        }
    });
    return queries;
};
const $1594040042302d21$var$strictBuild = process.env.VITE_BUILD_STRICT === "true";
const $1594040042302d21$var$circularRefErrorMsg = "Compiler error: circular reference";
/**
 * @param {string} content
 * @returns {Query[]}
 */ const $1594040042302d21$var$extractQueries = (content)=>{
    /** @type {Query[]} */ const queries = [];
    // todo: second parameter is filename but we don't have that here?
    queries.push(...$1594040042302d21$var$extractExternalQueries(content));
    queries.push(...$1594040042302d21$var$extractInlineQueries(content));
    // Handle query chaining:
    const maxIterations = 15;
    const queryIds = new Set(queries.map((d)=>d.id));
    const interpolated_variables = new Set();
    for(let i = 0; i <= maxIterations; i++)queries.forEach((query)=>{
        const startTemplateInterpolation = /[^\\](\$\{)/g;
        const validTemplateInterpolation = /[^\\]\$\{((?:.|\s)+?)\}/g;
        /*
				This is a somewhat naive way of looking for invalid template strings
				It currently tests for ${} and ${ cases, but is unable to detect } cases
			*/ const hasTemplates = startTemplateInterpolation.exec(query.inputQueryString);
        const hasValidTemplates = validTemplateInterpolation.exec(query.inputQueryString);
        if (hasTemplates?.length !== hasValidTemplates?.length) {
            if (query.inputQueryString.includes("${}")) query.compileError = "Query contains an empty template literal (${})";
            else query.compileError = "Query contains invalid template literal (unmatched ${ and }";
            return;
        }
        const references = query.compiledQueryString.match(/\${.*?\}/gi);
        if (references && references.some((d)=>!interpolated_variables.has(d))) references.forEach((reference)=>{
            try {
                const referencedQueryID = reference.replace("${", "").replace("}", "").trim();
                if (!queryIds.has(referencedQueryID)) interpolated_variables.add(reference);
                else if (i >= maxIterations) throw new Error($1594040042302d21$var$circularRefErrorMsg);
                else {
                    const referencedQuery = queries.find((d)=>d.id === referencedQueryID);
                    if (!referencedQuery) // should be unreachable
                    throw new Error(`Referenced query not found. (Referenced ${referencedQueryID})`);
                    if (!query.inline && referencedQuery.inline) throw new Error(`Cannot reference inline query from SQL File. (Referenced ${referencedQueryID})`);
                    const queryString = `(${referencedQuery.compiledQueryString})`;
                    query.compiledQueryString = query.compiledQueryString.replace(reference, // this actually replaces each $ with $$
                    // this is to avoid [this behaviour](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_string_as_the_replacement)
                    queryString.replaceAll("$", "$$$$"));
                    query.compiled = true;
                }
            } catch (/** @type {any} */ _e) {
                // if error is unknown use default circular ref. error
                const e = _e.message === undefined || _e.message === null ? Error($1594040042302d21$var$circularRefErrorMsg) : _e;
                query.compileError = e.message;
                query.compiledQueryString = e.message;
                // if build is strict and we detect an error, force a failure
                if ($1594040042302d21$var$strictBuild) throw new Error(e.message);
            }
        });
    });
    return queries;
};
/**
 *
 * @param {string} content File Content
 *
 * @param {string} content File Content
 * @returns {string[]}
 */ const $1594040042302d21$var$getQueryIds = (content)=>{
    return $1594040042302d21$var$extractQueries(content).map((q)=>q.id);
};
$1594040042302d21$exports = {
    extractQueries: $1594040042302d21$var$extractQueries,
    getQueryIds: $1594040042302d21$var$getQueryIds
};


var $812958982b4444cc$require$extractQueries = $1594040042302d21$exports.extractQueries;

var $812958982b4444cc$require$highlighter = $2521e4a700446aca$exports.highlighter;

var $gJ8VZ = parcelRequire("gJ8VZ");
var $812958982b4444cc$require$containsFrontmatter = $gJ8VZ.containsFrontmatter;
/**
 * If you need an @evidence-dev import in the template strings below, it must be added here to prevent a poor user experience when running a template
 * @type {{ import: string; from: `@evidence-dev/${string}` }[]}
 */ const $812958982b4444cc$var$injectedEvidenceImports = [
    {
        import: "{ pageHasQueries, routeHash, toasts }",
        from: "@evidence-dev/component-utilities/stores"
    },
    {
        import: "{ fmt }",
        from: "@evidence-dev/component-utilities/formatting"
    },
    {
        import: "{ CUSTOM_FORMATTING_SETTINGS_CONTEXT_KEY }",
        from: "@evidence-dev/component-utilities/globalContexts"
    },
    {
        import: "{ ensureInputContext }",
        from: "@evidence-dev/sdk/utils/svelte"
    },
    {
        import: "{ profile }",
        from: "@evidence-dev/component-utilities/profile"
    },
    {
        import: "{ Query, hasUnsetValues }",
        from: "@evidence-dev/sdk/usql"
    },
    {
        import: "{ setQueryFunction }",
        from: "@evidence-dev/component-utilities/buildQuery"
    }
];
/**
 *
 * @param {string} filename
 * @param {boolean} componentDevelopmentMode
 * @param {Record<string, import('./extract-queries/extract-queries.cjs').Query>} duckdbQueries
 * @returns
 */ const $812958982b4444cc$var$createDefaultProps = function(filename, componentDevelopmentMode, duckdbQueries = {}) {
    const routeH = $812958982b4444cc$require$getRouteHash(filename);
    let queryDeclarations = "";
    const IS_VALID_QUERY = /^([a-zA-Z_$][a-zA-Z0-9d_$]*)$/;
    const validIds = Object.keys(duckdbQueries).filter((query)=>IS_VALID_QUERY.test(query) && !duckdbQueries[query].compileError);
    if (validIds.length > 0) {
        // prerendered queries: stuff without ${}
        // reactive queries: stuff with ${}
        const IS_REACTIVE_QUERY = /\${.*?}/s;
        const reactiveIds = validIds.filter((id)=>IS_REACTIVE_QUERY.test(duckdbQueries[id].compiledQueryString));
        // input queries: reactive with ${inputs...} in it
        const IS_INPUT_QUERY = /\${\s*inputs\s*\..*?}/s;
        const input_ids = reactiveIds.filter((id)=>IS_INPUT_QUERY.test(duckdbQueries[id].compiledQueryString));
        const errQueries = Object.values(duckdbQueries).filter((q)=>q.compileError).map((q)=>`const ${q.id} = Query.create(\`${q.compiledQueryString.replaceAll("$", "\\$")}\`, undefined, { id: "${q.id}", initialError: new Error(\`${q.compileError.replaceAll("$", "\\$")}\`)})`);
        const queryStoreDeclarations = validIds.map((id)=>{
            return `
                // Update external queries
                if (import.meta?.hot) {
                    import.meta.hot.on("evidence:queryChange", ({queryId, content}) => {
                        let errors = []
                        if (!queryId) errors.push("Malformed event: Missing queryId")
                        if (!content) errors.push("Malformed event: Missing content")
                        if (errors.length) {
                            console.warn("Failed to update query on serverside change!", errors.join("\\n"))
                            return
                        }

                        if (queryId === "${id}") {
                            __${id}Text = content
                        }
                        
                    })
                }

                let ${id}InitialStates = { initialData: undefined, initialError: undefined }
                
                // Give initial states for these variables
                /** @type {boolean} */
                let __${id}HasUnresolved = hasUnsetValues\`${duckdbQueries[id].compiledQueryString.replaceAll("`", "\\`")}\`;
                /** @type {string} */
                let __${id}Text = \`${duckdbQueries[id].compiledQueryString.replaceAll("`", "\\`")}\`


                if (browser) {
                    // Data came from SSR
                    if (data.${id}_data) {
                        // vvv is this still used/possible?
                        if (data.${id}_data instanceof Error) {
                            ${id}InitialStates.initialError = data.${id}_data
                        } else {
                            ${id}InitialStates.initialData = data.${id}_data
                        }
                        if (data.${id}_columns) {
                            ${id}InitialStates.knownColumns = data.${id}_columns
                        }
                    }
                }

                /** @type {import("@evidence-dev/sdk/usql").QueryValue} */
                let ${id};

                $: __${id}HasUnresolved = hasUnsetValues\`${duckdbQueries[id].compiledQueryString.replaceAll("`", "\\`")}\`;
                $: __${id}Text = \`${duckdbQueries[id].compiledQueryString.replaceAll("`", "\\`")}\`

                // keep initial state around until after the query has resolved once
                let __${id}InitialFactory = false;
                $: if (__${id}HasUnresolved || !__${id}InitialFactory) {    
                    if (!__${id}HasUnresolved) {
                        __${id}Factory(__${id}Text, { noResolve: __${id}HasUnresolved, ...${id}InitialStates });
                        __${id}InitialFactory = true;
                    }
                } else {
                    __${id}Factory(__${id}Text, { noResolve: __${id}HasUnresolved });
                }

                const __${id}Factory = Query.createReactive(
                    { callback: v => {
                        ${id} = v
                    }, execFn: queryFunc },
                    { id: '${id}', ...${id}InitialStates }
                )

                // Assign a value for the initial run-through
                // This is split because chicken / egg
                __${id}Factory(__${id}Text, { noResolve: __${id}HasUnresolved, ...${id}InitialStates })

                // Add queries to global scope inside symbols to ease debugging
                globalThis[Symbol.for("${id}")] = { get value() { return ${id} } }
                
                
            `;
        });
        /* 
			reactivity doesn't happen on the server, so we need to manually subscribe to the inputs store
			and update the queries when the inputs change
		*/ const input_query_stores = `
		if (!browser) {
			onDestroy(inputs_store.subscribe((inputs) => {
				${input_ids.map((id)=>`
						__${id}HasUnresolved = hasUnsetValues\`${duckdbQueries[id].compiledQueryString.replaceAll("`", "\\`")}\`;
						__${id}Text = \`${duckdbQueries[id].compiledQueryString.replaceAll("`", "\\`")}\`;
						__${id}Factory(__${id}Text, { noResolve: __${id}HasUnresolved });
				`).join("\n")}
			}));
		}
		`;
        queryDeclarations += `
		${errQueries.join("\n")}
		${queryStoreDeclarations.join("\n")}
		${input_query_stores}
		
		`;
    }
    let defaultProps = `
        import { page } from '$app/stores';
        import { setContext, getContext, beforeUpdate, onDestroy, onMount } from 'svelte';
		import { writable, get } from 'svelte/store';
        
        // Functions

        
        let props;
        export { props as data }; // little hack to make the data name not overlap
        let { data = {}, customFormattingSettings, __db, inputs } = props;
        $: ({ data = {}, customFormattingSettings, __db } = props);

        $routeHash = '${routeH}';

		${/* 
			do not switch to $: inputs = $inputs_store
			reactive statements do not rerun during SSR 
			*/ ""}
		let inputs_store = ensureInputContext(writable(inputs));
		onDestroy(inputs_store.subscribe((value) => inputs = value));

        $: pageHasQueries.set(Object.keys(data).length > 0);

        setContext(CUSTOM_FORMATTING_SETTINGS_CONTEXT_KEY, {
            getCustomFormats: () => {
                return customFormattingSettings.customFormats || [];
            }
        });

		import { browser, dev } from "$app/environment";

		if (!browser) {
			onDestroy(() => Query.emptyCache());
		}

		const queryFunc = (query, query_name) => profile(__db.query, query, { query_name });
		setQueryFunction(queryFunc);

		const scoreNotifier = !dev? () => {} : (info) => {
			toasts.add({
				id: Math.random(),
				title: info.id,
				message: \`Results estimated to use \${
					Intl.NumberFormat().format(info.score / (1024 * 1024))
				}mb of memory, performance may be impacted\`,
				status: 'warning'
			}, 5000);
		};

		if (import.meta?.hot) {
            if (typeof import.meta.hot.data.hmrHasRun === 'undefined') import.meta.hot.data.hmrHasRun = false

			import.meta.hot.on("evidence:reset-queries", async (payload) => {
				await $page.data.__db.updateParquetURLs(JSON.stringify(payload.latestManifest), true);
				Query.emptyCache()
				${validIds.map((id)=>`__${id}Factory(__${id}Text, { noResolve: __${id}HasUnresolved });`).join("\n")}
			})
	    }
		
		let params = $page.params;
		$: params = $page.params;
		
		let _mounted = false;
		onMount(() => (_mounted = true));

        ${queryDeclarations}
    `;
    return `
		${$812958982b4444cc$var$injectedEvidenceImports.map((i)=>`import ${i.import} from '${i.from}';`).join("\n")}
		${defaultProps}
	`;
};
/**
 * @type {(componentDevelopmentMode: boolean) => import("svelte-preprocess/dist/types").PreprocessorGroup}
 */ const $812958982b4444cc$var$processQueries = (componentDevelopmentMode)=>{
    /**
	 * @type {Record<string, Record<string, import("./extract-queries/extract-queries.cjs").Query>>}
	 */ const dynamicQueries = {};
    return {
        markup ({ content: content, filename: filename }) {
            if (filename?.endsWith(".md")) {
                let fileQueries = $812958982b4444cc$require$extractQueries(content);
                dynamicQueries[$812958982b4444cc$require$getRouteHash(filename)] = fileQueries.reduce((acc, q)=>{
                    acc[q.id] = q;
                    return acc;
                }, /** @type {typeof dynamicQueries[string]} */ {});
                const externalQueryViews = "\n\n\n" + fileQueries.filter((q)=>!q.inline).map((q)=>{
                    return $812958982b4444cc$require$highlighter(q.compiledQueryString, q.id.toLowerCase());
                }).join("\n");
                // Page contains frontmatter
                const frontmatter = $812958982b4444cc$require$containsFrontmatter(content);
                if (frontmatter) {
                    const contentWithoutFrontmatter = content.substring(frontmatter.length + 6);
                    const output = `---\n${frontmatter}\n---` + externalQueryViews + contentWithoutFrontmatter;
                    return {
                        code: output
                    };
                }
                return {
                    code: externalQueryViews + content
                };
            }
        },
        script ({ content: content, filename: filename, attributes: attributes }) {
            if (filename?.endsWith(".md")) {
                if (attributes.context !== "module") {
                    const duckdbQueries = dynamicQueries[$812958982b4444cc$require$getRouteHash(filename)];
                    return {
                        code: $812958982b4444cc$var$createDefaultProps(filename, componentDevelopmentMode, duckdbQueries) + content
                    };
                }
            }
        }
    };
};
$812958982b4444cc$exports = {
    processQueries: $812958982b4444cc$var$processQueries,
    injectedEvidenceImports: $812958982b4444cc$var$injectedEvidenceImports
};


var $d8d0a3436c2ee92e$exports = {};
var $59f8cc3c57bc5912$exports = {};

$parcel$export($59f8cc3c57bc5912$exports, "matches", () => $83dc8573db127407$export$de994efd351b291c);
$parcel$export($59f8cc3c57bc5912$exports, "select", () => $83dc8573db127407$export$2e6c959c16ff56b8);
$parcel$export($59f8cc3c57bc5912$exports, "selectAll", () => $83dc8573db127407$export$90aca4adda6ff0f5);
/**
 * @typedef {import('./lib/types.js').Space} Space
 */ /**
 * @typedef {import('./types.js').Element} Element
 * @typedef {import('./types.js').Node} Node
 * @typedef {import('./types.js').Space} Space
 * @typedef {import('./types.js').SelectState} SelectState
 */ /**
 * @typedef {import('./lib/util/info.js').Info} Info
 * @typedef {import('./lib/util/schema.js').Schema} Schema
 */ /**
 * @typedef {import('./schema.js').Properties} Properties
 * @typedef {import('./schema.js').Normal} Normal
 */ /**
 * @typedef {import('./info.js').Info} Info
 * @typedef {Record<string, Info>} Properties
 * @typedef {Record<string, string>} Normal
 */ class $81fa33ed830346cc$export$19342e026b58ebb7 {
    /**
   * @constructor
   * @param {Properties} property
   * @param {Normal} normal
   * @param {string} [space]
   */ constructor(property, normal, space){
        this.property = property;
        this.normal = normal;
        if (space) this.space = space;
    }
}
/** @type {Properties} */ $81fa33ed830346cc$export$19342e026b58ebb7.prototype.property = {};
/** @type {Normal} */ $81fa33ed830346cc$export$19342e026b58ebb7.prototype.normal = {};
/** @type {string|null} */ $81fa33ed830346cc$export$19342e026b58ebb7.prototype.space = null;


function $8b43b564784566e8$export$4950aa0f605343fb(definitions, space) {
    /** @type {Properties} */ const property = {};
    /** @type {Normal} */ const normal = {};
    let index = -1;
    while(++index < definitions.length){
        Object.assign(property, definitions[index].property);
        Object.assign(normal, definitions[index].normal);
    }
    return new (0, $81fa33ed830346cc$export$19342e026b58ebb7)(property, normal, space);
}


/**
 * @typedef {import('./schema.js').Properties} Properties
 * @typedef {import('./schema.js').Normal} Normal
 *
 * @typedef {Record<string, string>} Attributes
 *
 * @typedef {Object} Definition
 * @property {Record<string, number|null>} properties
 * @property {(attributes: Attributes, property: string) => string} transform
 * @property {string} [space]
 * @property {Attributes} [attributes]
 * @property {Array<string>} [mustUseProperty]
 */ /**
 * @param {string} value
 * @returns {string}
 */ function $0880afc82b5794e9$export$a3295358bff77e(value) {
    return value.toLowerCase();
}



class $2fcc2e947415cf09$export$c4868e4a24d48fad {
    /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   */ constructor(property, attribute){
        /** @type {string} */ this.property = property;
        /** @type {string} */ this.attribute = attribute;
    }
}
/** @type {string|null} */ $2fcc2e947415cf09$export$c4868e4a24d48fad.prototype.space = null;
$2fcc2e947415cf09$export$c4868e4a24d48fad.prototype.boolean = false;
$2fcc2e947415cf09$export$c4868e4a24d48fad.prototype.booleanish = false;
$2fcc2e947415cf09$export$c4868e4a24d48fad.prototype.overloadedBoolean = false;
$2fcc2e947415cf09$export$c4868e4a24d48fad.prototype.number = false;
$2fcc2e947415cf09$export$c4868e4a24d48fad.prototype.commaSeparated = false;
$2fcc2e947415cf09$export$c4868e4a24d48fad.prototype.spaceSeparated = false;
$2fcc2e947415cf09$export$c4868e4a24d48fad.prototype.commaOrSpaceSeparated = false;
$2fcc2e947415cf09$export$c4868e4a24d48fad.prototype.mustUseProperty = false;
$2fcc2e947415cf09$export$c4868e4a24d48fad.prototype.defined = false;


var $bbc33f7d82395a8a$exports = {};

$parcel$export($bbc33f7d82395a8a$exports, "boolean", () => $bbc33f7d82395a8a$export$4a21f16c33752377);
$parcel$export($bbc33f7d82395a8a$exports, "booleanish", () => $bbc33f7d82395a8a$export$55e9e1fbc638dc8f);
$parcel$export($bbc33f7d82395a8a$exports, "overloadedBoolean", () => $bbc33f7d82395a8a$export$242ac3d3042558aa);
$parcel$export($bbc33f7d82395a8a$exports, "number", () => $bbc33f7d82395a8a$export$98e628dec113755e);
$parcel$export($bbc33f7d82395a8a$exports, "spaceSeparated", () => $bbc33f7d82395a8a$export$ab8645c862eb5a3e);
$parcel$export($bbc33f7d82395a8a$exports, "commaSeparated", () => $bbc33f7d82395a8a$export$9c8d678629b3d3);
$parcel$export($bbc33f7d82395a8a$exports, "commaOrSpaceSeparated", () => $bbc33f7d82395a8a$export$2ad25cfebf36cacd);
let $bbc33f7d82395a8a$var$powers = 0;
const $bbc33f7d82395a8a$export$4a21f16c33752377 = $bbc33f7d82395a8a$var$increment();
const $bbc33f7d82395a8a$export$55e9e1fbc638dc8f = $bbc33f7d82395a8a$var$increment();
const $bbc33f7d82395a8a$export$242ac3d3042558aa = $bbc33f7d82395a8a$var$increment();
const $bbc33f7d82395a8a$export$98e628dec113755e = $bbc33f7d82395a8a$var$increment();
const $bbc33f7d82395a8a$export$ab8645c862eb5a3e = $bbc33f7d82395a8a$var$increment();
const $bbc33f7d82395a8a$export$9c8d678629b3d3 = $bbc33f7d82395a8a$var$increment();
const $bbc33f7d82395a8a$export$2ad25cfebf36cacd = $bbc33f7d82395a8a$var$increment();
function $bbc33f7d82395a8a$var$increment() {
    return 2 ** ++$bbc33f7d82395a8a$var$powers;
}


/** @type {Array<keyof types>} */ // @ts-expect-error: hush.
const $25641d2f17987f4e$var$checks = Object.keys($bbc33f7d82395a8a$exports);
class $25641d2f17987f4e$export$ea6b9f0064e88c9b extends (0, $2fcc2e947415cf09$export$c4868e4a24d48fad) {
    /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   * @param {number|null} [mask]
   * @param {string} [space]
   */ constructor(property, attribute, mask, space){
        let index = -1;
        super(property, attribute);
        $25641d2f17987f4e$var$mark(this, "space", space);
        if (typeof mask === "number") while(++index < $25641d2f17987f4e$var$checks.length){
            const check = $25641d2f17987f4e$var$checks[index];
            $25641d2f17987f4e$var$mark(this, $25641d2f17987f4e$var$checks[index], (mask & $bbc33f7d82395a8a$exports[check]) === $bbc33f7d82395a8a$exports[check]);
        }
    }
}
$25641d2f17987f4e$export$ea6b9f0064e88c9b.prototype.defined = true;
/**
 * @param {DefinedInfo} values
 * @param {string} key
 * @param {unknown} value
 */ function $25641d2f17987f4e$var$mark(values, key, value) {
    if (value) // @ts-expect-error: assume `value` matches the expected value of `key`.
    values[key] = value;
}


const $b443da722a37a13b$var$own = {}.hasOwnProperty;
function $b443da722a37a13b$export$185802fd694ee1f5(definition) {
    /** @type {Properties} */ const property = {};
    /** @type {Normal} */ const normal = {};
    /** @type {string} */ let prop;
    for(prop in definition.properties)if ($b443da722a37a13b$var$own.call(definition.properties, prop)) {
        const value = definition.properties[prop];
        const info = new (0, $25641d2f17987f4e$export$ea6b9f0064e88c9b)(prop, definition.transform(definition.attributes || {}, prop), value, definition.space);
        if (definition.mustUseProperty && definition.mustUseProperty.includes(prop)) info.mustUseProperty = true;
        property[prop] = info;
        normal[(0, $0880afc82b5794e9$export$a3295358bff77e)(prop)] = prop;
        normal[(0, $0880afc82b5794e9$export$a3295358bff77e)(info.attribute)] = prop;
    }
    return new (0, $81fa33ed830346cc$export$19342e026b58ebb7)(property, normal, definition.space);
}


const $cb3554868573ee99$export$2bd1230ec7600845 = (0, $b443da722a37a13b$export$185802fd694ee1f5)({
    space: "xlink",
    transform (_, prop) {
        return "xlink:" + prop.slice(5).toLowerCase();
    },
    properties: {
        xLinkActuate: null,
        xLinkArcRole: null,
        xLinkHref: null,
        xLinkRole: null,
        xLinkShow: null,
        xLinkTitle: null,
        xLinkType: null
    }
});



const $000e0990fcf22f5d$export$f2913fe8983302e = (0, $b443da722a37a13b$export$185802fd694ee1f5)({
    space: "xml",
    transform (_, prop) {
        return "xml:" + prop.slice(3).toLowerCase();
    },
    properties: {
        xmlLang: null,
        xmlBase: null,
        xmlSpace: null
    }
});



/**
 * @param {Record<string, string>} attributes
 * @param {string} attribute
 * @returns {string}
 */ function $22f3c7b87445388a$export$5b10b3bc32d7efbc(attributes, attribute) {
    return attribute in attributes ? attributes[attribute] : attribute;
}


function $6efefe4f80cfa7a1$export$32b9e4cec9c208e1(attributes, property) {
    return (0, $22f3c7b87445388a$export$5b10b3bc32d7efbc)(attributes, property.toLowerCase());
}


const $39635c3c46b01137$export$e20c24a128671213 = (0, $b443da722a37a13b$export$185802fd694ee1f5)({
    space: "xmlns",
    attributes: {
        xmlnsxlink: "xmlns:xlink"
    },
    transform: (0, $6efefe4f80cfa7a1$export$32b9e4cec9c208e1),
    properties: {
        xmlns: null,
        xmlnsXLink: null
    }
});




const $479f5cbf5cbefa9f$export$4d2d26490572750a = (0, $b443da722a37a13b$export$185802fd694ee1f5)({
    transform (_, prop) {
        return prop === "role" ? prop : "aria-" + prop.slice(4).toLowerCase();
    },
    properties: {
        ariaActiveDescendant: null,
        ariaAtomic: (0, $bbc33f7d82395a8a$export$55e9e1fbc638dc8f),
        ariaAutoComplete: null,
        ariaBusy: (0, $bbc33f7d82395a8a$export$55e9e1fbc638dc8f),
        ariaChecked: (0, $bbc33f7d82395a8a$export$55e9e1fbc638dc8f),
        ariaColCount: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        ariaColIndex: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        ariaColSpan: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        ariaControls: (0, $bbc33f7d82395a8a$export$ab8645c862eb5a3e),
        ariaCurrent: null,
        ariaDescribedBy: (0, $bbc33f7d82395a8a$export$ab8645c862eb5a3e),
        ariaDetails: null,
        ariaDisabled: (0, $bbc33f7d82395a8a$export$55e9e1fbc638dc8f),
        ariaDropEffect: (0, $bbc33f7d82395a8a$export$ab8645c862eb5a3e),
        ariaErrorMessage: null,
        ariaExpanded: (0, $bbc33f7d82395a8a$export$55e9e1fbc638dc8f),
        ariaFlowTo: (0, $bbc33f7d82395a8a$export$ab8645c862eb5a3e),
        ariaGrabbed: (0, $bbc33f7d82395a8a$export$55e9e1fbc638dc8f),
        ariaHasPopup: null,
        ariaHidden: (0, $bbc33f7d82395a8a$export$55e9e1fbc638dc8f),
        ariaInvalid: null,
        ariaKeyShortcuts: null,
        ariaLabel: null,
        ariaLabelledBy: (0, $bbc33f7d82395a8a$export$ab8645c862eb5a3e),
        ariaLevel: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        ariaLive: null,
        ariaModal: (0, $bbc33f7d82395a8a$export$55e9e1fbc638dc8f),
        ariaMultiLine: (0, $bbc33f7d82395a8a$export$55e9e1fbc638dc8f),
        ariaMultiSelectable: (0, $bbc33f7d82395a8a$export$55e9e1fbc638dc8f),
        ariaOrientation: null,
        ariaOwns: (0, $bbc33f7d82395a8a$export$ab8645c862eb5a3e),
        ariaPlaceholder: null,
        ariaPosInSet: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        ariaPressed: (0, $bbc33f7d82395a8a$export$55e9e1fbc638dc8f),
        ariaReadOnly: (0, $bbc33f7d82395a8a$export$55e9e1fbc638dc8f),
        ariaRelevant: null,
        ariaRequired: (0, $bbc33f7d82395a8a$export$55e9e1fbc638dc8f),
        ariaRoleDescription: (0, $bbc33f7d82395a8a$export$ab8645c862eb5a3e),
        ariaRowCount: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        ariaRowIndex: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        ariaRowSpan: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        ariaSelected: (0, $bbc33f7d82395a8a$export$55e9e1fbc638dc8f),
        ariaSetSize: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        ariaSort: null,
        ariaValueMax: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        ariaValueMin: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        ariaValueNow: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        ariaValueText: null,
        role: null
    }
});





const $2a5424f016a37a22$export$c0bb0b647f701bb5 = (0, $b443da722a37a13b$export$185802fd694ee1f5)({
    space: "html",
    attributes: {
        acceptcharset: "accept-charset",
        classname: "class",
        htmlfor: "for",
        httpequiv: "http-equiv"
    },
    transform: (0, $6efefe4f80cfa7a1$export$32b9e4cec9c208e1),
    mustUseProperty: [
        "checked",
        "multiple",
        "muted",
        "selected"
    ],
    properties: {
        // Standard Properties.
        abbr: null,
        accept: (0, $bbc33f7d82395a8a$export$9c8d678629b3d3),
        acceptCharset: (0, $bbc33f7d82395a8a$export$ab8645c862eb5a3e),
        accessKey: (0, $bbc33f7d82395a8a$export$ab8645c862eb5a3e),
        action: null,
        allow: null,
        allowFullScreen: (0, $bbc33f7d82395a8a$export$4a21f16c33752377),
        allowPaymentRequest: (0, $bbc33f7d82395a8a$export$4a21f16c33752377),
        allowUserMedia: (0, $bbc33f7d82395a8a$export$4a21f16c33752377),
        alt: null,
        as: null,
        async: (0, $bbc33f7d82395a8a$export$4a21f16c33752377),
        autoCapitalize: null,
        autoComplete: (0, $bbc33f7d82395a8a$export$ab8645c862eb5a3e),
        autoFocus: (0, $bbc33f7d82395a8a$export$4a21f16c33752377),
        autoPlay: (0, $bbc33f7d82395a8a$export$4a21f16c33752377),
        blocking: (0, $bbc33f7d82395a8a$export$ab8645c862eb5a3e),
        capture: null,
        charSet: null,
        checked: (0, $bbc33f7d82395a8a$export$4a21f16c33752377),
        cite: null,
        className: (0, $bbc33f7d82395a8a$export$ab8645c862eb5a3e),
        cols: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        colSpan: null,
        content: null,
        contentEditable: (0, $bbc33f7d82395a8a$export$55e9e1fbc638dc8f),
        controls: (0, $bbc33f7d82395a8a$export$4a21f16c33752377),
        controlsList: (0, $bbc33f7d82395a8a$export$ab8645c862eb5a3e),
        coords: (0, $bbc33f7d82395a8a$export$98e628dec113755e) | (0, $bbc33f7d82395a8a$export$9c8d678629b3d3),
        crossOrigin: null,
        data: null,
        dateTime: null,
        decoding: null,
        default: (0, $bbc33f7d82395a8a$export$4a21f16c33752377),
        defer: (0, $bbc33f7d82395a8a$export$4a21f16c33752377),
        dir: null,
        dirName: null,
        disabled: (0, $bbc33f7d82395a8a$export$4a21f16c33752377),
        download: (0, $bbc33f7d82395a8a$export$242ac3d3042558aa),
        draggable: (0, $bbc33f7d82395a8a$export$55e9e1fbc638dc8f),
        encType: null,
        enterKeyHint: null,
        fetchPriority: null,
        form: null,
        formAction: null,
        formEncType: null,
        formMethod: null,
        formNoValidate: (0, $bbc33f7d82395a8a$export$4a21f16c33752377),
        formTarget: null,
        headers: (0, $bbc33f7d82395a8a$export$ab8645c862eb5a3e),
        height: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        hidden: (0, $bbc33f7d82395a8a$export$4a21f16c33752377),
        high: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        href: null,
        hrefLang: null,
        htmlFor: (0, $bbc33f7d82395a8a$export$ab8645c862eb5a3e),
        httpEquiv: (0, $bbc33f7d82395a8a$export$ab8645c862eb5a3e),
        id: null,
        imageSizes: null,
        imageSrcSet: null,
        inert: (0, $bbc33f7d82395a8a$export$4a21f16c33752377),
        inputMode: null,
        integrity: null,
        is: null,
        isMap: (0, $bbc33f7d82395a8a$export$4a21f16c33752377),
        itemId: null,
        itemProp: (0, $bbc33f7d82395a8a$export$ab8645c862eb5a3e),
        itemRef: (0, $bbc33f7d82395a8a$export$ab8645c862eb5a3e),
        itemScope: (0, $bbc33f7d82395a8a$export$4a21f16c33752377),
        itemType: (0, $bbc33f7d82395a8a$export$ab8645c862eb5a3e),
        kind: null,
        label: null,
        lang: null,
        language: null,
        list: null,
        loading: null,
        loop: (0, $bbc33f7d82395a8a$export$4a21f16c33752377),
        low: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        manifest: null,
        max: null,
        maxLength: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        media: null,
        method: null,
        min: null,
        minLength: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        multiple: (0, $bbc33f7d82395a8a$export$4a21f16c33752377),
        muted: (0, $bbc33f7d82395a8a$export$4a21f16c33752377),
        name: null,
        nonce: null,
        noModule: (0, $bbc33f7d82395a8a$export$4a21f16c33752377),
        noValidate: (0, $bbc33f7d82395a8a$export$4a21f16c33752377),
        onAbort: null,
        onAfterPrint: null,
        onAuxClick: null,
        onBeforeMatch: null,
        onBeforePrint: null,
        onBeforeToggle: null,
        onBeforeUnload: null,
        onBlur: null,
        onCancel: null,
        onCanPlay: null,
        onCanPlayThrough: null,
        onChange: null,
        onClick: null,
        onClose: null,
        onContextLost: null,
        onContextMenu: null,
        onContextRestored: null,
        onCopy: null,
        onCueChange: null,
        onCut: null,
        onDblClick: null,
        onDrag: null,
        onDragEnd: null,
        onDragEnter: null,
        onDragExit: null,
        onDragLeave: null,
        onDragOver: null,
        onDragStart: null,
        onDrop: null,
        onDurationChange: null,
        onEmptied: null,
        onEnded: null,
        onError: null,
        onFocus: null,
        onFormData: null,
        onHashChange: null,
        onInput: null,
        onInvalid: null,
        onKeyDown: null,
        onKeyPress: null,
        onKeyUp: null,
        onLanguageChange: null,
        onLoad: null,
        onLoadedData: null,
        onLoadedMetadata: null,
        onLoadEnd: null,
        onLoadStart: null,
        onMessage: null,
        onMessageError: null,
        onMouseDown: null,
        onMouseEnter: null,
        onMouseLeave: null,
        onMouseMove: null,
        onMouseOut: null,
        onMouseOver: null,
        onMouseUp: null,
        onOffline: null,
        onOnline: null,
        onPageHide: null,
        onPageShow: null,
        onPaste: null,
        onPause: null,
        onPlay: null,
        onPlaying: null,
        onPopState: null,
        onProgress: null,
        onRateChange: null,
        onRejectionHandled: null,
        onReset: null,
        onResize: null,
        onScroll: null,
        onScrollEnd: null,
        onSecurityPolicyViolation: null,
        onSeeked: null,
        onSeeking: null,
        onSelect: null,
        onSlotChange: null,
        onStalled: null,
        onStorage: null,
        onSubmit: null,
        onSuspend: null,
        onTimeUpdate: null,
        onToggle: null,
        onUnhandledRejection: null,
        onUnload: null,
        onVolumeChange: null,
        onWaiting: null,
        onWheel: null,
        open: (0, $bbc33f7d82395a8a$export$4a21f16c33752377),
        optimum: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        pattern: null,
        ping: (0, $bbc33f7d82395a8a$export$ab8645c862eb5a3e),
        placeholder: null,
        playsInline: (0, $bbc33f7d82395a8a$export$4a21f16c33752377),
        popover: null,
        popoverTarget: null,
        popoverTargetAction: null,
        poster: null,
        preload: null,
        readOnly: (0, $bbc33f7d82395a8a$export$4a21f16c33752377),
        referrerPolicy: null,
        rel: (0, $bbc33f7d82395a8a$export$ab8645c862eb5a3e),
        required: (0, $bbc33f7d82395a8a$export$4a21f16c33752377),
        reversed: (0, $bbc33f7d82395a8a$export$4a21f16c33752377),
        rows: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        rowSpan: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        sandbox: (0, $bbc33f7d82395a8a$export$ab8645c862eb5a3e),
        scope: null,
        scoped: (0, $bbc33f7d82395a8a$export$4a21f16c33752377),
        seamless: (0, $bbc33f7d82395a8a$export$4a21f16c33752377),
        selected: (0, $bbc33f7d82395a8a$export$4a21f16c33752377),
        shadowRootClonable: (0, $bbc33f7d82395a8a$export$4a21f16c33752377),
        shadowRootDelegatesFocus: (0, $bbc33f7d82395a8a$export$4a21f16c33752377),
        shadowRootMode: null,
        shape: null,
        size: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        sizes: null,
        slot: null,
        span: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        spellCheck: (0, $bbc33f7d82395a8a$export$55e9e1fbc638dc8f),
        src: null,
        srcDoc: null,
        srcLang: null,
        srcSet: null,
        start: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        step: null,
        style: null,
        tabIndex: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        target: null,
        title: null,
        translate: null,
        type: null,
        typeMustMatch: (0, $bbc33f7d82395a8a$export$4a21f16c33752377),
        useMap: null,
        value: (0, $bbc33f7d82395a8a$export$55e9e1fbc638dc8f),
        width: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        wrap: null,
        writingSuggestions: null,
        // Legacy.
        // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
        align: null,
        aLink: null,
        archive: (0, $bbc33f7d82395a8a$export$ab8645c862eb5a3e),
        axis: null,
        background: null,
        bgColor: null,
        border: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        borderColor: null,
        bottomMargin: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        cellPadding: null,
        cellSpacing: null,
        char: null,
        charOff: null,
        classId: null,
        clear: null,
        code: null,
        codeBase: null,
        codeType: null,
        color: null,
        compact: (0, $bbc33f7d82395a8a$export$4a21f16c33752377),
        declare: (0, $bbc33f7d82395a8a$export$4a21f16c33752377),
        event: null,
        face: null,
        frame: null,
        frameBorder: null,
        hSpace: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        leftMargin: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        link: null,
        longDesc: null,
        lowSrc: null,
        marginHeight: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        marginWidth: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        noResize: (0, $bbc33f7d82395a8a$export$4a21f16c33752377),
        noHref: (0, $bbc33f7d82395a8a$export$4a21f16c33752377),
        noShade: (0, $bbc33f7d82395a8a$export$4a21f16c33752377),
        noWrap: (0, $bbc33f7d82395a8a$export$4a21f16c33752377),
        object: null,
        profile: null,
        prompt: null,
        rev: null,
        rightMargin: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        rules: null,
        scheme: null,
        scrolling: (0, $bbc33f7d82395a8a$export$55e9e1fbc638dc8f),
        standby: null,
        summary: null,
        text: null,
        topMargin: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        valueType: null,
        version: null,
        vAlign: null,
        vLink: null,
        vSpace: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        // Non-standard Properties.
        allowTransparency: null,
        autoCorrect: null,
        autoSave: null,
        disablePictureInPicture: (0, $bbc33f7d82395a8a$export$4a21f16c33752377),
        disableRemotePlayback: (0, $bbc33f7d82395a8a$export$4a21f16c33752377),
        prefix: null,
        property: null,
        results: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        security: null,
        unselectable: null
    }
});





const $b5b70542c0690e44$export$7ed1367e7fa1ad68 = (0, $b443da722a37a13b$export$185802fd694ee1f5)({
    space: "svg",
    attributes: {
        accentHeight: "accent-height",
        alignmentBaseline: "alignment-baseline",
        arabicForm: "arabic-form",
        baselineShift: "baseline-shift",
        capHeight: "cap-height",
        className: "class",
        clipPath: "clip-path",
        clipRule: "clip-rule",
        colorInterpolation: "color-interpolation",
        colorInterpolationFilters: "color-interpolation-filters",
        colorProfile: "color-profile",
        colorRendering: "color-rendering",
        crossOrigin: "crossorigin",
        dataType: "datatype",
        dominantBaseline: "dominant-baseline",
        enableBackground: "enable-background",
        fillOpacity: "fill-opacity",
        fillRule: "fill-rule",
        floodColor: "flood-color",
        floodOpacity: "flood-opacity",
        fontFamily: "font-family",
        fontSize: "font-size",
        fontSizeAdjust: "font-size-adjust",
        fontStretch: "font-stretch",
        fontStyle: "font-style",
        fontVariant: "font-variant",
        fontWeight: "font-weight",
        glyphName: "glyph-name",
        glyphOrientationHorizontal: "glyph-orientation-horizontal",
        glyphOrientationVertical: "glyph-orientation-vertical",
        hrefLang: "hreflang",
        horizAdvX: "horiz-adv-x",
        horizOriginX: "horiz-origin-x",
        horizOriginY: "horiz-origin-y",
        imageRendering: "image-rendering",
        letterSpacing: "letter-spacing",
        lightingColor: "lighting-color",
        markerEnd: "marker-end",
        markerMid: "marker-mid",
        markerStart: "marker-start",
        navDown: "nav-down",
        navDownLeft: "nav-down-left",
        navDownRight: "nav-down-right",
        navLeft: "nav-left",
        navNext: "nav-next",
        navPrev: "nav-prev",
        navRight: "nav-right",
        navUp: "nav-up",
        navUpLeft: "nav-up-left",
        navUpRight: "nav-up-right",
        onAbort: "onabort",
        onActivate: "onactivate",
        onAfterPrint: "onafterprint",
        onBeforePrint: "onbeforeprint",
        onBegin: "onbegin",
        onCancel: "oncancel",
        onCanPlay: "oncanplay",
        onCanPlayThrough: "oncanplaythrough",
        onChange: "onchange",
        onClick: "onclick",
        onClose: "onclose",
        onCopy: "oncopy",
        onCueChange: "oncuechange",
        onCut: "oncut",
        onDblClick: "ondblclick",
        onDrag: "ondrag",
        onDragEnd: "ondragend",
        onDragEnter: "ondragenter",
        onDragExit: "ondragexit",
        onDragLeave: "ondragleave",
        onDragOver: "ondragover",
        onDragStart: "ondragstart",
        onDrop: "ondrop",
        onDurationChange: "ondurationchange",
        onEmptied: "onemptied",
        onEnd: "onend",
        onEnded: "onended",
        onError: "onerror",
        onFocus: "onfocus",
        onFocusIn: "onfocusin",
        onFocusOut: "onfocusout",
        onHashChange: "onhashchange",
        onInput: "oninput",
        onInvalid: "oninvalid",
        onKeyDown: "onkeydown",
        onKeyPress: "onkeypress",
        onKeyUp: "onkeyup",
        onLoad: "onload",
        onLoadedData: "onloadeddata",
        onLoadedMetadata: "onloadedmetadata",
        onLoadStart: "onloadstart",
        onMessage: "onmessage",
        onMouseDown: "onmousedown",
        onMouseEnter: "onmouseenter",
        onMouseLeave: "onmouseleave",
        onMouseMove: "onmousemove",
        onMouseOut: "onmouseout",
        onMouseOver: "onmouseover",
        onMouseUp: "onmouseup",
        onMouseWheel: "onmousewheel",
        onOffline: "onoffline",
        onOnline: "ononline",
        onPageHide: "onpagehide",
        onPageShow: "onpageshow",
        onPaste: "onpaste",
        onPause: "onpause",
        onPlay: "onplay",
        onPlaying: "onplaying",
        onPopState: "onpopstate",
        onProgress: "onprogress",
        onRateChange: "onratechange",
        onRepeat: "onrepeat",
        onReset: "onreset",
        onResize: "onresize",
        onScroll: "onscroll",
        onSeeked: "onseeked",
        onSeeking: "onseeking",
        onSelect: "onselect",
        onShow: "onshow",
        onStalled: "onstalled",
        onStorage: "onstorage",
        onSubmit: "onsubmit",
        onSuspend: "onsuspend",
        onTimeUpdate: "ontimeupdate",
        onToggle: "ontoggle",
        onUnload: "onunload",
        onVolumeChange: "onvolumechange",
        onWaiting: "onwaiting",
        onZoom: "onzoom",
        overlinePosition: "overline-position",
        overlineThickness: "overline-thickness",
        paintOrder: "paint-order",
        panose1: "panose-1",
        pointerEvents: "pointer-events",
        referrerPolicy: "referrerpolicy",
        renderingIntent: "rendering-intent",
        shapeRendering: "shape-rendering",
        stopColor: "stop-color",
        stopOpacity: "stop-opacity",
        strikethroughPosition: "strikethrough-position",
        strikethroughThickness: "strikethrough-thickness",
        strokeDashArray: "stroke-dasharray",
        strokeDashOffset: "stroke-dashoffset",
        strokeLineCap: "stroke-linecap",
        strokeLineJoin: "stroke-linejoin",
        strokeMiterLimit: "stroke-miterlimit",
        strokeOpacity: "stroke-opacity",
        strokeWidth: "stroke-width",
        tabIndex: "tabindex",
        textAnchor: "text-anchor",
        textDecoration: "text-decoration",
        textRendering: "text-rendering",
        transformOrigin: "transform-origin",
        typeOf: "typeof",
        underlinePosition: "underline-position",
        underlineThickness: "underline-thickness",
        unicodeBidi: "unicode-bidi",
        unicodeRange: "unicode-range",
        unitsPerEm: "units-per-em",
        vAlphabetic: "v-alphabetic",
        vHanging: "v-hanging",
        vIdeographic: "v-ideographic",
        vMathematical: "v-mathematical",
        vectorEffect: "vector-effect",
        vertAdvY: "vert-adv-y",
        vertOriginX: "vert-origin-x",
        vertOriginY: "vert-origin-y",
        wordSpacing: "word-spacing",
        writingMode: "writing-mode",
        xHeight: "x-height",
        // These were camelcased in Tiny. Now lowercased in SVG 2
        playbackOrder: "playbackorder",
        timelineBegin: "timelinebegin"
    },
    transform: (0, $22f3c7b87445388a$export$5b10b3bc32d7efbc),
    properties: {
        about: (0, $bbc33f7d82395a8a$export$2ad25cfebf36cacd),
        accentHeight: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        accumulate: null,
        additive: null,
        alignmentBaseline: null,
        alphabetic: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        amplitude: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        arabicForm: null,
        ascent: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        attributeName: null,
        attributeType: null,
        azimuth: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        bandwidth: null,
        baselineShift: null,
        baseFrequency: null,
        baseProfile: null,
        bbox: null,
        begin: null,
        bias: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        by: null,
        calcMode: null,
        capHeight: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        className: (0, $bbc33f7d82395a8a$export$ab8645c862eb5a3e),
        clip: null,
        clipPath: null,
        clipPathUnits: null,
        clipRule: null,
        color: null,
        colorInterpolation: null,
        colorInterpolationFilters: null,
        colorProfile: null,
        colorRendering: null,
        content: null,
        contentScriptType: null,
        contentStyleType: null,
        crossOrigin: null,
        cursor: null,
        cx: null,
        cy: null,
        d: null,
        dataType: null,
        defaultAction: null,
        descent: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        diffuseConstant: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        direction: null,
        display: null,
        dur: null,
        divisor: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        dominantBaseline: null,
        download: (0, $bbc33f7d82395a8a$export$4a21f16c33752377),
        dx: null,
        dy: null,
        edgeMode: null,
        editable: null,
        elevation: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        enableBackground: null,
        end: null,
        event: null,
        exponent: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        externalResourcesRequired: null,
        fill: null,
        fillOpacity: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        fillRule: null,
        filter: null,
        filterRes: null,
        filterUnits: null,
        floodColor: null,
        floodOpacity: null,
        focusable: null,
        focusHighlight: null,
        fontFamily: null,
        fontSize: null,
        fontSizeAdjust: null,
        fontStretch: null,
        fontStyle: null,
        fontVariant: null,
        fontWeight: null,
        format: null,
        fr: null,
        from: null,
        fx: null,
        fy: null,
        g1: (0, $bbc33f7d82395a8a$export$9c8d678629b3d3),
        g2: (0, $bbc33f7d82395a8a$export$9c8d678629b3d3),
        glyphName: (0, $bbc33f7d82395a8a$export$9c8d678629b3d3),
        glyphOrientationHorizontal: null,
        glyphOrientationVertical: null,
        glyphRef: null,
        gradientTransform: null,
        gradientUnits: null,
        handler: null,
        hanging: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        hatchContentUnits: null,
        hatchUnits: null,
        height: null,
        href: null,
        hrefLang: null,
        horizAdvX: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        horizOriginX: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        horizOriginY: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        id: null,
        ideographic: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        imageRendering: null,
        initialVisibility: null,
        in: null,
        in2: null,
        intercept: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        k: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        k1: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        k2: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        k3: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        k4: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        kernelMatrix: (0, $bbc33f7d82395a8a$export$2ad25cfebf36cacd),
        kernelUnitLength: null,
        keyPoints: null,
        keySplines: null,
        keyTimes: null,
        kerning: null,
        lang: null,
        lengthAdjust: null,
        letterSpacing: null,
        lightingColor: null,
        limitingConeAngle: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        local: null,
        markerEnd: null,
        markerMid: null,
        markerStart: null,
        markerHeight: null,
        markerUnits: null,
        markerWidth: null,
        mask: null,
        maskContentUnits: null,
        maskUnits: null,
        mathematical: null,
        max: null,
        media: null,
        mediaCharacterEncoding: null,
        mediaContentEncodings: null,
        mediaSize: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        mediaTime: null,
        method: null,
        min: null,
        mode: null,
        name: null,
        navDown: null,
        navDownLeft: null,
        navDownRight: null,
        navLeft: null,
        navNext: null,
        navPrev: null,
        navRight: null,
        navUp: null,
        navUpLeft: null,
        navUpRight: null,
        numOctaves: null,
        observer: null,
        offset: null,
        onAbort: null,
        onActivate: null,
        onAfterPrint: null,
        onBeforePrint: null,
        onBegin: null,
        onCancel: null,
        onCanPlay: null,
        onCanPlayThrough: null,
        onChange: null,
        onClick: null,
        onClose: null,
        onCopy: null,
        onCueChange: null,
        onCut: null,
        onDblClick: null,
        onDrag: null,
        onDragEnd: null,
        onDragEnter: null,
        onDragExit: null,
        onDragLeave: null,
        onDragOver: null,
        onDragStart: null,
        onDrop: null,
        onDurationChange: null,
        onEmptied: null,
        onEnd: null,
        onEnded: null,
        onError: null,
        onFocus: null,
        onFocusIn: null,
        onFocusOut: null,
        onHashChange: null,
        onInput: null,
        onInvalid: null,
        onKeyDown: null,
        onKeyPress: null,
        onKeyUp: null,
        onLoad: null,
        onLoadedData: null,
        onLoadedMetadata: null,
        onLoadStart: null,
        onMessage: null,
        onMouseDown: null,
        onMouseEnter: null,
        onMouseLeave: null,
        onMouseMove: null,
        onMouseOut: null,
        onMouseOver: null,
        onMouseUp: null,
        onMouseWheel: null,
        onOffline: null,
        onOnline: null,
        onPageHide: null,
        onPageShow: null,
        onPaste: null,
        onPause: null,
        onPlay: null,
        onPlaying: null,
        onPopState: null,
        onProgress: null,
        onRateChange: null,
        onRepeat: null,
        onReset: null,
        onResize: null,
        onScroll: null,
        onSeeked: null,
        onSeeking: null,
        onSelect: null,
        onShow: null,
        onStalled: null,
        onStorage: null,
        onSubmit: null,
        onSuspend: null,
        onTimeUpdate: null,
        onToggle: null,
        onUnload: null,
        onVolumeChange: null,
        onWaiting: null,
        onZoom: null,
        opacity: null,
        operator: null,
        order: null,
        orient: null,
        orientation: null,
        origin: null,
        overflow: null,
        overlay: null,
        overlinePosition: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        overlineThickness: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        paintOrder: null,
        panose1: null,
        path: null,
        pathLength: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        patternContentUnits: null,
        patternTransform: null,
        patternUnits: null,
        phase: null,
        ping: (0, $bbc33f7d82395a8a$export$ab8645c862eb5a3e),
        pitch: null,
        playbackOrder: null,
        pointerEvents: null,
        points: null,
        pointsAtX: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        pointsAtY: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        pointsAtZ: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        preserveAlpha: null,
        preserveAspectRatio: null,
        primitiveUnits: null,
        propagate: null,
        property: (0, $bbc33f7d82395a8a$export$2ad25cfebf36cacd),
        r: null,
        radius: null,
        referrerPolicy: null,
        refX: null,
        refY: null,
        rel: (0, $bbc33f7d82395a8a$export$2ad25cfebf36cacd),
        rev: (0, $bbc33f7d82395a8a$export$2ad25cfebf36cacd),
        renderingIntent: null,
        repeatCount: null,
        repeatDur: null,
        requiredExtensions: (0, $bbc33f7d82395a8a$export$2ad25cfebf36cacd),
        requiredFeatures: (0, $bbc33f7d82395a8a$export$2ad25cfebf36cacd),
        requiredFonts: (0, $bbc33f7d82395a8a$export$2ad25cfebf36cacd),
        requiredFormats: (0, $bbc33f7d82395a8a$export$2ad25cfebf36cacd),
        resource: null,
        restart: null,
        result: null,
        rotate: null,
        rx: null,
        ry: null,
        scale: null,
        seed: null,
        shapeRendering: null,
        side: null,
        slope: null,
        snapshotTime: null,
        specularConstant: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        specularExponent: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        spreadMethod: null,
        spacing: null,
        startOffset: null,
        stdDeviation: null,
        stemh: null,
        stemv: null,
        stitchTiles: null,
        stopColor: null,
        stopOpacity: null,
        strikethroughPosition: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        strikethroughThickness: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        string: null,
        stroke: null,
        strokeDashArray: (0, $bbc33f7d82395a8a$export$2ad25cfebf36cacd),
        strokeDashOffset: null,
        strokeLineCap: null,
        strokeLineJoin: null,
        strokeMiterLimit: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        strokeOpacity: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        strokeWidth: null,
        style: null,
        surfaceScale: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        syncBehavior: null,
        syncBehaviorDefault: null,
        syncMaster: null,
        syncTolerance: null,
        syncToleranceDefault: null,
        systemLanguage: (0, $bbc33f7d82395a8a$export$2ad25cfebf36cacd),
        tabIndex: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        tableValues: null,
        target: null,
        targetX: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        targetY: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        textAnchor: null,
        textDecoration: null,
        textRendering: null,
        textLength: null,
        timelineBegin: null,
        title: null,
        transformBehavior: null,
        type: null,
        typeOf: (0, $bbc33f7d82395a8a$export$2ad25cfebf36cacd),
        to: null,
        transform: null,
        transformOrigin: null,
        u1: null,
        u2: null,
        underlinePosition: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        underlineThickness: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        unicode: null,
        unicodeBidi: null,
        unicodeRange: null,
        unitsPerEm: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        values: null,
        vAlphabetic: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        vMathematical: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        vectorEffect: null,
        vHanging: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        vIdeographic: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        version: null,
        vertAdvY: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        vertOriginX: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        vertOriginY: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        viewBox: null,
        viewTarget: null,
        visibility: null,
        width: null,
        widths: null,
        wordSpacing: null,
        writingMode: null,
        x: null,
        x1: null,
        x2: null,
        xChannelSelector: null,
        xHeight: (0, $bbc33f7d82395a8a$export$98e628dec113755e),
        y: null,
        y1: null,
        y2: null,
        yChannelSelector: null,
        z: null,
        zoomAndPan: null
    }
});


/**
 * @typedef {import('./util/schema.js').Schema} Schema
 */ 


const $740afc8bd0302ea0$var$valid = /^data[-\w.:]+$/i;
const $740afc8bd0302ea0$var$dash = /-[a-z]/g;
const $740afc8bd0302ea0$var$cap = /[A-Z]/g;
function $740afc8bd0302ea0$export$71aa6c912b956294(schema, value) {
    const normal = (0, $0880afc82b5794e9$export$a3295358bff77e)(value);
    let prop = value;
    let Type = (0, $2fcc2e947415cf09$export$c4868e4a24d48fad);
    if (normal in schema.normal) return schema.property[schema.normal[normal]];
    if (normal.length > 4 && normal.slice(0, 4) === "data" && $740afc8bd0302ea0$var$valid.test(value)) {
        // Attribute or property.
        if (value.charAt(4) === "-") {
            // Turn it into a property.
            const rest = value.slice(5).replace($740afc8bd0302ea0$var$dash, $740afc8bd0302ea0$var$camelcase);
            prop = "data" + rest.charAt(0).toUpperCase() + rest.slice(1);
        } else {
            // Turn it into an attribute.
            const rest = value.slice(4);
            if (!$740afc8bd0302ea0$var$dash.test(rest)) {
                let dashes = rest.replace($740afc8bd0302ea0$var$cap, $740afc8bd0302ea0$var$kebab);
                if (dashes.charAt(0) !== "-") dashes = "-" + dashes;
                value = "data" + dashes;
            }
        }
        Type = (0, $25641d2f17987f4e$export$ea6b9f0064e88c9b);
    }
    return new Type(prop, value);
}
/**
 * @param {string} $0
 * @returns {string}
 */ function $740afc8bd0302ea0$var$kebab($0) {
    return "-" + $0.toLowerCase();
}
/**
 * @param {string} $0
 * @returns {string}
 */ function $740afc8bd0302ea0$var$camelcase($0) {
    return $0.charAt(1).toUpperCase();
}




const $bb9bd2b68008f123$export$c0bb0b647f701bb5 = (0, $8b43b564784566e8$export$4950aa0f605343fb)([
    (0, $000e0990fcf22f5d$export$f2913fe8983302e),
    (0, $cb3554868573ee99$export$2bd1230ec7600845),
    (0, $39635c3c46b01137$export$e20c24a128671213),
    (0, $479f5cbf5cbefa9f$export$4d2d26490572750a),
    (0, $2a5424f016a37a22$export$c0bb0b647f701bb5)
], "html");
const $bb9bd2b68008f123$export$7ed1367e7fa1ad68 = (0, $8b43b564784566e8$export$4950aa0f605343fb)([
    (0, $000e0990fcf22f5d$export$f2913fe8983302e),
    (0, $cb3554868573ee99$export$2bd1230ec7600845),
    (0, $39635c3c46b01137$export$e20c24a128671213),
    (0, $479f5cbf5cbefa9f$export$4d2d26490572750a),
    (0, $b5b70542c0690e44$export$7ed1367e7fa1ad68)
], "svg");


/**
 * @typedef {import('./types.js').Node} Node
 * @typedef {import('./types.js').Element} Element
 * @typedef {import('./types.js').Parent} Parent
 * @typedef {import('./types.js').RuleSet} RuleSet
 * @typedef {import('./types.js').SelectState} SelectState
 * @typedef {import('./types.js').Selectors} Selectors
 *
 * @typedef Nest
 *   Rule sets by nesting.
 * @property {Array<RuleSet> | undefined} descendant
 *   `a b`
 * @property {Array<RuleSet> | undefined} directChild
 *   `a > b`
 * @property {Array<RuleSet> | undefined} adjacentSibling
 *   `a + b`
 * @property {Array<RuleSet> | undefined} generalSibling
 *   `a ~ b`
 *
 * @typedef Counts
 *   Info on elements in a parent.
 * @property {number} count
 *   Number of elements.
 * @property {Map<string, number>} types
 *   Number of elements by tag name.
 */ /**
 * @typedef {import('./types.js').SelectState} SelectState
 * @typedef {import('./types.js').Node} Node
 * @typedef {import('./types.js').ElementChild} ElementChild
 * @typedef {import('./types.js').Direction} Direction
 * @typedef {import('unist-util-visit/complex-types.js').Visitor<ElementChild>} Visitor
 */ const $70c36d784f6d7c8b$var$rtlRange = "\u0591-\u07FF\uFB1D-\uFDFD\uFE70-\uFEFC";
const $70c36d784f6d7c8b$var$ltrRange = "A-Za-z\xc0-\xd6\xd8-\xf6\xf8-\u02B8\u0300-\u0590\u0800-\u1FFF\u200E\u2C00-\uFB1C\uFE00-\uFE6F\uFEFD-\uFFFF";
/* eslint-disable no-misleading-character-class */ const $70c36d784f6d7c8b$var$rtl = new RegExp("^[^" + $70c36d784f6d7c8b$var$ltrRange + "]*[" + $70c36d784f6d7c8b$var$rtlRange + "]");
const $70c36d784f6d7c8b$var$ltr = new RegExp("^[^" + $70c36d784f6d7c8b$var$rtlRange + "]*[" + $70c36d784f6d7c8b$var$ltrRange + "]");
function $70c36d784f6d7c8b$export$9fddb9d0dd7d8a54(value) {
    const source = String(value || "");
    return $70c36d784f6d7c8b$var$rtl.test(source) ? "rtl" : $70c36d784f6d7c8b$var$ltr.test(source) ? "ltr" : "neutral";
}


/**
 * @fileoverview
 *   Get the plain-text value of a hast node.
 * @longdescription
 *   ## Use
 *
 *   ```js
 *   import {h} from 'hastscript'
 *   import {toString} from 'hast-util-to-string'
 *
 *   toString(h('p', 'Alpha'))
 *   //=> 'Alpha'
 *   toString(h('div', [h('b', 'Bold'), ' and ', h('i', 'italic'), '.']))
 *   //=> 'Bold and italic.'
 *   ```
 *
 *   ## API
 *
 *   ### `toString(node)`
 *
 *   Transform a node to a string.
 */ /**
 * @typedef {import('hast').Root} Root
 * @typedef {import('hast').Element} Element
 * @typedef {Root|Root['children'][number]} Node
 */ /**
 * Get the plain-text value of a hast node.
 *
 * @param {Node} node
 * @returns {string}
 */ function $a4e8a7169281112e$export$f84e8e69fd4488a5(node) {
    // “The concatenation of data of all the Text node descendants of the context
    // object, in tree order.”
    if ("children" in node) return $a4e8a7169281112e$var$all(node);
    // “Context object’s data.”
    return "value" in node ? node.value : "";
}
/**
 * @param {Node} node
 * @returns {string}
 */ function $a4e8a7169281112e$var$one(node) {
    if (node.type === "text") return node.value;
    return "children" in node ? $a4e8a7169281112e$var$all(node) : "";
}
/**
 * @param {Root|Element} node
 * @returns {string}
 */ function $a4e8a7169281112e$var$all(node) {
    let index = -1;
    /** @type {string[]} */ const result = [];
    while(++index < node.children.length)result[index] = $a4e8a7169281112e$var$one(node.children[index]);
    return result.join("");
}



/**
 * @typedef {import('unist').Node} Node
 * @typedef {import('unist').Parent} Parent
 * @typedef {import('unist-util-is').Test} Test
 */ /**
 * @typedef {boolean | 'skip'} Action
 *   Union of the action types.
 *
 * @typedef {number} Index
 *   Move to the sibling at `index` next (after node itself is completely
 *   traversed).
 *
 *   Useful if mutating the tree, such as removing the node the visitor is
 *   currently on, or any of its previous siblings.
 *   Results less than 0 or greater than or equal to `children.length` stop
 *   traversing the parent.
 *
 * @typedef {[(Action | null | undefined | void)?, (Index | null | undefined)?]} ActionTuple
 *   List with one or two values, the first an action, the second an index.
 *
 * @typedef {Action | ActionTuple | Index | null | undefined | void} VisitorResult
 *   Any value that can be returned from a visitor.
 */ /**
 * @template {Node} [Visited=Node]
 *   Visited node type.
 * @template {Parent} [Ancestor=Parent]
 *   Ancestor type.
 * @callback Visitor
 *   Handle a node (matching `test`, if given).
 *
 *   Visitors are free to transform `node`.
 *   They can also transform the parent of node (the last of `ancestors`).
 *
 *   Replacing `node` itself, if `SKIP` is not returned, still causes its
 *   descendants to be walked (which is a bug).
 *
 *   When adding or removing previous siblings of `node` (or next siblings, in
 *   case of reverse), the `Visitor` should return a new `Index` to specify the
 *   sibling to traverse after `node` is traversed.
 *   Adding or removing next siblings of `node` (or previous siblings, in case
 *   of reverse) is handled as expected without needing to return a new `Index`.
 *
 *   Removing the children property of an ancestor still results in them being
 *   traversed.
 * @param {Visited} node
 *   Found node.
 * @param {Array<Ancestor>} ancestors
 *   Ancestors of `node`.
 * @returns {VisitorResult}
 *   What to do next.
 *
 *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.
 *   An `Action` is treated as a tuple of `[Action]`.
 *
 *   Passing a tuple back only makes sense if the `Action` is `SKIP`.
 *   When the `Action` is `EXIT`, that action can be returned.
 *   When the `Action` is `CONTINUE`, `Index` can be returned.
 */ /**
 * @template {Node} [Tree=Node]
 *   Tree type.
 * @template {Test} [Check=string]
 *   Test type.
 * @typedef {Visitor<import('./complex-types.js').Matches<import('./complex-types.js').InclusiveDescendant<Tree>, Check>, Extract<import('./complex-types.js').InclusiveDescendant<Tree>, Parent>>} BuildVisitor
 *   Build a typed `Visitor` function from a tree and a test.
 *
 *   It will infer which values are passed as `node` and which as `parents`.
 */ /**
 * @typedef {import('unist').Node} Node
 * @typedef {import('unist').Parent} Parent
 */ /**
 * @typedef {Record<string, unknown>} Props
 * @typedef {null | undefined | string | Props | TestFunctionAnything | Array<string | Props | TestFunctionAnything>} Test
 *   Check for an arbitrary node, unaware of TypeScript inferral.
 *
 * @callback TestFunctionAnything
 *   Check if a node passes a test, unaware of TypeScript inferral.
 * @param {unknown} this
 *   The given context.
 * @param {Node} node
 *   A node.
 * @param {number | null | undefined} [index]
 *   The node’s position in its parent.
 * @param {Parent | null | undefined} [parent]
 *   The node’s parent.
 * @returns {boolean | void}
 *   Whether this node passes the test.
 */ /**
 * @template {Node} Kind
 *   Node type.
 * @typedef {Kind['type'] | Partial<Kind> | TestFunctionPredicate<Kind> | Array<Kind['type'] | Partial<Kind> | TestFunctionPredicate<Kind>>} PredicateTest
 *   Check for a node that can be inferred by TypeScript.
 */ /**
 * Check if a node passes a certain test.
 *
 * @template {Node} Kind
 *   Node type.
 * @callback TestFunctionPredicate
 *   Complex test function for a node that can be inferred by TypeScript.
 * @param {Node} node
 *   A node.
 * @param {number | null | undefined} [index]
 *   The node’s position in its parent.
 * @param {Parent | null | undefined} [parent]
 *   The node’s parent.
 * @returns {node is Kind}
 *   Whether this node passes the test.
 */ /**
 * @callback AssertAnything
 *   Check that an arbitrary value is a node, unaware of TypeScript inferral.
 * @param {unknown} [node]
 *   Anything (typically a node).
 * @param {number | null | undefined} [index]
 *   The node’s position in its parent.
 * @param {Parent | null | undefined} [parent]
 *   The node’s parent.
 * @returns {boolean}
 *   Whether this is a node and passes a test.
 */ /**
 * Check if a node is a node and passes a certain node test.
 *
 * @template {Node} Kind
 *   Node type.
 * @callback AssertPredicate
 *   Check that an arbitrary value is a specific node, aware of TypeScript.
 * @param {unknown} [node]
 *   Anything (typically a node).
 * @param {number | null | undefined} [index]
 *   The node’s position in its parent.
 * @param {Parent | null | undefined} [parent]
 *   The node’s parent.
 * @returns {node is Kind}
 *   Whether this is a node and passes a test.
 */ /**
 * Check if `node` is a `Node` and whether it passes the given test.
 *
 * @param node
 *   Thing to check, typically `Node`.
 * @param test
 *   A check for a specific node.
 * @param index
 *   The node’s position in its parent.
 * @param parent
 *   The node’s parent.
 * @returns
 *   Whether `node` is a node and passes a test.
 */ const $ca62b203d2adafff$export$226b3eccf92c9ed9 = /**
   * @type {(
   *   (() => false) &
   *   (<Kind extends Node = Node>(node: unknown, test: PredicateTest<Kind>, index: number, parent: Parent, context?: unknown) => node is Kind) &
   *   (<Kind extends Node = Node>(node: unknown, test: PredicateTest<Kind>, index?: null | undefined, parent?: null | undefined, context?: unknown) => node is Kind) &
   *   ((node: unknown, test: Test, index: number, parent: Parent, context?: unknown) => boolean) &
   *   ((node: unknown, test?: Test, index?: null | undefined, parent?: null | undefined, context?: unknown) => boolean)
   * )}
   */ /**
     * @param {unknown} [node]
     * @param {Test} [test]
     * @param {number | null | undefined} [index]
     * @param {Parent | null | undefined} [parent]
     * @param {unknown} [context]
     * @returns {boolean}
     */ // eslint-disable-next-line max-params
function is(node, test, index, parent, context) {
    const check = $ca62b203d2adafff$export$9c68d69a4c5bbcf9(test);
    if (index !== undefined && index !== null && (typeof index !== "number" || index < 0 || index === Number.POSITIVE_INFINITY)) throw new Error("Expected positive finite index");
    if (parent !== undefined && parent !== null && (!is(parent) || !parent.children)) throw new Error("Expected parent node");
    if ((parent === undefined || parent === null) !== (index === undefined || index === null)) throw new Error("Expected both parent and index");
    // @ts-expect-error Looks like a node.
    return node && node.type && typeof node.type === "string" ? Boolean(check.call(context, node, index, parent)) : false;
};
const $ca62b203d2adafff$export$9c68d69a4c5bbcf9 = /**
   * @type {(
   *   (<Kind extends Node>(test: PredicateTest<Kind>) => AssertPredicate<Kind>) &
   *   ((test?: Test) => AssertAnything)
   * )}
   */ /**
     * @param {Test} [test]
     * @returns {AssertAnything}
     */ function(test) {
    if (test === undefined || test === null) return $ca62b203d2adafff$var$ok;
    if (typeof test === "string") return $ca62b203d2adafff$var$typeFactory(test);
    if (typeof test === "object") return Array.isArray(test) ? $ca62b203d2adafff$var$anyFactory(test) : $ca62b203d2adafff$var$propsFactory(test);
    if (typeof test === "function") return $ca62b203d2adafff$var$castFactory(test);
    throw new Error("Expected function, string, or object as test");
};
/**
 * @param {Array<string | Props | TestFunctionAnything>} tests
 * @returns {AssertAnything}
 */ function $ca62b203d2adafff$var$anyFactory(tests) {
    /** @type {Array<AssertAnything>} */ const checks = [];
    let index = -1;
    while(++index < tests.length)checks[index] = $ca62b203d2adafff$export$9c68d69a4c5bbcf9(tests[index]);
    return $ca62b203d2adafff$var$castFactory(any);
    /**
   * @this {unknown}
   * @param {Array<unknown>} parameters
   * @returns {boolean}
   */ function any(...parameters) {
        let index = -1;
        while(++index < checks.length){
            if (checks[index].call(this, ...parameters)) return true;
        }
        return false;
    }
}
/**
 * Turn an object into a test for a node with a certain fields.
 *
 * @param {Props} check
 * @returns {AssertAnything}
 */ function $ca62b203d2adafff$var$propsFactory(check) {
    return $ca62b203d2adafff$var$castFactory(all);
    /**
   * @param {Node} node
   * @returns {boolean}
   */ function all(node) {
        /** @type {string} */ let key;
        for(key in check){
            // @ts-expect-error: hush, it sure works as an index.
            if (node[key] !== check[key]) return false;
        }
        return true;
    }
}
/**
 * Turn a string into a test for a node with a certain type.
 *
 * @param {string} check
 * @returns {AssertAnything}
 */ function $ca62b203d2adafff$var$typeFactory(check) {
    return $ca62b203d2adafff$var$castFactory(type);
    /**
   * @param {Node} node
   */ function type(node) {
        return node && node.type === check;
    }
}
/**
 * Turn a custom test into a test for a node that passes that test.
 *
 * @param {TestFunctionAnything} check
 * @returns {AssertAnything}
 */ function $ca62b203d2adafff$var$castFactory(check) {
    return assertion;
    /**
   * @this {unknown}
   * @param {unknown} node
   * @param {Array<unknown>} parameters
   * @returns {boolean}
   */ function assertion(node, ...parameters) {
        return Boolean(node && typeof node === "object" && "type" in node && // @ts-expect-error: fine.
        Boolean(check.call(this, node, ...parameters)));
    }
}
function $ca62b203d2adafff$var$ok() {
    return true;
}


/**
 * @param {string} d
 * @returns {string}
 */ function $4dca52d6993b1fda$export$35e9368ef982300f(d) {
    return "\x1b[33m" + d + "\x1b[39m";
}


const $395321e98c0e9166$export$f4d8133c446fe484 = true;
const $395321e98c0e9166$export$7f100f842f565dc9 = false;
const $395321e98c0e9166$export$8773f85c2fb2c116 = "skip";
const $395321e98c0e9166$export$70008a21eb6de899 = /**
   * @type {(
   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &
   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)
   * )}
   */ /**
     * @param {Node} tree
     * @param {Test} test
     * @param {Visitor<Node>} visitor
     * @param {boolean | null | undefined} [reverse]
     * @returns {void}
     */ function(tree, test, visitor, reverse) {
    if (typeof test === "function" && typeof visitor !== "function") {
        reverse = visitor;
        // @ts-expect-error no visitor given, so `visitor` is test.
        visitor = test;
        test = null;
    }
    const is = (0, $ca62b203d2adafff$export$9c68d69a4c5bbcf9)(test);
    const step = reverse ? -1 : 1;
    factory(tree, undefined, [])();
    /**
       * @param {Node} node
       * @param {number | undefined} index
       * @param {Array<Parent>} parents
       */ function factory(node, index, parents) {
        /** @type {Record<string, unknown>} */ // @ts-expect-error: hush
        const value = node && typeof node === "object" ? node : {};
        if (typeof value.type === "string") {
            const name = // `hast`
            typeof value.tagName === "string" ? value.tagName : typeof value.name === "string" ? value.name : undefined;
            Object.defineProperty(visit, "name", {
                value: "node (" + (0, $4dca52d6993b1fda$export$35e9368ef982300f)(node.type + (name ? "<" + name + ">" : "")) + ")"
            });
        }
        return visit;
        function visit() {
            /** @type {ActionTuple} */ let result = [];
            /** @type {ActionTuple} */ let subresult;
            /** @type {number} */ let offset;
            /** @type {Array<Parent>} */ let grandparents;
            if (!test || is(node, index, parents[parents.length - 1] || null)) {
                result = $395321e98c0e9166$var$toResult(visitor(node, parents));
                if (result[0] === $395321e98c0e9166$export$7f100f842f565dc9) return result;
            }
            // @ts-expect-error looks like a parent.
            if (node.children && result[0] !== $395321e98c0e9166$export$8773f85c2fb2c116) {
                // @ts-expect-error looks like a parent.
                offset = (reverse ? node.children.length : -1) + step;
                // @ts-expect-error looks like a parent.
                grandparents = parents.concat(node);
                // @ts-expect-error looks like a parent.
                while(offset > -1 && offset < node.children.length){
                    // @ts-expect-error looks like a parent.
                    subresult = factory(node.children[offset], offset, grandparents)();
                    if (subresult[0] === $395321e98c0e9166$export$7f100f842f565dc9) return subresult;
                    offset = typeof subresult[1] === "number" ? subresult[1] : offset + step;
                }
            }
            return result;
        }
    }
};
/**
 * Turn a return value into a clean result.
 *
 * @param {VisitorResult} value
 *   Valid return values from visitors.
 * @returns {ActionTuple}
 *   Clean result.
 */ function $395321e98c0e9166$var$toResult(value) {
    if (Array.isArray(value)) return value;
    if (typeof value === "number") return [
        $395321e98c0e9166$export$f4d8133c446fe484,
        value
    ];
    return [
        value
    ];
}

/**
 * @typedef {import('unist').Node} Node
 * @typedef {import('unist').Parent} Parent
 * @typedef {import('unist-util-is').Test} Test
 * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult
 */ /**
 * Check if `Child` can be a child of `Ancestor`.
 *
 * Returns the ancestor when `Child` can be a child of `Ancestor`, or returns
 * `never`.
 *
 * @template {Node} Ancestor
 *   Node type.
 * @template {Node} Child
 *   Node type.
 * @typedef {(
 *   Ancestor extends Parent
 *     ? Child extends Ancestor['children'][number]
 *       ? Ancestor
 *       : never
 *     : never
 * )} ParentsOf
 */ /**
 * @template {Node} [Visited=Node]
 *   Visited node type.
 * @template {Parent} [Ancestor=Parent]
 *   Ancestor type.
 * @callback Visitor
 *   Handle a node (matching `test`, if given).
 *
 *   Visitors are free to transform `node`.
 *   They can also transform `parent`.
 *
 *   Replacing `node` itself, if `SKIP` is not returned, still causes its
 *   descendants to be walked (which is a bug).
 *
 *   When adding or removing previous siblings of `node` (or next siblings, in
 *   case of reverse), the `Visitor` should return a new `Index` to specify the
 *   sibling to traverse after `node` is traversed.
 *   Adding or removing next siblings of `node` (or previous siblings, in case
 *   of reverse) is handled as expected without needing to return a new `Index`.
 *
 *   Removing the children property of `parent` still results in them being
 *   traversed.
 * @param {Visited} node
 *   Found node.
 * @param {Visited extends Node ? number | null : never} index
 *   Index of `node` in `parent`.
 * @param {Ancestor extends Node ? Ancestor | null : never} parent
 *   Parent of `node`.
 * @returns {VisitorResult}
 *   What to do next.
 *
 *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.
 *   An `Action` is treated as a tuple of `[Action]`.
 *
 *   Passing a tuple back only makes sense if the `Action` is `SKIP`.
 *   When the `Action` is `EXIT`, that action can be returned.
 *   When the `Action` is `CONTINUE`, `Index` can be returned.
 */ /**
 * Build a typed `Visitor` function from a node and all possible parents.
 *
 * It will infer which values are passed as `node` and which as `parent`.
 *
 * @template {Node} Visited
 *   Node type.
 * @template {Parent} Ancestor
 *   Parent type.
 * @typedef {Visitor<Visited, ParentsOf<Ancestor, Visited>>} BuildVisitorFromMatch
 */ /**
 * Build a typed `Visitor` function from a list of descendants and a test.
 *
 * It will infer which values are passed as `node` and which as `parent`.
 *
 * @template {Node} Descendant
 *   Node type.
 * @template {Test} Check
 *   Test type.
 * @typedef {(
 *   BuildVisitorFromMatch<
 *     import('unist-util-visit-parents/complex-types.js').Matches<Descendant, Check>,
 *     Extract<Descendant, Parent>
 *   >
 * )} BuildVisitorFromDescendants
 */ /**
 * Build a typed `Visitor` function from a tree and a test.
 *
 * It will infer which values are passed as `node` and which as `parent`.
 *
 * @template {Node} [Tree=Node]
 *   Node type.
 * @template {Test} [Check=string]
 *   Test type.
 * @typedef {(
 *   BuildVisitorFromDescendants<
 *     import('unist-util-visit-parents/complex-types.js').InclusiveDescendant<Tree>,
 *     Check
 *   >
 * )} BuildVisitor
 */ 
const $e354ba8a3f4f5e7d$export$bf638b60ea8b89b7 = /**
   * @type {(
   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &
   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)
   * )}
   */ /**
     * @param {Node} tree
     * @param {Test} test
     * @param {Visitor} visitor
     * @param {boolean | null | undefined} [reverse]
     * @returns {void}
     */ function(tree, test, visitor, reverse) {
    if (typeof test === "function" && typeof visitor !== "function") {
        reverse = visitor;
        visitor = test;
        test = null;
    }
    (0, $395321e98c0e9166$export$70008a21eb6de899)(tree, test, overload, reverse);
    /**
       * @param {Node} node
       * @param {Array<Parent>} parents
       */ function overload(node, parents) {
        const parent = parents[parents.length - 1];
        return visitor(node, parent ? parent.children.indexOf(node) : null, parent);
    }
};


function $94bb0e936d3699a3$export$b6a91203b6b36f(state, node) {
    const schema = state.schema;
    const language = state.language;
    const currentDirection = state.direction;
    const editableOrEditingHost = state.editableOrEditingHost;
    /** @type {Direction | undefined} */ let dirInferred;
    if (node.type === "element" && node.properties) {
        const lang = node.properties.xmlLang || node.properties.lang;
        const type = node.properties.type || "text";
        const dir = $94bb0e936d3699a3$var$dirProperty(node);
        if (lang !== undefined && lang !== null) state.language = String(lang);
        if (schema && schema.space === "html") {
            if (node.properties.contentEditable === "true") state.editableOrEditingHost = true;
            if (node.tagName === "svg") state.schema = (0, $bb9bd2b68008f123$export$7ed1367e7fa1ad68);
            // See: <https://html.spec.whatwg.org/#the-directionality>.
            // Explicit `[dir=rtl]`.
            if (dir === "rtl") dirInferred = dir;
            else if (// Explicit `[dir=ltr]`.
            dir === "ltr" || // HTML with an invalid or no `[dir]`.
            dir !== "auto" && node.tagName === "html" || // `input[type=tel]` with an invalid or no `[dir]`.
            dir !== "auto" && node.tagName === "input" && type === "tel") dirInferred = "ltr";
            else if (dir === "auto" || node.tagName === "bdi") {
                if (node.tagName === "textarea") // Check contents of `<textarea>`.
                dirInferred = $94bb0e936d3699a3$var$dirBidi((0, $a4e8a7169281112e$export$f84e8e69fd4488a5)(node));
                else if (node.tagName === "input" && (type === "email" || type === "search" || type === "tel" || type === "text")) // Check value of `<input>`.
                dirInferred = node.properties.value ? $94bb0e936d3699a3$var$dirBidi(node.properties.value) : "ltr";
                else // Check text nodes in `node`.
                (0, $e354ba8a3f4f5e7d$export$bf638b60ea8b89b7)(node, inferDirectionality);
            }
            if (dirInferred) state.direction = dirInferred;
        } else if (state.editableOrEditingHost) state.editableOrEditingHost = false;
    }
    return reset;
    function reset() {
        state.schema = schema;
        state.language = language;
        state.direction = currentDirection;
        state.editableOrEditingHost = editableOrEditingHost;
    }
    /** @type {Visitor} */ function inferDirectionality(child) {
        if (child.type === "text") {
            dirInferred = $94bb0e936d3699a3$var$dirBidi(child.value);
            return dirInferred ? (0, $395321e98c0e9166$export$7f100f842f565dc9) : undefined;
        }
        if (child !== node && child.type === "element" && (child.tagName === "bdi" || child.tagName === "script" || child.tagName === "style" || child.tagName === "textare" || $94bb0e936d3699a3$var$dirProperty(child))) return 0, $395321e98c0e9166$export$8773f85c2fb2c116;
    }
}
/**
 * @param {string} value
 * @returns {Direction | undefined}
 */ function $94bb0e936d3699a3$var$dirBidi(value) {
    const result = (0, $70c36d784f6d7c8b$export$9fddb9d0dd7d8a54)(value);
    return result === "neutral" ? undefined : result;
}
/**
 * @param {ElementChild} node
 * @returns {Direction | undefined}
 */ function $94bb0e936d3699a3$var$dirProperty(node) {
    const value = node.type === "element" && node.properties && typeof node.properties.dir === "string" ? node.properties.dir.toLowerCase() : undefined;
    return value === "auto" || value === "ltr" || value === "rtl" ? value : undefined;
}


/**
 * @typedef {import('./types.js').Rule} Rule
 * @typedef {import('./types.js').Element} Element
 * @typedef {import('./types.js').Parent} Parent
 * @typedef {import('./types.js').SelectState} SelectState
 */ /**
 * @typedef {import('./types.js').Rule} Rule
 * @typedef {import('./types.js').RuleAttr} RuleAttr
 * @typedef {import('./types.js').Element} Element
 * @typedef {import('./types.js').Schema} Schema
 * @typedef {import('./types.js').Info} Info
 * @typedef {import('./types.js').PropertyValue} PropertyValue
 */ /**
 * @typedef Options
 *   Configuration for `stringify`.
 * @property {boolean} [padLeft=true]
 *   Whether to pad a space before a token.
 * @property {boolean} [padRight=false]
 *   Whether to pad a space after a token.
 */ /**
 * @typedef {Options} StringifyOptions
 *   Please use `StringifyOptions` instead.
 */ /**
 * Parse comma-separated tokens to an array.
 *
 * @param {string} value
 *   Comma-separated tokens.
 * @returns {Array<string>}
 *   List of tokens.
 */ function $f93df7ec1ab3323b$export$98e6a39c04603d36(value) {
    /** @type {Array<string>} */ const tokens = [];
    const input = String(value || "");
    let index = input.indexOf(",");
    let start = 0;
    /** @type {boolean} */ let end = false;
    while(!end){
        if (index === -1) {
            index = input.length;
            end = true;
        }
        const token = input.slice(start, index).trim();
        if (token || !end) tokens.push(token);
        start = index + 1;
        index = input.indexOf(",", start);
    }
    return tokens;
}
function $f93df7ec1ab3323b$export$fac44ee5b035f737(values, options) {
    const settings = options || {};
    // Ensure the last empty entry is seen.
    const input = values[values.length - 1] === "" ? [
        ...values,
        ""
    ] : values;
    return input.join((settings.padRight ? " " : "") + "," + (settings.padLeft === false ? "" : " ")).trim();
}


/**
 * @typedef {import('hast').Root} Root
 * @typedef {import('hast').Content} Content
 */ /**
 * @typedef {Root | Content} Node
 */ const $2547ff51c05cb0ad$var$own = {}.hasOwnProperty;
function $2547ff51c05cb0ad$export$bf9617eaf5d2451(node, field) {
    const value = typeof field === "string" && $2547ff51c05cb0ad$var$isNode(node) && node.type === "element" && node.properties && $2547ff51c05cb0ad$var$own.call(node.properties, field) && node.properties[field];
    return value !== null && value !== undefined && value !== false;
}
/**
 * @param {unknown} value
 * @returns {value is Node}
 */ function $2547ff51c05cb0ad$var$isNode(value) {
    return Boolean(value && typeof value === "object" && "type" in value);
}



/**
 * Parse space-separated tokens to an array of strings.
 *
 * @param {string} value
 *   Space-separated tokens.
 * @returns {Array<string>}
 *   List of tokens.
 */ function $e57d29e4a3e1444f$export$98e6a39c04603d36(value) {
    const input = String(value || "").trim();
    return input ? input.split(/[ \t\n\r\f]+/g) : [];
}
function $e57d29e4a3e1444f$export$fac44ee5b035f737(values) {
    return values.join(" ").trim();
}


/**
 * @callback Handler
 *   Handle a value, with a certain ID field set to a certain value.
 *   The ID field is passed to `zwitch`, and it’s value is this function’s
 *   place on the `handlers` record.
 * @param {...any} parameters
 *   Arbitrary parameters passed to the zwitch.
 *   The first will be an object with a certain ID field set to a certain value.
 * @returns {any}
 *   Anything!
 */ /**
 * @callback UnknownHandler
 *   Handle values that do have a certain ID field, but it’s set to a value
 *   that is not listed in the `handlers` record.
 * @param {unknown} value
 *   An object with a certain ID field set to an unknown value.
 * @param {...any} rest
 *   Arbitrary parameters passed to the zwitch.
 * @returns {any}
 *   Anything!
 */ /**
 * @callback InvalidHandler
 *   Handle values that do not have a certain ID field.
 * @param {unknown} value
 *   Any unknown value.
 * @param {...any} rest
 *   Arbitrary parameters passed to the zwitch.
 * @returns {void|null|undefined|never}
 *   This should crash or return nothing.
 */ /**
 * @template {InvalidHandler} [Invalid=InvalidHandler]
 * @template {UnknownHandler} [Unknown=UnknownHandler]
 * @template {Record<string, Handler>} [Handlers=Record<string, Handler>]
 * @typedef Options
 *   Configuration (required).
 * @property {Invalid} [invalid]
 *   Handler to use for invalid values.
 * @property {Unknown} [unknown]
 *   Handler to use for unknown values.
 * @property {Handlers} [handlers]
 *   Handlers to use.
 */ const $2f63128524cf9953$var$own = {}.hasOwnProperty;
function $2f63128524cf9953$export$d6a12bfbbedf6185(key, options) {
    const settings = options || {};
    /**
   * Handle one value.
   *
   * Based on the bound `key`, a respective handler will be called.
   * If `value` is not an object, or doesn’t have a `key` property, the special
   * “invalid” handler will be called.
   * If `value` has an unknown `key`, the special “unknown” handler will be
   * called.
   *
   * All arguments, and the context object, are passed through to the handler,
   * and it’s result is returned.
   *
   * @this {unknown}
   *   Any context object.
   * @param {unknown} [value]
   *   Any value.
   * @param {...unknown} parameters
   *   Arbitrary parameters passed to the zwitch.
   * @property {Handler} invalid
   *   Handle for values that do not have a certain ID field.
   * @property {Handler} unknown
   *   Handle values that do have a certain ID field, but it’s set to a value
   *   that is not listed in the `handlers` record.
   * @property {Handlers} handlers
   *   Record of handlers.
   * @returns {unknown}
   *   Anything.
   */ function one(value, ...parameters) {
        /** @type {Handler|undefined} */ let fn = one.invalid;
        const handlers = one.handlers;
        if (value && $2f63128524cf9953$var$own.call(value, key)) {
            // @ts-expect-error Indexable.
            const id = String(value[key]);
            // @ts-expect-error Indexable.
            fn = $2f63128524cf9953$var$own.call(handlers, id) ? handlers[id] : one.unknown;
        }
        if (fn) return fn.call(this, value, ...parameters);
    }
    one.handlers = settings.handlers || {};
    one.invalid = settings.invalid;
    one.unknown = settings.unknown;
    // @ts-expect-error: matches!
    return one;
}


/** @type {(query: RuleAttr, element: Element, info: Info) => boolean} */ const $1222f24c35f9e04c$var$handle = (0, $2f63128524cf9953$export$d6a12bfbbedf6185)("operator", {
    unknown: $1222f24c35f9e04c$var$unknownOperator,
    // @ts-expect-error: hush.
    invalid: $1222f24c35f9e04c$var$exists,
    handlers: {
        "=": $1222f24c35f9e04c$var$exact,
        "~=": $1222f24c35f9e04c$var$spaceSeparatedList,
        "|=": $1222f24c35f9e04c$var$exactOrPrefix,
        "^=": $1222f24c35f9e04c$var$begins,
        "$=": $1222f24c35f9e04c$var$ends,
        "*=": $1222f24c35f9e04c$var$contains
    }
});
function $1222f24c35f9e04c$export$af4b9a83f4b00434(query, element, schema) {
    const attrs = query.attrs;
    let index = -1;
    while(++index < attrs.length){
        if (!$1222f24c35f9e04c$var$handle(attrs[index], element, (0, $740afc8bd0302ea0$export$71aa6c912b956294)(schema, attrs[index].name))) return false;
    }
    return true;
}
/**
 * Check whether an attribute exists.
 *
 * `[attr]`
 *
 * @param {RuleAttr} _
 * @param {Element} element
 * @param {Info} info
 * @returns {boolean}
 */ function $1222f24c35f9e04c$var$exists(_, element, info) {
    return (0, $2547ff51c05cb0ad$export$bf9617eaf5d2451)(element, info.property);
}
/**
 * Check whether an attribute has an exact value.
 *
 * `[attr=value]`
 *
 * @param {RuleAttr} query
 * @param {Element} element
 * @param {Info} info
 * @returns {boolean}
 */ function $1222f24c35f9e04c$var$exact(query, element, info) {
    return Boolean((0, $2547ff51c05cb0ad$export$bf9617eaf5d2451)(element, info.property) && element.properties && $1222f24c35f9e04c$var$normalizeValue(element.properties[info.property], info) === query.value);
}
/**
 * Check whether an attribute, interpreted as a space-separated list, contains
 * a value.
 *
 * `[attr~=value]`
 *
 * @param {RuleAttr} query
 * @param {Element} element
 * @param {Info} info
 * @returns {boolean}
 */ function $1222f24c35f9e04c$var$spaceSeparatedList(query, element, info) {
    const value = element.properties && element.properties[info.property];
    return(// If this is a space-separated list, and the query is contained in it, return
    // true.
    !info.commaSeparated && value && typeof value === "object" && query.value && value.includes(query.value) || // For all other values (including comma-separated lists), return whether this
    // is an exact match.
    (0, $2547ff51c05cb0ad$export$bf9617eaf5d2451)(element, info.property) && $1222f24c35f9e04c$var$normalizeValue(value, info) === query.value);
}
/**
 * Check whether an attribute has a substring as either the exact value or a
 * prefix.
 *
 * `[attr|=value]`
 *
 * @param {RuleAttr} query
 * @param {Element} element
 * @param {Info} info
 * @returns {boolean}
 */ function $1222f24c35f9e04c$var$exactOrPrefix(query, element, info) {
    const value = $1222f24c35f9e04c$var$normalizeValue(element.properties && element.properties[info.property], info);
    return Boolean((0, $2547ff51c05cb0ad$export$bf9617eaf5d2451)(element, info.property) && query.value && (value === query.value || value.slice(0, query.value.length) === query.value && value.charAt(query.value.length) === "-"));
}
/**
 * Check whether an attribute has a substring as its start.
 *
 * `[attr^=value]`
 *
 * @param {RuleAttr} query
 * @param {Element} element
 * @param {Info} info
 * @returns {boolean}
 */ function $1222f24c35f9e04c$var$begins(query, element, info) {
    return Boolean((0, $2547ff51c05cb0ad$export$bf9617eaf5d2451)(element, info.property) && element.properties && query.value && $1222f24c35f9e04c$var$normalizeValue(element.properties[info.property], info).slice(0, query.value.length) === query.value);
}
/**
 * Check whether an attribute has a substring as its end.
 *
 * `[attr$=value]`
 *
 * @param {RuleAttr} query
 * @param {Element} element
 * @param {Info} info
 * @returns {boolean}
 */ function $1222f24c35f9e04c$var$ends(query, element, info) {
    return Boolean((0, $2547ff51c05cb0ad$export$bf9617eaf5d2451)(element, info.property) && element.properties && query.value && $1222f24c35f9e04c$var$normalizeValue(element.properties[info.property], info).slice(-query.value.length) === query.value);
}
/**
 * Check whether an attribute contains a substring.
 *
 * `[attr*=value]`
 *
 * @param {RuleAttr} query
 * @param {Element} element
 * @param {Info} info
 * @returns {boolean}
 */ function $1222f24c35f9e04c$var$contains(query, element, info) {
    return Boolean((0, $2547ff51c05cb0ad$export$bf9617eaf5d2451)(element, info.property) && element.properties && query.value && $1222f24c35f9e04c$var$normalizeValue(element.properties[info.property], info).includes(query.value));
}
// Shouldn’t be called, Parser throws an error instead.
/**
 * @param {unknown} query
 * @returns {never}
 */ /* c8 ignore next 4 */ function $1222f24c35f9e04c$var$unknownOperator(query) {
    // @ts-expect-error: `operator` guaranteed.
    throw new Error("Unknown operator `" + query.operator + "`");
}
/**
 * Stringify a hast value back to its HTML form.
 *
 * @param {PropertyValue} value
 * @param {Info} info
 * @returns {string}
 */ function $1222f24c35f9e04c$var$normalizeValue(value, info) {
    if (typeof value === "boolean") return info.attribute;
    if (Array.isArray(value)) return (info.commaSeparated ? (0, $f93df7ec1ab3323b$export$fac44ee5b035f737) : (0, $e57d29e4a3e1444f$export$fac44ee5b035f737))(value);
    return String(value);
}


/**
 * @typedef {import('./types.js').Rule} Rule
 * @typedef {import('./types.js').Element} Element
 */ /**
 * Check whether an element has all class names.
 *
 * @param {Rule} query
 * @param {Element} element
 * @returns {boolean}
 */ function $b4a085a3ae62a564$export$2913c0c0b5623090(query, element) {
    /** @type {readonly string[]} */ // @ts-expect-error Assume array.
    const value = element.properties.className || [];
    let index = -1;
    if (query.classNames) while(++index < query.classNames.length){
        if (!value.includes(query.classNames[index])) return false;
    }
    return true;
}


/**
 * @typedef {import('./types.js').Rule} Rule
 * @typedef {import('./types.js').Element} Element
 */ /**
 * Check whether an element has an ID.
 *
 * @param {Rule} query
 * @param {Element} element
 * @returns {boolean}
 */ function $4301d5d3cbe72a6c$export$d560c7e4a29451c2(query, element) {
    return Boolean(element.properties && element.properties.id === query.id);
}


/**
 * @typedef {import('./types.js').Rule} Rule
 * @typedef {import('./types.js').Element} Element
 */ /**
 * Check whether an element has a tag name.
 *
 * @param {Rule} query
 * @param {Element} element
 * @returns {boolean}
 */ function $836b9971912efe30$export$a8ff84c12d48cfa6(query, element) {
    return query.tagName === "*" || query.tagName === element.tagName;
}


/**
 * @typedef {import('./types.js').Rule} Rule
 * @typedef {import('./types.js').RulePseudo} RulePseudo
 * @typedef {import('./types.js').RulePseudoSelector} RulePseudoSelector
 * @typedef {import('./types.js').Parent} Parent
 * @typedef {import('./types.js').SelectState} SelectState
 * @typedef {import('./types.js').Element} Element
 * @typedef {import('./types.js').ElementChild} ElementChild
 */ /**
 * See <https://tools.ietf.org/html/rfc4647#section-3.1>
 * for more info on the algorithms.
 */ /**
 * @typedef {string} Tag
 *   BCP-47 tag.
 * @typedef {Array<Tag>} Tags
 *   List of BCP-47 tags.
 * @typedef {string} Range
 *   RFC 4647 range.
 * @typedef {Array<Range>} Ranges
 *   List of RFC 4647 range.
 *
 * @callback Check
 *   An internal check.
 * @param {Tag} tag
 *   BCP-47 tag.
 * @param {Range} range
 *   RFC 4647 range.
 * @returns {boolean}
 *   Whether the range matches the tag.
 *
 * @typedef {FilterOrLookup<true>} Filter
 *   Filter: yields all tags that match a range.
 * @typedef {FilterOrLookup<false>} Lookup
 *   Lookup: yields the best tag that matches a range.
 */ /**
 * @template {boolean} IsFilter
 *   Whether to filter or perform a lookup.
 * @callback FilterOrLookup
 *   A check.
 * @param {Tag|Tags} tags
 *   One or more BCP-47 tags.
 * @param {Range|Ranges|undefined} [ranges='*']
 *   One or more RFC 4647 ranges.
 * @returns {IsFilter extends true ? Tags : Tag|undefined}
 *   Result.
 */ /**
 * Factory to perform a filter or a lookup.
 *
 * This factory creates a function that accepts a list of tags and a list of
 * ranges, and contains logic to exit early for lookups.
 * `check` just has to deal with one tag and one range.
 * This match function iterates over ranges, and for each range,
 * iterates over tags.
 * That way, earlier ranges matching any tag have precedence over later ranges.
 *
 * @template {boolean} IsFilter
 * @param {Check} check
 *   A check.
 * @param {IsFilter} filter
 *   Whether to filter or perform a lookup.
 * @returns {FilterOrLookup<IsFilter>}
 *   Filter or lookup.
 */ function $9a576b8713f3a0a9$var$factory(check, filter) {
    /**
   * @param {Tag|Tags} tags
   *   One or more BCP-47 tags.
   * @param {Range|Ranges|undefined} [ranges='*']
   *   One or more RFC 4647 ranges.
   * @returns {IsFilter extends true ? Tags : Tag|undefined}
   *   Result.
   */ return function(tags, ranges) {
        let left = $9a576b8713f3a0a9$var$cast(tags, "tag");
        const right = $9a576b8713f3a0a9$var$cast(ranges === null || ranges === undefined ? "*" : ranges, "range");
        /** @type {Tags} */ const matches = [];
        let rightIndex = -1;
        while(++rightIndex < right.length){
            const range = right[rightIndex].toLowerCase();
            // Ignore wildcards in lookup mode.
            if (!filter && range === "*") continue;
            let leftIndex = -1;
            /** @type {Tags} */ const next = [];
            while(++leftIndex < left.length)if (check(left[leftIndex].toLowerCase(), range)) {
                // Exit if this is a lookup and we have a match.
                if (!filter) return /** @type {IsFilter extends true ? Tags : Tag|undefined} */ left[leftIndex];
                matches.push(left[leftIndex]);
            } else next.push(left[leftIndex]);
            left = next;
        }
        // If this is a filter, return the list.  If it’s a lookup, we didn’t find
        // a match, so return `undefined`.
        return /** @type {IsFilter extends true ? Tags : Tag|undefined} */ filter ? matches : undefined;
    };
}
const $9a576b8713f3a0a9$export$454d02d943c45292 = $9a576b8713f3a0a9$var$factory(function(tag, range) {
    return range === "*" || tag === range || tag.includes(range + "-");
}, true);
const $9a576b8713f3a0a9$export$d216e65da1a9aa7e = $9a576b8713f3a0a9$var$factory(function(tag, range) {
    // 3.3.2.1
    const left = tag.split("-");
    const right = range.split("-");
    let leftIndex = 0;
    let rightIndex = 0;
    // 3.3.2.2
    if (right[rightIndex] !== "*" && left[leftIndex] !== right[rightIndex]) return false;
    leftIndex++;
    rightIndex++;
    // 3.3.2.3
    while(rightIndex < right.length){
        // 3.3.2.3.A
        if (right[rightIndex] === "*") {
            rightIndex++;
            continue;
        }
        // 3.3.2.3.B
        if (!left[leftIndex]) return false;
        // 3.3.2.3.C
        if (left[leftIndex] === right[rightIndex]) {
            leftIndex++;
            rightIndex++;
            continue;
        }
        // 3.3.2.3.D
        if (left[leftIndex].length === 1) return false;
        // 3.3.2.3.E
        leftIndex++;
    }
    // 3.3.2.4
    return true;
}, true);
const $9a576b8713f3a0a9$export$dfc7155ac0343b8 = $9a576b8713f3a0a9$var$factory(function(tag, range) {
    let right = range;
    /* eslint-disable-next-line no-constant-condition */ while(true){
        if (right === "*" || tag === right) return true;
        let index = right.lastIndexOf("-");
        if (index < 0) return false;
        if (right.charAt(index - 2) === "-") index -= 2;
        right = right.slice(0, index);
    }
}, false);
/**
 * Validate tags or ranges, and cast them to arrays.
 *
 * @param {string|Array<string>} values
 * @param {string} name
 * @returns {Array<string>}
 */ function $9a576b8713f3a0a9$var$cast(values, name) {
    const value = values && typeof values === "string" ? [
        values
    ] : values;
    if (!value || typeof value !== "object" || !("length" in value)) throw new Error("Invalid " + name + " `" + value + "`, expected non-empty string");
    return value;
}




/**
 * Check if the given value is *inter-element whitespace*.
 *
 * @param {unknown} thing
 *   Thing to check (typically `Node` or `string`).
 * @returns {boolean}
 *   Whether the `value` is inter-element whitespace (`boolean`): consisting of
 *   zero or more of space, tab (`\t`), line feed (`\n`), carriage return
 *   (`\r`), or form feed (`\f`).
 *   If a node is passed it must be a `Text` node, whose `value` field is
 *   checked.
 */ function $b4cc9da1564d3496$export$7af1228ff777d175(thing) {
    /** @type {string} */ const value = // @ts-expect-error looks like a node.
    thing && typeof thing === "object" && thing.type === "text" ? thing.value || "" : thing;
    // HTML whitespace expression.
    // See <https://infra.spec.whatwg.org/#ascii-whitespace>.
    return typeof value === "string" && value.replace(/[ \t\n\f\r]/g, "") === "";
}


// Following http://www.w3.org/TR/css3-selectors/#nth-child-pseudo
// Whitespace as per https://www.w3.org/TR/selectors-3/#lex is " \t\r\n\f"
const $dcc51931024d78cc$var$whitespace = new Set([
    9,
    10,
    12,
    13,
    32
]);
const $dcc51931024d78cc$var$ZERO = "0".charCodeAt(0);
const $dcc51931024d78cc$var$NINE = "9".charCodeAt(0);
function $dcc51931024d78cc$export$98e6a39c04603d36(formula) {
    formula = formula.trim().toLowerCase();
    if (formula === "even") return [
        2,
        0
    ];
    else if (formula === "odd") return [
        2,
        1
    ];
    // Parse [ ['-'|'+']? INTEGER? {N} [ S* ['-'|'+'] S* INTEGER ]?
    let idx = 0;
    let a = 0;
    let sign = readSign();
    let number = readNumber();
    if (idx < formula.length && formula.charAt(idx) === "n") {
        idx++;
        a = sign * (number !== null && number !== void 0 ? number : 1);
        skipWhitespace();
        if (idx < formula.length) {
            sign = readSign();
            skipWhitespace();
            number = readNumber();
        } else sign = number = 0;
    }
    // Throw if there is anything else
    if (number === null || idx < formula.length) throw new Error(`n-th rule couldn't be parsed ('${formula}')`);
    return [
        a,
        sign * number
    ];
    function readSign() {
        if (formula.charAt(idx) === "-") {
            idx++;
            return -1;
        }
        if (formula.charAt(idx) === "+") idx++;
        return 1;
    }
    function readNumber() {
        const start = idx;
        let value = 0;
        while(idx < formula.length && formula.charCodeAt(idx) >= $dcc51931024d78cc$var$ZERO && formula.charCodeAt(idx) <= $dcc51931024d78cc$var$NINE){
            value = value * 10 + (formula.charCodeAt(idx) - $dcc51931024d78cc$var$ZERO);
            idx++;
        }
        // Return `null` if we didn't read anything.
        return idx === start ? null : value;
    }
    function skipWhitespace() {
        while(idx < formula.length && $dcc51931024d78cc$var$whitespace.has(formula.charCodeAt(idx)))idx++;
    }
}


var $44d926f40ea19575$exports = {};
$44d926f40ea19575$exports = {
    trueFunc: function trueFunc() {
        return true;
    },
    falseFunc: function falseFunc() {
        return false;
    }
};


function $6fbdb0097d520d13$export$ef7acd7185315e22(parsed) {
    const a = parsed[0];
    // Subtract 1 from `b`, to convert from one- to zero-indexed.
    const b = parsed[1] - 1;
    /*
     * When `b <= 0`, `a * n` won't be lead to any matches for `a < 0`.
     * Besides, the specification states that no elements are
     * matched when `a` and `b` are 0.
     *
     * `b < 0` here as we subtracted 1 from `b` above.
     */ if (b < 0 && a <= 0) return (0, (/*@__PURE__*/$parcel$interopDefault($44d926f40ea19575$exports))).falseFunc;
    // When `a` is in the range -1..1, it matches any element (so only `b` is checked).
    if (a === -1) return (index)=>index <= b;
    if (a === 0) return (index)=>index === b;
    // When `b <= 0` and `a === 1`, they match any element.
    if (a === 1) return b < 0 ? (0, (/*@__PURE__*/$parcel$interopDefault($44d926f40ea19575$exports))).trueFunc : (index)=>index >= b;
    /*
     * Otherwise, modulo can be used to check if there is a match.
     *
     * Modulo doesn't care about the sign, so let's use `a`s absolute value.
     */ const absA = Math.abs(a);
    // Get `b mod a`, + a if this is negative.
    const bMod = (b % absA + absA) % absA;
    return a > 1 ? (index)=>index >= b && index % absA === bMod : (index)=>index <= b && index % absA === bMod;
}
function $6fbdb0097d520d13$export$80d376111cc09ad7(parsed) {
    const a = parsed[0];
    // Subtract 1 from `b`, to convert from one- to zero-indexed.
    let b = parsed[1] - 1;
    let n = 0;
    // Make sure to always return an increasing sequence
    if (a < 0) {
        const aPos = -a;
        // Get `b mod a`
        const minValue = (b % aPos + aPos) % aPos;
        return ()=>{
            const val = minValue + aPos * n++;
            return val > b ? null : val;
        };
    }
    if (a === 0) return b < 0 ? ()=>null : ()=>n++ === 0 ? b : null;
    if (b < 0) b += a * Math.ceil(-b / a);
    return ()=>a * n++ + b;
}


function $3f9ce89db3cc8c8b$export$2e2bcd8739ae039(formula) {
    return (0, $6fbdb0097d520d13$export$ef7acd7185315e22)((0, $dcc51931024d78cc$export$98e6a39c04603d36)(formula));
}
function $3f9ce89db3cc8c8b$export$49bb65c2ea163039(formula) {
    return (0, $6fbdb0097d520d13$export$80d376111cc09ad7)((0, $dcc51931024d78cc$export$98e6a39c04603d36)(formula));
}




/** @type {import('nth-check').default} */ // @ts-expect-error
const $876fb11dbc8f7f0e$var$nthCheck = (0, $3f9ce89db3cc8c8b$export$2e2bcd8739ae039).default || (0, $3f9ce89db3cc8c8b$export$2e2bcd8739ae039);
/** @type {(rule: Rule | RulePseudo, element: Element, index: number | undefined, parent: Parent | undefined, state: SelectState) => boolean} */ const $876fb11dbc8f7f0e$var$handle = (0, $2f63128524cf9953$export$d6a12bfbbedf6185)("name", {
    unknown: $876fb11dbc8f7f0e$var$unknownPseudo,
    invalid: $876fb11dbc8f7f0e$var$invalidPseudo,
    handlers: {
        any: $876fb11dbc8f7f0e$var$matches,
        "any-link": $876fb11dbc8f7f0e$var$anyLink,
        blank: $876fb11dbc8f7f0e$var$blank,
        checked: $876fb11dbc8f7f0e$var$checked,
        dir: $876fb11dbc8f7f0e$var$dir,
        disabled: $876fb11dbc8f7f0e$var$disabled,
        empty: $876fb11dbc8f7f0e$var$empty,
        enabled: $876fb11dbc8f7f0e$var$enabled,
        "first-child": $876fb11dbc8f7f0e$var$firstChild,
        "first-of-type": $876fb11dbc8f7f0e$var$firstOfType,
        has: $876fb11dbc8f7f0e$var$has,
        lang: $876fb11dbc8f7f0e$var$lang,
        "last-child": $876fb11dbc8f7f0e$var$lastChild,
        "last-of-type": $876fb11dbc8f7f0e$var$lastOfType,
        matches: $876fb11dbc8f7f0e$var$matches,
        not: $876fb11dbc8f7f0e$var$not,
        "nth-child": $876fb11dbc8f7f0e$var$nthChild,
        "nth-last-child": $876fb11dbc8f7f0e$var$nthLastChild,
        "nth-of-type": $876fb11dbc8f7f0e$var$nthOfType,
        "nth-last-of-type": $876fb11dbc8f7f0e$var$nthLastOfType,
        "only-child": $876fb11dbc8f7f0e$var$onlyChild,
        "only-of-type": $876fb11dbc8f7f0e$var$onlyOfType,
        optional: $876fb11dbc8f7f0e$var$optional,
        "read-only": $876fb11dbc8f7f0e$var$readOnly,
        "read-write": $876fb11dbc8f7f0e$var$readWrite,
        required: $876fb11dbc8f7f0e$var$required,
        root: $876fb11dbc8f7f0e$var$root,
        scope: $876fb11dbc8f7f0e$var$scope
    }
});
$876fb11dbc8f7f0e$export$4a40d01fa098dd92.needsIndex = [
    "any",
    "first-child",
    "first-of-type",
    "last-child",
    "last-of-type",
    "matches",
    "not",
    "nth-child",
    "nth-last-child",
    "nth-of-type",
    "nth-last-of-type",
    "only-child",
    "only-of-type"
];
function $876fb11dbc8f7f0e$export$4a40d01fa098dd92(query, element, index, parent, state) {
    const pseudos = query.pseudos;
    let offset = -1;
    while(++offset < pseudos.length){
        if (!$876fb11dbc8f7f0e$var$handle(pseudos[offset], element, index, parent, state)) return false;
    }
    return true;
}
/**
 * Check whether an element matches an `:any-link` pseudo.
 *
 * @param {RulePseudo} _
 * @param {Element} element
 * @returns {boolean}
 */ function $876fb11dbc8f7f0e$var$anyLink(_, element) {
    return (element.tagName === "a" || element.tagName === "area" || element.tagName === "link") && (0, $2547ff51c05cb0ad$export$bf9617eaf5d2451)(element, "href");
}
/**
 * Check whether an element matches a `:blank` pseudo.
 *
 * @param {RulePseudo} _
 * @param {Element} element
 * @returns {boolean}
 */ function $876fb11dbc8f7f0e$var$blank(_, element) {
    return !$876fb11dbc8f7f0e$var$someChildren(element, check);
    /**
   * @param {ElementChild} child
   * @returns {boolean}
   */ function check(child) {
        return child.type === "element" || child.type === "text" && !(0, $b4cc9da1564d3496$export$7af1228ff777d175)(child);
    }
}
/**
 * Check whether an element matches a `:checked` pseudo.
 *
 * @param {RulePseudo} _
 * @param {Element} element
 * @returns {boolean}
 */ function $876fb11dbc8f7f0e$var$checked(_, element) {
    if (element.tagName === "input" || element.tagName === "menuitem") return Boolean(element.properties && (element.properties.type === "checkbox" || element.properties.type === "radio") && (0, $2547ff51c05cb0ad$export$bf9617eaf5d2451)(element, "checked"));
    if (element.tagName === "option") return (0, $2547ff51c05cb0ad$export$bf9617eaf5d2451)(element, "selected");
    return false;
}
/**
 * Check whether an element matches a `:dir()` pseudo.
 *
 * @param {RulePseudo} query
 * @param {Element} _1
 * @param {number | undefined} _2
 * @param {Parent | undefined} _3
 * @param {SelectState} state
 * @returns {boolean}
 */ function $876fb11dbc8f7f0e$var$dir(query, _1, _2, _3, state) {
    return state.direction === query.value;
}
/**
 * Check whether an element matches a `:disabled` pseudo.
 *
 * @param {RulePseudo} _
 * @param {Element} element
 * @returns {boolean}
 */ function $876fb11dbc8f7f0e$var$disabled(_, element) {
    return (element.tagName === "button" || element.tagName === "input" || element.tagName === "select" || element.tagName === "textarea" || element.tagName === "optgroup" || element.tagName === "option" || element.tagName === "menuitem" || element.tagName === "fieldset") && (0, $2547ff51c05cb0ad$export$bf9617eaf5d2451)(element, "disabled");
}
/**
 * Check whether an element matches an `:empty` pseudo.
 *
 * @param {RulePseudo} _
 * @param {Element} element
 * @returns {boolean}
 */ function $876fb11dbc8f7f0e$var$empty(_, element) {
    return !$876fb11dbc8f7f0e$var$someChildren(element, check);
    /**
   * @param {ElementChild} child
   * @returns {boolean}
   */ function check(child) {
        return child.type === "element" || child.type === "text";
    }
}
/**
 * Check whether an element matches an `:enabled` pseudo.
 *
 * @param {RulePseudo} query
 * @param {Element} element
 * @returns {boolean}
 */ function $876fb11dbc8f7f0e$var$enabled(query, element) {
    return !$876fb11dbc8f7f0e$var$disabled(query, element);
}
/**
 * Check whether an element matches a `:first-child` pseudo.
 *
 * @param {RulePseudo} query
 * @param {Element} _1
 * @param {number | undefined} _2
 * @param {Parent | undefined} _3
 * @param {SelectState} state
 * @returns {boolean}
 */ function $876fb11dbc8f7f0e$var$firstChild(query, _1, _2, _3, state) {
    $876fb11dbc8f7f0e$var$assertDeep(state, query);
    return state.elementIndex === 0;
}
/**
 * Check whether an element matches a `:first-of-type` pseudo.
 *
 * @param {RulePseudo} query
 * @param {Element} _1
 * @param {number | undefined} _2
 * @param {Parent | undefined} _3
 * @param {SelectState} state
 * @returns {boolean}
 */ function $876fb11dbc8f7f0e$var$firstOfType(query, _1, _2, _3, state) {
    $876fb11dbc8f7f0e$var$assertDeep(state, query);
    return state.typeIndex === 0;
}
/**
 * @param {RulePseudoSelector} query
 * @param {Element} element
 * @param {number | undefined} _1
 * @param {Parent | undefined} _2
 * @param {SelectState} state
 * @returns {boolean}
 */ function $876fb11dbc8f7f0e$var$has(query, element, _1, _2, state) {
    /** @type {SelectState} */ const childState = {
        ...state,
        // Not found yet.
        found: false,
        // Do walk deep.
        shallow: false,
        // One result is enough.
        one: true,
        scopeElements: [
            element
        ],
        results: [],
        rootQuery: (0, $58a1078981422728$export$9141434d8c079e66)(query.value)
    };
    (0, $58a1078981422728$export$588732934346abbf)(childState, {
        type: "root",
        children: element.children
    });
    return childState.results.length > 0;
}
/**
 * Check whether an element matches a `:lang()` pseudo.
 *
 * @param {RulePseudo} query
 * @param {Element} _1
 * @param {number | undefined} _2
 * @param {Parent | undefined} _3
 * @param {SelectState} state
 * @returns {boolean}
 */ function $876fb11dbc8f7f0e$var$lang(query, _1, _2, _3, state) {
    return state.language !== "" && state.language !== undefined && // @ts-expect-error never `selectors`.
    (0, $9a576b8713f3a0a9$export$d216e65da1a9aa7e)(state.language, (0, $f93df7ec1ab3323b$export$98e6a39c04603d36)(query.value)).length > 0;
}
/**
 * Check whether an element matches a `:last-child` pseudo.
 *
 * @param {RulePseudo} query
 * @param {Element} _1
 * @param {number | undefined} _2
 * @param {Parent | undefined} _3
 * @param {SelectState} state
 * @returns {boolean}
 */ function $876fb11dbc8f7f0e$var$lastChild(query, _1, _2, _3, state) {
    $876fb11dbc8f7f0e$var$assertDeep(state, query);
    return Boolean(state.elementCount && state.elementIndex === state.elementCount - 1);
}
/**
 * Check whether an element matches a `:last-of-type` pseudo.
 *
 * @param {RulePseudo} query
 * @param {Element} _1
 * @param {number | undefined} _2
 * @param {Parent | undefined} _3
 * @param {SelectState} state
 * @returns {boolean}
 */ function $876fb11dbc8f7f0e$var$lastOfType(query, _1, _2, _3, state) {
    $876fb11dbc8f7f0e$var$assertDeep(state, query);
    return typeof state.typeIndex === "number" && typeof state.typeCount === "number" && state.typeIndex === state.typeCount - 1;
}
/**
 * Check whether an element `:matches` further selectors.
 *
 * @param {RulePseudoSelector} query
 * @param {Element} element
 * @param {number | undefined} _
 * @param {Parent | undefined} parent
 * @param {SelectState} state
 * @returns {boolean}
 */ function $876fb11dbc8f7f0e$var$matches(query, element, _, parent, state) {
    /** @type {SelectState} */ const childState = {
        ...state,
        // Not found yet.
        found: false,
        // Do walk deep.
        shallow: false,
        // One result is enough.
        one: true,
        scopeElements: [
            element
        ],
        results: [],
        rootQuery: (0, $58a1078981422728$export$9141434d8c079e66)(query.value)
    };
    (0, $58a1078981422728$export$588732934346abbf)(childState, element);
    return childState.results[0] === element;
}
/**
 * Check whether an element does `:not` match further selectors.
 *
 * @param {RulePseudoSelector} query
 * @param {Element} element
 * @param {number | undefined} index
 * @param {Parent | undefined} parent
 * @param {SelectState} state
 * @returns {boolean}
 */ function $876fb11dbc8f7f0e$var$not(query, element, index, parent, state) {
    return !$876fb11dbc8f7f0e$var$matches(query, element, index, parent, state);
}
/**
 * Check whether an element matches an `:nth-child` pseudo.
 *
 * @param {RulePseudo} query
 * @param {Element} _1
 * @param {number | undefined} _2
 * @param {Parent | undefined} _3
 * @param {SelectState} state
 * @returns {boolean}
 */ function $876fb11dbc8f7f0e$var$nthChild(query, _1, _2, _3, state) {
    const fn = $876fb11dbc8f7f0e$var$getCachedNthCheck(query);
    $876fb11dbc8f7f0e$var$assertDeep(state, query);
    return typeof state.elementIndex === "number" && fn(state.elementIndex);
}
/**
 * Check whether an element matches an `:nth-last-child` pseudo.
 *
 * @param {RulePseudo} query
 * @param {Element} _1
 * @param {number | undefined} _2
 * @param {Parent | undefined} _3
 * @param {SelectState} state
 * @returns {boolean}
 */ function $876fb11dbc8f7f0e$var$nthLastChild(query, _1, _2, _3, state) {
    const fn = $876fb11dbc8f7f0e$var$getCachedNthCheck(query);
    $876fb11dbc8f7f0e$var$assertDeep(state, query);
    return Boolean(typeof state.elementCount === "number" && typeof state.elementIndex === "number" && fn(state.elementCount - state.elementIndex - 1));
}
/**
 * Check whether an element matches a `:nth-last-of-type` pseudo.
 *
 * @param {RulePseudo} query
 * @param {Element} _1
 * @param {number | undefined} _2
 * @param {Parent | undefined} _3
 * @param {SelectState} state
 * @returns {boolean}
 */ function $876fb11dbc8f7f0e$var$nthLastOfType(query, _1, _2, _3, state) {
    const fn = $876fb11dbc8f7f0e$var$getCachedNthCheck(query);
    $876fb11dbc8f7f0e$var$assertDeep(state, query);
    return typeof state.typeCount === "number" && typeof state.typeIndex === "number" && fn(state.typeCount - 1 - state.typeIndex);
}
/**
 * Check whether an element matches an `:nth-of-type` pseudo.
 *
 * @param {RulePseudo} query
 * @param {Element} _1
 * @param {number | undefined} _2
 * @param {Parent | undefined} _3
 * @param {SelectState} state
 * @returns {boolean}
 */ function $876fb11dbc8f7f0e$var$nthOfType(query, _1, _2, _3, state) {
    const fn = $876fb11dbc8f7f0e$var$getCachedNthCheck(query);
    $876fb11dbc8f7f0e$var$assertDeep(state, query);
    return typeof state.typeIndex === "number" && fn(state.typeIndex);
}
/**
 * Check whether an element matches an `:only-child` pseudo.
 *
 * @param {RulePseudo} query
 * @param {Element} _1
 * @param {number | undefined} _2
 * @param {Parent | undefined} _3
 * @param {SelectState} state
 * @returns {boolean}
 */ function $876fb11dbc8f7f0e$var$onlyChild(query, _1, _2, _3, state) {
    $876fb11dbc8f7f0e$var$assertDeep(state, query);
    return state.elementCount === 1;
}
/**
 * Check whether an element matches an `:only-of-type` pseudo.
 *
 * @param {RulePseudo} query
 * @param {Element} _1
 * @param {number | undefined} _2
 * @param {Parent | undefined} _3
 * @param {SelectState} state
 * @returns {boolean}
 */ function $876fb11dbc8f7f0e$var$onlyOfType(query, _1, _2, _3, state) {
    $876fb11dbc8f7f0e$var$assertDeep(state, query);
    return state.typeCount === 1;
}
/**
 * Check whether an element matches an `:optional` pseudo.
 *
 * @param {RulePseudo} query
 * @param {Element} element
 * @returns {boolean}
 */ function $876fb11dbc8f7f0e$var$optional(query, element) {
    return !$876fb11dbc8f7f0e$var$required(query, element);
}
/**
 * Check whether an element matches a `:read-only` pseudo.
 *
 * @param {RulePseudo} query
 * @param {Element} element
 * @param {number | undefined} index
 * @param {Parent | undefined} parent
 * @param {SelectState} state
 * @returns {boolean}
 */ function $876fb11dbc8f7f0e$var$readOnly(query, element, index, parent, state) {
    return !$876fb11dbc8f7f0e$var$readWrite(query, element, index, parent, state);
}
/**
 * Check whether an element matches a `:read-write` pseudo.
 *
 * @param {RulePseudo} _
 * @param {Element} element
 * @param {number | undefined} _1
 * @param {Parent | undefined} _2
 * @param {SelectState} state
 * @returns {boolean}
 */ function $876fb11dbc8f7f0e$var$readWrite(_, element, _1, _2, state) {
    return element.tagName === "input" || element.tagName === "textarea" ? !(0, $2547ff51c05cb0ad$export$bf9617eaf5d2451)(element, "readOnly") && !(0, $2547ff51c05cb0ad$export$bf9617eaf5d2451)(element, "disabled") : Boolean(state.editableOrEditingHost);
}
/**
 * Check whether an element matches a `:required` pseudo.
 *
 * @param {RulePseudo} _
 * @param {Element} element
 * @returns {boolean}
 */ function $876fb11dbc8f7f0e$var$required(_, element) {
    return (element.tagName === "input" || element.tagName === "textarea" || element.tagName === "select") && (0, $2547ff51c05cb0ad$export$bf9617eaf5d2451)(element, "required");
}
/**
 * Check whether an element matches a `:root` pseudo.
 *
 * @param {RulePseudo} _
 * @param {Element} element
 * @param {number | undefined} _1
 * @param {Parent | undefined} parent
 * @param {SelectState} state
 * @returns {boolean}
 */ function $876fb11dbc8f7f0e$var$root(_, element, _1, parent, state) {
    return Boolean((!parent || parent.type === "root") && state.schema && (state.schema.space === "html" || state.schema.space === "svg") && (element.tagName === "html" || element.tagName === "svg"));
}
/**
 * Check whether an element matches a `:scope` pseudo.
 *
 * @param {RulePseudo} _
 * @param {Element} element
 * @param {number | undefined} _1
 * @param {Parent | undefined} _2
 * @param {SelectState} state
 * @returns {boolean}
 */ function $876fb11dbc8f7f0e$var$scope(_, element, _1, _2, state) {
    return state.scopeElements.includes(element);
}
// Shouldn’t be called, parser gives correct data.
/* c8 ignore next 3 */ function $876fb11dbc8f7f0e$var$invalidPseudo() {
    throw new Error("Invalid pseudo-selector");
}
/**
 * @param {unknown} query
 * @returns {never}
 */ function $876fb11dbc8f7f0e$var$unknownPseudo(query) {
    // @ts-expect-error: indexable.
    if (query.name) // @ts-expect-error: indexable.
    throw new Error("Unknown pseudo-selector `" + query.name + "`");
    throw new Error("Unexpected pseudo-element or empty pseudo-class");
}
/**
 * Check children.
 *
 * @param {Element} element
 * @param {(child: ElementChild) => boolean} check
 * @returns {boolean}
 */ function $876fb11dbc8f7f0e$var$someChildren(element, check) {
    const children = element.children;
    let index = -1;
    while(++index < children.length){
        if (check(children[index])) return true;
    }
    return false;
}
/**
 * @param {SelectState} state
 * @param {RulePseudo} query
 */ function $876fb11dbc8f7f0e$var$assertDeep(state, query) {
    if (state.shallow) throw new Error("Cannot use `:" + query.name + "` without parent");
}
/**
 * @param {RulePseudo} query
 * @returns {(value: number) => boolean}
 */ function $876fb11dbc8f7f0e$var$getCachedNthCheck(query) {
    /** @type {(value: number) => boolean} */ // @ts-expect-error: cache.
    let fn = query._cachedFn;
    if (!fn) {
        // @ts-expect-error: always string.
        fn = $876fb11dbc8f7f0e$var$nthCheck(query.value);
        // @ts-expect-error: cache.
        query._cachedFn = fn;
    }
    return fn;
}


function $29403dfa3545a30c$export$e0969da9b8fb378d(query, element, index, parent, state) {
    return Boolean((!query.tagName || (0, $836b9971912efe30$export$a8ff84c12d48cfa6)(query, element)) && (!query.classNames || (0, $b4a085a3ae62a564$export$2913c0c0b5623090)(query, element)) && (!query.id || (0, $4301d5d3cbe72a6c$export$d560c7e4a29451c2)(query, element)) && (!query.attrs || (0, $1222f24c35f9e04c$export$af4b9a83f4b00434)(query, element, state.schema)) && (!query.pseudos || (0, $876fb11dbc8f7f0e$export$4a40d01fa098dd92)(query, element, index, parent, state)));
}


/** @type {Array<never>} */ const $58a1078981422728$var$empty = [];
function $58a1078981422728$export$9141434d8c079e66(query) {
    if (query === null) return {
        type: "selectors",
        selectors: []
    };
    if (query.type === "ruleSet") return {
        type: "selectors",
        selectors: [
            query
        ]
    };
    return query;
}
function $58a1078981422728$export$588732934346abbf(state, tree) {
    if (tree) $58a1078981422728$var$one(state, [], tree, undefined, undefined);
}
/**
 * Check a node.
 *
 * @param {SelectState} state
 * @param {Array<RuleSet>} currentRules
 * @param {Node} node
 * @param {number | undefined} index
 * @param {Parent | undefined} parent
 * @returns {Nest}
 */ function $58a1078981422728$var$one(state, currentRules, node, index, parent) {
    /** @type {Nest} */ let nestResult = {
        directChild: undefined,
        descendant: undefined,
        adjacentSibling: undefined,
        generalSibling: undefined
    };
    const exit = (0, $94bb0e936d3699a3$export$b6a91203b6b36f)(state, node);
    if (node.type === "element") nestResult = $58a1078981422728$var$applySelectors(state, // Try the root rules for this element too.
    $58a1078981422728$var$combine(currentRules, state.rootQuery.selectors), node, index, parent);
    // If this is a parent, and we want to delve into them, and we haven’t found
    // our single result yet.
    if ("children" in node && !state.shallow && !(state.one && state.found)) $58a1078981422728$var$all(state, nestResult, node);
    exit();
    return nestResult;
}
/**
 * Check a node.
 *
 * @param {SelectState} state
 * @param {Nest} nest
 * @param {Parent} node
 * @returns {void}
 */ function $58a1078981422728$var$all(state, nest, node) {
    const fromParent = $58a1078981422728$var$combine(nest.descendant, nest.directChild);
    /** @type {Array<RuleSet> | undefined} */ let fromSibling;
    let index = -1;
    /**
   * Total counts.
   * @type {Counts}
   */ const total = {
        count: 0,
        types: new Map()
    };
    /**
   * Counts of previous siblings.
   * @type {Counts}
   */ const before = {
        count: 0,
        types: new Map()
    };
    while(++index < node.children.length)$58a1078981422728$var$count(total, node.children[index]);
    index = -1;
    while(++index < node.children.length){
        const child = node.children[index];
        // Uppercase to prevent prototype polution, injecting `constructor` or so.
        // Normalize because HTML is insensitive.
        const name = child.type === "element" ? child.tagName.toUpperCase() : undefined;
        // Before counting further elements:
        state.elementIndex = before.count;
        state.typeIndex = name ? before.types.get(name) || 0 : 0;
        // After counting all elements.
        state.elementCount = total.count;
        state.typeCount = name ? total.types.get(name) : 0;
        // Only apply if this is a parent, this should be an element, but we check
        // for parents so that we delve into custom nodes too.
        if ("children" in child) {
            const forSibling = $58a1078981422728$var$combine(fromParent, fromSibling);
            const nest = $58a1078981422728$var$one(state, forSibling, node.children[index], index, node);
            fromSibling = $58a1078981422728$var$combine(nest.generalSibling, nest.adjacentSibling);
        }
        // We found one thing, and one is enough.
        if (state.one && state.found) break;
        $58a1078981422728$var$count(before, node.children[index]);
    }
}
/**
 * Apply selectors to an element.
 *
 * @param {SelectState} state
 *   Current state.
 * @param {Array<RuleSet>} rules
 *   Rules to apply.
 * @param {Element} node
 *   Element to apply rules to.
 * @param {number | undefined} index
 *   Index of node in parent.
 * @param {Parent | undefined} parent
 *   Parent of node.
 * @returns {Nest}
 *   Further rules.
 */ function $58a1078981422728$var$applySelectors(state, rules, node, index, parent) {
    /** @type {Nest} */ const nestResult = {
        directChild: undefined,
        descendant: undefined,
        adjacentSibling: undefined,
        generalSibling: undefined
    };
    let selectorIndex = -1;
    while(++selectorIndex < rules.length){
        const ruleSet = rules[selectorIndex];
        // We found one thing, and one is enough.
        if (state.one && state.found) break;
        // When shallow, we don’t allow nested rules.
        // Idea: we could allow a stack of parents?
        // Might get quite complex though.
        if (state.shallow && ruleSet.rule.rule) throw new Error("Expected selector without nesting");
        // If this rule matches:
        if ((0, $29403dfa3545a30c$export$e0969da9b8fb378d)(ruleSet.rule, node, index, parent, state)) {
            const nest = ruleSet.rule.rule;
            // Are there more?
            if (nest) {
                /** @type {RuleSet} */ const rule = {
                    type: "ruleSet",
                    rule: nest
                };
                /** @type {keyof Nest} */ const label = nest.nestingOperator === "+" ? "adjacentSibling" : nest.nestingOperator === "~" ? "generalSibling" : nest.nestingOperator === ">" ? "directChild" : "descendant";
                $58a1078981422728$var$add(nestResult, label, rule);
            } else {
                // We have a match!
                state.found = true;
                if (!state.results.includes(node)) state.results.push(node);
            }
        }
        // Descendant.
        if (ruleSet.rule.nestingOperator === null) $58a1078981422728$var$add(nestResult, "descendant", ruleSet);
        else if (ruleSet.rule.nestingOperator === "~") $58a1078981422728$var$add(nestResult, "generalSibling", ruleSet);
    // Drop top-level nesting (`undefined`), direct child (`>`), adjacent sibling (`+`).
    }
    return nestResult;
}
/**
 * Combine two lists, if needed.
 *
 * This is optimized to create as few lists as possible.
 *
 * @param {Array<RuleSet> | undefined} left
 * @param {Array<RuleSet> | undefined} right
 * @returns {Array<RuleSet>}
 */ function $58a1078981422728$var$combine(left, right) {
    return left && right && left.length > 0 && right.length > 0 ? [
        ...left,
        ...right
    ] : left && left.length > 0 ? left : right && right.length > 0 ? right : $58a1078981422728$var$empty;
}
/**
 * Add a rule to a nesting map.
 *
 * @param {Nest} nest
 * @param {keyof Nest} field
 * @param {RuleSet} rule
 */ function $58a1078981422728$var$add(nest, field, rule) {
    const list = nest[field];
    if (list) list.push(rule);
    else nest[field] = [
        rule
    ];
}
/**
 * Count a node.
 *
 * @param {Counts} counts
 *   Counts.
 * @param {Node} node
 *   Node (we’re looking for elements).
 * @returns {void}
 *   Nothing.
 */ function $58a1078981422728$var$count(counts, node) {
    if (node.type === "element") {
        // Uppercase to prevent prototype polution, injecting `constructor` or so.
        // Normalize because HTML is insensitive.
        const name = node.tagName.toUpperCase();
        const count = (counts.types.get(name) || 0) + 1;
        counts.count++;
        counts.types.set(name, count);
    }
}


/**
 * @typedef {import('./types.js').Selectors} Selectors
 * @typedef {import('./types.js').RuleSet} RuleSet
 */ var $d140b0999ce5b499$exports = {};
"use strict";
Object.defineProperty($d140b0999ce5b499$exports, "__esModule", {
    value: true
});
var $e704b78782728e94$exports = {};
"use strict";
Object.defineProperty($e704b78782728e94$exports, "__esModule", {
    value: true
});
var $18a94290f1afd18c$exports = {};
"use strict";
Object.defineProperty($18a94290f1afd18c$exports, "__esModule", {
    value: true
});
function $18a94290f1afd18c$var$isIdentStart(c) {
    return c >= "a" && c <= "z" || c >= "A" && c <= "Z" || c === "-" || c === "_";
}
$18a94290f1afd18c$exports.isIdentStart = $18a94290f1afd18c$var$isIdentStart;
function $18a94290f1afd18c$var$isIdent(c) {
    return c >= "a" && c <= "z" || c >= "A" && c <= "Z" || c >= "0" && c <= "9" || c === "-" || c === "_";
}
$18a94290f1afd18c$exports.isIdent = $18a94290f1afd18c$var$isIdent;
function $18a94290f1afd18c$var$isHex(c) {
    return c >= "a" && c <= "f" || c >= "A" && c <= "F" || c >= "0" && c <= "9";
}
$18a94290f1afd18c$exports.isHex = $18a94290f1afd18c$var$isHex;
function $18a94290f1afd18c$var$escapeIdentifier(s) {
    var len = s.length;
    var result = "";
    var i = 0;
    while(i < len){
        var chr = s.charAt(i);
        if ($18a94290f1afd18c$exports.identSpecialChars[chr]) result += "\\" + chr;
        else if (!(chr === "_" || chr === "-" || chr >= "A" && chr <= "Z" || chr >= "a" && chr <= "z" || i !== 0 && chr >= "0" && chr <= "9")) {
            var charCode = chr.charCodeAt(0);
            if ((charCode & 0xF800) === 0xD800) {
                var extraCharCode = s.charCodeAt(i++);
                if ((charCode & 0xFC00) !== 0xD800 || (extraCharCode & 0xFC00) !== 0xDC00) throw Error("UCS-2(decode): illegal sequence");
                charCode = ((charCode & 0x3FF) << 10) + (extraCharCode & 0x3FF) + 0x10000;
            }
            result += "\\" + charCode.toString(16) + " ";
        } else result += chr;
        i++;
    }
    return result;
}
$18a94290f1afd18c$exports.escapeIdentifier = $18a94290f1afd18c$var$escapeIdentifier;
function $18a94290f1afd18c$var$escapeStr(s) {
    var len = s.length;
    var result = "";
    var i = 0;
    var replacement;
    while(i < len){
        var chr = s.charAt(i);
        if (chr === '"') chr = '\\"';
        else if (chr === "\\") chr = "\\\\";
        else if ((replacement = $18a94290f1afd18c$exports.strReplacementsRev[chr]) !== undefined) chr = replacement;
        result += chr;
        i++;
    }
    return '"' + result + '"';
}
$18a94290f1afd18c$exports.escapeStr = $18a94290f1afd18c$var$escapeStr;
$18a94290f1afd18c$exports.identSpecialChars = {
    "!": true,
    '"': true,
    "#": true,
    "$": true,
    "%": true,
    "&": true,
    "'": true,
    "(": true,
    ")": true,
    "*": true,
    "+": true,
    ",": true,
    ".": true,
    "/": true,
    ";": true,
    "<": true,
    "=": true,
    ">": true,
    "?": true,
    "@": true,
    "[": true,
    "\\": true,
    "]": true,
    "^": true,
    "`": true,
    "{": true,
    "|": true,
    "}": true,
    "~": true
};
$18a94290f1afd18c$exports.strReplacementsRev = {
    "\n": "\\n",
    "\r": "\\r",
    "	": "\\t",
    "\f": "\\f",
    "\v": "\\v"
};
$18a94290f1afd18c$exports.singleQuoteEscapeChars = {
    n: "\n",
    r: "\r",
    t: "	",
    f: "\f",
    "\\": "\\",
    "'": "'"
};
$18a94290f1afd18c$exports.doubleQuotesEscapeChars = {
    n: "\n",
    r: "\r",
    t: "	",
    f: "\f",
    "\\": "\\",
    '"': '"'
};


function $e704b78782728e94$var$parseCssSelector(str, pos, pseudos, attrEqualityMods, ruleNestingOperators, substitutesEnabled) {
    var l = str.length;
    var chr = "";
    function getStr(quote, escapeTable) {
        var result = "";
        pos++;
        chr = str.charAt(pos);
        while(pos < l){
            if (chr === quote) {
                pos++;
                return result;
            } else if (chr === "\\") {
                pos++;
                chr = str.charAt(pos);
                var esc = void 0;
                if (chr === quote) result += quote;
                else if ((esc = escapeTable[chr]) !== undefined) result += esc;
                else if ($18a94290f1afd18c$exports.isHex(chr)) {
                    var hex = chr;
                    pos++;
                    chr = str.charAt(pos);
                    while($18a94290f1afd18c$exports.isHex(chr)){
                        hex += chr;
                        pos++;
                        chr = str.charAt(pos);
                    }
                    if (chr === " ") {
                        pos++;
                        chr = str.charAt(pos);
                    }
                    result += String.fromCharCode(parseInt(hex, 16));
                    continue;
                } else result += chr;
            } else result += chr;
            pos++;
            chr = str.charAt(pos);
        }
        return result;
    }
    function getIdent() {
        var result = "";
        chr = str.charAt(pos);
        while(pos < l){
            if ($18a94290f1afd18c$exports.isIdent(chr)) result += chr;
            else if (chr === "\\") {
                pos++;
                if (pos >= l) throw Error("Expected symbol but end of file reached.");
                chr = str.charAt(pos);
                if ($18a94290f1afd18c$exports.identSpecialChars[chr]) result += chr;
                else if ($18a94290f1afd18c$exports.isHex(chr)) {
                    var hex = chr;
                    pos++;
                    chr = str.charAt(pos);
                    while($18a94290f1afd18c$exports.isHex(chr)){
                        hex += chr;
                        pos++;
                        chr = str.charAt(pos);
                    }
                    if (chr === " ") {
                        pos++;
                        chr = str.charAt(pos);
                    }
                    result += String.fromCharCode(parseInt(hex, 16));
                    continue;
                } else result += chr;
            } else return result;
            pos++;
            chr = str.charAt(pos);
        }
        return result;
    }
    function skipWhitespace() {
        chr = str.charAt(pos);
        var result = false;
        while(chr === " " || chr === "	" || chr === "\n" || chr === "\r" || chr === "\f"){
            result = true;
            pos++;
            chr = str.charAt(pos);
        }
        return result;
    }
    function parse() {
        var res = parseSelector();
        if (pos < l) throw Error('Rule expected but "' + str.charAt(pos) + '" found.');
        return res;
    }
    function parseSelector() {
        var selector = parseSingleSelector();
        if (!selector) return null;
        var res = selector;
        chr = str.charAt(pos);
        while(chr === ","){
            pos++;
            skipWhitespace();
            if (res.type !== "selectors") res = {
                type: "selectors",
                selectors: [
                    selector
                ]
            };
            selector = parseSingleSelector();
            if (!selector) throw Error('Rule expected after ",".');
            res.selectors.push(selector);
        }
        return res;
    }
    function parseSingleSelector() {
        skipWhitespace();
        var selector = {
            type: "ruleSet"
        };
        var rule = parseRule();
        if (!rule) return null;
        var currentRule = selector;
        while(rule){
            rule.type = "rule";
            currentRule.rule = rule;
            currentRule = rule;
            skipWhitespace();
            chr = str.charAt(pos);
            if (pos >= l || chr === "," || chr === ")") break;
            if (ruleNestingOperators[chr]) {
                var op = chr;
                pos++;
                skipWhitespace();
                rule = parseRule();
                if (!rule) throw Error('Rule expected after "' + op + '".');
                rule.nestingOperator = op;
            } else {
                rule = parseRule();
                if (rule) rule.nestingOperator = null;
            }
        }
        return selector;
    }
    // @ts-ignore no-overlap
    function parseRule() {
        var rule = null;
        while(pos < l){
            chr = str.charAt(pos);
            if (chr === "*") {
                pos++;
                (rule = rule || {}).tagName = "*";
            } else if ($18a94290f1afd18c$exports.isIdentStart(chr) || chr === "\\") (rule = rule || {}).tagName = getIdent();
            else if (chr === ".") {
                pos++;
                rule = rule || {};
                (rule.classNames = rule.classNames || []).push(getIdent());
            } else if (chr === "#") {
                pos++;
                (rule = rule || {}).id = getIdent();
            } else if (chr === "[") {
                pos++;
                skipWhitespace();
                var attr = {
                    name: getIdent()
                };
                skipWhitespace();
                // @ts-ignore
                if (chr === "]") pos++;
                else {
                    var operator = "";
                    if (attrEqualityMods[chr]) {
                        operator = chr;
                        pos++;
                        chr = str.charAt(pos);
                    }
                    if (pos >= l) throw Error('Expected "=" but end of file reached.');
                    if (chr !== "=") throw Error('Expected "=" but "' + chr + '" found.');
                    attr.operator = operator + "=";
                    pos++;
                    skipWhitespace();
                    var attrValue = "";
                    attr.valueType = "string";
                    // @ts-ignore
                    if (chr === '"') attrValue = getStr('"', $18a94290f1afd18c$exports.doubleQuotesEscapeChars);
                    else if (chr === "'") attrValue = getStr("'", $18a94290f1afd18c$exports.singleQuoteEscapeChars);
                    else if (substitutesEnabled && chr === "$") {
                        pos++;
                        attrValue = getIdent();
                        attr.valueType = "substitute";
                    } else {
                        while(pos < l){
                            if (chr === "]") break;
                            attrValue += chr;
                            pos++;
                            chr = str.charAt(pos);
                        }
                        attrValue = attrValue.trim();
                    }
                    skipWhitespace();
                    if (pos >= l) throw Error('Expected "]" but end of file reached.');
                    if (chr !== "]") throw Error('Expected "]" but "' + chr + '" found.');
                    pos++;
                    attr.value = attrValue;
                }
                rule = rule || {};
                (rule.attrs = rule.attrs || []).push(attr);
            } else if (chr === ":") {
                pos++;
                var pseudoName = getIdent();
                var pseudo = {
                    name: pseudoName
                };
                // @ts-ignore
                if (chr === "(") {
                    pos++;
                    var value = "";
                    skipWhitespace();
                    if (pseudos[pseudoName] === "selector") {
                        pseudo.valueType = "selector";
                        value = parseSelector();
                    } else {
                        pseudo.valueType = pseudos[pseudoName] || "string";
                        // @ts-ignore
                        if (chr === '"') value = getStr('"', $18a94290f1afd18c$exports.doubleQuotesEscapeChars);
                        else if (chr === "'") value = getStr("'", $18a94290f1afd18c$exports.singleQuoteEscapeChars);
                        else if (substitutesEnabled && chr === "$") {
                            pos++;
                            value = getIdent();
                            pseudo.valueType = "substitute";
                        } else {
                            while(pos < l){
                                if (chr === ")") break;
                                value += chr;
                                pos++;
                                chr = str.charAt(pos);
                            }
                            value = value.trim();
                        }
                        skipWhitespace();
                    }
                    if (pos >= l) throw Error('Expected ")" but end of file reached.');
                    if (chr !== ")") throw Error('Expected ")" but "' + chr + '" found.');
                    pos++;
                    pseudo.value = value;
                }
                rule = rule || {};
                (rule.pseudos = rule.pseudos || []).push(pseudo);
            } else break;
        }
        return rule;
    }
    return parse();
}
$e704b78782728e94$exports.parseCssSelector = $e704b78782728e94$var$parseCssSelector;


var $67201e3e5ad11134$exports = {};
"use strict";
Object.defineProperty($67201e3e5ad11134$exports, "__esModule", {
    value: true
});

function $67201e3e5ad11134$var$renderEntity(entity) {
    var res = "";
    switch(entity.type){
        case "ruleSet":
            var currentEntity = entity.rule;
            var parts = [];
            while(currentEntity){
                if (currentEntity.nestingOperator) parts.push(currentEntity.nestingOperator);
                parts.push($67201e3e5ad11134$var$renderEntity(currentEntity));
                currentEntity = currentEntity.rule;
            }
            res = parts.join(" ");
            break;
        case "selectors":
            res = entity.selectors.map($67201e3e5ad11134$var$renderEntity).join(", ");
            break;
        case "rule":
            if (entity.tagName) {
                if (entity.tagName === "*") res = "*";
                else res = $18a94290f1afd18c$exports.escapeIdentifier(entity.tagName);
            }
            if (entity.id) res += "#" + $18a94290f1afd18c$exports.escapeIdentifier(entity.id);
            if (entity.classNames) res += entity.classNames.map(function(cn) {
                return "." + $18a94290f1afd18c$exports.escapeIdentifier(cn);
            }).join("");
            if (entity.attrs) res += entity.attrs.map(function(attr) {
                if ("operator" in attr) {
                    if (attr.valueType === "substitute") return "[" + $18a94290f1afd18c$exports.escapeIdentifier(attr.name) + attr.operator + "$" + attr.value + "]";
                    else return "[" + $18a94290f1afd18c$exports.escapeIdentifier(attr.name) + attr.operator + $18a94290f1afd18c$exports.escapeStr(attr.value) + "]";
                } else return "[" + $18a94290f1afd18c$exports.escapeIdentifier(attr.name) + "]";
            }).join("");
            if (entity.pseudos) res += entity.pseudos.map(function(pseudo) {
                if (pseudo.valueType) {
                    if (pseudo.valueType === "selector") return ":" + $18a94290f1afd18c$exports.escapeIdentifier(pseudo.name) + "(" + $67201e3e5ad11134$var$renderEntity(pseudo.value) + ")";
                    else if (pseudo.valueType === "substitute") return ":" + $18a94290f1afd18c$exports.escapeIdentifier(pseudo.name) + "($" + pseudo.value + ")";
                    else if (pseudo.valueType === "numeric") return ":" + $18a94290f1afd18c$exports.escapeIdentifier(pseudo.name) + "(" + pseudo.value + ")";
                    else return ":" + $18a94290f1afd18c$exports.escapeIdentifier(pseudo.name) + "(" + $18a94290f1afd18c$exports.escapeIdentifier(pseudo.value) + ")";
                } else return ":" + $18a94290f1afd18c$exports.escapeIdentifier(pseudo.name);
            }).join("");
            break;
        default:
            throw Error('Unknown entity type: "' + entity.type + '".');
    }
    return res;
}
$67201e3e5ad11134$exports.renderEntity = $67201e3e5ad11134$var$renderEntity;


var $d140b0999ce5b499$var$CssSelectorParser = /** @class */ function() {
    function CssSelectorParser() {
        this.pseudos = {};
        this.attrEqualityMods = {};
        this.ruleNestingOperators = {};
        this.substitutesEnabled = false;
    }
    CssSelectorParser.prototype.registerSelectorPseudos = function() {
        var pseudos = [];
        for(var _i = 0; _i < arguments.length; _i++)pseudos[_i] = arguments[_i];
        for(var _a = 0, pseudos_1 = pseudos; _a < pseudos_1.length; _a++){
            var pseudo = pseudos_1[_a];
            this.pseudos[pseudo] = "selector";
        }
        return this;
    };
    CssSelectorParser.prototype.unregisterSelectorPseudos = function() {
        var pseudos = [];
        for(var _i = 0; _i < arguments.length; _i++)pseudos[_i] = arguments[_i];
        for(var _a = 0, pseudos_2 = pseudos; _a < pseudos_2.length; _a++){
            var pseudo = pseudos_2[_a];
            delete this.pseudos[pseudo];
        }
        return this;
    };
    CssSelectorParser.prototype.registerNumericPseudos = function() {
        var pseudos = [];
        for(var _i = 0; _i < arguments.length; _i++)pseudos[_i] = arguments[_i];
        for(var _a = 0, pseudos_3 = pseudos; _a < pseudos_3.length; _a++){
            var pseudo = pseudos_3[_a];
            this.pseudos[pseudo] = "numeric";
        }
        return this;
    };
    CssSelectorParser.prototype.unregisterNumericPseudos = function() {
        var pseudos = [];
        for(var _i = 0; _i < arguments.length; _i++)pseudos[_i] = arguments[_i];
        for(var _a = 0, pseudos_4 = pseudos; _a < pseudos_4.length; _a++){
            var pseudo = pseudos_4[_a];
            delete this.pseudos[pseudo];
        }
        return this;
    };
    CssSelectorParser.prototype.registerNestingOperators = function() {
        var operators = [];
        for(var _i = 0; _i < arguments.length; _i++)operators[_i] = arguments[_i];
        for(var _a = 0, operators_1 = operators; _a < operators_1.length; _a++){
            var operator = operators_1[_a];
            this.ruleNestingOperators[operator] = true;
        }
        return this;
    };
    CssSelectorParser.prototype.unregisterNestingOperators = function() {
        var operators = [];
        for(var _i = 0; _i < arguments.length; _i++)operators[_i] = arguments[_i];
        for(var _a = 0, operators_2 = operators; _a < operators_2.length; _a++){
            var operator = operators_2[_a];
            delete this.ruleNestingOperators[operator];
        }
        return this;
    };
    CssSelectorParser.prototype.registerAttrEqualityMods = function() {
        var mods = [];
        for(var _i = 0; _i < arguments.length; _i++)mods[_i] = arguments[_i];
        for(var _a = 0, mods_1 = mods; _a < mods_1.length; _a++){
            var mod = mods_1[_a];
            this.attrEqualityMods[mod] = true;
        }
        return this;
    };
    CssSelectorParser.prototype.unregisterAttrEqualityMods = function() {
        var mods = [];
        for(var _i = 0; _i < arguments.length; _i++)mods[_i] = arguments[_i];
        for(var _a = 0, mods_2 = mods; _a < mods_2.length; _a++){
            var mod = mods_2[_a];
            delete this.attrEqualityMods[mod];
        }
        return this;
    };
    CssSelectorParser.prototype.enableSubstitutes = function() {
        this.substitutesEnabled = true;
        return this;
    };
    CssSelectorParser.prototype.disableSubstitutes = function() {
        this.substitutesEnabled = false;
        return this;
    };
    CssSelectorParser.prototype.parse = function(str) {
        return $e704b78782728e94$exports.parseCssSelector(str, 0, this.pseudos, this.attrEqualityMods, this.ruleNestingOperators, this.substitutesEnabled);
    };
    CssSelectorParser.prototype.render = function(path) {
        return $67201e3e5ad11134$exports.renderEntity(path).trim();
    };
    return CssSelectorParser;
}();
$d140b0999ce5b499$exports.CssSelectorParser = $d140b0999ce5b499$var$CssSelectorParser;


const $ca4ba1259c2fbe42$var$parser = new (0, $d140b0999ce5b499$exports.CssSelectorParser)();
$ca4ba1259c2fbe42$var$parser.registerAttrEqualityMods("~", "|", "^", "$", "*");
$ca4ba1259c2fbe42$var$parser.registerSelectorPseudos("any", "matches", "not", "has");
$ca4ba1259c2fbe42$var$parser.registerNestingOperators(">", "+", "~");
function $ca4ba1259c2fbe42$export$98e6a39c04603d36(selector) {
    if (typeof selector !== "string") throw new TypeError("Expected `string` as selector, not `" + selector + "`");
    return $ca4ba1259c2fbe42$var$parser.parse(selector);
}


function $83dc8573db127407$export$de994efd351b291c(selector, node, space) {
    const state = $83dc8573db127407$var$createState(selector, node, space);
    state.one = true;
    state.shallow = true;
    (0, $58a1078981422728$export$588732934346abbf)(state, node || undefined);
    return state.results.length > 0;
}
function $83dc8573db127407$export$2e6c959c16ff56b8(selector, tree, space) {
    const state = $83dc8573db127407$var$createState(selector, tree, space);
    state.one = true;
    (0, $58a1078981422728$export$588732934346abbf)(state, tree || undefined);
    // To do in major: return `undefined` instead.
    return state.results[0] || null;
}
function $83dc8573db127407$export$90aca4adda6ff0f5(selector, tree, space) {
    const state = $83dc8573db127407$var$createState(selector, tree, space);
    (0, $58a1078981422728$export$588732934346abbf)(state, tree || undefined);
    return state.results;
}
/**
 * @param {string} selector
 *   Tree to search.
 * @param {Node | null | undefined} [tree]
 *   Tree to search.
 * @param {Space | null | undefined} [space='html']
 *   Name of namespace (`'svg'` or `'html'`).
 * @returns {SelectState} SelectState
 */ function $83dc8573db127407$var$createState(selector, tree, space) {
    return {
        // State of the query.
        rootQuery: (0, $58a1078981422728$export$9141434d8c079e66)((0, $ca4ba1259c2fbe42$export$98e6a39c04603d36)(selector)),
        results: [],
        // @ts-expect-error assume elements.
        scopeElements: tree ? tree.type === "root" ? tree.children : [
            tree
        ] : [],
        one: false,
        shallow: false,
        found: false,
        // State in the tree.
        schema: space === "svg" ? (0, $bb9bd2b68008f123$export$7ed1367e7fa1ad68) : (0, $bb9bd2b68008f123$export$c0bb0b647f701bb5),
        language: undefined,
        direction: "ltr",
        editableOrEditingHost: false,
        typeIndex: undefined,
        elementIndex: undefined,
        typeCount: undefined,
        elementCount: undefined
    };
}




const { selectAll: $d8d0a3436c2ee92e$var$selectAll } = $59f8cc3c57bc5912$exports;
/**
 * @param {Record<string, string>} additions
 * @returns {(node: import("hast").Element) => void}
 */ $d8d0a3436c2ee92e$exports = (additions)=>{
    const adders = Object.entries(additions).map($d8d0a3436c2ee92e$var$adder);
    return (node)=>adders.forEach((a)=>a(node));
};
/**
 * @param {[string, string]} entry
 * @returns {(node: import("hast").Element) => void}
 */ const $d8d0a3436c2ee92e$var$adder = ([selector, className])=>{
    const writer = $d8d0a3436c2ee92e$var$write(className);
    return (node)=>$d8d0a3436c2ee92e$var$selectAll(selector, node).forEach(writer);
};
/**
 * @param {string} className
 * @returns {(node: import("hast").Element) => void}
 */ const $d8d0a3436c2ee92e$var$write = (className)=>{
    return ({ properties: properties })=>{
        if (!properties) return;
        if (!properties.className) properties.className = className;
        else properties.className += ` ${className}`;
    };
};


var $633145f4fdb2fefa$exports = {};
/**
 * @type {(componentDevelopmentMode: boolean) => import("svelte-preprocess/dist/types").PreprocessorGroup}
 */ 
$633145f4fdb2fefa$exports = ()=>{
    /**
	 * This ensures that we don't read ./handle-og.svelte more than once
	 * @type {string}
	 */ let handleOgContent;
    return {
        markup: ({ content: content, filename: filename })=>{
            if (typeof filename === "undefined") return;
            if (!filename.endsWith("+page.md")) return;
            if (!handleOgContent) handleOgContent = (parcelRequire("9FTVY"));
            return {
                code: handleOgContent + content
            };
        },
        script: ({ content: content, filename: filename, attributes: attributes })=>{
            if (!filename?.endsWith("+page.md")) return;
            if (attributes.context === "module") {
                if (!content.includes("export const metadata =")) // There is no frontmatter, and we want to make sure that it as at least defined.
                // Technically this won't _break_ things, just spam the logs with a vite warning.
                return {
                    code: content + ";const metadata = undefined;"
                };
                else // exporting makes tailwind break HMR
                return {
                    code: content.replace("export const metadata =", "const metadata =")
                };
            } else return {
                code: 'import { addBasePath } from "@evidence-dev/sdk/utils/svelte";' + content
            };
        }
    };
};


var $e07c8d31339f08f2$exports = {};

/**
 * @param {string} originalString
 * @returns {string}
 */ function $e07c8d31339f08f2$var$injectPartials(originalString) {
    const r = /\{@partial\s+"(.*?)"\s*\}/g;
    for (const match of originalString.matchAll(r) ?? []){
        const filename = match[1];
        // There is an error with parcel that prevents the use of the "path" library.
        const content = $773sa$readFileSync(`./partials/${filename}`).toString();
        originalString = originalString.replace(match[0], content);
    }
    return originalString;
}
/** @type {import('svelte/compiler').PreprocessorGroup & { injectPartials: typeof injectPartials }} */ $e07c8d31339f08f2$exports = {
    markup: ({ content: content, filename: filename })=>{
        if (typeof filename === "undefined") return;
        if (!filename.endsWith("+page.md")) return;
        return {
            code: $e07c8d31339f08f2$var$injectPartials(content)
        };
    },
    injectPartials: $e07c8d31339f08f2$var$injectPartials
};


var $8cd497f89760a2b3$exports = {};
"use strict";

var $8cd497f89760a2b3$var$slugs = (parcelRequire("gZwsz"))();
var $e385ba995cade06b$exports = {};
"use strict";
var $e385ba995cade06b$var$own = {}.hasOwnProperty;
$e385ba995cade06b$exports = $e385ba995cade06b$var$hasProperty;
// Check if `node` has a set `name` property.
function $e385ba995cade06b$var$hasProperty(node, name) {
    var props;
    var value;
    if (!node || !name || typeof node !== "object" || node.type !== "element") return false;
    props = node.properties;
    value = props && $e385ba995cade06b$var$own.call(props, name) && props[name];
    return value !== null && value !== undefined && value !== false;
}


var $4be7db0ee7079fd2$exports = {};
"use strict";
$4be7db0ee7079fd2$exports = $4be7db0ee7079fd2$var$headingRank;
var $4be7db0ee7079fd2$var$lowercaseH = 104 // `h`
;
var $4be7db0ee7079fd2$var$digit0 = 48 // `0`
;
var $4be7db0ee7079fd2$var$digit6 = 54 // `6`
;
// Rank of a heading: H1 -> 1, H2 -> 2, etc.
function $4be7db0ee7079fd2$var$headingRank(node) {
    var name = (node && node.type === "element" && node.tagName || "").toLowerCase();
    var code = name.length === 2 && name.charCodeAt(0) === $4be7db0ee7079fd2$var$lowercaseH ? name.charCodeAt(1) : 0;
    return code > $4be7db0ee7079fd2$var$digit0 && code <= $4be7db0ee7079fd2$var$digit6 ? code - $4be7db0ee7079fd2$var$digit0 : null;
}


var $4d69007275632fd4$exports = {};
/**
 * @fileoverview
 *   Get the plain-text value of a hast node.
 * @longdescription
 *   ## Use
 *
 *   ```js
 *   var h = require('hastscript')
 *   var toString = require('hast-util-to-string')
 *
 *   toString(h('p', 'Alpha'))
 *   //=> 'Alpha'
 *   toString(h('div', [h('b', 'Bold'), ' and ', h('i', 'italic'), '.']))
 *   //=> 'Bold and italic.'
 *   ```
 *
 *   ## API
 *
 *   ### `toString(node)`
 *
 *   Transform a node to a string.
 */ "use strict";
$4d69007275632fd4$exports = $4d69007275632fd4$var$toString;
function $4d69007275632fd4$var$toString(node) {
    // “The concatenation of data of all the Text node descendants of the context
    // object, in tree order.”
    if ("children" in node) return $4d69007275632fd4$var$all(node);
    // “Context object’s data.”
    return "value" in node ? node.value : "";
}
function $4d69007275632fd4$var$one(node) {
    if (node.type === "text") return node.value;
    return node.children ? $4d69007275632fd4$var$all(node) : "";
}
function $4d69007275632fd4$var$all(node) {
    var children = node.children;
    var length = children.length;
    var index = -1;
    var result = [];
    while(++index < length)result[index] = $4d69007275632fd4$var$one(children[index]);
    return result.join("");
}



var $cGAg2 = parcelRequire("cGAg2");
$8cd497f89760a2b3$exports = $8cd497f89760a2b3$var$slug;
function $8cd497f89760a2b3$var$slug() {
    return $8cd497f89760a2b3$var$transformer;
}
function $8cd497f89760a2b3$var$transformer(tree) {
    $8cd497f89760a2b3$var$slugs.reset();
    $cGAg2(tree, "element", function(node) {
        if ($4be7db0ee7079fd2$exports(node) && !$e385ba995cade06b$exports(node, "id")) node.properties.id = $8cd497f89760a2b3$var$slugs.slug($4d69007275632fd4$exports(node));
    });
}


var $85e63f570b9074a0$exports = {};
"use strict";




var $cGAg2 = parcelRequire("cGAg2");
$85e63f570b9074a0$exports = $85e63f570b9074a0$var$autolink;
var $85e63f570b9074a0$var$splice = [].splice;
var $85e63f570b9074a0$var$contentDefaults = {
    type: "element",
    tagName: "span",
    properties: {
        className: [
            "icon",
            "icon-link"
        ]
    },
    children: []
};
function $85e63f570b9074a0$var$autolink(options) {
    var settings = options || {};
    var props = settings.properties;
    var behavior = settings.behaviour || settings.behavior || "prepend";
    var content = settings.content || $85e63f570b9074a0$var$contentDefaults;
    var group = settings.group;
    var method;
    if (behavior === "wrap") method = wrap;
    else if (behavior === "before" || behavior === "after") method = around;
    else {
        method = inject;
        if (!props) props = {
            ariaHidden: "true",
            tabIndex: -1
        };
    }
    return transformer;
    function transformer(tree) {
        $cGAg2(tree, "element", visitor);
    }
    function visitor(node, index, parent) {
        if ($4be7db0ee7079fd2$exports(node) && $e385ba995cade06b$exports(node, "id")) return method(node, index, parent);
    }
    function inject(node) {
        node.children[behavior === "prepend" ? "unshift" : "push"](create(node, $9189b693d4c784a9$exports(true, {}, props), toChildren(content, node)));
        return [
            $cGAg2.SKIP
        ];
    }
    function around(node, index, parent) {
        var link = create(node, $9189b693d4c784a9$exports(true, {}, props), toChildren(content, node));
        var nodes = behavior === "before" ? [
            link,
            node
        ] : [
            node,
            link
        ];
        var grouping = group && toNode(group, node);
        if (grouping) {
            grouping.children = nodes;
            nodes = grouping;
        }
        $85e63f570b9074a0$var$splice.apply(parent.children, [
            index,
            1
        ].concat(nodes));
        return [
            $cGAg2.SKIP,
            index + nodes.length
        ];
    }
    function wrap(node) {
        node.children = [
            create(node, $9189b693d4c784a9$exports(true, {}, props), node.children)
        ];
        return [
            $cGAg2.SKIP
        ];
    }
    function toChildren(value, node) {
        var result = toNode(value, node);
        return Array.isArray(result) ? result : [
            result
        ];
    }
    function toNode(value, node) {
        if (typeof value === "function") return value(node);
        return $9189b693d4c784a9$exports(true, Array.isArray(value) ? [] : {}, value);
    }
    function create(node, props, children) {
        return {
            type: "element",
            tagName: "a",
            properties: Object.assign({}, props, {
                href: "#" + node.properties.id
            }),
            children: children
        };
    }
}


$57a4462a49c99b67$exports = function evidencePreprocess(componentDevelopmentMode = false) {
    return [
        $e07c8d31339f08f2$exports,
        $8ce7c84cad4722b7$exports,
        $812958982b4444cc$exports.processQueries(componentDevelopmentMode),
        $538971b5b904f078$export$d61cf7a1924293cc({
            extensions: [
                ".md"
            ],
            smartypants: {
                quotes: false,
                ellipses: true,
                backticks: true,
                dashes: "oldschool"
            },
            highlight: {
                highlighter: $57a4462a49c99b67$require$highlighter
            },
            rehypePlugins: [
                [
                    $d8d0a3436c2ee92e$exports,
                    {
                        "*": "markdown"
                    }
                ],
                [
                    $8cd497f89760a2b3$exports
                ],
                [
                    $85e63f570b9074a0$exports,
                    {
                        behavior: "wrap",
                        properties: {}
                    }
                ]
            ]
        }),
        // Add both script tags to all markdown files, if they are missing
        $633145f4fdb2fefa$exports()
    ];
};

$57a4462a49c99b67$exports.parseFrontmatter = (parcelRequire("i09cj")).parseFrontmatter;

$57a4462a49c99b67$exports.extractQueries = $1594040042302d21$exports.extractQueries;
$57a4462a49c99b67$exports.getQueryIds = $1594040042302d21$exports.getQueryIds;
$57a4462a49c99b67$exports.injectPartials = $e07c8d31339f08f2$exports.injectPartials;
$57a4462a49c99b67$exports.processQueries = $812958982b4444cc$exports.processQueries;
$57a4462a49c99b67$exports.injectedEvidenceImports = $812958982b4444cc$exports.injectedEvidenceImports;


export {$57a4462a49c99b67$exports as default};
